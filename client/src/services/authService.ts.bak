import { apiClient } from './api/apiClient';
import type { LoginDto, RegisterDto } from '@shared/types/auth/dto';
import type { AuthResponse, AuthTokens } from '@shared/types/auth/jwt';
import type { AuthUser } from '@shared/types/auth/user';
import { TokenManager } from '@/utils/tokenManager';

// Base API response type
interface ApiResponse<T> {
  data: T;
  error?: never;
}

// Error response type
interface ApiError {
  error: {
    message: string;
    code?: string;
  };
  data?: never;
}

type ApiResult<T> = ApiResponse<T> | ApiError;

export class AuthService {
  private tokenManager: TokenManager;

  constructor() {
    this.tokenManager = TokenManager.getInstance();
  }

  /**
   * Login with email and password
   */
  async login(loginDto: LoginDto): Promise<AuthUser> {
    try {
      const response = await apiClient.post<ApiResult<AuthResponse>>('/auth/login', loginDto);
      
      if ('error' in response) {
        throw new Error(response.error.message);
      }

      // Store tokens if available
      if (response.data.tokens) {
        this.tokenManager.setTokens(response.data.tokens);
      }

      return response.data.user;
    } catch (error) {
      console.error('Login failed:', error);
      throw this.handleAuthError(error);
    }
  }

  /**
   * Register a new user
   */
  async register(registerDto: RegisterDto): Promise<AuthUser> {
    try {
      const response = await apiClient.post<ApiResult<AuthResponse>>('/auth/register', registerDto);
      
      if ('error' in response) {
        throw new Error(response.error.message);
      }

      // Store tokens if available
      if (response.data.tokens) {
        this.tokenManager.setTokens(response.data.tokens);
      }

      return response.data.user;
    } catch (error) {
      console.error('Registration failed:', error);
      throw this.handleAuthError(error);
    }
  }

  /**
   * Logout the current user
   */
  async logout(): Promise<void> {
    try {
      // Call the logout endpoint
      await apiClient.post('/auth/logout');
    } catch (error) {
      console.error('Logout failed:', error);
      // Continue with local cleanup even if the server request fails
    } finally {
      // Clear local tokens and session data
      this.tokenManager.clearTokens();
    }
  }

  /**
   * Refresh the access token
   */
  async refreshToken(): Promise<AuthTokens> {
    try {
      const refreshToken = this.tokenManager.getRefreshToken();
      if (!refreshToken) {
        throw new Error('No refresh token available');
      }

      const response = await apiClient.post<ApiResult<{ tokens: AuthTokens }>>('/auth/refresh-token', {
        refresh_token: refreshToken
      });

      if ('error' in response) {
        throw new Error(response.error.message);
      }

      if (!response.data.tokens) {
        throw new Error('Invalid token response');
      }

      // Update stored tokens
      this.tokenManager.setTokens(response.data.tokens);
      return response.data.tokens;
    } catch (error) {
      console.error('Token refresh failed:', error);
      throw this.handleAuthError(error);
    }
  }

  /**
   * Get the current user's profile
   */
  async getCurrentUser(): Promise<AuthUser | null> {
    try {
      const response = await apiClient.get<ApiResult<{ user: AuthUser }>>('/auth/me');
      
      if ('error' in response) {
        throw new Error(response.error.message);
      }

      return response.data.user;
    } catch (error) {
      console.error('Failed to fetch user profile:', error);
      throw this.handleAuthError(error);
    }
  }

  /**
   * Handle authentication errors
   */
  private handleAuthError(error: unknown): Error {
    if (error instanceof Error) {
      return error;
    }
    
    if (error && typeof error === 'object' && 'message' in error) {
      return new Error(String(error.message));
    }
    
    return new Error('An unknown authentication error occurred');
  }
}

// Create and export a singleton instance
export const authService = new AuthService();

export type { AuthError } from '@shared/types/auth/auth';
