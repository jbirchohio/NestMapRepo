import express, { Request, Response, NextFunction } from 'express';
import { hashPassword, verifyPassword, findUserByEmail, isAccountLocked } from '../utils/auth';
import { dbService } from '../services/database.service';
import { users, organizations } from '@shared/schema';
import { and, eq } from 'drizzle-orm';
import { z } from 'zod';
import rateLimit from 'express-rate-limit';
import { signToken } from '../utils/jwt';

// JWT User type
type JwtUser = {
  id: number;
  email: string;
  role: string;
  organization_id: number | null;
  tokenType: 'access' | 'refresh';
};

// Extend Express Request type
declare global {
  namespace Express {
    interface Request {
      user?: JwtUser;
      validatedData?: unknown;
    }
  }
}

// Response type for API responses
interface ApiResponse<T> {
  status: 'success' | 'error';
  data?: T;
  message?: string;
  error?: {
    code?: string;
    message: string;
    details?: unknown;
  };
}

// Input validation schemas
const registerSchema = z.object({
  email: z.string()
    .email('Invalid email address')
    .max(255, 'Email must be less than 255 characters')
    .toLowerCase()
    .trim(),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .max(100, 'Password must be less than 100 characters')
    .regex(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>/?]).+$/,
      'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'
    ),
  username: z.string()
    .min(3, 'Username must be at least 3 characters')
    .max(50, 'Username must be less than 50 characters')
    .regex(
      /^[a-zA-Z0-9_]+$/,
      'Username can only contain letters, numbers, and underscores'
    ),
  organizationName: z.string()
    .min(2, 'Organization name must be at least 2 characters')
    .max(100, 'Organization name must be less than 100 characters'),
  firstName: z.string()
    .max(50, 'First name must be less than 50 characters')
    .optional(),
  lastName: z.string()
    .max(50, 'Last name must be less than 50 characters')
    .optional(),
  recaptchaToken: z.string().optional()
});

const loginSchema = z.object({
  email: z.string()
    .email('Invalid email address')
    .max(255, 'Email must be less than 255 characters')
    .toLowerCase()
    .trim(),
  password: z.string()
    .min(1, 'Password is required')
    .max(100, 'Password must be less than 100 characters'),
  rememberMe: z.boolean().optional()
});

export const refreshTokenSchema = z.object({
  refreshToken: z.string().min(1, 'Refresh token is required')
});

export const forgotPasswordSchema = z.object({
  email: z.string()
    .email('Invalid email address')
    .max(255, 'Email must be less than 255 characters')
    .toLowerCase()
    .trim()
});

export const resetPasswordSchema = z.object({
  token: z.string().min(1, 'Token is required'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .max(100, 'Password must be less than 100 characters')
});

// Rate limiting for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // Limit each IP to 10 requests per windowMs
  message: JSON.stringify({
    status: 'error',
    message: 'Too many requests, please try again later'
  }),
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req: Request) => {
    const ip = req.ip || '';
    const userAgent = req.headers['user-agent'] || '';
    return `${ip}-${userAgent}`;
  },
  skip: (req: Request) => {
    return req.path === '/health';
  }
});

const router = express.Router();

// Input validation middleware
const validateRequestBody = (schema: z.ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const validation = schema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        details: validation.error.format()
      });
    }
    
    req.validatedData = validation.data;
    next();
  };
};

// Register route
router.post('/register', validateRequestBody(registerSchema), async (req: Request, res: Response<ApiResponse<any>>) => {
  const db = dbService.getDrizzle();
  const { email, password, username, firstName, lastName, organizationName } = req.validatedData as z.infer<typeof registerSchema>;
  
  try {
    // Check if user already exists
    const existingUser = await findUserByEmail(email);
    if (existingUser) {
      return res.status(400).json({
        status: 'error',
        error: {
          code: 'EMAIL_EXISTS',
          message: 'Email already in use'
        }
      });
    }

    // Start transaction
    await db.transaction(async (tx) => {
      // Create organization
      const [organization] = await tx.insert(organizations)
        .values({
          name: organizationName,
          created_at: new Date(),
          updated_at: new Date()
        })
        .returning();

      // Create user
      const hashedPassword = await hashPassword(password);
      await tx.insert(users).values({
        email,
        username,
        first_name: firstName,
        last_name: lastName,
        password_hash: hashedPassword,
        organization_id: organization.id,
        created_at: new Date(),
        updated_at: new Date()
      });
    });

    return res.status(201).json({
      status: 'success',
      message: 'Registration successful. Please check your email to verify your account.'
    });
  } catch (error) {
    console.error('Registration error:', error);
    return res.status(500).json({
      status: 'error',
      error: {
        code: 'REGISTRATION_FAILED',
        message: 'Failed to register user',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined
      }
    });
  }
});

// Login route
router.post('/login', validateRequestBody(loginSchema), async (req: Request, res: Response<ApiResponse<any>>) => {
  const { email, password, rememberMe } = req.validatedData as z.infer<typeof loginSchema>;
  
  try {
    const user = await findUserByEmail(email);
    
    // Check if user exists
    if (!user) {
      return res.status(401).json({
        status: 'error',
        error: {
          code: 'INVALID_CREDENTIALS',
          message: 'Invalid email or password'
        }
      });
    }

    // Check if account is locked
    if (isAccountLocked(user)) {
      return res.status(403).json({
        status: 'error',
        error: {
          code: 'ACCOUNT_LOCKED',
          message: 'Account is temporarily locked due to too many failed login attempts. Please try again later.'
        }
      });
    }

    // Verify password
    const isPasswordValid = await verifyPassword(password, user.password_hash || '');
    if (!isPasswordValid) {
      // Update failed login attempts
      await dbService.getDrizzle()
        .update(users)
        .set({
          failed_login_attempts: (user.failed_login_attempts || 0) + 1,
          last_failed_login: new Date()
        })
        .where(eq(users.id, user.id));
      
      return res.status(401).json({
        status: 'error',
        error: {
          code: 'INVALID_CREDENTIALS',
          message: 'Invalid email or password'
        }
      });
    }

    // Reset failed login attempts on successful login
    await dbService.getDrizzle()
      .update(users)
      .set({
        failed_login_attempts: 0,
        last_login: new Date()
      })
      .where(eq(users.id, user.id));

    // Generate tokens
    const accessToken = signToken(
      {
        id: user.id,
        email: user.email,
        role: user.role || 'user',
        organization_id: user.organization_id,
        tokenType: 'access'
      },
      '15m' // 15 minutes
    );

    const refreshToken = signToken(
      {
        id: user.id,
        email: user.email,
        role: user.role || 'user',
        organization_id: user.organization_id,
        tokenType: 'refresh'
      },
      '7d' // 7 days
    );

    // Set HTTP-only cookie for refresh token
    res.cookie('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
    });

    return res.json({
      status: 'success',
      data: {
        user: {
          id: user.id,
          email: user.email,
          username: user.username,
          firstName: user.first_name,
          lastName: user.last_name,
          role: user.role,
          organizationId: user.organization_id
        },
        tokens: {
          accessToken,
          refreshToken: rememberMe ? refreshToken : undefined
        }
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    return res.status(500).json({
      status: 'error',
      error: {
        code: 'LOGIN_FAILED',
        message: 'Failed to log in',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined
      }
    });
  }
});

export default router;
