import express, { Request, Response, NextFunction } from 'express';
import { hashPassword, verifyPassword } from '../utils/auth';
import { dbService } from '../services/database.service';
import { users, organizations } from '@shared/schema';
import { and, eq } from 'drizzle-orm';
import { z } from 'zod';
import { v4 as uuidv4 } from 'uuid';
import { logger } from '../utils/logger';
import { 
  generateAuthTokens, 
  verifyToken, 
  type JwtPayload,
  type JwtUser,
  TokenType
} from '../utils/jwt';
import type { ApiResponse } from '../../shared/types/api';
import { ROLES } from '../config/constants';
import { rateLimit } from 'express-rate-limit';

// Extend Express Request type to include our custom properties
declare global {
  namespace Express {
    interface Request {
      user?: JwtUser;
      validatedData?: unknown;
    }
  }
}

// JWT User type
type JwtUser = {
  id: number;
  email: string;
  role: string;
  organization_id: number | null;
  tokenType: 'access' | 'refresh';
};

// Response type for API responses
interface ApiResponse<T> {
  status: 'success' | 'error';
  data?: T;
  message?: string;
  error?: {
    code?: string;
    message: string;
    details?: unknown;
    email: string;
    username: string;
    firstName: string | null;
    lastName: string | null;
    role: string;
    organizationId: number | null;
  };
  tokens: {
    accessToken: string;
    refreshToken: string;
  };
}

interface LoginResponse {
  user: {
    id: number;
    email: string;
    username: string;
    firstName: string | null;
    lastName: string | null;
    role: string;
    organizationId: number | null;
  };
  tokens: {
    accessToken: string;
    refreshToken: string;
  };
}

interface AuthErrorResponse {
  status: 'error';
  message: string;
  code?: string;
  details?: Record<string, unknown>;
}

const router = express.Router();

// Rate limiting for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // Limit each IP to 10 requests per windowMs
  message: JSON.stringify({
    status: 'error',
    message: 'Too many requests, please try again later'
  }),
  standardHeaders: true,
  legacyHeaders: false,
  email: z.string()
    .email('Invalid email address')
    .max(255, 'Email must be less than 255 characters')
    .toLowerCase()
    .trim(),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .max(100, 'Password must be less than 100 characters')
    .regex(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>/?]).+$/,
      'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'
    ),
  username: z.string()
    .min(3, 'Username must be at least 3 characters')
    .max(50, 'Username must be less than 50 characters')
    .regex(
      /^[a-zA-Z0-9_]+$/,
      'Username can only contain letters, numbers, and underscores'
    ),
  organizationName: z.string()
    .min(2, 'Organization name must be at least 2 characters')
    .max(100, 'Organization name must be less than 100 characters'),
  firstName: z.string()
    .max(50, 'First name must be less than 50 characters')
    .optional(),
  lastName: z.string()
    .max(50, 'Last name must be less than 50 characters')
    .optional(),
  recaptchaToken: z.string().optional()
});

export const loginSchema = z.object({
  email: z.string()
    .email('Invalid email address')
    .max(255, 'Email must be less than 255 characters')
    .toLowerCase()
    .trim(),
  password: z.string()
    .min(1, 'Password is required')
    .max(100, 'Password must be less than 100 characters'),
  rememberMe: z.boolean().optional()
});

export const refreshTokenSchema = z.object({
  refreshToken: z.string().min(1, 'Refresh token is required')
});

export const forgotPasswordSchema = z.object({
  email: z.string()
    .email('Invalid email address')
    .max(255, 'Email must be less than 255 characters')
    .toLowerCase()
    .trim()
});

export const resetPasswordSchema = z.object({
  token: z.string().min(1, 'Token is required'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .max(100, 'Password must be less than 100 characters')
});

// Response types
interface RegisterResponse {
  user: {
    id: number;
    email: string;
    username: string;
    firstName: string | null;
    lastName: string | null;
    role: string;
    organizationId: number | null;
  };
  tokens: {
    accessToken: string;
    refreshToken?: string;
  };
}

interface LoginResponse {
  user: {
    id: number;
    email: string;
    username: string;
    firstName: string | null;
    lastName: string | null;
    role: string;
    organizationId: number | null;
  };
  tokens: {
    accessToken: string;
    refreshToken?: string;
  };
}

interface AuthErrorResponse {
  status: 'error';
  message: string;
  code?: string;
  details?: Record<string, unknown>;
}

const router = express.Router();

// Rate limiting for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // Limit each IP to 10 requests per windowMs
  message: JSON.stringify({
    status: 'error',
    message: 'Too many requests, please try again later'
  }),
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req: Request) => {
    // Use IP + user agent for rate limiting to be more accurate
    const ip = req.ip || '';
    const userAgent = req.headers['user-agent'] || '';
    return `${ip}-${userAgent}`;
  },
  skip: (req: Request) => {
    // Skip rate limiting for health checks
    return req.path === '/health';
  }
});
    .max(255, 'Email must be less than 255 characters')
});

const resetPasswordSchema = z.object({
  token: z.string().min(1, 'Token is required'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .max(100, 'Password must be less than 100 characters')
});

const validateRequestBody = (schema: z.ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const validation = schema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        details: validation.error.format()
      } as const);
    }
    
    req.validatedData = validation.data;
    next();
    return undefined;
  };
};

// Helper function to calculate remaining lockout time in minutes
export const getRemainingLockoutTime = (lastFailedLogin: Date | null): number => {
  if (!lastFailedLogin) return 0;
  const lockoutDuration = 30 * 60 * 1000; // 30 minutes in milliseconds
  const elapsed = Date.now() - lastFailedLogin.getTime();
  return Math.max(0, Math.ceil((lockoutDuration - elapsed) / 60000));
};

// Middleware to check if user is authenticated
export const authenticate = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        status: 'error',
        message: 'No token provided'
      });
    }

    const token = authHeader.split(' ')[1];
    if (!token) {
      return res.status(401).json({
        status: 'error',
        message: 'No token provided'
      });
    }

    const decoded = verifyToken(token) as JwtPayload;
    if (!decoded) {
      return res.status(401).json({
        status: 'error',
        message: 'Invalid or expired token'
      });
    }

    // Check if token type is access token
    if (decoded.type !== 'access') {
      return res.status(401).json({
        status: 'error',
        message: 'Invalid token type'
      });
    }

    // Get user from database
    const db = dbService.getDrizzle();
    const user = await db.query.users.findFirst({
      where: (users, { eq }) => eq(users.id, decoded.userId as number)
    });

    if (!user) {
      return res.status(401).json({
        status: 'error',
        message: 'User not found'
      });
    }

    // Check if account is active
    if (user.is_active === false) {
      return res.status(403).json({
        status: 'error',
        message: 'Account is deactivated',
        code: 'ACCOUNT_DEACTIVATED'
      });
    }

    // Check if account is locked
    if (user.failed_login_attempts && user.failed_login_attempts >= 5 && user.last_failed_login) {
      const lockoutTime = new Date(user.last_failed_login.getTime() + 30 * 60 * 1000);
      if (new Date() < lockoutTime) {
        return res.status(403).json({
          status: 'error',
          message: 'Account is temporarily locked due to too many failed login attempts',
          code: 'ACCOUNT_LOCKED',
          details: {
            retryAfter: Math.ceil((lockoutTime.getTime() - Date.now()) / 1000)
          }
        });
      }
    }

    // Attach user to request
    req.user = {
      id: user.id,
      email: user.email,
      username: user.username,
      organization_id: user.organization_id || null,
      role: user.role || 'user'
    } as JWTUser;

    next();
  } catch (error) {
    logger.error('Authentication error:', error);
    return res.status(401).json({
      status: 'error',
      message: 'Invalid or expired token'
    });
  }
};

/**
 * @route POST /api/auth/register
 * @desc Register a new user and create an organization
 * @access Public
 */
router.post('/register', validateRequestBody(registerSchema), async (req: Request, res: Response<ApiResponse<RegisterResponse>>) => {
  const db = dbService.getDrizzle();
  const { email, password, username, firstName, lastName, organizationName } = req.validatedData as z.infer<typeof registerSchema>;
  try {
    // Check if user already exists
    const [existingUser] = await db
      .select()
      .from(users)
      .where(eq(users.email, email))
      .limit(1);

    if (existingUser) {
      return res.status(409).json({
        success: false,
        error: {
          code: 'EMAIL_ALREADY_EXISTS',
          message: 'A user with this email already exists',
        },
      });
    }

    // Check if username is taken
    const [existingUsername] = await db
      .select()
      .from(users)
      .where(eq(users.username, username))
      .limit(1);

    if (existingUsername) {
      return res.status(409).json({
        success: false,
        error: {
          code: 'USERNAME_TAKEN',
          message: 'This username is already taken',
        },
      });
    }

    // Hash password
    const hashedPassword = await hashPassword(password);
    const userId = uuidv4();

    // Start a transaction
    const result = await db.transaction(async (tx) => {
      try {
        // Create organization
        const [organization] = await tx
          .insert(organizations)
          .values({
            id: uuidv4(),
            name: `${username}'s Organization`,
            plan: 'free',
            slug: `${username}-org-${Date.now()}`,
            timezone: 'UTC',
            locale: 'en-US',
            createdAt: new Date(),
            updatedAt: new Date(),
          })
          .returning();

        if (!organization) {
          throw new Error('Failed to create organization');
        }

        // Create user
        const [user] = await tx
          .insert(users)
          .values({
            id: userId,
            email,
            username,
            firstName: firstName || null,
            lastName: lastName || null,
            passwordHash: hashedPassword,
            role: ROLES.ADMIN,
            organizationId: organization.id,
            emailVerified: false,
            isActive: true,
            lastLoginAt: new Date(),
            createdAt: new Date(),
            updatedAt: new Date(),
          })
          .returning();

        if (!user) {
          throw new Error('Failed to create user');
        }

        return { user, organization };
      } catch (error) {
        logger.error('Registration transaction error:', error);
        throw error;
      }
    });

    // Generate auth tokens
    const { accessToken, refreshToken } = generateAuthTokens(
      result.user.id,
      result.organization.id,
      result.user.role
    );

    // Return the response
    const response: ApiResponse<RegisterResponse> = {
      success: true,
      data: {
        user: {
          id: result.user.id,
          email: result.user.email,
          username: result.user.username,
          firstName: result.user.firstName,
          lastName: result.user.lastName,
          role: result.user.role,
          organizationId: result.user.organizationId,
        },
        tokens: {
          accessToken,
          refreshToken,
        },
      },
    };

    return res.status(201).json(response);
  } catch (error) {
    logger.error('Registration error:', error);
    res.status(500).json({ 
      success: false,
      error: {
        code: 'REGISTRATION_FAILED',
        message: 'Failed to register user',
        ...(process.env.NODE_ENV === 'development' && { details: (error as Error).message })
      }
    });
  }
});

/**
 * @route POST /api/auth/login
 * @desc Authenticate user and get tokens
 * @access Public
 */
router.post('/login', validateRequestBody(loginSchema), async (req: Request, res: Response<ApiResponse<LoginResponse>>) => {
  try {
    const db = dbService.getDrizzle();
    const { email, password, rememberMe } = req.validatedData as { email: string; password: string; rememberMe?: boolean };

    // Find user
    const [user] = await db
      .select()
      .from(users)
      .where(and(
        eq(users.email, email),
        eq(users.isActive, true)
      ))
      .limit(1);

    if (!user) {
      return res.status(401).json({
        success: false,
        error: {
          code: 'INVALID_CREDENTIALS',
          message: 'Invalid email or password',
        },
      });
    }

    // Verify password
    const isValidPassword = await verifyPassword(password, user.passwordHash);
    if (!isValidPassword) {
      return res.status(401).json({
        success: false,
        error: {
          code: 'INVALID_CREDENTIALS',
          message: 'Invalid email or password',
        },
      });
    }

    // Update last login time
    await db
      .update(users)
      .set({ lastLoginAt: new Date() })
      .where(eq(users.id, user.id));

    // Generate auth tokens
    const { accessToken, refreshToken } = generateAuthTokens(
      user.id,
      user.organizationId,
      user.role
    );

    // Set refresh token as HTTP-only cookie if rememberMe is true
    if (rememberMe) {
      res.cookie('refreshToken', refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
      });
    }

    // Return the response
    const response: ApiResponse<{
      user: {
        id: string;
        email: string;
        username: string;
        firstName: string | null;
        lastName: string | null;
        role: string;
        organizationId: string;
      };
      tokens: {
        accessToken: string;
        refreshToken?: string;
      };
    }> = {
      success: true,
      data: {
        user: {
          id: user.id,
          email: user.email,
          username: user.username,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
          organizationId: user.organizationId,
        },
        tokens: {
          accessToken,
          // Only return refresh token in response if not using httpOnly cookie
          ...(rememberMe ? {} : { refreshToken }),
        },
      },
    };

    res.status(200).json(response);
  } catch (error) {
    logger.error('Login error:', { error });
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_SERVER_ERROR',
        message: 'An error occurred during login',
      },
    });
  }
});

export default router;