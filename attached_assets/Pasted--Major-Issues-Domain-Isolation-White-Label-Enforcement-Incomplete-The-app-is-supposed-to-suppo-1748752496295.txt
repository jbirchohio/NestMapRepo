🟠 Major Issues
Domain Isolation & White-Label Enforcement Incomplete – The app is supposed to support custom domains per organization, but the middleware resolveDomainOrganization is effectively a no-op: it extracts the subdomain but then skips lookup entirely (the code early-next() without assigning an org)
GitHub
. This means the server does not tie requests to an organization based on domain. In practice, all multi-tenant scoping relies only on the logged-in user’s org, and branding defaults to “NestMap” unless overridden in localStorage.
❗ Why it matters: Enterprise white-label setups expect that visiting clientA.example.com automatically applies Client A’s branding and data isolation. Currently, if a user from Org A logs into Org B’s domain, they would still see Org A’s data (since org context comes solely from the user’s session) but perhaps Org B’s public-facing domain – a confusing and potentially insecure scenario. It also means branding isn’t auto-loaded per domain – a readiness gap for selling to clients with custom domains.
🔮 Suspicious even if working: The comment hints this was disabled due to “circular dependency” concerns
GitHub
. So, even though users can log in and the app works, the domain itself isn’t truly enforced. It’s a latent bug: for example, password reset links or public pages might not know which org context to use.
✅ Fix: Implement the domain-to-organization mapping. Likely store each org’s custom domain in the organizations table and use it in resolveDomainOrganization to set req.organizationId (before auth). Also update the front-end to fetch and apply branding based on the resolved org (perhaps via an API call like /api/organizations/me/branding). Ensure that if a user attempts to access an org domain that doesn’t match their org, the server denies access or at least serves a generic page prompting them to use the correct domain.
🧠 Replit AI Prompt: “Complete the resolveDomainOrganization middleware in organizationScoping.ts. Given the request host, query the organizations table to find a matching custom domain and set req.organizationId accordingly. If the domain is not recognized or user’s org doesn’t match, respond with 403 or redirect appropriately. Also ensure front-end branding is loaded from the server for that org.”
🧪 Tests: Configure two organizations with different custom domains. Make a request to a protected API (e.g. /api/trips) on Org A’s domain while authenticated as an Org B user – it should be rejected or return Org A’s content only if the user actually belongs to Org A. Test that visiting each domain yields that org’s branding (e.g., check companyName in the UI or via an API). Also test that an unknown subdomain or base domain yields an appropriate error or default page.
User Signup Flow Blocked by Auth Middleware – The API endpoint for creating new users (POST /api/users) is intended to be called at signup (Supabase auth callback). However, the unified auth middleware is requiring a valid session on all /api routes except a few auth ones. /api/users is not whitelisted in the publicPaths list
GitHub
. As a result, a new user (not logged in yet) trying to call /api/users will hit the unifiedAuthMiddleware and get a 401 Unauthorized before the request even reaches the user creation logic.
❗ Why it matters: This breaks the sign-up workflow. In practice, after a user registers via Supabase (or any auth), the app likely needs to call /api/users to create their profile in the NestMap database. Currently that call would fail unless manually exempted. This is a functional blocker for onboarding new users – an enterprise readiness issue.
🔮 Suspicious even if working: The API docs indicate user creation is open, and .env.example sets up Supabase keys – suggesting external auth integration. The code inconsistency (not exempting /api/users) is a sign of oversight. It might “work” if the team manually added a session for new users somehow, but it’s not by design.
✅ Fix: Allow unauthenticated access to the user creation endpoint. You can add /api/users (and perhaps /api/users/auth/:authId for lookup) to the publicPaths in unifiedAuthMiddleware
GitHub
 so it skips session check. Alternatively, handle this in the route: e.g., if no session but a valid Supabase token is present, allow creation. Also, consider securing it by an API key or one-time token from the client to prevent random spam account creation across orgs.
🧠 Replit AI Prompt: “Adjust unifiedAuthMiddleware in middleware/unifiedAuth.ts to permit /api/users and related onboarding routes without a session. Ensure new users can be created without being logged in. For example, treat /api/users similar to other public auth routes.”
🧪 Tests: Simulate a fresh signup: call POST /api/users with a new user payload without sending any session cookie. It should return 201 Created (or appropriate response) instead of 401. Also test that the endpoint still rejects malformed data (e.g. missing email) with 400, and that once created, the user can then log in normally. Verify that authenticated endpoints still require session, i.e. this change doesn’t open any other route unexpectedly.
Missing Role Checks on Some Admin APIs – A few admin or sensitive routes are accessible to regular users when they should not be: for example, GET /api/admin/session-stats simply checks that the caller is authenticated, not that they are an admin
GitHub
. Any logged-in user could hit this and get information like total sessions and active session count (albeit not highly sensitive, it’s internal info). Similarly, the user permission endpoint /api/user/permissions doesn’t ensure the requesting user is allowed to view the target’s permissions – it only requires authentication and then returns the role and permission list of any user ID supplied
GitHub
GitHub
.
❗ Why it matters: While these are not critical data leaks, they violate the principle of least privilege. A regular user shouldn’t be able to call “admin” endpoints or enumerate other users’ roles. In a multi-tenant app, even knowledge of another tenant’s user IDs or roles is unnecessary exposure. These lapses could hint at other hidden permission issues.
🔮 Suspicious even if working: The routes function and return data, but the naming (/api/admin/*) suggests they meant it for admins. The lack of checks looks like an oversight. It’s the kind of thing an auditor or savvy customer might notice and question the rigor of role enforcement.
✅ Fix: Implement proper authorization checks on all admin routes. For session-stats, ensure req.user.role is admin or super_admin before allowing. For user/permissions, restrict it: either allow only querying one’s own permissions, or if an admin is querying subordinates in their org. At minimum, add an org match check (if user A requests user B’s permissions, ensure A’s org == B’s org, or A is super_admin). Also consider removing this endpoint entirely in favor of deriving permissions on the client from the user’s role.
🧠 Replit AI Prompt: “Strengthen access control in admin endpoints. In server/routes.ts, add role checks for /api/admin/session-stats (admin-only) and ensure /api/user/permissions only allows access to appropriate users (same organization or admin viewing own team). Implement missing checks and return 403 for unauthorized access.”
🧪 Tests: Log in as a normal user (role “user”) and call GET /api/admin/session-stats – it should now return 403 Forbidden instead of session data. Likewise, have User A (Org1) attempt GET /api/user/permissions?userId=<ID of User B in Org2> – this should be denied (403 or 404). As an admin, test that you can retrieve a team member’s permissions (if intended by design) but not a user from another org. Ensure that an admin can still access intended admin functions after the change.