Insecure Plaintext Password Authentication – The login logic in server/auth.ts simply checks if the provided password is "password" or matches the user’s email
GitHub
. This means any account can be accessed with a default or known string, a severe security risk. It completely bypasses real password authentication, violating enterprise security standards. Even if it “works” for dev, it’s highly suspicious in production.
❗ Why it matters: Attackers could trivially breach any user’s account, compromising all tenant data. There is no hashing or validation – a critical violation of security best practices.
🔮 Suspicious even if working: A comment in code admits this is a temporary measure and proper hashing is missing
GitHub
. Relying on it in a live system is dangerous, even if it “works” for demo logins.
✅ Fix: Integrate a robust password hashing mechanism (e.g. bcrypt with the provided salt rounds env setting) and store hashed passwords. Remove the hardcoded check. On login, hash the input password and compare with the stored hash. If using Supabase for auth, delegate verification to Supabase and remove this code.
🧠 Replit AI Prompt: “In server/auth.ts, replace the dummy password check with bcrypt hashing. Generate and store password hashes for users and verify them on login. Ensure the fix uses BCRYPT_SALT_ROUNDS from env for hashing.”
🧪 Tests: After refactoring, attempt logins with correct password vs. “password” to ensure only the real password works. Try logging in with an email as the password (previously allowed) – it should now fail. Also test creating a user and logging in to verify the hashing flow.
Cross-Tenant Analytics Data Exposure – The analytics endpoint logic allows an organization admin to access system-wide analytics. In server/routes.ts for /api/analytics, if no specific userId is requested, any user with role “admin” (not just a platform super-admin) can fetch global stats
GitHub
. The underlying query getAnalytics() aggregates all trips/users across tenants with no org filter
GitHub
, meaning an org admin could see total users, trips, etc. of other organizations.
❗ Why it matters: This violates cross-tenant isolation. One customer’s admin could glean another tenant’s usage metrics, undermining data confidentiality. Enterprise clients expect that no tenant can ever see another’s data.
🔮 Suspicious even if technically working: The code explicitly only restricts non-admin roles
GitHub
, implying org admins are treated like super-users. That’s likely an oversight – “admin” usually means org-level admin, not a global platform admin. It’s a red flag that a tenant admin has such broad access.
✅ Fix: Restrict global analytics to super_admin role only. In the /api/analytics handler, change the role check to allow only super_admin for the system-wide branch. Alternatively, scope the analytics queries by req.user.organizationId for org admins so they see only their org’s stats. E.g. modify getAnalytics() to accept an optional orgId and filter counts (e.g., WHERE organization_id = X) if provided.
🧠 Replit AI Prompt: “In the analytics route, ensure that only super_admin can access system-wide metrics. Update the role check and have org admins default to organization-scoped analytics. Implement an organizationId filter in analytics queries so org admins see only their org’s data.”
🧪 Tests: Log in as an org admin (non-super) and call GET /api/analytics. It should not return other organizations’ totals (either reject with 403 or return only that org’s data). As a super_admin, calling the endpoint should still return the full system analytics. Also test GET /api/analytics?userId=X for cross-org user IDs: ensure a non-super admin cannot fetch another org’s user analytics (should get 403).
Team Invitation Impersonation & Privilege Bypass – The team invite creation API (POST /api/invitations) trusts a client-supplied header x-user-id to identify the inviter
GitHub
, instead of using the session’s user. There is no role check – any logged-in user could attempt this. The code then loads whatever user ID was provided and uses that user’s organization to create an invitation
GitHub
. This means a malicious user could supply another user’s ID (even from another org) and create invites under that org.
❗ Why it matters: Relying on client input for user identity is a major security flaw. An attacker could potentially invite themselves into a different tenant’s team or perform admin-only actions. Lack of role verification means even basic users could send invites (possibly to elevate their own access). Cross-org authorization is broken here.
🔮 Suspicious even if working: It’s unusual that the server doesn’t simply use req.user. The presence of x-user-id hints that something is off with how the front-end or API is designed. Even if it “works” when the correct header is sent, it’s an unsafe design – essentially trusting user-provided identity.
✅ Fix: Use the authenticated session user for invite actions. Remove the x-user-id usage entirely; instead, get inviterUserId from req.user.id (set by unifiedAuthMiddleware). Also enforce that only authorized roles (e.g. org admin/manager) can invite. Implement a check like: if (req.user.role !== 'admin' && req.user.role !== 'manager') return 403. Ensure the invite’s organizationId is req.user.organizationId (already inherently true if using the session user).
🧠 Replit AI Prompt: “Refactor the /api/invitations POST handler in server/routes.ts: use req.user.id and req.user.organizationId instead of x-user-id. Add a role guard so that only users with admin privileges can create invitations. Remove any client-supplied user ID trust.”
🧪 Tests: With the fix, test creating invites: as an admin user (role Admin) call the endpoint (no special header needed) – it should succeed and issue an email (simulate the send). As a non-admin user, the endpoint should now reject with 403. Also attempt to spoof another ID by sending an x-user-id: the server should ignore it, preventing cross-org invite creation. Validate that the invitation’s organizationId always matches the inviter’s org.