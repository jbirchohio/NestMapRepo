White-Label Domain Context Not Fully Enforced: The multi-tenant “white-label” domain feature (custom domains per org) is only partially implemented – branding is applied, but requests aren’t auto-scoped by domain. The middleware resolveDomainOrganization is present but skips org resolution
GitHub
, and the global org context injection was disabled due to a crash
GitHub
. Consequently, visiting a custom domain loads the correct branding (logo/colors)
GitHub
GitHub
, but does not automatically restrict data to that org unless the user account itself is tied to it.
📍 Evidence: In server/index.ts, the call to inject org context is commented out “temporarily”
GitHub
. The resolveDomainOrganization function returns next() without setting an org (lines 88-90)
GitHub
. On the positive side, the /api/branding endpoint does fetch org by host header and returns custom UI config when white_label_enabled is true
GitHub
GitHub
. But that is purely cosmetic – the backend doesn’t tie the session or queries to that org based on domain.
❗ Why it Matters: For enterprise clients using custom domains, the expectation is that data and context are siloed by domain. A user hitting clientA.nestmap.com should ideally be “locked” to ClientA’s org context. Without this, there’s room for confusion or even phishing-style attacks (e.g., logging into the wrong domain with valid credentials might show data from the user’s actual org). It also places full reliance on user’s orgId in their account, rather than using domain as an added assurance of context.
✅ Fix: Finish and enable the domain scoping middleware. When a request comes in, look up the organization by req.hostname and then:
Pre-auth: On login or sign-up, auto-associate the user to that org if domains match (or require invite).
Post-auth: For authenticated requests, if req.hostname maps to an org different from req.user.organizationId, decide whether to reject (safer) or switch context. Likely, reject access to prevent cross-org access via wrong domain.
Set req.organizationId based on domain if user is admin of that org (for admin pages).
At minimum, re-enable injectOrganizationContext (after resolving its crash) so that req.organizationId is always set for authenticated users
GitHub
GitHub
. This will automatically enforce org filtering in queries and via the canAccessOrganization checks.
🧠 Replit Agent Prompt: “Enable and debug the organization context middleware for custom domains. When a request’s Host header matches an organization’s domain, set req.organizationId accordingly and ensure all queries filter by it. Prevent users from accessing data on a domain that doesn’t match their org. Implement unit tests for domain-based org isolation.”
🧪 Testing: Configure two organizations with distinct domains (e.g. orgA.localhost and orgB.localhost in hosts file). Log in as an Org A user on orgA.localhost – verify you only see Org A’s data. Then manually navigate to orgB.localhost with the same session cookie – the server should reject requests (e.g., /api/trips returns 403) if domain-org mismatch is enforced. Additionally, hitting /api/branding on each domain should return that org’s branding JSON (already working: e.g., curl -H "Host: orgA.localhost" http://localhost:5000/api/branding should show Org A’s custom colors).