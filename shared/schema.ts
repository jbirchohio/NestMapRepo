import { text, boolean, timestamp, jsonb, pgTable, serial, integer } from "drizzle-orm/pg-core"; // Restore pgTable, serial, integer for tables not yet moved
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import {
  users,
  organizations,
  trips,
  activities,
  todos,
  notes,
  invitations,
  organizationRoles,
  organizationMembers,
  tripCollaborators,
  insertTripSchema, // Import the Zod schema
  selectTripSchema, // Import the Zod schema
  insertActivitySchema, // Import the Zod schema
  selectActivitySchema, // Import the Zod schema
  // Explicitly import Trip and Activity types for transform functions
  type Trip, 
  type Activity,
  // TripComments and related items
  tripComments,
  insertTripCommentSchema,
  selectTripCommentSchema,
  type TripComment,
  type NewTripComment,
  // Will import other tables once they are defined in server/db/schema.ts
  // For example: userRoleEnum, organizationPlanEnum, etc.
} from "../server/db/schema"; // Adjusted path assuming shared is sibling to server

// pgTable definitions for users, organizations, trips, activities, todos, notes,
// invitations, organizationRoles, organizationMembers, tripCollaborators
// are imported from '../server/db/schema'.
// Other table definitions below will be moved progressively.

// Re-export commonly used tables and schemas for backward compatibility
export {
  users,
  organizations,
  trips,
  activities,
  todos,
  notes,
  invitations,
  organizationRoles,
  organizationMembers,
  tripCollaborators,
  tripComments,
  insertTripSchema,
  selectTripSchema,
  insertActivitySchema,
  selectActivitySchema,
  insertTripCommentSchema,
  selectTripCommentSchema,
} from "../server/db/schema";

// Re-export types from server/db/schema for consistent usage
export type {
  User, NewUser,
  Organization, NewOrganization,
  OrganizationRole, NewOrganizationRole,
  OrganizationMember, NewOrganizationMember,
  TripCollaborator, NewTripCollaborator,
  Invitation, NewInvitation,
  Trip, NewTrip,
  Activity, NewActivity,
  Todo, NewTodo,
  Note, NewNote,
  // Types for tables to be moved will be imported once defined in server/db/schema
  // For now, local type definitions will remain for tables still defined here.
} from "../server/db/schema";

export const insertUserSchema = createInsertSchema(users); // This now uses the imported UUID-based 'users' table


// Authentication schema for registration (includes password field)
// insertUserSchema is now derived from the UUID-based users table from server/db/schema.ts
// Ensure the fields in .omit() and .extend() are compatible with the new insertUserSchema structure.
export const registerUserSchema = insertUserSchema.pick({
  email: true,
  username: true,
  firstName: true, // Optional in DB, pick will respect this
  lastName: true   // Optional in DB, pick will respect this
}).extend({
  password: z.string().min(8, "Password must be at least 8 characters")
});

// Login schema
export const loginSchema = z.object({
  email: z.string().email("Invalid email address"),
  password: z.string().min(1, "Password is required")
});

export const insertOrganizationSchema = createInsertSchema(organizations); // This now uses the imported UUID-based 'organizations' table

export const insertOrganizationRoleSchema = createInsertSchema(organizationRoles); // organizationRoles is imported UUID-based table. id, created_at, and updated_at are typically auto-generated by the DB or have defaults, and createInsertSchema handles this by omitting them from the insert schema by default.

export const insertOrganizationMemberSchema = createInsertSchema(organizationMembers); // organizationMembers is imported UUID-based table
// Implicitly, organization_id, user_id, invited_by will be UUIDs if defined as such in the server/db/schema.ts

export const insertTripCollaboratorSchema = createInsertSchema(tripCollaborators); // tripCollaborators is imported UUID-based table
// Implicitly, trip_id, user_id, invited_by will be UUIDs

// Invitations pgTable definition removed, imported from server/db/schema.

export const insertInvitationSchema = createInsertSchema(invitations).pick({ // invitations is imported UUID-based table
  // Ensure picked fields like organizationId, invitedByUserId are UUIDs in the base schema
  email: true,
  organizationId: true, // Ensure this exists on 'invitations' table and is a UUID
  invitedByUserId: true, // Corrected from invitedBy, ensure this exists and is UUID
  // roleToAssign: true,    // Temporarily commented out for diagnosis
  token: true,
  expiresAt: true,
});

// Trips pgTable definition removed, imported from server/db/schema.

// The insertTripSchema is now imported from ../server/db/schema.ts
// The selectTripSchema is also imported.
// The insertActivitySchema is now imported from ../server/db/schema.ts
// The selectActivitySchema is also imported.


// Helper function to transform database trip to frontend format
// The 'Trip' type is now imported from server/db/schema and is UUID-based
export function transformTripToFrontend(trip: Trip) {
  return {
    id: trip.id,
    title: trip.title,
    startDate: trip.startDate,
    endDate: trip.endDate,
    userId: trip.userId,
    organizationId: trip.organizationId,
    collaborators: trip.collaborators,
    isPublic: trip.isPublic,
    shareCode: trip.shareCode,
    sharingEnabled: trip.sharingEnabled,
    sharePermission: trip.sharePermission,
    city: trip.city,
    country: trip.country,
    location: trip.location,
    cityLatitude: trip.cityLatitude,
    cityLongitude: trip.cityLongitude,
    hotel: trip.hotel,
    hotelLatitude: trip.hotelLatitude,
    hotelLongitude: trip.hotelLongitude,
    completed: trip.completed,
    completedAt: trip.completedAt,
    tripType: trip.tripType,
    clientName: trip.clientName,
    projectType: trip.projectType,
    budget: trip.budget,
    createdAt: trip.createdAt,
    updatedAt: trip.updatedAt,
  };
}

// Helper function to transform database activity to frontend format
// The 'Activity' type is now imported from server/db/schema and is UUID-based
export function transformActivityToFrontend(activity: Activity) {
  return {
    id: activity.id,
    tripId: activity.tripId,
    organizationId: activity.organizationId,
    title: activity.title,
    date: activity.date,
    time: activity.time,
    locationName: activity.locationName,
    latitude: activity.latitude,
    longitude: activity.longitude,
    notes: activity.notes,
    tag: activity.tag,
    assignedTo: activity.assignedTo,
    order: activity.order,
    travelMode: activity.travelMode,
    completed: activity.completed,
  };
}

// Activities pgTable definition removed, imported from server/db/schema.

/*
// Create a custom schema that properly handles dates as strings from JSON and uses UUIDs
export const insertActivitySchema = createInsertSchema(activities, {
  tripId: z.string().uuid({ message: "Trip ID must be a valid UUID" }),
  organizationId: z.string().uuid({ message: "Organization ID must be a valid UUID" }).optional().nullable(), // Match DB schema
  title: z.string(),
  date: z.coerce.date(), // Handles string or date input
  time: z.string().optional().nullable(), // Match DB schema
  locationName: z.string().optional().nullable(), // Match DB schema
  latitude: z.string().optional().nullable(), // Match DB schema
  longitude: z.string().optional().nullable(), // Match DB schema
  notes: z.string().optional().nullable(), // Match DB schema
  tag: z.string().optional().nullable(), // Match DB schema
  assignedTo: z.string().uuid({ message: "Assigned user ID must be a valid UUID" }).optional().nullable(), // Match DB schema
  order: z.number().optional().default(0), // Match DB schema
  travelMode: z.string().optional().nullable(), // Match DB schema
  completed: z.boolean().optional().default(false), // Match DB schema
});
*/

// Todos pgTable definition removed, imported from server/db/schema.

export const insertTodoSchema = createInsertSchema(todos, {
  tripId: z.string().uuid({ message: "Trip ID must be a valid UUID" }),
  organizationId: z.string().uuid({ message: "Organization ID must be a valid UUID" }).optional().nullable(), // Match DB schema
  task: z.string(),
  completed: z.boolean().optional().default(false), // Match DB schema
  assignedTo: z.string().uuid({ message: "Assigned user ID must be a valid UUID" }).optional().nullable(), // Match DB schema
  dueDate: z.coerce.date().optional().nullable()
});

// Notes pgTable definition removed, imported from server/db/schema.

export const insertNoteSchema = createInsertSchema(notes, {
  tripId: z.string().uuid({ message: "Trip ID must be a valid UUID" }).optional().nullable(), // Match DB schema
  activityId: z.string().uuid({ message: "Activity ID must be a valid UUID" }).optional().nullable(), // Match DB schema
  userId: z.string().uuid({ message: "User ID must be a valid UUID" }), // Match DB schema, notNull
  organizationId: z.string().uuid({ message: "Organization ID must be a valid UUID" }).optional().nullable(), // Match DB schema
  content: z.string(),
  title: z.string().optional().nullable(), // Match DB schema
  category: z.string().optional().nullable(), // Match DB schema
});

// RBAC constants moved to end of file

export const TRIP_ROLES = {
  ADMIN: 'admin',
  EDITOR: 'editor',
  VIEWER: 'viewer',
  COMMENTER: 'commenter'
} as const;

export const ORGANIZATION_PLANS = {
  FREE: 'free',
  TEAM: 'team',
  ENTERPRISE: 'enterprise'
} as const;

// Enhanced permission system for organizations
export const ORGANIZATION_PERMISSIONS = {
  // Trip permissions
  VIEW_ALL_TRIPS: "view_all_trips",
  EDIT_ALL_TRIPS: "edit_all_trips", 
  CREATE_TRIPS: "create_trips",
  DELETE_TRIPS: "delete_trips",
  
  // Team permissions
  INVITE_MEMBERS: "invite_members",
  MANAGE_MEMBERS: "manage_members",
  VIEW_MEMBERS: "view_members",
  
  // Business permissions
  MANAGE_BUDGETS: "manage_budgets",
  EXPORT_DATA: "export_data",
  ACCESS_ANALYTICS: "access_analytics",
  
  // Admin permissions
  MANAGE_ORGANIZATION: "manage_organization",
  BILLING_ACCESS: "billing_access"
} as const;

// Export types
// User and Organization types are re-exported from "../server/db/schema" on lines 25-38.
// The $inferSelect types are implicitly available via those re-exports.
// InsertUser and InsertOrganization will be inferred correctly from their Zod schemas.

// Trip travelers table will be moved to server/db/schema.ts and imported.
/*
export const tripTravelers = pgTable("trip_travelers", {
  id: serial("id").primaryKey(), // If this table is to be migrated, id should be uuid()
  trip_id: integer("trip_id").notNull(), // MUST BECOME: text("trip_id").notNull().references(() => trips.id, { onDelete: 'cascade' })
  user_id: integer("user_id").notNull(), // MUST BECOME: text("user_id").notNull().references(() => users.id, { onDelete: 'cascade' })
  first_name: text("first_name").notNull(),
  last_name: text("last_name").notNull(),
  email: text("email"),
  phone: text("phone"),
  date_of_birth: timestamp("date_of_birth"),
  passport_number: text("passport_number"),
  passport_expiry: timestamp("passport_expiry"),
  nationality: text("nationality"),
  seat_preference: text("seat_preference"),
  meal_preference: text("meal_preference"),
  loyalty_program_number: text("loyalty_program_number"),
  notes: text("notes"),
  created_at: timestamp("created_at").defaultNow(),
  updated_at: timestamp("updated_at").defaultNow(),
});
*/

/*
export const insertTripTravelerSchema = createInsertSchema(tripTravelers);
// This will be updated once tripTravelers is imported from server/db/schema.ts
*/

// RBAC utility types - definitions moved to end of file

// The InvitationSchema definition previously here (around line 253-260) was redundant with insertInvitationSchema.
// Please use insertInvitationSchema (defined around line 65) for validating invitation creation data.

// Corporate Card Management System tables will be moved to server/db/schema.ts and imported.
/*
export const corporateCards = pgTable("corporate_cards", {
  id: serial("id").primaryKey(),
  organization_id: integer("organization_id").notNull(),
  user_id: integer("user_id").notNull(),
  stripe_card_id: text("stripe_card_id").notNull(), // Stripe card ID
  card_number_masked: text("card_number_masked").notNull(), // Last 4 digits only
  card_token: text("card_token").notNull(), // Encrypted token for API calls
  card_provider: text("card_provider").notNull(), // stripe, marqeta, etc
  card_type: text("card_type").default("virtual"), // virtual, physical
  status: text("status").default("active"), // active, inactive, frozen, canceled
  spending_limit: integer("spending_limit"), // Limit in cents
  available_balance: integer("available_balance"), // Available balance in cents
  currency: text("currency").default("USD"),
  category_limits: jsonb("category_limits"), // Per-category spending limits
  allowed_merchants: jsonb("allowed_merchants"), // Whitelist of merchant categories
  blocked_merchants: jsonb("blocked_merchants"), // Blacklist of merchant categories
  cardholder_name: text("cardholder_name").notNull(),
  expiry_month: text("expiry_month"),
  expiry_year: text("expiry_year"),
  billing_address: jsonb("billing_address"),
  shipping_address: jsonb("shipping_address"),
  purpose: text("purpose"), // travel, office_supplies, marketing, etc
  department: text("department"),
  cost_center: text("cost_center"),
  manager_id: integer("manager_id"), // Who approves expenses
  auto_lock_triggers: jsonb("auto_lock_triggers"), // Automated controls
  created_by: integer("created_by").notNull(),
  created_at: timestamp("created_at").defaultNow(),
  updated_at: timestamp("updated_at").defaultNow(),
});
*/

/*
export const cardholders = pgTable("cardholders", {
  id: serial("id").primaryKey(),
  organization_id: integer("organization_id").notNull(),
  stripe_cardholder_id: text("stripe_cardholder_id").notNull(),
  name: text("name").notNull(),
  email: text("email").notNull(),
  phone_number: text("phone_number"),
  billing_address: jsonb("billing_address").notNull(),
  created_by: integer("created_by").notNull(),
  created_at: timestamp("created_at").defaultNow(),
  updated_at: timestamp("updated_at").defaultNow(),
});
*/

/*
export const cardTransactions = pgTable("card_transactions", {
  id: serial("id").primaryKey(),
  card_id: integer("card_id").notNull(),
  user_id: integer("user_id").notNull(),
  stripe_transaction_id: text("stripe_transaction_id").notNull(),
  amount: integer("amount").notNull(), // Amount in cents
  currency: text("currency").default("USD"),
  merchant_name: text("merchant_name").notNull(),
  merchant_category: text("merchant_category"),
  merchant_mcc: text("merchant_mcc"), // Merchant Category Code
  status: text("status").default("pending"), // pending, completed, declined
  transaction_type: text("transaction_type").default("purchase"), // purchase, refund, adjustment
  authorization_code: text("authorization_code"),
  network_transaction_id: text("network_transaction_id")
});
*/
/*
export const insertCorporateCardSchema = createInsertSchema(corporateCards).omit({
  id: true,
  created_at: true,
  updated_at: true,
});
*/

/*
export const insertCardholderSchema = createInsertSchema(cardholders).omit({
  id: true,
  created_at: true,
  updated_at: true,
});
*/

/*
export const insertCardTransactionSchema = createInsertSchema(cardTransactions).omit({
  id: true,
  created_at: true,
  updated_at: true,
});
*/

// Types for corporate cards
/*
export type CorporateCard = typeof corporateCards.$inferSelect;
export type InsertCorporateCard = z.infer<typeof insertCorporateCardSchema>;
export type Cardholder = typeof cardholders.$inferSelect;
export type InsertCardholder = z.infer<typeof insertCardholderSchema>;


// Expenses table will be moved to server/db/schema.ts and imported.
/*
export const expenses = pgTable("expenses", {
  id: serial("id").primaryKey(),
  organization_id: integer("organization_id").notNull(),
  user_id: integer("user_id").notNull(),
  card_id: integer("card_id"), // If paid with corporate card
  trip_id: integer("trip_id"), // If related to travel
  transaction_id: text("transaction_id"), // External transaction ID
  merchant_name: text("merchant_name").notNull(),
  merchant_category: text("merchant_category"),
  merchant_mcc: text("merchant_mcc"), // Merchant Category Code
  amount: integer("amount").notNull(), // Amount in cents
  currency: text("currency").default("USD"),
  transaction_date: timestamp("transaction_date").notNull(),
  expense_category: text("expense_category").notNull(), // travel, meals, office, etc
  description: text("description"),
  receipt_url: text("receipt_url"),
  receipt_status: text("receipt_status").default("pending"), // pending, uploaded, verified
  business_purpose: text("business_purpose"),
  attendees: jsonb("attendees"), // For meal expenses
  mileage: integer("mileage"), // For vehicle expenses
  status: text("status").default("pending"), // pending, approved, rejected, reimbursed
  approval_status: text("approval_status").default("pending"), // pending, approved, rejected
  approved_by: integer("approved_by"),
  approved_at: timestamp("approved_at"),
  rejection_reason: text("rejection_reason"),
  reimbursement_status: text("reimbursement_status").default("pending"),
  reimbursed_at: timestamp("reimbursed_at"),
  policy_violations: jsonb("policy_violations"), // Any policy violations detected
  tax_deductible: boolean("tax_deductible").default(true),
  billable_to_client: boolean("billable_to_client").default(false),
  client_id: integer("client_id"), // If billable
  project_code: text("project_code"),
  gl_code: text("gl_code"), // General Ledger code
  created_at: timestamp("created_at").defaultNow(),
  updated_at: timestamp("updated_at").defaultNow(),
});
*/

export const spendPolicies = pgTable("spend_policies", {
  id: serial("id").primaryKey(),
  organization_id: integer("organization_id").notNull(),
  name: text("name").notNull(),
  description: text("description"),
  is_active: boolean("is_active").default(true),
  applies_to: text("applies_to").default("all"), // all, departments, users, roles
  target_departments: jsonb("target_departments"),
  target_users: jsonb("target_users"),
  target_roles: jsonb("target_roles"),
  
  // Spending limits
  daily_limit: integer("daily_limit"),
  weekly_limit: integer("weekly_limit"),
  monthly_limit: integer("monthly_limit"),
  annual_limit: integer("annual_limit"),
  
  // Category-specific limits
  category_limits: jsonb("category_limits"), // { "travel": 5000, "meals": 100 }
  merchant_restrictions: jsonb("merchant_restrictions"),
  
  // Approval workflows
  requires_approval_over: integer("requires_approval_over"), // Amount requiring approval
  auto_approve_under: integer("auto_approve_under"), // Auto-approve small amounts
  approval_chain: jsonb("approval_chain"), // Multi-level approval process
  
  // Receipt requirements
  receipt_required_over: integer("receipt_required_over"),
  business_purpose_required: boolean("business_purpose_required").default(false),
  
  // Time restrictions
  allowed_days: jsonb("allowed_days"), // Days of week allowed
  allowed_hours: jsonb("allowed_hours"), // Time ranges allowed
  
  // Geographic restrictions
  allowed_countries: jsonb("allowed_countries"),
  blocked_countries: jsonb("blocked_countries"),
  
  created_by: integer("created_by").notNull(),
  created_at: timestamp("created_at").defaultNow(),
  updated_at: timestamp("updated_at").defaultNow(),
});

// Duplicate declaration removed - using the one defined above

// Budgets table will be moved to server/db/schema.ts and imported.
/*
export const budgets = pgTable("budgets", {
  id: serial("id").primaryKey(),
  organization_id: integer("organization_id").notNull(),
  name: text("name").notNull(),
  description: text("description"),
  budget_type: text("budget_type").notNull(), // department, project, employee, category
  
  // Budget scope
  department: text("department"),
  project_code: text("project_code"),
  employee_id: integer("employee_id"),
  expense_category: text("expense_category"),
  
  // Budget amounts
  total_budget: integer("total_budget").notNull(), // Total budget in cents
  spent_amount: integer("spent_amount").default(0),
  committed_amount: integer("committed_amount").default(0), // Pending expenses
  remaining_amount: integer("remaining_amount").notNull(),
  
  // Time period
  start_date: timestamp("start_date").notNull(),
  end_date: timestamp("end_date").notNull(),
  budget_period: text("budget_period"), // monthly, quarterly, annual
  
  // Alerts and controls
  alert_thresholds: jsonb("alert_thresholds"), // { "50": ["email"], "80": ["email", "slack"] }
  auto_lock_at_limit: boolean("auto_lock_at_limit").default(false),
  
  // Ownership
  owner_id: integer("owner_id").notNull(),
  approvers: jsonb("approvers"), // Who can approve budget changes
  
  is_active: boolean("is_active").default(true),
  created_at: timestamp("created_at").defaultNow(),
  updated_at: timestamp("updated_at").defaultNow(),
});

*/
export const expenseApprovals = pgTable("expense_approvals", {
  id: serial("id").primaryKey(),
  expense_id: integer("expense_id").notNull(),
  organization_id: integer("organization_id").notNull(),
  approver_id: integer("approver_id").notNull(),
  approval_level: integer("approval_level").default(1), // For multi-level approvals
  status: text("status").default("pending"), // pending, approved, rejected
  comments: text("comments"),
  approved_amount: integer("approved_amount"), // Might be less than requested
  policy_override: boolean("policy_override").default(false),
  override_reason: text("override_reason"),
  processed_at: timestamp("processed_at"),
  created_at: timestamp("created_at").defaultNow(),
});

export const reimbursements = pgTable("reimbursements", {
  id: serial("id").primaryKey(),
  organization_id: integer("organization_id").notNull(),
  user_id: integer("user_id").notNull(),
  batch_id: text("batch_id"), // Group reimbursements together
  
  // Reimbursement details
  total_amount: integer("total_amount").notNull(),
  currency: text("currency").default("USD"),
  expense_ids: jsonb("expense_ids").notNull(), // Array of expense IDs
  
  // Payment details
  payment_method: text("payment_method"), // direct_deposit, check, payroll
  payment_status: text("payment_status").default("pending"), // pending, processing, paid, failed
  payment_reference: text("payment_reference"), // Bank reference number
  payment_date: timestamp("payment_date"),
  
  // Banking information
  bank_account_id: text("bank_account_id"),
  routing_number: text("routing_number"),
  account_number_masked: text("account_number_masked"),
  
  processed_by: integer("processed_by"),
  created_at: timestamp("created_at").defaultNow(),
  updated_at: timestamp("updated_at").defaultNow(),
});

// White Label Branding Settings
export const whiteLabelSettings = pgTable("white_label_settings", {
  id: serial("id").primaryKey(),
  organization_id: integer("organization_id").references(() => organizations.id).notNull(),
  company_name: text("company_name").notNull(),
  company_logo: text("company_logo"),
  tagline: text("tagline"),
  primary_color: text("primary_color").default("#3B82F6"),
  secondary_color: text("secondary_color").default("#64748B"),
  accent_color: text("accent_color").default("#10B981"),
  custom_domain: text("custom_domain"),
  support_email: text("support_email"),
  help_url: text("help_url"),
  footer_text: text("footer_text"),
  status: text("status").default("draft"), // draft, pending_approval, approved, rejected
  approved_by: integer("approved_by").references(() => users.id),
  approved_at: timestamp("approved_at"),
  rejection_reason: text("rejection_reason"),
  created_at: timestamp("created_at").defaultNow(),
  updated_at: timestamp("updated_at").defaultNow(),
});

// Custom Domain Management
// Custom domains table will be moved to server/db/schema.ts and imported.
/*
export const customDomains = pgTable("custom_domains", {
  id: serial("id").primaryKey(),
  organization_id: integer("organization_id").references(() => organizations.id).notNull(),
  domain: text("domain").notNull().unique(),
  subdomain: text("subdomain"), // For subdomain.nestmap.com
  ssl_certificate: text("ssl_certificate"),
  dns_verified: boolean("dns_verified").default(false),
  ssl_verified: boolean("ssl_verified").default(false),
  status: text("status").default("pending"), // pending, active, failed, disabled
  verification_token: text("verification_token"),
  created_at: timestamp("created_at").defaultNow(),
  verified_at: timestamp("verified_at"),
});
*/

// White Label Approval Requests
export const whiteLabelRequests = pgTable("white_label_requests", {
  id: serial("id").primaryKey(),
  organization_id: integer("organization_id").references(() => organizations.id).notNull(),
  requested_by: integer("requested_by").references(() => users.id).notNull(),
  request_type: text("request_type").notNull(), // branding_update, domain_setup, plan_upgrade
  request_data: jsonb("request_data"), // JSON data for the request
  status: text("status").default("pending"), // pending, approved, rejected
  reviewed_by: integer("reviewed_by").references(() => users.id),
  reviewed_at: timestamp("reviewed_at"),
  review_notes: text("review_notes"),
  created_at: timestamp("created_at").defaultNow(),
});

// White Label Feature Limits
export const whiteLabelFeatures = pgTable("white_label_features", {
  id: serial("id").primaryKey(),
  plan: text("plan").notNull(), // basic, premium, enterprise
  custom_logo: boolean("custom_logo").default(false),
  custom_colors: boolean("custom_colors").default(false),
  custom_domain: boolean("custom_domain").default(false),
  remove_branding: boolean("remove_branding").default(false),
  custom_email_templates: boolean("custom_email_templates").default(false),
  api_access: boolean("api_access").default(false),
  max_users: integer("max_users").default(5),
  monthly_price: integer("monthly_price").default(0), // in cents
});

// User Sessions for tracking active users
export const userSessions = pgTable("user_sessions", {
  id: serial("id").primaryKey(),
  user_id: integer("user_id").references(() => users.id).notNull(),
  organization_id: integer("organization_id").references(() => organizations.id),
  session_token: text("session_token").notNull().unique(),
  ip_address: text("ip_address"),
  user_agent: text("user_agent"),
  last_activity: timestamp("last_activity").defaultNow(),
  created_at: timestamp("created_at").defaultNow(),
  expires_at: timestamp("expires_at").notNull(),
});

// Admin Settings for system configuration
export const adminSettings = pgTable("admin_settings", {
  id: serial("id").primaryKey(),
  key: text("key").notNull().unique(),
  value: text("value").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// User Activity Logs for tracking regular user actions
export const userActivityLogs = pgTable("user_activity_logs", {
  id: serial("id").primaryKey(),
  user_id: integer("user_id").references(() => users.id).notNull(),
  organization_id: integer("organization_id").references(() => organizations.id),
  action: text("action").notNull(), // e.g., 'create_trip', 'update_profile', 'add_collaborator'
  details: jsonb("details"), // Additional context, e.g., { trip_id: 123, collaborator_id: 456 }
  ip_address: text("ip_address"),
  user_agent: text("user_agent"),
  created_at: timestamp("created_at").defaultNow(),
});

export const insertUserActivityLogSchema = createInsertSchema(userActivityLogs);
export type UserActivityLog = typeof userActivityLogs.$inferSelect;

// Admin Audit Log table will be moved to server/db/schema.ts and imported.
// export const insertAdminAuditLogSchema = createInsertSchema(adminAuditLog).omit({
//   id: true,
//   created_at: true,
// });
// export type InsertAdminAuditLog = z.infer<typeof insertAdminAuditLogSchema>;

// Trip Collaboration Types
// export type TripCollaboration = typeof tripCollaborators.$inferSelect; // TripCollaborator type is already re-exported from server/db/schema
export type { TripComment, NewTripComment }; // Re-exporting types imported above
// The .omit logic for insertTripCommentSchema should ideally be in server/db/schema.ts if it's the standard schema.
// If a specific variant is needed here, it would require createInsertSchema and tripComments to be available/imported.
// For now, re-exporting the standard schemas from server/db/schema.ts.
// export type ActivityLog = typeof activityLog.$inferSelect;
// export type InsertActivityLog = z.infer<typeof insertUserActivityLogSchema>;

// Approval Workflow Schema
/*
// export const insertApprovalRequestSchema = createInsertSchema(approvalRequests).omit({
//   id: true,
//   createdAt: true,
//   updatedAt: true,
//   organizationId: true,
// });
// export type InsertApprovalRequest = z.infer<typeof insertApprovalRequestSchema>;
// export type ApprovalRule = typeof approvalRules.$inferSelect;
// export type InsertApprovalRule = z.infer<typeof insertApprovalRuleSchema>;

// Superadmin Audit Logs
// export const insertSuperadminAuditLogSchema = createInsertSchema(superadminAuditLogs).omit({
//   id: true,
//   created_at: true,
// });
// export type InsertSuperadminAuditLog = z.infer<typeof insertSuperadminAuditLogSchema>;

// Superadmin types
// export type ActiveSession = typeof activeSessions.$inferSelect;
// export type InsertActiveSession = z.infer<typeof insertActiveSessionSchema>;
// export type AiUsageLog = typeof aiUsageLogs.$inferSelect;
// export type InsertAiUsageLog = z.infer<typeof insertAiUsageLogSchema>;
// export type FeatureFlag = typeof featureFlags.$inferSelect;
// export type InsertFeatureFlag = z.infer<typeof insertFeatureFlagSchema>;
// export type OrganizationFeatureFlag = typeof organizationFeatureFlags.$inferSelect;
// export type InsertOrganizationFeatureFlag = z.infer<typeof insertOrganizationFeatureFlagSchema>;
// export type BackgroundJob = typeof backgroundJobs.$inferSelect;
// export type InsertBackgroundJob = z.infer<typeof insertBackgroundJobSchema>;
// export type BillingEvent = typeof billingEvents.$inferSelect;
// export type InsertBillingEvent = z.infer<typeof insertBillingEventSchema>;
*/


// User roles constants
export const USER_ROLES = {
  SUPERADMIN_OWNER: 'superadmin_owner',
  SUPERADMIN_STAFF: 'superadmin_staff', 
  SUPERADMIN_AUDITOR: 'superadmin_auditor',
  ADMIN: 'admin',
  MANAGER: 'manager',
  USER: 'user',
  GUEST: 'guest'
} as const;

export type UserRoleType = typeof USER_ROLES[keyof typeof USER_ROLES];
export type TripRole = typeof TRIP_ROLES[keyof typeof TRIP_ROLES];
export type OrganizationPlan = typeof ORGANIZATION_PLANS[keyof typeof ORGANIZATION_PLANS];
