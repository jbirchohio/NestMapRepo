# tRPC Migration Guide

This document outlines the steps required to migrate the existing Express REST API and React client to tRPC. The goal is to provide a clear roadmap so even newer developers can understand the process.

## 1. Overview of Current Architecture

- **Server**
  - Located in the `server` workspace.
  - Uses Express with routes defined under `server/src/routes` and loaded dynamically in `server/src/routes/index.ts`.
  - Middleware handles authentication, error handling and logging.
  - Drizzle ORM is used for database access (`server/src/db`).
- **Client**
  - Located in the `client` workspace.
  - Uses React + Vite. Network calls use a custom `ApiClient` wrapper around `fetch`/`axios` (`client/src/lib/apiClient.ts`).

The new architecture will use **tRPC** to create type‑safe APIs shared between the server and client.

## 2. Installing Dependencies

1. In the repository root run:
   ```bash
   pnpm add -w @trpc/server @trpc/client @trpc/react-query @trpc/server/adapters/express zod
   pnpm add -w -D @trpc/react-query@latest
   ```
2. These libraries allow defining procedures on the server and consuming them in the client with React Query.

## 3. Creating the Server Setup

1. **Create tRPC context** – this contains things like the database connection and the authenticated user:
   ```ts
   // server/src/trpc/context.ts
   import type { inferAsyncReturnType } from '@trpc/server';
   import { initTRPC } from '@trpc/server';

   export async function createContext({ req, res }: { req: any; res: any }) {
     return { req, res, db: getDatabase(), user: req.user };
   }
   export type Context = inferAsyncReturnType<typeof createContext>;
   export const t = initTRPC.context<Context>().create();
   ```
2. **Build routers** – convert each route file into a tRPC router. Example for `auth`:
   ```ts
   // server/src/trpc/routers/auth.ts
   import { t } from '../context';
   import { z } from 'zod';
   export const authRouter = t.router({
     login: t.procedure
       .input(z.object({ email: z.string().email(), password: z.string().min(6) }))
       .mutation(async ({ input, ctx }) => {
         // reuse logic from existing /api/auth/login
       }),
     me: t.procedure.query(async ({ ctx }) => {
       return ctx.user; // or fetch from db
     }),
   });
   ```
3. **Combine routers**:
   ```ts
   // server/src/trpc/routers/index.ts
   import { t } from '../context';
   import { authRouter } from './auth';
   export const appRouter = t.router({
     auth: authRouter,
     // add other routers here
   });
   export type AppRouter = typeof appRouter;
   ```
4. **Add tRPC middleware to Express**:
   ```ts
   // server/src/app.ts (or main.ts)
   import { createExpressMiddleware } from '@trpc/server/adapters/express';
   import { appRouter } from './trpc/routers';
   import { createContext } from './trpc/context';

   app.use('/trpc', createExpressMiddleware({ router: appRouter, createContext }));
   ```
   Keep existing REST endpoints during migration to allow gradual conversion.

## 4. Updating the Client

1. **Create the tRPC client**:
   ```ts
   // client/src/lib/trpc.ts
   import { createTRPCReact } from '@trpc/react-query';
   import type { AppRouter } from '@server/api/dist/trpc/routers'; // adjust path
   export const trpc = createTRPCReact<AppRouter>();
   ```
2. **Set up the tRPC provider**:
   ```tsx
   // client/src/main.tsx
   import { httpBatchLink } from '@trpc/client';
   import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
   import { trpc } from './lib/trpc';

   const client = trpc.createClient({
     links: [httpBatchLink({ url: '/trpc' })],
   });
   const queryClient = new QueryClient();

   ReactDOM.createRoot(document.getElementById('root')!).render(
     <trpc.Provider client={client} queryClient={queryClient}>
       <QueryClientProvider client={queryClient}>
         <App />
       </QueryClientProvider>
     </trpc.Provider>
   );
   ```
3. **Replace REST calls** – Instead of `apiClient.get('/api/trips')` you call hooks generated by tRPC:
   ```tsx
   const { data, isLoading } = trpc.auth.me.useQuery();
   const loginMutation = trpc.auth.login.useMutation();
   ```

## 5. Migration Strategy

1. **Set up tRPC alongside existing REST API** so the application continues working.
2. **Iteratively migrate each route**:
   - Start with simple routes like `/health` or `/auth`.
   - Move the business logic from Express handlers into tRPC procedures.
   - Update client code to call the new procedure using generated hooks.
   - Remove the old REST endpoint after confirming the tRPC procedure works.
3. **Share types** – reuse Zod schemas from `server` or `shared` so the client gets types automatically.
4. **Authentication** – replicate the `authenticateJWT` middleware logic inside tRPC context or as middleware using `t.middleware()`.
5. **Error handling** – throw `TRPCError` within procedures. The client receives structured errors automatically.
6. **Testing** – update Jest tests to use the tRPC routes. The pattern is similar to calling Express endpoints but using the tRPC caller (`appRouter.createCaller(ctx)`).

## 6. Example Procedure Conversion

Below is a sketch of converting the trip list endpoint to tRPC:
```ts
// server/src/trpc/routers/trips.ts
import { t } from '../context';
export const tripsRouter = t.router({
  list: t.procedure.query(async ({ ctx }) => {
    const db = ctx.db;
    if (!db) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR' });
    return db.select().from(trips).where(eq(trips.organizationId, ctx.user.organizationId));
  }),
});
```
Client usage:
```tsx
const { data: trips } = trpc.trips.list.useQuery();
```

## 7. Cleaning Up

- Once all routes are migrated, remove unused Express route files and the custom `ApiClient`.
- Ensure all tests are updated to use tRPC.
- Update documentation and deployment scripts to expose the `/trpc` endpoint.

## 8. Learning Resources

- [tRPC documentation](https://trpc.io/docs)
- [tRPC with Express](https://trpc.io/docs/server/adapters/express)
- [tRPC React Query](https://trpc.io/docs/react)

Following this plan will modernize the API layer with end‑to‑end type safety and reduce the amount of manual request and response handling currently in the codebase.
