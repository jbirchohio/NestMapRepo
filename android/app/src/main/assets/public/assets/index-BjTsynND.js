var Tk = t => { throw TypeError(t); };
var GS = (t, r, o) => r.has(t) || Tk("Cannot " + o);
var Ke = (t, r, o) => (GS(t, r, "read from private field"), o ? o.call(t) : r.get(t)), rn = (t, r, o) => r.has(t) ? Tk("Cannot add the same private member more than once") : r instanceof WeakSet ? r.add(t) : r.set(t, o), Sr = (t, r, o, u) => (GS(t, r, "write to private field"), u ? u.call(t, o) : r.set(t, o), o), Nn = (t, r, o) => (GS(t, r, "access private method"), o);
var u1 = (t, r, o, u) => ({ set _(g) { Sr(t, r, g, o); }, get _() { return Ke(t, r, u); } });
function kU(t, r) { for (var o = 0; o < r.length; o++) {
    const u = r[o];
    if (typeof u != "string" && !Array.isArray(u)) {
        for (const g in u)
            if (g !== "default" && !(g in t)) {
                const y = Object.getOwnPropertyDescriptor(u, g);
                y && Object.defineProperty(t, g, y.get ? y : { enumerable: !0, get: () => u[g] });
            }
    }
} return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })); }
(function () { const r = document.createElement("link").relList; if (r && r.supports && r.supports("modulepreload"))
    return; for (const g of document.querySelectorAll("link[rel=\"modulepreload\"]"))
    u(g); new MutationObserver(g => { for (const y of g)
    if (y.type === "childList")
        for (const E of y.addedNodes)
            E.tagName === "LINK" && E.rel === "modulepreload" && u(E); }).observe(document, { childList: !0, subtree: !0 }); function o(g) { const y = {}; return g.integrity && (y.integrity = g.integrity), g.referrerPolicy && (y.referrerPolicy = g.referrerPolicy), g.crossOrigin === "use-credentials" ? y.credentials = "include" : g.crossOrigin === "anonymous" ? y.credentials = "omit" : y.credentials = "same-origin", y; } function u(g) { if (g.ep)
    return; g.ep = !0; const y = o(g); fetch(g.href, y); } })();
var _a = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function TC(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t; }
function DU(t) { if (t.__esModule)
    return t; var r = t.default; if (typeof r == "function") {
    var o = function u() { return this instanceof u ? Reflect.construct(r, arguments, this.constructor) : r.apply(this, arguments); };
    o.prototype = r.prototype;
}
else
    o = {}; return Object.defineProperty(o, "__esModule", { value: !0 }), Object.keys(t).forEach(function (u) { var g = Object.getOwnPropertyDescriptor(t, u); Object.defineProperty(o, u, g.get ? g : { enumerable: !0, get: function () { return t[u]; } }); }), o; }
var wO = { exports: {} }, Jw = {}, bO = { exports: {} }, Qn = {}; /**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Yv = Symbol.for("react.element"), LU = Symbol.for("react.portal"), OU = Symbol.for("react.fragment"), zU = Symbol.for("react.strict_mode"), FU = Symbol.for("react.profiler"), NU = Symbol.for("react.provider"), BU = Symbol.for("react.context"), jU = Symbol.for("react.forward_ref"), VU = Symbol.for("react.suspense"), UU = Symbol.for("react.memo"), $U = Symbol.for("react.lazy"), Sk = Symbol.iterator;
function GU(t) { return t === null || typeof t != "object" ? null : (t = Sk && t[Sk] || t["@@iterator"], typeof t == "function" ? t : null); }
var TO = { isMounted: function () { return !1; }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, SO = Object.assign, EO = {};
function wg(t, r, o) { this.props = t, this.context = r, this.refs = EO, this.updater = o || TO; }
wg.prototype.isReactComponent = {};
wg.prototype.setState = function (t, r) { if (typeof t != "object" && typeof t != "function" && t != null)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, t, r, "setState"); };
wg.prototype.forceUpdate = function (t) { this.updater.enqueueForceUpdate(this, t, "forceUpdate"); };
function CO() { }
CO.prototype = wg.prototype;
function SC(t, r, o) { this.props = t, this.context = r, this.refs = EO, this.updater = o || TO; }
var EC = SC.prototype = new CO;
EC.constructor = SC;
SO(EC, wg.prototype);
EC.isPureReactComponent = !0;
var Ek = Array.isArray, AO = Object.prototype.hasOwnProperty, CC = { current: null }, IO = { key: !0, ref: !0, __self: !0, __source: !0 };
function PO(t, r, o) { var u, g = {}, y = null, E = null; if (r != null)
    for (u in r.ref !== void 0 && (E = r.ref), r.key !== void 0 && (y = "" + r.key), r)
        AO.call(r, u) && !IO.hasOwnProperty(u) && (g[u] = r[u]); var s = arguments.length - 2; if (s === 1)
    g.children = o;
else if (1 < s) {
    for (var k = Array(s), L = 0; L < s; L++)
        k[L] = arguments[L + 2];
    g.children = k;
} if (t && t.defaultProps)
    for (u in s = t.defaultProps, s)
        g[u] === void 0 && (g[u] = s[u]); return { $$typeof: Yv, type: t, key: y, ref: E, props: g, _owner: CC.current }; }
function qU(t, r) { return { $$typeof: Yv, type: t.type, key: r, ref: t.ref, props: t.props, _owner: t._owner }; }
function AC(t) { return typeof t == "object" && t !== null && t.$$typeof === Yv; }
function HU(t) { var r = { "=": "=0", ":": "=2" }; return "$" + t.replace(/[=:]/g, function (o) { return r[o]; }); }
var Ck = /\/+/g;
function qS(t, r) { return typeof t == "object" && t !== null && t.key != null ? HU("" + t.key) : r.toString(36); }
function j1(t, r, o, u, g) { var y = typeof t; (y === "undefined" || y === "boolean") && (t = null); var E = !1; if (t === null)
    E = !0;
else
    switch (y) {
        case "string":
        case "number":
            E = !0;
            break;
        case "object": switch (t.$$typeof) {
            case Yv:
            case LU: E = !0;
        }
    } if (E)
    return E = t, g = g(E), t = u === "" ? "." + qS(E, 0) : u, Ek(g) ? (o = "", t != null && (o = t.replace(Ck, "$&/") + "/"), j1(g, r, o, "", function (L) { return L; })) : g != null && (AC(g) && (g = qU(g, o + (!g.key || E && E.key === g.key ? "" : ("" + g.key).replace(Ck, "$&/") + "/") + t)), r.push(g)), 1; if (E = 0, u = u === "" ? "." : u + ":", Ek(t))
    for (var s = 0; s < t.length; s++) {
        y = t[s];
        var k = u + qS(y, s);
        E += j1(y, r, o, k, g);
    }
else if (k = GU(t), typeof k == "function")
    for (t = k.call(t), s = 0; !(y = t.next()).done;)
        y = y.value, k = u + qS(y, s++), E += j1(y, r, o, k, g);
else if (y === "object")
    throw r = String(t), Error("Objects are not valid as a React child (found: " + (r === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : r) + "). If you meant to render a collection of children, use an array instead."); return E; }
function h1(t, r, o) { if (t == null)
    return t; var u = [], g = 0; return j1(t, u, "", "", function (y) { return r.call(o, y, g++); }), u; }
function WU(t) { if (t._status === -1) {
    var r = t._result;
    r = r(), r.then(function (o) { (t._status === 0 || t._status === -1) && (t._status = 1, t._result = o); }, function (o) { (t._status === 0 || t._status === -1) && (t._status = 2, t._result = o); }), t._status === -1 && (t._status = 0, t._result = r);
} if (t._status === 1)
    return t._result.default; throw t._result; }
var Eo = { current: null }, V1 = { transition: null }, ZU = { ReactCurrentDispatcher: Eo, ReactCurrentBatchConfig: V1, ReactCurrentOwner: CC };
function MO() { throw Error("act(...) is not supported in production builds of React."); }
Qn.Children = { map: h1, forEach: function (t, r, o) { h1(t, function () { r.apply(this, arguments); }, o); }, count: function (t) { var r = 0; return h1(t, function () { r++; }), r; }, toArray: function (t) { return h1(t, function (r) { return r; }) || []; }, only: function (t) { if (!AC(t))
        throw Error("React.Children.only expected to receive a single React element child."); return t; } };
Qn.Component = wg;
Qn.Fragment = OU;
Qn.Profiler = FU;
Qn.PureComponent = SC;
Qn.StrictMode = zU;
Qn.Suspense = VU;
Qn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ZU;
Qn.act = MO;
Qn.cloneElement = function (t, r, o) { if (t == null)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + "."); var u = SO({}, t.props), g = t.key, y = t.ref, E = t._owner; if (r != null) {
    if (r.ref !== void 0 && (y = r.ref, E = CC.current), r.key !== void 0 && (g = "" + r.key), t.type && t.type.defaultProps)
        var s = t.type.defaultProps;
    for (k in r)
        AO.call(r, k) && !IO.hasOwnProperty(k) && (u[k] = r[k] === void 0 && s !== void 0 ? s[k] : r[k]);
} var k = arguments.length - 2; if (k === 1)
    u.children = o;
else if (1 < k) {
    s = Array(k);
    for (var L = 0; L < k; L++)
        s[L] = arguments[L + 2];
    u.children = s;
} return { $$typeof: Yv, type: t.type, key: g, ref: y, props: u, _owner: E }; };
Qn.createContext = function (t) { return t = { $$typeof: BU, _currentValue: t, _currentValue2: t, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, t.Provider = { $$typeof: NU, _context: t }, t.Consumer = t; };
Qn.createElement = PO;
Qn.createFactory = function (t) { var r = PO.bind(null, t); return r.type = t, r; };
Qn.createRef = function () { return { current: null }; };
Qn.forwardRef = function (t) { return { $$typeof: jU, render: t }; };
Qn.isValidElement = AC;
Qn.lazy = function (t) { return { $$typeof: $U, _payload: { _status: -1, _result: t }, _init: WU }; };
Qn.memo = function (t, r) { return { $$typeof: UU, type: t, compare: r === void 0 ? null : r }; };
Qn.startTransition = function (t) { var r = V1.transition; V1.transition = {}; try {
    t();
}
finally {
    V1.transition = r;
} };
Qn.unstable_act = MO;
Qn.useCallback = function (t, r) { return Eo.current.useCallback(t, r); };
Qn.useContext = function (t) { return Eo.current.useContext(t); };
Qn.useDebugValue = function () { };
Qn.useDeferredValue = function (t) { return Eo.current.useDeferredValue(t); };
Qn.useEffect = function (t, r) { return Eo.current.useEffect(t, r); };
Qn.useId = function () { return Eo.current.useId(); };
Qn.useImperativeHandle = function (t, r, o) { return Eo.current.useImperativeHandle(t, r, o); };
Qn.useInsertionEffect = function (t, r) { return Eo.current.useInsertionEffect(t, r); };
Qn.useLayoutEffect = function (t, r) { return Eo.current.useLayoutEffect(t, r); };
Qn.useMemo = function (t, r) { return Eo.current.useMemo(t, r); };
Qn.useReducer = function (t, r, o) { return Eo.current.useReducer(t, r, o); };
Qn.useRef = function (t) { return Eo.current.useRef(t); };
Qn.useState = function (t) { return Eo.current.useState(t); };
Qn.useSyncExternalStore = function (t, r, o) { return Eo.current.useSyncExternalStore(t, r, o); };
Qn.useTransition = function () { return Eo.current.useTransition(); };
Qn.version = "18.3.1";
bO.exports = Qn;
var ne = bO.exports;
const bs = TC(ne), RO = kU({ __proto__: null, default: bs }, [ne]); /**
* @license React
* react-jsx-runtime.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var XU = ne, KU = Symbol.for("react.element"), YU = Symbol.for("react.fragment"), QU = Object.prototype.hasOwnProperty, JU = XU.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, e6 = { key: !0, ref: !0, __self: !0, __source: !0 };
function kO(t, r, o) { var u, g = {}, y = null, E = null; o !== void 0 && (y = "" + o), r.key !== void 0 && (y = "" + r.key), r.ref !== void 0 && (E = r.ref); for (u in r)
    QU.call(r, u) && !e6.hasOwnProperty(u) && (g[u] = r[u]); if (t && t.defaultProps)
    for (u in r = t.defaultProps, r)
        g[u] === void 0 && (g[u] = r[u]); return { $$typeof: KU, type: t, key: y, ref: E, props: g, _owner: JU.current }; }
Jw.Fragment = YU;
Jw.jsx = kO;
Jw.jsxs = kO;
wO.exports = Jw;
var j = wO.exports, DO = { exports: {} }, va = {}, LO = { exports: {} }, OO = {}; /**
* @license React
* scheduler.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
(function (t) { function r(xt, Pt) { var Ft = xt.length; xt.push(Pt); e: for (; 0 < Ft;) {
    var gr = Ft - 1 >>> 1, Jr = xt[gr];
    if (0 < g(Jr, Pt))
        xt[gr] = Pt, xt[Ft] = Jr, Ft = gr;
    else
        break e;
} } function o(xt) { return xt.length === 0 ? null : xt[0]; } function u(xt) { if (xt.length === 0)
    return null; var Pt = xt[0], Ft = xt.pop(); if (Ft !== Pt) {
    xt[0] = Ft;
    e: for (var gr = 0, Jr = xt.length, pi = Jr >>> 1; gr < pi;) {
        var Si = 2 * (gr + 1) - 1, an = xt[Si], Kr = Si + 1, mn = xt[Kr];
        if (0 > g(an, Ft))
            Kr < Jr && 0 > g(mn, an) ? (xt[gr] = mn, xt[Kr] = Ft, gr = Kr) : (xt[gr] = an, xt[Si] = Ft, gr = Si);
        else if (Kr < Jr && 0 > g(mn, Ft))
            xt[gr] = mn, xt[Kr] = Ft, gr = Kr;
        else
            break e;
    }
} return Pt; } function g(xt, Pt) { var Ft = xt.sortIndex - Pt.sortIndex; return Ft !== 0 ? Ft : xt.id - Pt.id; } if (typeof performance == "object" && typeof performance.now == "function") {
    var y = performance;
    t.unstable_now = function () { return y.now(); };
}
else {
    var E = Date, s = E.now();
    t.unstable_now = function () { return E.now() - s; };
} var k = [], L = [], N = 1, V = null, H = 3, ee = !1, ce = !1, J = !1, ye = typeof setTimeout == "function" ? setTimeout : null, ie = typeof clearTimeout == "function" ? clearTimeout : null, Q = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function ue(xt) { for (var Pt = o(L); Pt !== null;) {
    if (Pt.callback === null)
        u(L);
    else if (Pt.startTime <= xt)
        u(L), Pt.sortIndex = Pt.expirationTime, r(k, Pt);
    else
        break;
    Pt = o(L);
} } function be(xt) { if (J = !1, ue(xt), !ce)
    if (o(k) !== null)
        ce = !0, tr(Ie);
    else {
        var Pt = o(L);
        Pt !== null && Or(be, Pt.startTime - xt);
    } } function Ie(xt, Pt) { ce = !1, J && (J = !1, ie(ot), ot = -1), ee = !0; var Ft = H; try {
    for (ue(Pt), V = o(k); V !== null && (!(V.expirationTime > Pt) || xt && !ct());) {
        var gr = V.callback;
        if (typeof gr == "function") {
            V.callback = null, H = V.priorityLevel;
            var Jr = gr(V.expirationTime <= Pt);
            Pt = t.unstable_now(), typeof Jr == "function" ? V.callback = Jr : V === o(k) && u(k), ue(Pt);
        }
        else
            u(k);
        V = o(k);
    }
    if (V !== null)
        var pi = !0;
    else {
        var Si = o(L);
        Si !== null && Or(be, Si.startTime - Pt), pi = !1;
    }
    return pi;
}
finally {
    V = null, H = Ft, ee = !1;
} } var Be = !1, Ze = null, ot = -1, At = 5, kt = -1; function ct() { return !(t.unstable_now() - kt < At); } function St() { if (Ze !== null) {
    var xt = t.unstable_now();
    kt = xt;
    var Pt = !0;
    try {
        Pt = Ze(!0, xt);
    }
    finally {
        Pt ? Kt() : (Be = !1, Ze = null);
    }
}
else
    Be = !1; } var Kt; if (typeof Q == "function")
    Kt = function () { Q(St); };
else if (typeof MessageChannel < "u") {
    var bt = new MessageChannel, ir = bt.port2;
    bt.port1.onmessage = St, Kt = function () { ir.postMessage(null); };
}
else
    Kt = function () { ye(St, 0); }; function tr(xt) { Ze = xt, Be || (Be = !0, Kt()); } function Or(xt, Pt) { ot = ye(function () { xt(t.unstable_now()); }, Pt); } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (xt) { xt.callback = null; }, t.unstable_continueExecution = function () { ce || ee || (ce = !0, tr(Ie)); }, t.unstable_forceFrameRate = function (xt) { 0 > xt || 125 < xt ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : At = 0 < xt ? Math.floor(1e3 / xt) : 5; }, t.unstable_getCurrentPriorityLevel = function () { return H; }, t.unstable_getFirstCallbackNode = function () { return o(k); }, t.unstable_next = function (xt) { switch (H) {
    case 1:
    case 2:
    case 3:
        var Pt = 3;
        break;
    default: Pt = H;
} var Ft = H; H = Pt; try {
    return xt();
}
finally {
    H = Ft;
} }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (xt, Pt) { switch (xt) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5: break;
    default: xt = 3;
} var Ft = H; H = xt; try {
    return Pt();
}
finally {
    H = Ft;
} }, t.unstable_scheduleCallback = function (xt, Pt, Ft) { var gr = t.unstable_now(); switch (typeof Ft == "object" && Ft !== null ? (Ft = Ft.delay, Ft = typeof Ft == "number" && 0 < Ft ? gr + Ft : gr) : Ft = gr, xt) {
    case 1:
        var Jr = -1;
        break;
    case 2:
        Jr = 250;
        break;
    case 5:
        Jr = 1073741823;
        break;
    case 4:
        Jr = 1e4;
        break;
    default: Jr = 5e3;
} return Jr = Ft + Jr, xt = { id: N++, callback: Pt, priorityLevel: xt, startTime: Ft, expirationTime: Jr, sortIndex: -1 }, Ft > gr ? (xt.sortIndex = Ft, r(L, xt), o(k) === null && xt === o(L) && (J ? (ie(ot), ot = -1) : J = !0, Or(be, Ft - gr))) : (xt.sortIndex = Jr, r(k, xt), ce || ee || (ce = !0, tr(Ie))), xt; }, t.unstable_shouldYield = ct, t.unstable_wrapCallback = function (xt) { var Pt = H; return function () { var Ft = H; H = Pt; try {
    return xt.apply(this, arguments);
}
finally {
    H = Ft;
} }; }; })(OO);
LO.exports = OO;
var t6 = LO.exports; /**
* @license React
* react-dom.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var r6 = ne, ya = t6;
function rr(t) { for (var r = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, o = 1; o < arguments.length; o++)
    r += "&args[]=" + encodeURIComponent(arguments[o]); return "Minified React error #" + t + "; visit " + r + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."; }
var zO = new Set, uv = {};
function Bf(t, r) { sg(t, r), sg(t + "Capture", r); }
function sg(t, r) { for (uv[t] = r, t = 0; t < r.length; t++)
    zO.add(r[t]); }
var su = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), qE = Object.prototype.hasOwnProperty, n6 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Ak = {}, Ik = {};
function i6(t) { return qE.call(Ik, t) ? !0 : qE.call(Ak, t) ? !1 : n6.test(t) ? Ik[t] = !0 : (Ak[t] = !0, !1); }
function s6(t, r, o, u) { if (o !== null && o.type === 0)
    return !1; switch (typeof r) {
    case "function":
    case "symbol": return !0;
    case "boolean": return u ? !1 : o !== null ? !o.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-");
    default: return !1;
} }
function o6(t, r, o, u) { if (r === null || typeof r > "u" || s6(t, r, o, u))
    return !0; if (u)
    return !1; if (o !== null)
    switch (o.type) {
        case 3: return !r;
        case 4: return r === !1;
        case 5: return isNaN(r);
        case 6: return isNaN(r) || 1 > r;
    } return !1; }
function Co(t, r, o, u, g, y, E) { this.acceptsBooleans = r === 2 || r === 3 || r === 4, this.attributeName = u, this.attributeNamespace = g, this.mustUseProperty = o, this.propertyName = t, this.type = r, this.sanitizeURL = y, this.removeEmptyString = E; }
var Zs = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (t) { Zs[t] = new Co(t, 0, !1, t, null, !1, !1); });
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (t) { var r = t[0]; Zs[r] = new Co(r, 1, !1, t[1], null, !1, !1); });
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) { Zs[t] = new Co(t, 2, !1, t.toLowerCase(), null, !1, !1); });
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) { Zs[t] = new Co(t, 2, !1, t, null, !1, !1); });
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (t) { Zs[t] = new Co(t, 3, !1, t.toLowerCase(), null, !1, !1); });
["checked", "multiple", "muted", "selected"].forEach(function (t) { Zs[t] = new Co(t, 3, !0, t, null, !1, !1); });
["capture", "download"].forEach(function (t) { Zs[t] = new Co(t, 4, !1, t, null, !1, !1); });
["cols", "rows", "size", "span"].forEach(function (t) { Zs[t] = new Co(t, 6, !1, t, null, !1, !1); });
["rowSpan", "start"].forEach(function (t) { Zs[t] = new Co(t, 5, !1, t.toLowerCase(), null, !1, !1); });
var IC = /[\-:]([a-z])/g;
function PC(t) { return t[1].toUpperCase(); }
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (t) { var r = t.replace(IC, PC); Zs[r] = new Co(r, 1, !1, t, null, !1, !1); });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) { var r = t.replace(IC, PC); Zs[r] = new Co(r, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1); });
["xml:base", "xml:lang", "xml:space"].forEach(function (t) { var r = t.replace(IC, PC); Zs[r] = new Co(r, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1); });
["tabIndex", "crossOrigin"].forEach(function (t) { Zs[t] = new Co(t, 1, !1, t.toLowerCase(), null, !1, !1); });
Zs.xlinkHref = new Co("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function (t) { Zs[t] = new Co(t, 1, !1, t.toLowerCase(), null, !0, !0); });
function MC(t, r, o, u) { var g = Zs.hasOwnProperty(r) ? Zs[r] : null; (g !== null ? g.type !== 0 : u || !(2 < r.length) || r[0] !== "o" && r[0] !== "O" || r[1] !== "n" && r[1] !== "N") && (o6(r, o, g, u) && (o = null), u || g === null ? i6(r) && (o === null ? t.removeAttribute(r) : t.setAttribute(r, "" + o)) : g.mustUseProperty ? t[g.propertyName] = o === null ? g.type === 3 ? !1 : "" : o : (r = g.attributeName, u = g.attributeNamespace, o === null ? t.removeAttribute(r) : (g = g.type, o = g === 3 || g === 4 && o === !0 ? "" : "" + o, u ? t.setAttributeNS(u, r, o) : t.setAttribute(r, o)))); }
var du = r6.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, d1 = Symbol.for("react.element"), xm = Symbol.for("react.portal"), wm = Symbol.for("react.fragment"), RC = Symbol.for("react.strict_mode"), HE = Symbol.for("react.profiler"), FO = Symbol.for("react.provider"), NO = Symbol.for("react.context"), kC = Symbol.for("react.forward_ref"), WE = Symbol.for("react.suspense"), ZE = Symbol.for("react.suspense_list"), DC = Symbol.for("react.memo"), ph = Symbol.for("react.lazy"), BO = Symbol.for("react.offscreen"), Pk = Symbol.iterator;
function by(t) { return t === null || typeof t != "object" ? null : (t = Pk && t[Pk] || t["@@iterator"], typeof t == "function" ? t : null); }
var Qi = Object.assign, HS;
function Ny(t) {
    if (HS === void 0)
        try {
            throw Error();
        }
        catch (o) {
            var r = o.stack.trim().match(/\n( *(at )?)/);
            HS = r && r[1] || "";
        }
    return `
` + HS + t;
}
var WS = !1;
function ZS(t, r) {
    if (!t || WS)
        return "";
    WS = !0;
    var o = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (r)
            if (r = function () { throw Error(); }, Object.defineProperty(r.prototype, "props", { set: function () { throw Error(); } }), typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(r, []);
                }
                catch (L) {
                    var u = L;
                }
                Reflect.construct(t, [], r);
            }
            else {
                try {
                    r.call();
                }
                catch (L) {
                    u = L;
                }
                t.call(r.prototype);
            }
        else {
            try {
                throw Error();
            }
            catch (L) {
                u = L;
            }
            t();
        }
    }
    catch (L) {
        if (L && u && typeof L.stack == "string") {
            for (var g = L.stack.split(`
`), y = u.stack.split(`
`), E = g.length - 1, s = y.length - 1; 1 <= E && 0 <= s && g[E] !== y[s];)
                s--;
            for (; 1 <= E && 0 <= s; E--, s--)
                if (g[E] !== y[s]) {
                    if (E !== 1 || s !== 1)
                        do
                            if (E--, s--, 0 > s || g[E] !== y[s]) {
                                var k = `
` + g[E].replace(" at new ", " at ");
                                return t.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", t.displayName)), k;
                            }
                        while (1 <= E && 0 <= s);
                    break;
                }
        }
    }
    finally {
        WS = !1, Error.prepareStackTrace = o;
    }
    return (t = t ? t.displayName || t.name : "") ? Ny(t) : "";
}
function a6(t) { switch (t.tag) {
    case 5: return Ny(t.type);
    case 16: return Ny("Lazy");
    case 13: return Ny("Suspense");
    case 19: return Ny("SuspenseList");
    case 0:
    case 2:
    case 15: return t = ZS(t.type, !1), t;
    case 11: return t = ZS(t.type.render, !1), t;
    case 1: return t = ZS(t.type, !0), t;
    default: return "";
} }
function XE(t) { if (t == null)
    return null; if (typeof t == "function")
    return t.displayName || t.name || null; if (typeof t == "string")
    return t; switch (t) {
    case wm: return "Fragment";
    case xm: return "Portal";
    case HE: return "Profiler";
    case RC: return "StrictMode";
    case WE: return "Suspense";
    case ZE: return "SuspenseList";
} if (typeof t == "object")
    switch (t.$$typeof) {
        case NO: return (t.displayName || "Context") + ".Consumer";
        case FO: return (t._context.displayName || "Context") + ".Provider";
        case kC:
            var r = t.render;
            return t = t.displayName, t || (t = r.displayName || r.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
        case DC: return r = t.displayName || null, r !== null ? r : XE(t.type) || "Memo";
        case ph:
            r = t._payload, t = t._init;
            try {
                return XE(t(r));
            }
            catch { }
    } return null; }
function l6(t) { var r = t.type; switch (t.tag) {
    case 24: return "Cache";
    case 9: return (r.displayName || "Context") + ".Consumer";
    case 10: return (r._context.displayName || "Context") + ".Provider";
    case 18: return "DehydratedFragment";
    case 11: return t = r.render, t = t.displayName || t.name || "", r.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
    case 7: return "Fragment";
    case 5: return r;
    case 4: return "Portal";
    case 3: return "Root";
    case 6: return "Text";
    case 16: return XE(r);
    case 8: return r === RC ? "StrictMode" : "Mode";
    case 22: return "Offscreen";
    case 12: return "Profiler";
    case 21: return "Scope";
    case 13: return "Suspense";
    case 19: return "SuspenseList";
    case 25: return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof r == "function")
            return r.displayName || r.name || null;
        if (typeof r == "string")
            return r;
} return null; }
function Gh(t) { switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined": return t;
    case "object": return t;
    default: return "";
} }
function jO(t) { var r = t.type; return (t = t.nodeName) && t.toLowerCase() === "input" && (r === "checkbox" || r === "radio"); }
function c6(t) { var r = jO(t) ? "checked" : "value", o = Object.getOwnPropertyDescriptor(t.constructor.prototype, r), u = "" + t[r]; if (!t.hasOwnProperty(r) && typeof o < "u" && typeof o.get == "function" && typeof o.set == "function") {
    var g = o.get, y = o.set;
    return Object.defineProperty(t, r, { configurable: !0, get: function () { return g.call(this); }, set: function (E) { u = "" + E, y.call(this, E); } }), Object.defineProperty(t, r, { enumerable: o.enumerable }), { getValue: function () { return u; }, setValue: function (E) { u = "" + E; }, stopTracking: function () { t._valueTracker = null, delete t[r]; } };
} }
function f1(t) { t._valueTracker || (t._valueTracker = c6(t)); }
function VO(t) { if (!t)
    return !1; var r = t._valueTracker; if (!r)
    return !0; var o = r.getValue(), u = ""; return t && (u = jO(t) ? t.checked ? "true" : "false" : t.value), t = u, t !== o ? (r.setValue(t), !0) : !1; }
function aw(t) { if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u")
    return null; try {
    return t.activeElement || t.body;
}
catch {
    return t.body;
} }
function KE(t, r) { var o = r.checked; return Qi({}, r, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: o ?? t._wrapperState.initialChecked }); }
function Mk(t, r) { var o = r.defaultValue == null ? "" : r.defaultValue, u = r.checked != null ? r.checked : r.defaultChecked; o = Gh(r.value != null ? r.value : o), t._wrapperState = { initialChecked: u, initialValue: o, controlled: r.type === "checkbox" || r.type === "radio" ? r.checked != null : r.value != null }; }
function UO(t, r) { r = r.checked, r != null && MC(t, "checked", r, !1); }
function YE(t, r) { UO(t, r); var o = Gh(r.value), u = r.type; if (o != null)
    u === "number" ? (o === 0 && t.value === "" || t.value != o) && (t.value = "" + o) : t.value !== "" + o && (t.value = "" + o);
else if (u === "submit" || u === "reset") {
    t.removeAttribute("value");
    return;
} r.hasOwnProperty("value") ? QE(t, r.type, o) : r.hasOwnProperty("defaultValue") && QE(t, r.type, Gh(r.defaultValue)), r.checked == null && r.defaultChecked != null && (t.defaultChecked = !!r.defaultChecked); }
function Rk(t, r, o) { if (r.hasOwnProperty("value") || r.hasOwnProperty("defaultValue")) {
    var u = r.type;
    if (!(u !== "submit" && u !== "reset" || r.value !== void 0 && r.value !== null))
        return;
    r = "" + t._wrapperState.initialValue, o || r === t.value || (t.value = r), t.defaultValue = r;
} o = t.name, o !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, o !== "" && (t.name = o); }
function QE(t, r, o) { (r !== "number" || aw(t.ownerDocument) !== t) && (o == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + o && (t.defaultValue = "" + o)); }
var By = Array.isArray;
function Lm(t, r, o, u) { if (t = t.options, r) {
    r = {};
    for (var g = 0; g < o.length; g++)
        r["$" + o[g]] = !0;
    for (o = 0; o < t.length; o++)
        g = r.hasOwnProperty("$" + t[o].value), t[o].selected !== g && (t[o].selected = g), g && u && (t[o].defaultSelected = !0);
}
else {
    for (o = "" + Gh(o), r = null, g = 0; g < t.length; g++) {
        if (t[g].value === o) {
            t[g].selected = !0, u && (t[g].defaultSelected = !0);
            return;
        }
        r !== null || t[g].disabled || (r = t[g]);
    }
    r !== null && (r.selected = !0);
} }
function JE(t, r) { if (r.dangerouslySetInnerHTML != null)
    throw Error(rr(91)); return Qi({}, r, { value: void 0, defaultValue: void 0, children: "" + t._wrapperState.initialValue }); }
function kk(t, r) { var o = r.value; if (o == null) {
    if (o = r.children, r = r.defaultValue, o != null) {
        if (r != null)
            throw Error(rr(92));
        if (By(o)) {
            if (1 < o.length)
                throw Error(rr(93));
            o = o[0];
        }
        r = o;
    }
    r == null && (r = ""), o = r;
} t._wrapperState = { initialValue: Gh(o) }; }
function $O(t, r) { var o = Gh(r.value), u = Gh(r.defaultValue); o != null && (o = "" + o, o !== t.value && (t.value = o), r.defaultValue == null && t.defaultValue !== o && (t.defaultValue = o)), u != null && (t.defaultValue = "" + u); }
function Dk(t) { var r = t.textContent; r === t._wrapperState.initialValue && r !== "" && r !== null && (t.value = r); }
function GO(t) { switch (t) {
    case "svg": return "http://www.w3.org/2000/svg";
    case "math": return "http://www.w3.org/1998/Math/MathML";
    default: return "http://www.w3.org/1999/xhtml";
} }
function e2(t, r) { return t == null || t === "http://www.w3.org/1999/xhtml" ? GO(r) : t === "http://www.w3.org/2000/svg" && r === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t; }
var p1, qO = function (t) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (r, o, u, g) { MSApp.execUnsafeLocalFunction(function () { return t(r, o, u, g); }); } : t; }(function (t, r) { if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t)
    t.innerHTML = r;
else {
    for (p1 = p1 || document.createElement("div"), p1.innerHTML = "<svg>" + r.valueOf().toString() + "</svg>", r = p1.firstChild; t.firstChild;)
        t.removeChild(t.firstChild);
    for (; r.firstChild;)
        t.appendChild(r.firstChild);
} });
function hv(t, r) { if (r) {
    var o = t.firstChild;
    if (o && o === t.lastChild && o.nodeType === 3) {
        o.nodeValue = r;
        return;
    }
} t.textContent = r; }
var Zy = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, u6 = ["Webkit", "ms", "Moz", "O"];
Object.keys(Zy).forEach(function (t) { u6.forEach(function (r) { r = r + t.charAt(0).toUpperCase() + t.substring(1), Zy[r] = Zy[t]; }); });
function HO(t, r, o) { return r == null || typeof r == "boolean" || r === "" ? "" : o || typeof r != "number" || r === 0 || Zy.hasOwnProperty(t) && Zy[t] ? ("" + r).trim() : r + "px"; }
function WO(t, r) { t = t.style; for (var o in r)
    if (r.hasOwnProperty(o)) {
        var u = o.indexOf("--") === 0, g = HO(o, r[o], u);
        o === "float" && (o = "cssFloat"), u ? t.setProperty(o, g) : t[o] = g;
    } }
var h6 = Qi({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function t2(t, r) { if (r) {
    if (h6[t] && (r.children != null || r.dangerouslySetInnerHTML != null))
        throw Error(rr(137, t));
    if (r.dangerouslySetInnerHTML != null) {
        if (r.children != null)
            throw Error(rr(60));
        if (typeof r.dangerouslySetInnerHTML != "object" || !("__html" in r.dangerouslySetInnerHTML))
            throw Error(rr(61));
    }
    if (r.style != null && typeof r.style != "object")
        throw Error(rr(62));
} }
function r2(t, r) { if (t.indexOf("-") === -1)
    return typeof r.is == "string"; switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph": return !1;
    default: return !0;
} }
var n2 = null;
function LC(t) { return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t; }
var i2 = null, Om = null, zm = null;
function Lk(t) { if (t = e0(t)) {
    if (typeof i2 != "function")
        throw Error(rr(280));
    var r = t.stateNode;
    r && (r = ib(r), i2(t.stateNode, t.type, r));
} }
function ZO(t) { Om ? zm ? zm.push(t) : zm = [t] : Om = t; }
function XO() { if (Om) {
    var t = Om, r = zm;
    if (zm = Om = null, Lk(t), r)
        for (t = 0; t < r.length; t++)
            Lk(r[t]);
} }
function KO(t, r) { return t(r); }
function YO() { }
var XS = !1;
function QO(t, r, o) { if (XS)
    return t(r, o); XS = !0; try {
    return KO(t, r, o);
}
finally {
    XS = !1, (Om !== null || zm !== null) && (YO(), XO());
} }
function dv(t, r) { var o = t.stateNode; if (o === null)
    return null; var u = ib(o); if (u === null)
    return null; o = u[r]; e: switch (r) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (u = !u.disabled) || (t = t.type, u = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !u;
        break e;
    default: t = !1;
} if (t)
    return null; if (o && typeof o != "function")
    throw Error(rr(231, r, typeof o)); return o; }
var s2 = !1;
if (su)
    try {
        var Ty = {};
        Object.defineProperty(Ty, "passive", { get: function () { s2 = !0; } }), window.addEventListener("test", Ty, Ty), window.removeEventListener("test", Ty, Ty);
    }
    catch {
        s2 = !1;
    }
function d6(t, r, o, u, g, y, E, s, k) { var L = Array.prototype.slice.call(arguments, 3); try {
    r.apply(o, L);
}
catch (N) {
    this.onError(N);
} }
var Xy = !1, lw = null, cw = !1, o2 = null, f6 = { onError: function (t) { Xy = !0, lw = t; } };
function p6(t, r, o, u, g, y, E, s, k) { Xy = !1, lw = null, d6.apply(f6, arguments); }
function m6(t, r, o, u, g, y, E, s, k) { if (p6.apply(this, arguments), Xy) {
    if (Xy) {
        var L = lw;
        Xy = !1, lw = null;
    }
    else
        throw Error(rr(198));
    cw || (cw = !0, o2 = L);
} }
function jf(t) { var r = t, o = t; if (t.alternate)
    for (; r.return;)
        r = r.return;
else {
    t = r;
    do
        r = t, r.flags & 4098 && (o = r.return), t = r.return;
    while (t);
} return r.tag === 3 ? o : null; }
function JO(t) { if (t.tag === 13) {
    var r = t.memoizedState;
    if (r === null && (t = t.alternate, t !== null && (r = t.memoizedState)), r !== null)
        return r.dehydrated;
} return null; }
function Ok(t) { if (jf(t) !== t)
    throw Error(rr(188)); }
function g6(t) { var r = t.alternate; if (!r) {
    if (r = jf(t), r === null)
        throw Error(rr(188));
    return r !== t ? null : t;
} for (var o = t, u = r;;) {
    var g = o.return;
    if (g === null)
        break;
    var y = g.alternate;
    if (y === null) {
        if (u = g.return, u !== null) {
            o = u;
            continue;
        }
        break;
    }
    if (g.child === y.child) {
        for (y = g.child; y;) {
            if (y === o)
                return Ok(g), t;
            if (y === u)
                return Ok(g), r;
            y = y.sibling;
        }
        throw Error(rr(188));
    }
    if (o.return !== u.return)
        o = g, u = y;
    else {
        for (var E = !1, s = g.child; s;) {
            if (s === o) {
                E = !0, o = g, u = y;
                break;
            }
            if (s === u) {
                E = !0, u = g, o = y;
                break;
            }
            s = s.sibling;
        }
        if (!E) {
            for (s = y.child; s;) {
                if (s === o) {
                    E = !0, o = y, u = g;
                    break;
                }
                if (s === u) {
                    E = !0, u = y, o = g;
                    break;
                }
                s = s.sibling;
            }
            if (!E)
                throw Error(rr(189));
        }
    }
    if (o.alternate !== u)
        throw Error(rr(190));
} if (o.tag !== 3)
    throw Error(rr(188)); return o.stateNode.current === o ? t : r; }
function ez(t) { return t = g6(t), t !== null ? tz(t) : null; }
function tz(t) { if (t.tag === 5 || t.tag === 6)
    return t; for (t = t.child; t !== null;) {
    var r = tz(t);
    if (r !== null)
        return r;
    t = t.sibling;
} return null; }
var rz = ya.unstable_scheduleCallback, zk = ya.unstable_cancelCallback, _6 = ya.unstable_shouldYield, y6 = ya.unstable_requestPaint, cs = ya.unstable_now, v6 = ya.unstable_getCurrentPriorityLevel, OC = ya.unstable_ImmediatePriority, nz = ya.unstable_UserBlockingPriority, uw = ya.unstable_NormalPriority, x6 = ya.unstable_LowPriority, iz = ya.unstable_IdlePriority, eb = null, sc = null;
function w6(t) { if (sc && typeof sc.onCommitFiberRoot == "function")
    try {
        sc.onCommitFiberRoot(eb, t, void 0, (t.current.flags & 128) === 128);
    }
    catch { } }
var _l = Math.clz32 ? Math.clz32 : S6, b6 = Math.log, T6 = Math.LN2;
function S6(t) { return t >>>= 0, t === 0 ? 32 : 31 - (b6(t) / T6 | 0) | 0; }
var m1 = 64, g1 = 4194304;
function jy(t) { switch (t & -t) {
    case 1: return 1;
    case 2: return 2;
    case 4: return 4;
    case 8: return 8;
    case 16: return 16;
    case 32: return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152: return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864: return t & 130023424;
    case 134217728: return 134217728;
    case 268435456: return 268435456;
    case 536870912: return 536870912;
    case 1073741824: return 1073741824;
    default: return t;
} }
function hw(t, r) { var o = t.pendingLanes; if (o === 0)
    return 0; var u = 0, g = t.suspendedLanes, y = t.pingedLanes, E = o & 268435455; if (E !== 0) {
    var s = E & ~g;
    s !== 0 ? u = jy(s) : (y &= E, y !== 0 && (u = jy(y)));
}
else
    E = o & ~g, E !== 0 ? u = jy(E) : y !== 0 && (u = jy(y)); if (u === 0)
    return 0; if (r !== 0 && r !== u && !(r & g) && (g = u & -u, y = r & -r, g >= y || g === 16 && (y & 4194240) !== 0))
    return r; if (u & 4 && (u |= o & 16), r = t.entangledLanes, r !== 0)
    for (t = t.entanglements, r &= u; 0 < r;)
        o = 31 - _l(r), g = 1 << o, u |= t[o], r &= ~g; return u; }
function E6(t, r) { switch (t) {
    case 1:
    case 2:
    case 4: return r + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152: return r + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864: return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824: return -1;
    default: return -1;
} }
function C6(t, r) { for (var o = t.suspendedLanes, u = t.pingedLanes, g = t.expirationTimes, y = t.pendingLanes; 0 < y;) {
    var E = 31 - _l(y), s = 1 << E, k = g[E];
    k === -1 ? (!(s & o) || s & u) && (g[E] = E6(s, r)) : k <= r && (t.expiredLanes |= s), y &= ~s;
} }
function a2(t) { return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0; }
function sz() { var t = m1; return m1 <<= 1, !(m1 & 4194240) && (m1 = 64), t; }
function KS(t) { for (var r = [], o = 0; 31 > o; o++)
    r.push(t); return r; }
function Qv(t, r, o) { t.pendingLanes |= r, r !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, r = 31 - _l(r), t[r] = o; }
function A6(t, r) { var o = t.pendingLanes & ~r; t.pendingLanes = r, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= r, t.mutableReadLanes &= r, t.entangledLanes &= r, r = t.entanglements; var u = t.eventTimes; for (t = t.expirationTimes; 0 < o;) {
    var g = 31 - _l(o), y = 1 << g;
    r[g] = 0, u[g] = -1, t[g] = -1, o &= ~y;
} }
function zC(t, r) { var o = t.entangledLanes |= r; for (t = t.entanglements; o;) {
    var u = 31 - _l(o), g = 1 << u;
    g & r | t[u] & r && (t[u] |= r), o &= ~g;
} }
var Ti = 0;
function oz(t) { return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1; }
var az, FC, lz, cz, uz, l2 = !1, _1 = [], Dh = null, Lh = null, Oh = null, fv = new Map, pv = new Map, _h = [], I6 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Fk(t, r) { switch (t) {
    case "focusin":
    case "focusout":
        Dh = null;
        break;
    case "dragenter":
    case "dragleave":
        Lh = null;
        break;
    case "mouseover":
    case "mouseout":
        Oh = null;
        break;
    case "pointerover":
    case "pointerout":
        fv.delete(r.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture": pv.delete(r.pointerId);
} }
function Sy(t, r, o, u, g, y) { return t === null || t.nativeEvent !== y ? (t = { blockedOn: r, domEventName: o, eventSystemFlags: u, nativeEvent: y, targetContainers: [g] }, r !== null && (r = e0(r), r !== null && FC(r)), t) : (t.eventSystemFlags |= u, r = t.targetContainers, g !== null && r.indexOf(g) === -1 && r.push(g), t); }
function P6(t, r, o, u, g) { switch (r) {
    case "focusin": return Dh = Sy(Dh, t, r, o, u, g), !0;
    case "dragenter": return Lh = Sy(Lh, t, r, o, u, g), !0;
    case "mouseover": return Oh = Sy(Oh, t, r, o, u, g), !0;
    case "pointerover":
        var y = g.pointerId;
        return fv.set(y, Sy(fv.get(y) || null, t, r, o, u, g)), !0;
    case "gotpointercapture": return y = g.pointerId, pv.set(y, Sy(pv.get(y) || null, t, r, o, u, g)), !0;
} return !1; }
function hz(t) { var r = hf(t.target); if (r !== null) {
    var o = jf(r);
    if (o !== null) {
        if (r = o.tag, r === 13) {
            if (r = JO(o), r !== null) {
                t.blockedOn = r, uz(t.priority, function () { lz(o); });
                return;
            }
        }
        else if (r === 3 && o.stateNode.current.memoizedState.isDehydrated) {
            t.blockedOn = o.tag === 3 ? o.stateNode.containerInfo : null;
            return;
        }
    }
} t.blockedOn = null; }
function U1(t) { if (t.blockedOn !== null)
    return !1; for (var r = t.targetContainers; 0 < r.length;) {
    var o = c2(t.domEventName, t.eventSystemFlags, r[0], t.nativeEvent);
    if (o === null) {
        o = t.nativeEvent;
        var u = new o.constructor(o.type, o);
        n2 = u, o.target.dispatchEvent(u), n2 = null;
    }
    else
        return r = e0(o), r !== null && FC(r), t.blockedOn = o, !1;
    r.shift();
} return !0; }
function Nk(t, r, o) { U1(t) && o.delete(r); }
function M6() { l2 = !1, Dh !== null && U1(Dh) && (Dh = null), Lh !== null && U1(Lh) && (Lh = null), Oh !== null && U1(Oh) && (Oh = null), fv.forEach(Nk), pv.forEach(Nk); }
function Ey(t, r) { t.blockedOn === r && (t.blockedOn = null, l2 || (l2 = !0, ya.unstable_scheduleCallback(ya.unstable_NormalPriority, M6))); }
function mv(t) { function r(g) { return Ey(g, t); } if (0 < _1.length) {
    Ey(_1[0], t);
    for (var o = 1; o < _1.length; o++) {
        var u = _1[o];
        u.blockedOn === t && (u.blockedOn = null);
    }
} for (Dh !== null && Ey(Dh, t), Lh !== null && Ey(Lh, t), Oh !== null && Ey(Oh, t), fv.forEach(r), pv.forEach(r), o = 0; o < _h.length; o++)
    u = _h[o], u.blockedOn === t && (u.blockedOn = null); for (; 0 < _h.length && (o = _h[0], o.blockedOn === null);)
    hz(o), o.blockedOn === null && _h.shift(); }
var Fm = du.ReactCurrentBatchConfig, dw = !0;
function R6(t, r, o, u) { var g = Ti, y = Fm.transition; Fm.transition = null; try {
    Ti = 1, NC(t, r, o, u);
}
finally {
    Ti = g, Fm.transition = y;
} }
function k6(t, r, o, u) { var g = Ti, y = Fm.transition; Fm.transition = null; try {
    Ti = 4, NC(t, r, o, u);
}
finally {
    Ti = g, Fm.transition = y;
} }
function NC(t, r, o, u) { if (dw) {
    var g = c2(t, r, o, u);
    if (g === null)
        oE(t, r, u, fw, o), Fk(t, u);
    else if (P6(g, t, r, o, u))
        u.stopPropagation();
    else if (Fk(t, u), r & 4 && -1 < I6.indexOf(t)) {
        for (; g !== null;) {
            var y = e0(g);
            if (y !== null && az(y), y = c2(t, r, o, u), y === null && oE(t, r, u, fw, o), y === g)
                break;
            g = y;
        }
        g !== null && u.stopPropagation();
    }
    else
        oE(t, r, u, null, o);
} }
var fw = null;
function c2(t, r, o, u) { if (fw = null, t = LC(u), t = hf(t), t !== null)
    if (r = jf(t), r === null)
        t = null;
    else if (o = r.tag, o === 13) {
        if (t = JO(r), t !== null)
            return t;
        t = null;
    }
    else if (o === 3) {
        if (r.stateNode.current.memoizedState.isDehydrated)
            return r.tag === 3 ? r.stateNode.containerInfo : null;
        t = null;
    }
    else
        r !== t && (t = null); return fw = t, null; }
function dz(t) { switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart": return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave": return 4;
    case "message": switch (v6()) {
        case OC: return 1;
        case nz: return 4;
        case uw:
        case x6: return 16;
        case iz: return 536870912;
        default: return 16;
    }
    default: return 16;
} }
var Mh = null, BC = null, $1 = null;
function fz() { if ($1)
    return $1; var t, r = BC, o = r.length, u, g = "value" in Mh ? Mh.value : Mh.textContent, y = g.length; for (t = 0; t < o && r[t] === g[t]; t++)
    ; var E = o - t; for (u = 1; u <= E && r[o - u] === g[y - u]; u++)
    ; return $1 = g.slice(t, 1 < u ? 1 - u : void 0); }
function G1(t) { var r = t.keyCode; return "charCode" in t ? (t = t.charCode, t === 0 && r === 13 && (t = 13)) : t = r, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0; }
function y1() { return !0; }
function Bk() { return !1; }
function xa(t) { function r(o, u, g, y, E) { this._reactName = o, this._targetInst = g, this.type = u, this.nativeEvent = y, this.target = E, this.currentTarget = null; for (var s in t)
    t.hasOwnProperty(s) && (o = t[s], this[s] = o ? o(y) : y[s]); return this.isDefaultPrevented = (y.defaultPrevented != null ? y.defaultPrevented : y.returnValue === !1) ? y1 : Bk, this.isPropagationStopped = Bk, this; } return Qi(r.prototype, { preventDefault: function () { this.defaultPrevented = !0; var o = this.nativeEvent; o && (o.preventDefault ? o.preventDefault() : typeof o.returnValue != "unknown" && (o.returnValue = !1), this.isDefaultPrevented = y1); }, stopPropagation: function () { var o = this.nativeEvent; o && (o.stopPropagation ? o.stopPropagation() : typeof o.cancelBubble != "unknown" && (o.cancelBubble = !0), this.isPropagationStopped = y1); }, persist: function () { }, isPersistent: y1 }), r; }
var bg = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (t) { return t.timeStamp || Date.now(); }, defaultPrevented: 0, isTrusted: 0 }, jC = xa(bg), Jv = Qi({}, bg, { view: 0, detail: 0 }), D6 = xa(Jv), YS, QS, Cy, tb = Qi({}, Jv, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: VC, button: 0, buttons: 0, relatedTarget: function (t) { return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget; }, movementX: function (t) { return "movementX" in t ? t.movementX : (t !== Cy && (Cy && t.type === "mousemove" ? (YS = t.screenX - Cy.screenX, QS = t.screenY - Cy.screenY) : QS = YS = 0, Cy = t), YS); }, movementY: function (t) { return "movementY" in t ? t.movementY : QS; } }), jk = xa(tb), L6 = Qi({}, tb, { dataTransfer: 0 }), O6 = xa(L6), z6 = Qi({}, Jv, { relatedTarget: 0 }), JS = xa(z6), F6 = Qi({}, bg, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), N6 = xa(F6), B6 = Qi({}, bg, { clipboardData: function (t) { return "clipboardData" in t ? t.clipboardData : window.clipboardData; } }), j6 = xa(B6), V6 = Qi({}, bg, { data: 0 }), Vk = xa(V6), U6 = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, $6 = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, G6 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function q6(t) { var r = this.nativeEvent; return r.getModifierState ? r.getModifierState(t) : (t = G6[t]) ? !!r[t] : !1; }
function VC() { return q6; }
var H6 = Qi({}, Jv, { key: function (t) { if (t.key) {
        var r = U6[t.key] || t.key;
        if (r !== "Unidentified")
            return r;
    } return t.type === "keypress" ? (t = G1(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? $6[t.keyCode] || "Unidentified" : ""; }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: VC, charCode: function (t) { return t.type === "keypress" ? G1(t) : 0; }, keyCode: function (t) { return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0; }, which: function (t) { return t.type === "keypress" ? G1(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0; } }), W6 = xa(H6), Z6 = Qi({}, tb, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Uk = xa(Z6), X6 = Qi({}, Jv, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: VC }), K6 = xa(X6), Y6 = Qi({}, bg, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Q6 = xa(Y6), J6 = Qi({}, tb, { deltaX: function (t) { return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0; }, deltaY: function (t) { return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0; }, deltaZ: 0, deltaMode: 0 }), e$ = xa(J6), t$ = [9, 13, 27, 32], UC = su && "CompositionEvent" in window, Ky = null;
su && "documentMode" in document && (Ky = document.documentMode);
var r$ = su && "TextEvent" in window && !Ky, pz = su && (!UC || Ky && 8 < Ky && 11 >= Ky), $k = " ", Gk = !1;
function mz(t, r) { switch (t) {
    case "keyup": return t$.indexOf(r.keyCode) !== -1;
    case "keydown": return r.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout": return !0;
    default: return !1;
} }
function gz(t) { return t = t.detail, typeof t == "object" && "data" in t ? t.data : null; }
var bm = !1;
function n$(t, r) { switch (t) {
    case "compositionend": return gz(r);
    case "keypress": return r.which !== 32 ? null : (Gk = !0, $k);
    case "textInput": return t = r.data, t === $k && Gk ? null : t;
    default: return null;
} }
function i$(t, r) { if (bm)
    return t === "compositionend" || !UC && mz(t, r) ? (t = fz(), $1 = BC = Mh = null, bm = !1, t) : null; switch (t) {
    case "paste": return null;
    case "keypress":
        if (!(r.ctrlKey || r.altKey || r.metaKey) || r.ctrlKey && r.altKey) {
            if (r.char && 1 < r.char.length)
                return r.char;
            if (r.which)
                return String.fromCharCode(r.which);
        }
        return null;
    case "compositionend": return pz && r.locale !== "ko" ? null : r.data;
    default: return null;
} }
var s$ = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function qk(t) { var r = t && t.nodeName && t.nodeName.toLowerCase(); return r === "input" ? !!s$[t.type] : r === "textarea"; }
function _z(t, r, o, u) { ZO(u), r = pw(r, "onChange"), 0 < r.length && (o = new jC("onChange", "change", null, o, u), t.push({ event: o, listeners: r })); }
var Yy = null, gv = null;
function o$(t) { Iz(t, 0); }
function rb(t) { var r = Em(t); if (VO(r))
    return t; }
function a$(t, r) { if (t === "change")
    return r; }
var yz = !1;
if (su) {
    var eE;
    if (su) {
        var tE = "oninput" in document;
        if (!tE) {
            var Hk = document.createElement("div");
            Hk.setAttribute("oninput", "return;"), tE = typeof Hk.oninput == "function";
        }
        eE = tE;
    }
    else
        eE = !1;
    yz = eE && (!document.documentMode || 9 < document.documentMode);
}
function Wk() { Yy && (Yy.detachEvent("onpropertychange", vz), gv = Yy = null); }
function vz(t) { if (t.propertyName === "value" && rb(gv)) {
    var r = [];
    _z(r, gv, t, LC(t)), QO(o$, r);
} }
function l$(t, r, o) { t === "focusin" ? (Wk(), Yy = r, gv = o, Yy.attachEvent("onpropertychange", vz)) : t === "focusout" && Wk(); }
function c$(t) { if (t === "selectionchange" || t === "keyup" || t === "keydown")
    return rb(gv); }
function u$(t, r) { if (t === "click")
    return rb(r); }
function h$(t, r) { if (t === "input" || t === "change")
    return rb(r); }
function d$(t, r) { return t === r && (t !== 0 || 1 / t === 1 / r) || t !== t && r !== r; }
var xl = typeof Object.is == "function" ? Object.is : d$;
function _v(t, r) { if (xl(t, r))
    return !0; if (typeof t != "object" || t === null || typeof r != "object" || r === null)
    return !1; var o = Object.keys(t), u = Object.keys(r); if (o.length !== u.length)
    return !1; for (u = 0; u < o.length; u++) {
    var g = o[u];
    if (!qE.call(r, g) || !xl(t[g], r[g]))
        return !1;
} return !0; }
function Zk(t) { for (; t && t.firstChild;)
    t = t.firstChild; return t; }
function Xk(t, r) { var o = Zk(t); t = 0; for (var u; o;) {
    if (o.nodeType === 3) {
        if (u = t + o.textContent.length, t <= r && u >= r)
            return { node: o, offset: r - t };
        t = u;
    }
    e: {
        for (; o;) {
            if (o.nextSibling) {
                o = o.nextSibling;
                break e;
            }
            o = o.parentNode;
        }
        o = void 0;
    }
    o = Zk(o);
} }
function xz(t, r) { return t && r ? t === r ? !0 : t && t.nodeType === 3 ? !1 : r && r.nodeType === 3 ? xz(t, r.parentNode) : "contains" in t ? t.contains(r) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(r) & 16) : !1 : !1; }
function wz() { for (var t = window, r = aw(); r instanceof t.HTMLIFrameElement;) {
    try {
        var o = typeof r.contentWindow.location.href == "string";
    }
    catch {
        o = !1;
    }
    if (o)
        t = r.contentWindow;
    else
        break;
    r = aw(t.document);
} return r; }
function $C(t) { var r = t && t.nodeName && t.nodeName.toLowerCase(); return r && (r === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || r === "textarea" || t.contentEditable === "true"); }
function f$(t) { var r = wz(), o = t.focusedElem, u = t.selectionRange; if (r !== o && o && o.ownerDocument && xz(o.ownerDocument.documentElement, o)) {
    if (u !== null && $C(o)) {
        if (r = u.start, t = u.end, t === void 0 && (t = r), "selectionStart" in o)
            o.selectionStart = r, o.selectionEnd = Math.min(t, o.value.length);
        else if (t = (r = o.ownerDocument || document) && r.defaultView || window, t.getSelection) {
            t = t.getSelection();
            var g = o.textContent.length, y = Math.min(u.start, g);
            u = u.end === void 0 ? y : Math.min(u.end, g), !t.extend && y > u && (g = u, u = y, y = g), g = Xk(o, y);
            var E = Xk(o, u);
            g && E && (t.rangeCount !== 1 || t.anchorNode !== g.node || t.anchorOffset !== g.offset || t.focusNode !== E.node || t.focusOffset !== E.offset) && (r = r.createRange(), r.setStart(g.node, g.offset), t.removeAllRanges(), y > u ? (t.addRange(r), t.extend(E.node, E.offset)) : (r.setEnd(E.node, E.offset), t.addRange(r)));
        }
    }
    for (r = [], t = o; t = t.parentNode;)
        t.nodeType === 1 && r.push({ element: t, left: t.scrollLeft, top: t.scrollTop });
    for (typeof o.focus == "function" && o.focus(), o = 0; o < r.length; o++)
        t = r[o], t.element.scrollLeft = t.left, t.element.scrollTop = t.top;
} }
var p$ = su && "documentMode" in document && 11 >= document.documentMode, Tm = null, u2 = null, Qy = null, h2 = !1;
function Kk(t, r, o) { var u = o.window === o ? o.document : o.nodeType === 9 ? o : o.ownerDocument; h2 || Tm == null || Tm !== aw(u) || (u = Tm, "selectionStart" in u && $C(u) ? u = { start: u.selectionStart, end: u.selectionEnd } : (u = (u.ownerDocument && u.ownerDocument.defaultView || window).getSelection(), u = { anchorNode: u.anchorNode, anchorOffset: u.anchorOffset, focusNode: u.focusNode, focusOffset: u.focusOffset }), Qy && _v(Qy, u) || (Qy = u, u = pw(u2, "onSelect"), 0 < u.length && (r = new jC("onSelect", "select", null, r, o), t.push({ event: r, listeners: u }), r.target = Tm))); }
function v1(t, r) { var o = {}; return o[t.toLowerCase()] = r.toLowerCase(), o["Webkit" + t] = "webkit" + r, o["Moz" + t] = "moz" + r, o; }
var Sm = { animationend: v1("Animation", "AnimationEnd"), animationiteration: v1("Animation", "AnimationIteration"), animationstart: v1("Animation", "AnimationStart"), transitionend: v1("Transition", "TransitionEnd") }, rE = {}, bz = {};
su && (bz = document.createElement("div").style, "AnimationEvent" in window || (delete Sm.animationend.animation, delete Sm.animationiteration.animation, delete Sm.animationstart.animation), "TransitionEvent" in window || delete Sm.transitionend.transition);
function nb(t) { if (rE[t])
    return rE[t]; if (!Sm[t])
    return t; var r = Sm[t], o; for (o in r)
    if (r.hasOwnProperty(o) && o in bz)
        return rE[t] = r[o]; return t; }
var Tz = nb("animationend"), Sz = nb("animationiteration"), Ez = nb("animationstart"), Cz = nb("transitionend"), Az = new Map, Yk = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ed(t, r) { Az.set(t, r), Bf(r, [t]); }
for (var nE = 0; nE < Yk.length; nE++) {
    var iE = Yk[nE], m$ = iE.toLowerCase(), g$ = iE[0].toUpperCase() + iE.slice(1);
    ed(m$, "on" + g$);
}
ed(Tz, "onAnimationEnd");
ed(Sz, "onAnimationIteration");
ed(Ez, "onAnimationStart");
ed("dblclick", "onDoubleClick");
ed("focusin", "onFocus");
ed("focusout", "onBlur");
ed(Cz, "onTransitionEnd");
sg("onMouseEnter", ["mouseout", "mouseover"]);
sg("onMouseLeave", ["mouseout", "mouseover"]);
sg("onPointerEnter", ["pointerout", "pointerover"]);
sg("onPointerLeave", ["pointerout", "pointerover"]);
Bf("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Bf("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Bf("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Bf("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Bf("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Bf("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Vy = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), _$ = new Set("cancel close invalid load scroll toggle".split(" ").concat(Vy));
function Qk(t, r, o) { var u = t.type || "unknown-event"; t.currentTarget = o, m6(u, r, void 0, t), t.currentTarget = null; }
function Iz(t, r) { r = (r & 4) !== 0; for (var o = 0; o < t.length; o++) {
    var u = t[o], g = u.event;
    u = u.listeners;
    e: {
        var y = void 0;
        if (r)
            for (var E = u.length - 1; 0 <= E; E--) {
                var s = u[E], k = s.instance, L = s.currentTarget;
                if (s = s.listener, k !== y && g.isPropagationStopped())
                    break e;
                Qk(g, s, L), y = k;
            }
        else
            for (E = 0; E < u.length; E++) {
                if (s = u[E], k = s.instance, L = s.currentTarget, s = s.listener, k !== y && g.isPropagationStopped())
                    break e;
                Qk(g, s, L), y = k;
            }
    }
} if (cw)
    throw t = o2, cw = !1, o2 = null, t; }
function Ni(t, r) { var o = r[g2]; o === void 0 && (o = r[g2] = new Set); var u = t + "__bubble"; o.has(u) || (Pz(r, t, 2, !1), o.add(u)); }
function sE(t, r, o) { var u = 0; r && (u |= 4), Pz(o, t, u, r); }
var x1 = "_reactListening" + Math.random().toString(36).slice(2);
function yv(t) { if (!t[x1]) {
    t[x1] = !0, zO.forEach(function (o) { o !== "selectionchange" && (_$.has(o) || sE(o, !1, t), sE(o, !0, t)); });
    var r = t.nodeType === 9 ? t : t.ownerDocument;
    r === null || r[x1] || (r[x1] = !0, sE("selectionchange", !1, r));
} }
function Pz(t, r, o, u) { switch (dz(r)) {
    case 1:
        var g = R6;
        break;
    case 4:
        g = k6;
        break;
    default: g = NC;
} o = g.bind(null, r, o, t), g = void 0, !s2 || r !== "touchstart" && r !== "touchmove" && r !== "wheel" || (g = !0), u ? g !== void 0 ? t.addEventListener(r, o, { capture: !0, passive: g }) : t.addEventListener(r, o, !0) : g !== void 0 ? t.addEventListener(r, o, { passive: g }) : t.addEventListener(r, o, !1); }
function oE(t, r, o, u, g) { var y = u; if (!(r & 1) && !(r & 2) && u !== null)
    e: for (;;) {
        if (u === null)
            return;
        var E = u.tag;
        if (E === 3 || E === 4) {
            var s = u.stateNode.containerInfo;
            if (s === g || s.nodeType === 8 && s.parentNode === g)
                break;
            if (E === 4)
                for (E = u.return; E !== null;) {
                    var k = E.tag;
                    if ((k === 3 || k === 4) && (k = E.stateNode.containerInfo, k === g || k.nodeType === 8 && k.parentNode === g))
                        return;
                    E = E.return;
                }
            for (; s !== null;) {
                if (E = hf(s), E === null)
                    return;
                if (k = E.tag, k === 5 || k === 6) {
                    u = y = E;
                    continue e;
                }
                s = s.parentNode;
            }
        }
        u = u.return;
    } QO(function () { var L = y, N = LC(o), V = []; e: {
    var H = Az.get(t);
    if (H !== void 0) {
        var ee = jC, ce = t;
        switch (t) {
            case "keypress": if (G1(o) === 0)
                break e;
            case "keydown":
            case "keyup":
                ee = W6;
                break;
            case "focusin":
                ce = "focus", ee = JS;
                break;
            case "focusout":
                ce = "blur", ee = JS;
                break;
            case "beforeblur":
            case "afterblur":
                ee = JS;
                break;
            case "click": if (o.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
                ee = jk;
                break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
                ee = O6;
                break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
                ee = K6;
                break;
            case Tz:
            case Sz:
            case Ez:
                ee = N6;
                break;
            case Cz:
                ee = Q6;
                break;
            case "scroll":
                ee = D6;
                break;
            case "wheel":
                ee = e$;
                break;
            case "copy":
            case "cut":
            case "paste":
                ee = j6;
                break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup": ee = Uk;
        }
        var J = (r & 4) !== 0, ye = !J && t === "scroll", ie = J ? H !== null ? H + "Capture" : null : H;
        J = [];
        for (var Q = L, ue; Q !== null;) {
            ue = Q;
            var be = ue.stateNode;
            if (ue.tag === 5 && be !== null && (ue = be, ie !== null && (be = dv(Q, ie), be != null && J.push(vv(Q, be, ue)))), ye)
                break;
            Q = Q.return;
        }
        0 < J.length && (H = new ee(H, ce, null, o, N), V.push({ event: H, listeners: J }));
    }
} if (!(r & 7)) {
    e: {
        if (H = t === "mouseover" || t === "pointerover", ee = t === "mouseout" || t === "pointerout", H && o !== n2 && (ce = o.relatedTarget || o.fromElement) && (hf(ce) || ce[ou]))
            break e;
        if ((ee || H) && (H = N.window === N ? N : (H = N.ownerDocument) ? H.defaultView || H.parentWindow : window, ee ? (ce = o.relatedTarget || o.toElement, ee = L, ce = ce ? hf(ce) : null, ce !== null && (ye = jf(ce), ce !== ye || ce.tag !== 5 && ce.tag !== 6) && (ce = null)) : (ee = null, ce = L), ee !== ce)) {
            if (J = jk, be = "onMouseLeave", ie = "onMouseEnter", Q = "mouse", (t === "pointerout" || t === "pointerover") && (J = Uk, be = "onPointerLeave", ie = "onPointerEnter", Q = "pointer"), ye = ee == null ? H : Em(ee), ue = ce == null ? H : Em(ce), H = new J(be, Q + "leave", ee, o, N), H.target = ye, H.relatedTarget = ue, be = null, hf(N) === L && (J = new J(ie, Q + "enter", ce, o, N), J.target = ue, J.relatedTarget = ye, be = J), ye = be, ee && ce)
                t: {
                    for (J = ee, ie = ce, Q = 0, ue = J; ue; ue = lm(ue))
                        Q++;
                    for (ue = 0, be = ie; be; be = lm(be))
                        ue++;
                    for (; 0 < Q - ue;)
                        J = lm(J), Q--;
                    for (; 0 < ue - Q;)
                        ie = lm(ie), ue--;
                    for (; Q--;) {
                        if (J === ie || ie !== null && J === ie.alternate)
                            break t;
                        J = lm(J), ie = lm(ie);
                    }
                    J = null;
                }
            else
                J = null;
            ee !== null && Jk(V, H, ee, J, !1), ce !== null && ye !== null && Jk(V, ye, ce, J, !0);
        }
    }
    e: {
        if (H = L ? Em(L) : window, ee = H.nodeName && H.nodeName.toLowerCase(), ee === "select" || ee === "input" && H.type === "file")
            var Ie = a$;
        else if (qk(H))
            if (yz)
                Ie = h$;
            else {
                Ie = c$;
                var Be = l$;
            }
        else
            (ee = H.nodeName) && ee.toLowerCase() === "input" && (H.type === "checkbox" || H.type === "radio") && (Ie = u$);
        if (Ie && (Ie = Ie(t, L))) {
            _z(V, Ie, o, N);
            break e;
        }
        Be && Be(t, H, L), t === "focusout" && (Be = H._wrapperState) && Be.controlled && H.type === "number" && QE(H, "number", H.value);
    }
    switch (Be = L ? Em(L) : window, t) {
        case "focusin":
            (qk(Be) || Be.contentEditable === "true") && (Tm = Be, u2 = L, Qy = null);
            break;
        case "focusout":
            Qy = u2 = Tm = null;
            break;
        case "mousedown":
            h2 = !0;
            break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
            h2 = !1, Kk(V, o, N);
            break;
        case "selectionchange": if (p$)
            break;
        case "keydown":
        case "keyup": Kk(V, o, N);
    }
    var Ze;
    if (UC)
        e: {
            switch (t) {
                case "compositionstart":
                    var ot = "onCompositionStart";
                    break e;
                case "compositionend":
                    ot = "onCompositionEnd";
                    break e;
                case "compositionupdate":
                    ot = "onCompositionUpdate";
                    break e;
            }
            ot = void 0;
        }
    else
        bm ? mz(t, o) && (ot = "onCompositionEnd") : t === "keydown" && o.keyCode === 229 && (ot = "onCompositionStart");
    ot && (pz && o.locale !== "ko" && (bm || ot !== "onCompositionStart" ? ot === "onCompositionEnd" && bm && (Ze = fz()) : (Mh = N, BC = "value" in Mh ? Mh.value : Mh.textContent, bm = !0)), Be = pw(L, ot), 0 < Be.length && (ot = new Vk(ot, t, null, o, N), V.push({ event: ot, listeners: Be }), Ze ? ot.data = Ze : (Ze = gz(o), Ze !== null && (ot.data = Ze)))), (Ze = r$ ? n$(t, o) : i$(t, o)) && (L = pw(L, "onBeforeInput"), 0 < L.length && (N = new Vk("onBeforeInput", "beforeinput", null, o, N), V.push({ event: N, listeners: L }), N.data = Ze));
} Iz(V, r); }); }
function vv(t, r, o) { return { instance: t, listener: r, currentTarget: o }; }
function pw(t, r) { for (var o = r + "Capture", u = []; t !== null;) {
    var g = t, y = g.stateNode;
    g.tag === 5 && y !== null && (g = y, y = dv(t, o), y != null && u.unshift(vv(t, y, g)), y = dv(t, r), y != null && u.push(vv(t, y, g))), t = t.return;
} return u; }
function lm(t) { if (t === null)
    return null; do
    t = t.return;
while (t && t.tag !== 5); return t || null; }
function Jk(t, r, o, u, g) { for (var y = r._reactName, E = []; o !== null && o !== u;) {
    var s = o, k = s.alternate, L = s.stateNode;
    if (k !== null && k === u)
        break;
    s.tag === 5 && L !== null && (s = L, g ? (k = dv(o, y), k != null && E.unshift(vv(o, k, s))) : g || (k = dv(o, y), k != null && E.push(vv(o, k, s)))), o = o.return;
} E.length !== 0 && t.push({ event: r, listeners: E }); }
var y$ = /\r\n?/g, v$ = /\u0000|\uFFFD/g;
function eD(t) {
    return (typeof t == "string" ? t : "" + t).replace(y$, `
`).replace(v$, "");
}
function w1(t, r, o) { if (r = eD(r), eD(t) !== r && o)
    throw Error(rr(425)); }
function mw() { }
var d2 = null, f2 = null;
function p2(t, r) { return t === "textarea" || t === "noscript" || typeof r.children == "string" || typeof r.children == "number" || typeof r.dangerouslySetInnerHTML == "object" && r.dangerouslySetInnerHTML !== null && r.dangerouslySetInnerHTML.__html != null; }
var m2 = typeof setTimeout == "function" ? setTimeout : void 0, x$ = typeof clearTimeout == "function" ? clearTimeout : void 0, tD = typeof Promise == "function" ? Promise : void 0, w$ = typeof queueMicrotask == "function" ? queueMicrotask : typeof tD < "u" ? function (t) { return tD.resolve(null).then(t).catch(b$); } : m2;
function b$(t) { setTimeout(function () { throw t; }); }
function aE(t, r) { var o = r, u = 0; do {
    var g = o.nextSibling;
    if (t.removeChild(o), g && g.nodeType === 8)
        if (o = g.data, o === "/$") {
            if (u === 0) {
                t.removeChild(g), mv(r);
                return;
            }
            u--;
        }
        else
            o !== "$" && o !== "$?" && o !== "$!" || u++;
    o = g;
} while (o); mv(r); }
function zh(t) { for (; t != null; t = t.nextSibling) {
    var r = t.nodeType;
    if (r === 1 || r === 3)
        break;
    if (r === 8) {
        if (r = t.data, r === "$" || r === "$!" || r === "$?")
            break;
        if (r === "/$")
            return null;
    }
} return t; }
function rD(t) { t = t.previousSibling; for (var r = 0; t;) {
    if (t.nodeType === 8) {
        var o = t.data;
        if (o === "$" || o === "$!" || o === "$?") {
            if (r === 0)
                return t;
            r--;
        }
        else
            o === "/$" && r++;
    }
    t = t.previousSibling;
} return null; }
var Tg = Math.random().toString(36).slice(2), rc = "__reactFiber$" + Tg, xv = "__reactProps$" + Tg, ou = "__reactContainer$" + Tg, g2 = "__reactEvents$" + Tg, T$ = "__reactListeners$" + Tg, S$ = "__reactHandles$" + Tg;
function hf(t) { var r = t[rc]; if (r)
    return r; for (var o = t.parentNode; o;) {
    if (r = o[ou] || o[rc]) {
        if (o = r.alternate, r.child !== null || o !== null && o.child !== null)
            for (t = rD(t); t !== null;) {
                if (o = t[rc])
                    return o;
                t = rD(t);
            }
        return r;
    }
    t = o, o = t.parentNode;
} return null; }
function e0(t) { return t = t[rc] || t[ou], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t; }
function Em(t) { if (t.tag === 5 || t.tag === 6)
    return t.stateNode; throw Error(rr(33)); }
function ib(t) { return t[xv] || null; }
var _2 = [], Cm = -1;
function td(t) { return { current: t }; }
function Bi(t) { 0 > Cm || (t.current = _2[Cm], _2[Cm] = null, Cm--); }
function Oi(t, r) { Cm++, _2[Cm] = t.current, t.current = r; }
var qh = {}, ho = td(qh), Ho = td(!1), Cf = qh;
function og(t, r) { var o = t.type.contextTypes; if (!o)
    return qh; var u = t.stateNode; if (u && u.__reactInternalMemoizedUnmaskedChildContext === r)
    return u.__reactInternalMemoizedMaskedChildContext; var g = {}, y; for (y in o)
    g[y] = r[y]; return u && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = r, t.__reactInternalMemoizedMaskedChildContext = g), g; }
function Wo(t) { return t = t.childContextTypes, t != null; }
function gw() { Bi(Ho), Bi(ho); }
function nD(t, r, o) { if (ho.current !== qh)
    throw Error(rr(168)); Oi(ho, r), Oi(Ho, o); }
function Mz(t, r, o) { var u = t.stateNode; if (r = r.childContextTypes, typeof u.getChildContext != "function")
    return o; u = u.getChildContext(); for (var g in u)
    if (!(g in r))
        throw Error(rr(108, l6(t) || "Unknown", g)); return Qi({}, o, u); }
function _w(t) { return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || qh, Cf = ho.current, Oi(ho, t), Oi(Ho, Ho.current), !0; }
function iD(t, r, o) { var u = t.stateNode; if (!u)
    throw Error(rr(169)); o ? (t = Mz(t, r, Cf), u.__reactInternalMemoizedMergedChildContext = t, Bi(Ho), Bi(ho), Oi(ho, t)) : Bi(Ho), Oi(Ho, o); }
var Qc = null, sb = !1, lE = !1;
function Rz(t) { Qc === null ? Qc = [t] : Qc.push(t); }
function E$(t) { sb = !0, Rz(t); }
function rd() { if (!lE && Qc !== null) {
    lE = !0;
    var t = 0, r = Ti;
    try {
        var o = Qc;
        for (Ti = 1; t < o.length; t++) {
            var u = o[t];
            do
                u = u(!0);
            while (u !== null);
        }
        Qc = null, sb = !1;
    }
    catch (g) {
        throw Qc !== null && (Qc = Qc.slice(t + 1)), rz(OC, rd), g;
    }
    finally {
        Ti = r, lE = !1;
    }
} return null; }
var Am = [], Im = 0, yw = null, vw = 0, Da = [], La = 0, Af = null, tu = 1, ru = "";
function of(t, r) { Am[Im++] = vw, Am[Im++] = yw, yw = t, vw = r; }
function kz(t, r, o) { Da[La++] = tu, Da[La++] = ru, Da[La++] = Af, Af = t; var u = tu; t = ru; var g = 32 - _l(u) - 1; u &= ~(1 << g), o += 1; var y = 32 - _l(r) + g; if (30 < y) {
    var E = g - g % 5;
    y = (u & (1 << E) - 1).toString(32), u >>= E, g -= E, tu = 1 << 32 - _l(r) + g | o << g | u, ru = y + t;
}
else
    tu = 1 << y | o << g | u, ru = t; }
function GC(t) { t.return !== null && (of(t, 1), kz(t, 1, 0)); }
function qC(t) { for (; t === yw;)
    yw = Am[--Im], Am[Im] = null, vw = Am[--Im], Am[Im] = null; for (; t === Af;)
    Af = Da[--La], Da[La] = null, ru = Da[--La], Da[La] = null, tu = Da[--La], Da[La] = null; }
var pa = null, fa = null, Ui = !1, dl = null;
function Dz(t, r) { var o = Oa(5, null, null, 0); o.elementType = "DELETED", o.stateNode = r, o.return = t, r = t.deletions, r === null ? (t.deletions = [o], t.flags |= 16) : r.push(o); }
function sD(t, r) { switch (t.tag) {
    case 5:
        var o = t.type;
        return r = r.nodeType !== 1 || o.toLowerCase() !== r.nodeName.toLowerCase() ? null : r, r !== null ? (t.stateNode = r, pa = t, fa = zh(r.firstChild), !0) : !1;
    case 6: return r = t.pendingProps === "" || r.nodeType !== 3 ? null : r, r !== null ? (t.stateNode = r, pa = t, fa = null, !0) : !1;
    case 13: return r = r.nodeType !== 8 ? null : r, r !== null ? (o = Af !== null ? { id: tu, overflow: ru } : null, t.memoizedState = { dehydrated: r, treeContext: o, retryLane: 1073741824 }, o = Oa(18, null, null, 0), o.stateNode = r, o.return = t, t.child = o, pa = t, fa = null, !0) : !1;
    default: return !1;
} }
function y2(t) { return (t.mode & 1) !== 0 && (t.flags & 128) === 0; }
function v2(t) { if (Ui) {
    var r = fa;
    if (r) {
        var o = r;
        if (!sD(t, r)) {
            if (y2(t))
                throw Error(rr(418));
            r = zh(o.nextSibling);
            var u = pa;
            r && sD(t, r) ? Dz(u, o) : (t.flags = t.flags & -4097 | 2, Ui = !1, pa = t);
        }
    }
    else {
        if (y2(t))
            throw Error(rr(418));
        t.flags = t.flags & -4097 | 2, Ui = !1, pa = t;
    }
} }
function oD(t) { for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;)
    t = t.return; pa = t; }
function b1(t) { if (t !== pa)
    return !1; if (!Ui)
    return oD(t), Ui = !0, !1; var r; if ((r = t.tag !== 3) && !(r = t.tag !== 5) && (r = t.type, r = r !== "head" && r !== "body" && !p2(t.type, t.memoizedProps)), r && (r = fa)) {
    if (y2(t))
        throw Lz(), Error(rr(418));
    for (; r;)
        Dz(t, r), r = zh(r.nextSibling);
} if (oD(t), t.tag === 13) {
    if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t)
        throw Error(rr(317));
    e: {
        for (t = t.nextSibling, r = 0; t;) {
            if (t.nodeType === 8) {
                var o = t.data;
                if (o === "/$") {
                    if (r === 0) {
                        fa = zh(t.nextSibling);
                        break e;
                    }
                    r--;
                }
                else
                    o !== "$" && o !== "$!" && o !== "$?" || r++;
            }
            t = t.nextSibling;
        }
        fa = null;
    }
}
else
    fa = pa ? zh(t.stateNode.nextSibling) : null; return !0; }
function Lz() { for (var t = fa; t;)
    t = zh(t.nextSibling); }
function ag() { fa = pa = null, Ui = !1; }
function HC(t) { dl === null ? dl = [t] : dl.push(t); }
var C$ = du.ReactCurrentBatchConfig;
function Ay(t, r, o) { if (t = o.ref, t !== null && typeof t != "function" && typeof t != "object") {
    if (o._owner) {
        if (o = o._owner, o) {
            if (o.tag !== 1)
                throw Error(rr(309));
            var u = o.stateNode;
        }
        if (!u)
            throw Error(rr(147, t));
        var g = u, y = "" + t;
        return r !== null && r.ref !== null && typeof r.ref == "function" && r.ref._stringRef === y ? r.ref : (r = function (E) { var s = g.refs; E === null ? delete s[y] : s[y] = E; }, r._stringRef = y, r);
    }
    if (typeof t != "string")
        throw Error(rr(284));
    if (!o._owner)
        throw Error(rr(290, t));
} return t; }
function T1(t, r) { throw t = Object.prototype.toString.call(r), Error(rr(31, t === "[object Object]" ? "object with keys {" + Object.keys(r).join(", ") + "}" : t)); }
function aD(t) { var r = t._init; return r(t._payload); }
function Oz(t) { function r(ie, Q) { if (t) {
    var ue = ie.deletions;
    ue === null ? (ie.deletions = [Q], ie.flags |= 16) : ue.push(Q);
} } function o(ie, Q) { if (!t)
    return null; for (; Q !== null;)
    r(ie, Q), Q = Q.sibling; return null; } function u(ie, Q) { for (ie = new Map; Q !== null;)
    Q.key !== null ? ie.set(Q.key, Q) : ie.set(Q.index, Q), Q = Q.sibling; return ie; } function g(ie, Q) { return ie = jh(ie, Q), ie.index = 0, ie.sibling = null, ie; } function y(ie, Q, ue) { return ie.index = ue, t ? (ue = ie.alternate, ue !== null ? (ue = ue.index, ue < Q ? (ie.flags |= 2, Q) : ue) : (ie.flags |= 2, Q)) : (ie.flags |= 1048576, Q); } function E(ie) { return t && ie.alternate === null && (ie.flags |= 2), ie; } function s(ie, Q, ue, be) { return Q === null || Q.tag !== 6 ? (Q = mE(ue, ie.mode, be), Q.return = ie, Q) : (Q = g(Q, ue), Q.return = ie, Q); } function k(ie, Q, ue, be) { var Ie = ue.type; return Ie === wm ? N(ie, Q, ue.props.children, be, ue.key) : Q !== null && (Q.elementType === Ie || typeof Ie == "object" && Ie !== null && Ie.$$typeof === ph && aD(Ie) === Q.type) ? (be = g(Q, ue.props), be.ref = Ay(ie, Q, ue), be.return = ie, be) : (be = Y1(ue.type, ue.key, ue.props, null, ie.mode, be), be.ref = Ay(ie, Q, ue), be.return = ie, be); } function L(ie, Q, ue, be) { return Q === null || Q.tag !== 4 || Q.stateNode.containerInfo !== ue.containerInfo || Q.stateNode.implementation !== ue.implementation ? (Q = gE(ue, ie.mode, be), Q.return = ie, Q) : (Q = g(Q, ue.children || []), Q.return = ie, Q); } function N(ie, Q, ue, be, Ie) { return Q === null || Q.tag !== 7 ? (Q = Tf(ue, ie.mode, be, Ie), Q.return = ie, Q) : (Q = g(Q, ue), Q.return = ie, Q); } function V(ie, Q, ue) { if (typeof Q == "string" && Q !== "" || typeof Q == "number")
    return Q = mE("" + Q, ie.mode, ue), Q.return = ie, Q; if (typeof Q == "object" && Q !== null) {
    switch (Q.$$typeof) {
        case d1: return ue = Y1(Q.type, Q.key, Q.props, null, ie.mode, ue), ue.ref = Ay(ie, null, Q), ue.return = ie, ue;
        case xm: return Q = gE(Q, ie.mode, ue), Q.return = ie, Q;
        case ph:
            var be = Q._init;
            return V(ie, be(Q._payload), ue);
    }
    if (By(Q) || by(Q))
        return Q = Tf(Q, ie.mode, ue, null), Q.return = ie, Q;
    T1(ie, Q);
} return null; } function H(ie, Q, ue, be) { var Ie = Q !== null ? Q.key : null; if (typeof ue == "string" && ue !== "" || typeof ue == "number")
    return Ie !== null ? null : s(ie, Q, "" + ue, be); if (typeof ue == "object" && ue !== null) {
    switch (ue.$$typeof) {
        case d1: return ue.key === Ie ? k(ie, Q, ue, be) : null;
        case xm: return ue.key === Ie ? L(ie, Q, ue, be) : null;
        case ph: return Ie = ue._init, H(ie, Q, Ie(ue._payload), be);
    }
    if (By(ue) || by(ue))
        return Ie !== null ? null : N(ie, Q, ue, be, null);
    T1(ie, ue);
} return null; } function ee(ie, Q, ue, be, Ie) { if (typeof be == "string" && be !== "" || typeof be == "number")
    return ie = ie.get(ue) || null, s(Q, ie, "" + be, Ie); if (typeof be == "object" && be !== null) {
    switch (be.$$typeof) {
        case d1: return ie = ie.get(be.key === null ? ue : be.key) || null, k(Q, ie, be, Ie);
        case xm: return ie = ie.get(be.key === null ? ue : be.key) || null, L(Q, ie, be, Ie);
        case ph:
            var Be = be._init;
            return ee(ie, Q, ue, Be(be._payload), Ie);
    }
    if (By(be) || by(be))
        return ie = ie.get(ue) || null, N(Q, ie, be, Ie, null);
    T1(Q, be);
} return null; } function ce(ie, Q, ue, be) { for (var Ie = null, Be = null, Ze = Q, ot = Q = 0, At = null; Ze !== null && ot < ue.length; ot++) {
    Ze.index > ot ? (At = Ze, Ze = null) : At = Ze.sibling;
    var kt = H(ie, Ze, ue[ot], be);
    if (kt === null) {
        Ze === null && (Ze = At);
        break;
    }
    t && Ze && kt.alternate === null && r(ie, Ze), Q = y(kt, Q, ot), Be === null ? Ie = kt : Be.sibling = kt, Be = kt, Ze = At;
} if (ot === ue.length)
    return o(ie, Ze), Ui && of(ie, ot), Ie; if (Ze === null) {
    for (; ot < ue.length; ot++)
        Ze = V(ie, ue[ot], be), Ze !== null && (Q = y(Ze, Q, ot), Be === null ? Ie = Ze : Be.sibling = Ze, Be = Ze);
    return Ui && of(ie, ot), Ie;
} for (Ze = u(ie, Ze); ot < ue.length; ot++)
    At = ee(Ze, ie, ot, ue[ot], be), At !== null && (t && At.alternate !== null && Ze.delete(At.key === null ? ot : At.key), Q = y(At, Q, ot), Be === null ? Ie = At : Be.sibling = At, Be = At); return t && Ze.forEach(function (ct) { return r(ie, ct); }), Ui && of(ie, ot), Ie; } function J(ie, Q, ue, be) { var Ie = by(ue); if (typeof Ie != "function")
    throw Error(rr(150)); if (ue = Ie.call(ue), ue == null)
    throw Error(rr(151)); for (var Be = Ie = null, Ze = Q, ot = Q = 0, At = null, kt = ue.next(); Ze !== null && !kt.done; ot++, kt = ue.next()) {
    Ze.index > ot ? (At = Ze, Ze = null) : At = Ze.sibling;
    var ct = H(ie, Ze, kt.value, be);
    if (ct === null) {
        Ze === null && (Ze = At);
        break;
    }
    t && Ze && ct.alternate === null && r(ie, Ze), Q = y(ct, Q, ot), Be === null ? Ie = ct : Be.sibling = ct, Be = ct, Ze = At;
} if (kt.done)
    return o(ie, Ze), Ui && of(ie, ot), Ie; if (Ze === null) {
    for (; !kt.done; ot++, kt = ue.next())
        kt = V(ie, kt.value, be), kt !== null && (Q = y(kt, Q, ot), Be === null ? Ie = kt : Be.sibling = kt, Be = kt);
    return Ui && of(ie, ot), Ie;
} for (Ze = u(ie, Ze); !kt.done; ot++, kt = ue.next())
    kt = ee(Ze, ie, ot, kt.value, be), kt !== null && (t && kt.alternate !== null && Ze.delete(kt.key === null ? ot : kt.key), Q = y(kt, Q, ot), Be === null ? Ie = kt : Be.sibling = kt, Be = kt); return t && Ze.forEach(function (St) { return r(ie, St); }), Ui && of(ie, ot), Ie; } function ye(ie, Q, ue, be) { if (typeof ue == "object" && ue !== null && ue.type === wm && ue.key === null && (ue = ue.props.children), typeof ue == "object" && ue !== null) {
    switch (ue.$$typeof) {
        case d1:
            e: {
                for (var Ie = ue.key, Be = Q; Be !== null;) {
                    if (Be.key === Ie) {
                        if (Ie = ue.type, Ie === wm) {
                            if (Be.tag === 7) {
                                o(ie, Be.sibling), Q = g(Be, ue.props.children), Q.return = ie, ie = Q;
                                break e;
                            }
                        }
                        else if (Be.elementType === Ie || typeof Ie == "object" && Ie !== null && Ie.$$typeof === ph && aD(Ie) === Be.type) {
                            o(ie, Be.sibling), Q = g(Be, ue.props), Q.ref = Ay(ie, Be, ue), Q.return = ie, ie = Q;
                            break e;
                        }
                        o(ie, Be);
                        break;
                    }
                    else
                        r(ie, Be);
                    Be = Be.sibling;
                }
                ue.type === wm ? (Q = Tf(ue.props.children, ie.mode, be, ue.key), Q.return = ie, ie = Q) : (be = Y1(ue.type, ue.key, ue.props, null, ie.mode, be), be.ref = Ay(ie, Q, ue), be.return = ie, ie = be);
            }
            return E(ie);
        case xm:
            e: {
                for (Be = ue.key; Q !== null;) {
                    if (Q.key === Be)
                        if (Q.tag === 4 && Q.stateNode.containerInfo === ue.containerInfo && Q.stateNode.implementation === ue.implementation) {
                            o(ie, Q.sibling), Q = g(Q, ue.children || []), Q.return = ie, ie = Q;
                            break e;
                        }
                        else {
                            o(ie, Q);
                            break;
                        }
                    else
                        r(ie, Q);
                    Q = Q.sibling;
                }
                Q = gE(ue, ie.mode, be), Q.return = ie, ie = Q;
            }
            return E(ie);
        case ph: return Be = ue._init, ye(ie, Q, Be(ue._payload), be);
    }
    if (By(ue))
        return ce(ie, Q, ue, be);
    if (by(ue))
        return J(ie, Q, ue, be);
    T1(ie, ue);
} return typeof ue == "string" && ue !== "" || typeof ue == "number" ? (ue = "" + ue, Q !== null && Q.tag === 6 ? (o(ie, Q.sibling), Q = g(Q, ue), Q.return = ie, ie = Q) : (o(ie, Q), Q = mE(ue, ie.mode, be), Q.return = ie, ie = Q), E(ie)) : o(ie, Q); } return ye; }
var lg = Oz(!0), zz = Oz(!1), xw = td(null), ww = null, Pm = null, WC = null;
function ZC() { WC = Pm = ww = null; }
function XC(t) { var r = xw.current; Bi(xw), t._currentValue = r; }
function x2(t, r, o) { for (; t !== null;) {
    var u = t.alternate;
    if ((t.childLanes & r) !== r ? (t.childLanes |= r, u !== null && (u.childLanes |= r)) : u !== null && (u.childLanes & r) !== r && (u.childLanes |= r), t === o)
        break;
    t = t.return;
} }
function Nm(t, r) { ww = t, WC = Pm = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & r && (qo = !0), t.firstContext = null); }
function Ba(t) { var r = t._currentValue; if (WC !== t)
    if (t = { context: t, memoizedValue: r, next: null }, Pm === null) {
        if (ww === null)
            throw Error(rr(308));
        Pm = t, ww.dependencies = { lanes: 0, firstContext: t };
    }
    else
        Pm = Pm.next = t; return r; }
var df = null;
function KC(t) { df === null ? df = [t] : df.push(t); }
function Fz(t, r, o, u) { var g = r.interleaved; return g === null ? (o.next = o, KC(r)) : (o.next = g.next, g.next = o), r.interleaved = o, au(t, u); }
function au(t, r) { t.lanes |= r; var o = t.alternate; for (o !== null && (o.lanes |= r), o = t, t = t.return; t !== null;)
    t.childLanes |= r, o = t.alternate, o !== null && (o.childLanes |= r), o = t, t = t.return; return o.tag === 3 ? o.stateNode : null; }
var mh = !1;
function YC(t) { t.updateQueue = { baseState: t.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null }; }
function Nz(t, r) { t = t.updateQueue, r.updateQueue === t && (r.updateQueue = { baseState: t.baseState, firstBaseUpdate: t.firstBaseUpdate, lastBaseUpdate: t.lastBaseUpdate, shared: t.shared, effects: t.effects }); }
function nu(t, r) { return { eventTime: t, lane: r, tag: 0, payload: null, callback: null, next: null }; }
function Fh(t, r, o) { var u = t.updateQueue; if (u === null)
    return null; if (u = u.shared, fi & 2) {
    var g = u.pending;
    return g === null ? r.next = r : (r.next = g.next, g.next = r), u.pending = r, au(t, o);
} return g = u.interleaved, g === null ? (r.next = r, KC(u)) : (r.next = g.next, g.next = r), u.interleaved = r, au(t, o); }
function q1(t, r, o) { if (r = r.updateQueue, r !== null && (r = r.shared, (o & 4194240) !== 0)) {
    var u = r.lanes;
    u &= t.pendingLanes, o |= u, r.lanes = o, zC(t, o);
} }
function lD(t, r) { var o = t.updateQueue, u = t.alternate; if (u !== null && (u = u.updateQueue, o === u)) {
    var g = null, y = null;
    if (o = o.firstBaseUpdate, o !== null) {
        do {
            var E = { eventTime: o.eventTime, lane: o.lane, tag: o.tag, payload: o.payload, callback: o.callback, next: null };
            y === null ? g = y = E : y = y.next = E, o = o.next;
        } while (o !== null);
        y === null ? g = y = r : y = y.next = r;
    }
    else
        g = y = r;
    o = { baseState: u.baseState, firstBaseUpdate: g, lastBaseUpdate: y, shared: u.shared, effects: u.effects }, t.updateQueue = o;
    return;
} t = o.lastBaseUpdate, t === null ? o.firstBaseUpdate = r : t.next = r, o.lastBaseUpdate = r; }
function bw(t, r, o, u) { var g = t.updateQueue; mh = !1; var y = g.firstBaseUpdate, E = g.lastBaseUpdate, s = g.shared.pending; if (s !== null) {
    g.shared.pending = null;
    var k = s, L = k.next;
    k.next = null, E === null ? y = L : E.next = L, E = k;
    var N = t.alternate;
    N !== null && (N = N.updateQueue, s = N.lastBaseUpdate, s !== E && (s === null ? N.firstBaseUpdate = L : s.next = L, N.lastBaseUpdate = k));
} if (y !== null) {
    var V = g.baseState;
    E = 0, N = L = k = null, s = y;
    do {
        var H = s.lane, ee = s.eventTime;
        if ((u & H) === H) {
            N !== null && (N = N.next = { eventTime: ee, lane: 0, tag: s.tag, payload: s.payload, callback: s.callback, next: null });
            e: {
                var ce = t, J = s;
                switch (H = r, ee = o, J.tag) {
                    case 1:
                        if (ce = J.payload, typeof ce == "function") {
                            V = ce.call(ee, V, H);
                            break e;
                        }
                        V = ce;
                        break e;
                    case 3: ce.flags = ce.flags & -65537 | 128;
                    case 0:
                        if (ce = J.payload, H = typeof ce == "function" ? ce.call(ee, V, H) : ce, H == null)
                            break e;
                        V = Qi({}, V, H);
                        break e;
                    case 2: mh = !0;
                }
            }
            s.callback !== null && s.lane !== 0 && (t.flags |= 64, H = g.effects, H === null ? g.effects = [s] : H.push(s));
        }
        else
            ee = { eventTime: ee, lane: H, tag: s.tag, payload: s.payload, callback: s.callback, next: null }, N === null ? (L = N = ee, k = V) : N = N.next = ee, E |= H;
        if (s = s.next, s === null) {
            if (s = g.shared.pending, s === null)
                break;
            H = s, s = H.next, H.next = null, g.lastBaseUpdate = H, g.shared.pending = null;
        }
    } while (!0);
    if (N === null && (k = V), g.baseState = k, g.firstBaseUpdate = L, g.lastBaseUpdate = N, r = g.shared.interleaved, r !== null) {
        g = r;
        do
            E |= g.lane, g = g.next;
        while (g !== r);
    }
    else
        y === null && (g.shared.lanes = 0);
    Pf |= E, t.lanes = E, t.memoizedState = V;
} }
function cD(t, r, o) { if (t = r.effects, r.effects = null, t !== null)
    for (r = 0; r < t.length; r++) {
        var u = t[r], g = u.callback;
        if (g !== null) {
            if (u.callback = null, u = o, typeof g != "function")
                throw Error(rr(191, g));
            g.call(u);
        }
    } }
var t0 = {}, oc = td(t0), wv = td(t0), bv = td(t0);
function ff(t) { if (t === t0)
    throw Error(rr(174)); return t; }
function QC(t, r) { switch (Oi(bv, r), Oi(wv, t), Oi(oc, t0), t = r.nodeType, t) {
    case 9:
    case 11:
        r = (r = r.documentElement) ? r.namespaceURI : e2(null, "");
        break;
    default: t = t === 8 ? r.parentNode : r, r = t.namespaceURI || null, t = t.tagName, r = e2(r, t);
} Bi(oc), Oi(oc, r); }
function cg() { Bi(oc), Bi(wv), Bi(bv); }
function Bz(t) { ff(bv.current); var r = ff(oc.current), o = e2(r, t.type); r !== o && (Oi(wv, t), Oi(oc, o)); }
function JC(t) { wv.current === t && (Bi(oc), Bi(wv)); }
var Ki = td(0);
function Tw(t) { for (var r = t; r !== null;) {
    if (r.tag === 13) {
        var o = r.memoizedState;
        if (o !== null && (o = o.dehydrated, o === null || o.data === "$?" || o.data === "$!"))
            return r;
    }
    else if (r.tag === 19 && r.memoizedProps.revealOrder !== void 0) {
        if (r.flags & 128)
            return r;
    }
    else if (r.child !== null) {
        r.child.return = r, r = r.child;
        continue;
    }
    if (r === t)
        break;
    for (; r.sibling === null;) {
        if (r.return === null || r.return === t)
            return null;
        r = r.return;
    }
    r.sibling.return = r.return, r = r.sibling;
} return null; }
var cE = [];
function eA() { for (var t = 0; t < cE.length; t++)
    cE[t]._workInProgressVersionPrimary = null; cE.length = 0; }
var H1 = du.ReactCurrentDispatcher, uE = du.ReactCurrentBatchConfig, If = 0, Yi = null, Ts = null, Fs = null, Sw = !1, Jy = !1, Tv = 0, A$ = 0;
function so() { throw Error(rr(321)); }
function tA(t, r) { if (r === null)
    return !1; for (var o = 0; o < r.length && o < t.length; o++)
    if (!xl(t[o], r[o]))
        return !1; return !0; }
function rA(t, r, o, u, g, y) { if (If = y, Yi = r, r.memoizedState = null, r.updateQueue = null, r.lanes = 0, H1.current = t === null || t.memoizedState === null ? R$ : k$, t = o(u, g), Jy) {
    y = 0;
    do {
        if (Jy = !1, Tv = 0, 25 <= y)
            throw Error(rr(301));
        y += 1, Fs = Ts = null, r.updateQueue = null, H1.current = D$, t = o(u, g);
    } while (Jy);
} if (H1.current = Ew, r = Ts !== null && Ts.next !== null, If = 0, Fs = Ts = Yi = null, Sw = !1, r)
    throw Error(rr(300)); return t; }
function nA() { var t = Tv !== 0; return Tv = 0, t; }
function Kl() { var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Fs === null ? Yi.memoizedState = Fs = t : Fs = Fs.next = t, Fs; }
function ja() { if (Ts === null) {
    var t = Yi.alternate;
    t = t !== null ? t.memoizedState : null;
}
else
    t = Ts.next; var r = Fs === null ? Yi.memoizedState : Fs.next; if (r !== null)
    Fs = r, Ts = t;
else {
    if (t === null)
        throw Error(rr(310));
    Ts = t, t = { memoizedState: Ts.memoizedState, baseState: Ts.baseState, baseQueue: Ts.baseQueue, queue: Ts.queue, next: null }, Fs === null ? Yi.memoizedState = Fs = t : Fs = Fs.next = t;
} return Fs; }
function Sv(t, r) { return typeof r == "function" ? r(t) : r; }
function hE(t) { var r = ja(), o = r.queue; if (o === null)
    throw Error(rr(311)); o.lastRenderedReducer = t; var u = Ts, g = u.baseQueue, y = o.pending; if (y !== null) {
    if (g !== null) {
        var E = g.next;
        g.next = y.next, y.next = E;
    }
    u.baseQueue = g = y, o.pending = null;
} if (g !== null) {
    y = g.next, u = u.baseState;
    var s = E = null, k = null, L = y;
    do {
        var N = L.lane;
        if ((If & N) === N)
            k !== null && (k = k.next = { lane: 0, action: L.action, hasEagerState: L.hasEagerState, eagerState: L.eagerState, next: null }), u = L.hasEagerState ? L.eagerState : t(u, L.action);
        else {
            var V = { lane: N, action: L.action, hasEagerState: L.hasEagerState, eagerState: L.eagerState, next: null };
            k === null ? (s = k = V, E = u) : k = k.next = V, Yi.lanes |= N, Pf |= N;
        }
        L = L.next;
    } while (L !== null && L !== y);
    k === null ? E = u : k.next = s, xl(u, r.memoizedState) || (qo = !0), r.memoizedState = u, r.baseState = E, r.baseQueue = k, o.lastRenderedState = u;
} if (t = o.interleaved, t !== null) {
    g = t;
    do
        y = g.lane, Yi.lanes |= y, Pf |= y, g = g.next;
    while (g !== t);
}
else
    g === null && (o.lanes = 0); return [r.memoizedState, o.dispatch]; }
function dE(t) { var r = ja(), o = r.queue; if (o === null)
    throw Error(rr(311)); o.lastRenderedReducer = t; var u = o.dispatch, g = o.pending, y = r.memoizedState; if (g !== null) {
    o.pending = null;
    var E = g = g.next;
    do
        y = t(y, E.action), E = E.next;
    while (E !== g);
    xl(y, r.memoizedState) || (qo = !0), r.memoizedState = y, r.baseQueue === null && (r.baseState = y), o.lastRenderedState = y;
} return [y, u]; }
function jz() { }
function Vz(t, r) { var o = Yi, u = ja(), g = r(), y = !xl(u.memoizedState, g); if (y && (u.memoizedState = g, qo = !0), u = u.queue, iA(Gz.bind(null, o, u, t), [t]), u.getSnapshot !== r || y || Fs !== null && Fs.memoizedState.tag & 1) {
    if (o.flags |= 2048, Ev(9, $z.bind(null, o, u, g, r), void 0, null), Ns === null)
        throw Error(rr(349));
    If & 30 || Uz(o, r, g);
} return g; }
function Uz(t, r, o) { t.flags |= 16384, t = { getSnapshot: r, value: o }, r = Yi.updateQueue, r === null ? (r = { lastEffect: null, stores: null }, Yi.updateQueue = r, r.stores = [t]) : (o = r.stores, o === null ? r.stores = [t] : o.push(t)); }
function $z(t, r, o, u) { r.value = o, r.getSnapshot = u, qz(r) && Hz(t); }
function Gz(t, r, o) { return o(function () { qz(r) && Hz(t); }); }
function qz(t) { var r = t.getSnapshot; t = t.value; try {
    var o = r();
    return !xl(t, o);
}
catch {
    return !0;
} }
function Hz(t) { var r = au(t, 1); r !== null && yl(r, t, 1, -1); }
function uD(t) { var r = Kl(); return typeof t == "function" && (t = t()), r.memoizedState = r.baseState = t, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Sv, lastRenderedState: t }, r.queue = t, t = t.dispatch = M$.bind(null, Yi, t), [r.memoizedState, t]; }
function Ev(t, r, o, u) { return t = { tag: t, create: r, destroy: o, deps: u, next: null }, r = Yi.updateQueue, r === null ? (r = { lastEffect: null, stores: null }, Yi.updateQueue = r, r.lastEffect = t.next = t) : (o = r.lastEffect, o === null ? r.lastEffect = t.next = t : (u = o.next, o.next = t, t.next = u, r.lastEffect = t)), t; }
function Wz() { return ja().memoizedState; }
function W1(t, r, o, u) { var g = Kl(); Yi.flags |= t, g.memoizedState = Ev(1 | r, o, void 0, u === void 0 ? null : u); }
function ob(t, r, o, u) { var g = ja(); u = u === void 0 ? null : u; var y = void 0; if (Ts !== null) {
    var E = Ts.memoizedState;
    if (y = E.destroy, u !== null && tA(u, E.deps)) {
        g.memoizedState = Ev(r, o, y, u);
        return;
    }
} Yi.flags |= t, g.memoizedState = Ev(1 | r, o, y, u); }
function hD(t, r) { return W1(8390656, 8, t, r); }
function iA(t, r) { return ob(2048, 8, t, r); }
function Zz(t, r) { return ob(4, 2, t, r); }
function Xz(t, r) { return ob(4, 4, t, r); }
function Kz(t, r) { if (typeof r == "function")
    return t = t(), r(t), function () { r(null); }; if (r != null)
    return t = t(), r.current = t, function () { r.current = null; }; }
function Yz(t, r, o) { return o = o != null ? o.concat([t]) : null, ob(4, 4, Kz.bind(null, r, t), o); }
function sA() { }
function Qz(t, r) { var o = ja(); r = r === void 0 ? null : r; var u = o.memoizedState; return u !== null && r !== null && tA(r, u[1]) ? u[0] : (o.memoizedState = [t, r], t); }
function Jz(t, r) { var o = ja(); r = r === void 0 ? null : r; var u = o.memoizedState; return u !== null && r !== null && tA(r, u[1]) ? u[0] : (t = t(), o.memoizedState = [t, r], t); }
function e3(t, r, o) { return If & 21 ? (xl(o, r) || (o = sz(), Yi.lanes |= o, Pf |= o, t.baseState = !0), r) : (t.baseState && (t.baseState = !1, qo = !0), t.memoizedState = o); }
function I$(t, r) { var o = Ti; Ti = o !== 0 && 4 > o ? o : 4, t(!0); var u = uE.transition; uE.transition = {}; try {
    t(!1), r();
}
finally {
    Ti = o, uE.transition = u;
} }
function t3() { return ja().memoizedState; }
function P$(t, r, o) { var u = Bh(t); if (o = { lane: u, action: o, hasEagerState: !1, eagerState: null, next: null }, r3(t))
    n3(r, o);
else if (o = Fz(t, r, o, u), o !== null) {
    var g = bo();
    yl(o, t, u, g), i3(o, r, u);
} }
function M$(t, r, o) { var u = Bh(t), g = { lane: u, action: o, hasEagerState: !1, eagerState: null, next: null }; if (r3(t))
    n3(r, g);
else {
    var y = t.alternate;
    if (t.lanes === 0 && (y === null || y.lanes === 0) && (y = r.lastRenderedReducer, y !== null))
        try {
            var E = r.lastRenderedState, s = y(E, o);
            if (g.hasEagerState = !0, g.eagerState = s, xl(s, E)) {
                var k = r.interleaved;
                k === null ? (g.next = g, KC(r)) : (g.next = k.next, k.next = g), r.interleaved = g;
                return;
            }
        }
        catch { }
        finally { }
    o = Fz(t, r, g, u), o !== null && (g = bo(), yl(o, t, u, g), i3(o, r, u));
} }
function r3(t) { var r = t.alternate; return t === Yi || r !== null && r === Yi; }
function n3(t, r) { Jy = Sw = !0; var o = t.pending; o === null ? r.next = r : (r.next = o.next, o.next = r), t.pending = r; }
function i3(t, r, o) { if (o & 4194240) {
    var u = r.lanes;
    u &= t.pendingLanes, o |= u, r.lanes = o, zC(t, o);
} }
var Ew = { readContext: Ba, useCallback: so, useContext: so, useEffect: so, useImperativeHandle: so, useInsertionEffect: so, useLayoutEffect: so, useMemo: so, useReducer: so, useRef: so, useState: so, useDebugValue: so, useDeferredValue: so, useTransition: so, useMutableSource: so, useSyncExternalStore: so, useId: so, unstable_isNewReconciler: !1 }, R$ = { readContext: Ba, useCallback: function (t, r) { return Kl().memoizedState = [t, r === void 0 ? null : r], t; }, useContext: Ba, useEffect: hD, useImperativeHandle: function (t, r, o) { return o = o != null ? o.concat([t]) : null, W1(4194308, 4, Kz.bind(null, r, t), o); }, useLayoutEffect: function (t, r) { return W1(4194308, 4, t, r); }, useInsertionEffect: function (t, r) { return W1(4, 2, t, r); }, useMemo: function (t, r) { var o = Kl(); return r = r === void 0 ? null : r, t = t(), o.memoizedState = [t, r], t; }, useReducer: function (t, r, o) { var u = Kl(); return r = o !== void 0 ? o(r) : r, u.memoizedState = u.baseState = r, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: r }, u.queue = t, t = t.dispatch = P$.bind(null, Yi, t), [u.memoizedState, t]; }, useRef: function (t) { var r = Kl(); return t = { current: t }, r.memoizedState = t; }, useState: uD, useDebugValue: sA, useDeferredValue: function (t) { return Kl().memoizedState = t; }, useTransition: function () { var t = uD(!1), r = t[0]; return t = I$.bind(null, t[1]), Kl().memoizedState = t, [r, t]; }, useMutableSource: function () { }, useSyncExternalStore: function (t, r, o) { var u = Yi, g = Kl(); if (Ui) {
        if (o === void 0)
            throw Error(rr(407));
        o = o();
    }
    else {
        if (o = r(), Ns === null)
            throw Error(rr(349));
        If & 30 || Uz(u, r, o);
    } g.memoizedState = o; var y = { value: o, getSnapshot: r }; return g.queue = y, hD(Gz.bind(null, u, y, t), [t]), u.flags |= 2048, Ev(9, $z.bind(null, u, y, o, r), void 0, null), o; }, useId: function () { var t = Kl(), r = Ns.identifierPrefix; if (Ui) {
        var o = ru, u = tu;
        o = (u & ~(1 << 32 - _l(u) - 1)).toString(32) + o, r = ":" + r + "R" + o, o = Tv++, 0 < o && (r += "H" + o.toString(32)), r += ":";
    }
    else
        o = A$++, r = ":" + r + "r" + o.toString(32) + ":"; return t.memoizedState = r; }, unstable_isNewReconciler: !1 }, k$ = { readContext: Ba, useCallback: Qz, useContext: Ba, useEffect: iA, useImperativeHandle: Yz, useInsertionEffect: Zz, useLayoutEffect: Xz, useMemo: Jz, useReducer: hE, useRef: Wz, useState: function () { return hE(Sv); }, useDebugValue: sA, useDeferredValue: function (t) { var r = ja(); return e3(r, Ts.memoizedState, t); }, useTransition: function () { var t = hE(Sv)[0], r = ja().memoizedState; return [t, r]; }, useMutableSource: jz, useSyncExternalStore: Vz, useId: t3, unstable_isNewReconciler: !1 }, D$ = { readContext: Ba, useCallback: Qz, useContext: Ba, useEffect: iA, useImperativeHandle: Yz, useInsertionEffect: Zz, useLayoutEffect: Xz, useMemo: Jz, useReducer: dE, useRef: Wz, useState: function () { return dE(Sv); }, useDebugValue: sA, useDeferredValue: function (t) { var r = ja(); return Ts === null ? r.memoizedState = t : e3(r, Ts.memoizedState, t); }, useTransition: function () { var t = dE(Sv)[0], r = ja().memoizedState; return [t, r]; }, useMutableSource: jz, useSyncExternalStore: Vz, useId: t3, unstable_isNewReconciler: !1 };
function ll(t, r) { if (t && t.defaultProps) {
    r = Qi({}, r), t = t.defaultProps;
    for (var o in t)
        r[o] === void 0 && (r[o] = t[o]);
    return r;
} return r; }
function w2(t, r, o, u) { r = t.memoizedState, o = o(u, r), o = o == null ? r : Qi({}, r, o), t.memoizedState = o, t.lanes === 0 && (t.updateQueue.baseState = o); }
var ab = { isMounted: function (t) { return (t = t._reactInternals) ? jf(t) === t : !1; }, enqueueSetState: function (t, r, o) { t = t._reactInternals; var u = bo(), g = Bh(t), y = nu(u, g); y.payload = r, o != null && (y.callback = o), r = Fh(t, y, g), r !== null && (yl(r, t, g, u), q1(r, t, g)); }, enqueueReplaceState: function (t, r, o) { t = t._reactInternals; var u = bo(), g = Bh(t), y = nu(u, g); y.tag = 1, y.payload = r, o != null && (y.callback = o), r = Fh(t, y, g), r !== null && (yl(r, t, g, u), q1(r, t, g)); }, enqueueForceUpdate: function (t, r) { t = t._reactInternals; var o = bo(), u = Bh(t), g = nu(o, u); g.tag = 2, r != null && (g.callback = r), r = Fh(t, g, u), r !== null && (yl(r, t, u, o), q1(r, t, u)); } };
function dD(t, r, o, u, g, y, E) { return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(u, y, E) : r.prototype && r.prototype.isPureReactComponent ? !_v(o, u) || !_v(g, y) : !0; }
function s3(t, r, o) { var u = !1, g = qh, y = r.contextType; return typeof y == "object" && y !== null ? y = Ba(y) : (g = Wo(r) ? Cf : ho.current, u = r.contextTypes, y = (u = u != null) ? og(t, g) : qh), r = new r(o, y), t.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, r.updater = ab, t.stateNode = r, r._reactInternals = t, u && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = g, t.__reactInternalMemoizedMaskedChildContext = y), r; }
function fD(t, r, o, u) { t = r.state, typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps(o, u), typeof r.UNSAFE_componentWillReceiveProps == "function" && r.UNSAFE_componentWillReceiveProps(o, u), r.state !== t && ab.enqueueReplaceState(r, r.state, null); }
function b2(t, r, o, u) { var g = t.stateNode; g.props = o, g.state = t.memoizedState, g.refs = {}, YC(t); var y = r.contextType; typeof y == "object" && y !== null ? g.context = Ba(y) : (y = Wo(r) ? Cf : ho.current, g.context = og(t, y)), g.state = t.memoizedState, y = r.getDerivedStateFromProps, typeof y == "function" && (w2(t, r, y, o), g.state = t.memoizedState), typeof r.getDerivedStateFromProps == "function" || typeof g.getSnapshotBeforeUpdate == "function" || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (r = g.state, typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount(), r !== g.state && ab.enqueueReplaceState(g, g.state, null), bw(t, o, g, u), g.state = t.memoizedState), typeof g.componentDidMount == "function" && (t.flags |= 4194308); }
function ug(t, r) {
    try {
        var o = "", u = r;
        do
            o += a6(u), u = u.return;
        while (u);
        var g = o;
    }
    catch (y) {
        g = `
Error generating stack: ` + y.message + `
` + y.stack;
    }
    return { value: t, source: r, stack: g, digest: null };
}
function fE(t, r, o) { return { value: t, source: null, stack: o ?? null, digest: r ?? null }; }
function T2(t, r) { try {
    console.error(r.value);
}
catch (o) {
    setTimeout(function () { throw o; });
} }
var L$ = typeof WeakMap == "function" ? WeakMap : Map;
function o3(t, r, o) { o = nu(-1, o), o.tag = 3, o.payload = { element: null }; var u = r.value; return o.callback = function () { Aw || (Aw = !0, D2 = u), T2(t, r); }, o; }
function a3(t, r, o) { o = nu(-1, o), o.tag = 3; var u = t.type.getDerivedStateFromError; if (typeof u == "function") {
    var g = r.value;
    o.payload = function () { return u(g); }, o.callback = function () { T2(t, r); };
} var y = t.stateNode; return y !== null && typeof y.componentDidCatch == "function" && (o.callback = function () { T2(t, r), typeof u != "function" && (Nh === null ? Nh = new Set([this]) : Nh.add(this)); var E = r.stack; this.componentDidCatch(r.value, { componentStack: E !== null ? E : "" }); }), o; }
function pD(t, r, o) { var u = t.pingCache; if (u === null) {
    u = t.pingCache = new L$;
    var g = new Set;
    u.set(r, g);
}
else
    g = u.get(r), g === void 0 && (g = new Set, u.set(r, g)); g.has(o) || (g.add(o), t = Z$.bind(null, t, r, o), r.then(t, t)); }
function mD(t) { do {
    var r;
    if ((r = t.tag === 13) && (r = t.memoizedState, r = r !== null ? r.dehydrated !== null : !0), r)
        return t;
    t = t.return;
} while (t !== null); return null; }
function gD(t, r, o, u, g) { return t.mode & 1 ? (t.flags |= 65536, t.lanes = g, t) : (t === r ? t.flags |= 65536 : (t.flags |= 128, o.flags |= 131072, o.flags &= -52805, o.tag === 1 && (o.alternate === null ? o.tag = 17 : (r = nu(-1, 1), r.tag = 2, Fh(o, r, 1))), o.lanes |= 1), t); }
var O$ = du.ReactCurrentOwner, qo = !1;
function xo(t, r, o, u) { r.child = t === null ? zz(r, null, o, u) : lg(r, t.child, o, u); }
function _D(t, r, o, u, g) { o = o.render; var y = r.ref; return Nm(r, g), u = rA(t, r, o, u, y, g), o = nA(), t !== null && !qo ? (r.updateQueue = t.updateQueue, r.flags &= -2053, t.lanes &= ~g, lu(t, r, g)) : (Ui && o && GC(r), r.flags |= 1, xo(t, r, u, g), r.child); }
function yD(t, r, o, u, g) { if (t === null) {
    var y = o.type;
    return typeof y == "function" && !fA(y) && y.defaultProps === void 0 && o.compare === null && o.defaultProps === void 0 ? (r.tag = 15, r.type = y, l3(t, r, y, u, g)) : (t = Y1(o.type, null, u, r, r.mode, g), t.ref = r.ref, t.return = r, r.child = t);
} if (y = t.child, !(t.lanes & g)) {
    var E = y.memoizedProps;
    if (o = o.compare, o = o !== null ? o : _v, o(E, u) && t.ref === r.ref)
        return lu(t, r, g);
} return r.flags |= 1, t = jh(y, u), t.ref = r.ref, t.return = r, r.child = t; }
function l3(t, r, o, u, g) { if (t !== null) {
    var y = t.memoizedProps;
    if (_v(y, u) && t.ref === r.ref)
        if (qo = !1, r.pendingProps = u = y, (t.lanes & g) !== 0)
            t.flags & 131072 && (qo = !0);
        else
            return r.lanes = t.lanes, lu(t, r, g);
} return S2(t, r, o, u, g); }
function c3(t, r, o) { var u = r.pendingProps, g = u.children, y = t !== null ? t.memoizedState : null; if (u.mode === "hidden")
    if (!(r.mode & 1))
        r.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Oi(Rm, ha), ha |= o;
    else {
        if (!(o & 1073741824))
            return t = y !== null ? y.baseLanes | o : o, r.lanes = r.childLanes = 1073741824, r.memoizedState = { baseLanes: t, cachePool: null, transitions: null }, r.updateQueue = null, Oi(Rm, ha), ha |= t, null;
        r.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, u = y !== null ? y.baseLanes : o, Oi(Rm, ha), ha |= u;
    }
else
    y !== null ? (u = y.baseLanes | o, r.memoizedState = null) : u = o, Oi(Rm, ha), ha |= u; return xo(t, r, g, o), r.child; }
function u3(t, r) { var o = r.ref; (t === null && o !== null || t !== null && t.ref !== o) && (r.flags |= 512, r.flags |= 2097152); }
function S2(t, r, o, u, g) { var y = Wo(o) ? Cf : ho.current; return y = og(r, y), Nm(r, g), o = rA(t, r, o, u, y, g), u = nA(), t !== null && !qo ? (r.updateQueue = t.updateQueue, r.flags &= -2053, t.lanes &= ~g, lu(t, r, g)) : (Ui && u && GC(r), r.flags |= 1, xo(t, r, o, g), r.child); }
function vD(t, r, o, u, g) { if (Wo(o)) {
    var y = !0;
    _w(r);
}
else
    y = !1; if (Nm(r, g), r.stateNode === null)
    Z1(t, r), s3(r, o, u), b2(r, o, u, g), u = !0;
else if (t === null) {
    var E = r.stateNode, s = r.memoizedProps;
    E.props = s;
    var k = E.context, L = o.contextType;
    typeof L == "object" && L !== null ? L = Ba(L) : (L = Wo(o) ? Cf : ho.current, L = og(r, L));
    var N = o.getDerivedStateFromProps, V = typeof N == "function" || typeof E.getSnapshotBeforeUpdate == "function";
    V || typeof E.UNSAFE_componentWillReceiveProps != "function" && typeof E.componentWillReceiveProps != "function" || (s !== u || k !== L) && fD(r, E, u, L), mh = !1;
    var H = r.memoizedState;
    E.state = H, bw(r, u, E, g), k = r.memoizedState, s !== u || H !== k || Ho.current || mh ? (typeof N == "function" && (w2(r, o, N, u), k = r.memoizedState), (s = mh || dD(r, o, s, u, H, k, L)) ? (V || typeof E.UNSAFE_componentWillMount != "function" && typeof E.componentWillMount != "function" || (typeof E.componentWillMount == "function" && E.componentWillMount(), typeof E.UNSAFE_componentWillMount == "function" && E.UNSAFE_componentWillMount()), typeof E.componentDidMount == "function" && (r.flags |= 4194308)) : (typeof E.componentDidMount == "function" && (r.flags |= 4194308), r.memoizedProps = u, r.memoizedState = k), E.props = u, E.state = k, E.context = L, u = s) : (typeof E.componentDidMount == "function" && (r.flags |= 4194308), u = !1);
}
else {
    E = r.stateNode, Nz(t, r), s = r.memoizedProps, L = r.type === r.elementType ? s : ll(r.type, s), E.props = L, V = r.pendingProps, H = E.context, k = o.contextType, typeof k == "object" && k !== null ? k = Ba(k) : (k = Wo(o) ? Cf : ho.current, k = og(r, k));
    var ee = o.getDerivedStateFromProps;
    (N = typeof ee == "function" || typeof E.getSnapshotBeforeUpdate == "function") || typeof E.UNSAFE_componentWillReceiveProps != "function" && typeof E.componentWillReceiveProps != "function" || (s !== V || H !== k) && fD(r, E, u, k), mh = !1, H = r.memoizedState, E.state = H, bw(r, u, E, g);
    var ce = r.memoizedState;
    s !== V || H !== ce || Ho.current || mh ? (typeof ee == "function" && (w2(r, o, ee, u), ce = r.memoizedState), (L = mh || dD(r, o, L, u, H, ce, k) || !1) ? (N || typeof E.UNSAFE_componentWillUpdate != "function" && typeof E.componentWillUpdate != "function" || (typeof E.componentWillUpdate == "function" && E.componentWillUpdate(u, ce, k), typeof E.UNSAFE_componentWillUpdate == "function" && E.UNSAFE_componentWillUpdate(u, ce, k)), typeof E.componentDidUpdate == "function" && (r.flags |= 4), typeof E.getSnapshotBeforeUpdate == "function" && (r.flags |= 1024)) : (typeof E.componentDidUpdate != "function" || s === t.memoizedProps && H === t.memoizedState || (r.flags |= 4), typeof E.getSnapshotBeforeUpdate != "function" || s === t.memoizedProps && H === t.memoizedState || (r.flags |= 1024), r.memoizedProps = u, r.memoizedState = ce), E.props = u, E.state = ce, E.context = k, u = L) : (typeof E.componentDidUpdate != "function" || s === t.memoizedProps && H === t.memoizedState || (r.flags |= 4), typeof E.getSnapshotBeforeUpdate != "function" || s === t.memoizedProps && H === t.memoizedState || (r.flags |= 1024), u = !1);
} return E2(t, r, o, u, y, g); }
function E2(t, r, o, u, g, y) { u3(t, r); var E = (r.flags & 128) !== 0; if (!u && !E)
    return g && iD(r, o, !1), lu(t, r, y); u = r.stateNode, O$.current = r; var s = E && typeof o.getDerivedStateFromError != "function" ? null : u.render(); return r.flags |= 1, t !== null && E ? (r.child = lg(r, t.child, null, y), r.child = lg(r, null, s, y)) : xo(t, r, s, y), r.memoizedState = u.state, g && iD(r, o, !0), r.child; }
function h3(t) { var r = t.stateNode; r.pendingContext ? nD(t, r.pendingContext, r.pendingContext !== r.context) : r.context && nD(t, r.context, !1), QC(t, r.containerInfo); }
function xD(t, r, o, u, g) { return ag(), HC(g), r.flags |= 256, xo(t, r, o, u), r.child; }
var C2 = { dehydrated: null, treeContext: null, retryLane: 0 };
function A2(t) { return { baseLanes: t, cachePool: null, transitions: null }; }
function d3(t, r, o) { var u = r.pendingProps, g = Ki.current, y = !1, E = (r.flags & 128) !== 0, s; if ((s = E) || (s = t !== null && t.memoizedState === null ? !1 : (g & 2) !== 0), s ? (y = !0, r.flags &= -129) : (t === null || t.memoizedState !== null) && (g |= 1), Oi(Ki, g & 1), t === null)
    return v2(r), t = r.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (r.mode & 1 ? t.data === "$!" ? r.lanes = 8 : r.lanes = 1073741824 : r.lanes = 1, null) : (E = u.children, t = u.fallback, y ? (u = r.mode, y = r.child, E = { mode: "hidden", children: E }, !(u & 1) && y !== null ? (y.childLanes = 0, y.pendingProps = E) : y = ub(E, u, 0, null), t = Tf(t, u, o, null), y.return = r, t.return = r, y.sibling = t, r.child = y, r.child.memoizedState = A2(o), r.memoizedState = C2, t) : oA(r, E)); if (g = t.memoizedState, g !== null && (s = g.dehydrated, s !== null))
    return z$(t, r, E, u, s, g, o); if (y) {
    y = u.fallback, E = r.mode, g = t.child, s = g.sibling;
    var k = { mode: "hidden", children: u.children };
    return !(E & 1) && r.child !== g ? (u = r.child, u.childLanes = 0, u.pendingProps = k, r.deletions = null) : (u = jh(g, k), u.subtreeFlags = g.subtreeFlags & 14680064), s !== null ? y = jh(s, y) : (y = Tf(y, E, o, null), y.flags |= 2), y.return = r, u.return = r, u.sibling = y, r.child = u, u = y, y = r.child, E = t.child.memoizedState, E = E === null ? A2(o) : { baseLanes: E.baseLanes | o, cachePool: null, transitions: E.transitions }, y.memoizedState = E, y.childLanes = t.childLanes & ~o, r.memoizedState = C2, u;
} return y = t.child, t = y.sibling, u = jh(y, { mode: "visible", children: u.children }), !(r.mode & 1) && (u.lanes = o), u.return = r, u.sibling = null, t !== null && (o = r.deletions, o === null ? (r.deletions = [t], r.flags |= 16) : o.push(t)), r.child = u, r.memoizedState = null, u; }
function oA(t, r) { return r = ub({ mode: "visible", children: r }, t.mode, 0, null), r.return = t, t.child = r; }
function S1(t, r, o, u) { return u !== null && HC(u), lg(r, t.child, null, o), t = oA(r, r.pendingProps.children), t.flags |= 2, r.memoizedState = null, t; }
function z$(t, r, o, u, g, y, E) { if (o)
    return r.flags & 256 ? (r.flags &= -257, u = fE(Error(rr(422))), S1(t, r, E, u)) : r.memoizedState !== null ? (r.child = t.child, r.flags |= 128, null) : (y = u.fallback, g = r.mode, u = ub({ mode: "visible", children: u.children }, g, 0, null), y = Tf(y, g, E, null), y.flags |= 2, u.return = r, y.return = r, u.sibling = y, r.child = u, r.mode & 1 && lg(r, t.child, null, E), r.child.memoizedState = A2(E), r.memoizedState = C2, y); if (!(r.mode & 1))
    return S1(t, r, E, null); if (g.data === "$!") {
    if (u = g.nextSibling && g.nextSibling.dataset, u)
        var s = u.dgst;
    return u = s, y = Error(rr(419)), u = fE(y, u, void 0), S1(t, r, E, u);
} if (s = (E & t.childLanes) !== 0, qo || s) {
    if (u = Ns, u !== null) {
        switch (E & -E) {
            case 4:
                g = 2;
                break;
            case 16:
                g = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                g = 32;
                break;
            case 536870912:
                g = 268435456;
                break;
            default: g = 0;
        }
        g = g & (u.suspendedLanes | E) ? 0 : g, g !== 0 && g !== y.retryLane && (y.retryLane = g, au(t, g), yl(u, t, g, -1));
    }
    return dA(), u = fE(Error(rr(421))), S1(t, r, E, u);
} return g.data === "$?" ? (r.flags |= 128, r.child = t.child, r = X$.bind(null, t), g._reactRetry = r, null) : (t = y.treeContext, fa = zh(g.nextSibling), pa = r, Ui = !0, dl = null, t !== null && (Da[La++] = tu, Da[La++] = ru, Da[La++] = Af, tu = t.id, ru = t.overflow, Af = r), r = oA(r, u.children), r.flags |= 4096, r); }
function wD(t, r, o) { t.lanes |= r; var u = t.alternate; u !== null && (u.lanes |= r), x2(t.return, r, o); }
function pE(t, r, o, u, g) { var y = t.memoizedState; y === null ? t.memoizedState = { isBackwards: r, rendering: null, renderingStartTime: 0, last: u, tail: o, tailMode: g } : (y.isBackwards = r, y.rendering = null, y.renderingStartTime = 0, y.last = u, y.tail = o, y.tailMode = g); }
function f3(t, r, o) { var u = r.pendingProps, g = u.revealOrder, y = u.tail; if (xo(t, r, u.children, o), u = Ki.current, u & 2)
    u = u & 1 | 2, r.flags |= 128;
else {
    if (t !== null && t.flags & 128)
        e: for (t = r.child; t !== null;) {
            if (t.tag === 13)
                t.memoizedState !== null && wD(t, o, r);
            else if (t.tag === 19)
                wD(t, o, r);
            else if (t.child !== null) {
                t.child.return = t, t = t.child;
                continue;
            }
            if (t === r)
                break e;
            for (; t.sibling === null;) {
                if (t.return === null || t.return === r)
                    break e;
                t = t.return;
            }
            t.sibling.return = t.return, t = t.sibling;
        }
    u &= 1;
} if (Oi(Ki, u), !(r.mode & 1))
    r.memoizedState = null;
else
    switch (g) {
        case "forwards":
            for (o = r.child, g = null; o !== null;)
                t = o.alternate, t !== null && Tw(t) === null && (g = o), o = o.sibling;
            o = g, o === null ? (g = r.child, r.child = null) : (g = o.sibling, o.sibling = null), pE(r, !1, g, o, y);
            break;
        case "backwards":
            for (o = null, g = r.child, r.child = null; g !== null;) {
                if (t = g.alternate, t !== null && Tw(t) === null) {
                    r.child = g;
                    break;
                }
                t = g.sibling, g.sibling = o, o = g, g = t;
            }
            pE(r, !0, o, null, y);
            break;
        case "together":
            pE(r, !1, null, null, void 0);
            break;
        default: r.memoizedState = null;
    } return r.child; }
function Z1(t, r) { !(r.mode & 1) && t !== null && (t.alternate = null, r.alternate = null, r.flags |= 2); }
function lu(t, r, o) { if (t !== null && (r.dependencies = t.dependencies), Pf |= r.lanes, !(o & r.childLanes))
    return null; if (t !== null && r.child !== t.child)
    throw Error(rr(153)); if (r.child !== null) {
    for (t = r.child, o = jh(t, t.pendingProps), r.child = o, o.return = r; t.sibling !== null;)
        t = t.sibling, o = o.sibling = jh(t, t.pendingProps), o.return = r;
    o.sibling = null;
} return r.child; }
function F$(t, r, o) { switch (r.tag) {
    case 3:
        h3(r), ag();
        break;
    case 5:
        Bz(r);
        break;
    case 1:
        Wo(r.type) && _w(r);
        break;
    case 4:
        QC(r, r.stateNode.containerInfo);
        break;
    case 10:
        var u = r.type._context, g = r.memoizedProps.value;
        Oi(xw, u._currentValue), u._currentValue = g;
        break;
    case 13:
        if (u = r.memoizedState, u !== null)
            return u.dehydrated !== null ? (Oi(Ki, Ki.current & 1), r.flags |= 128, null) : o & r.child.childLanes ? d3(t, r, o) : (Oi(Ki, Ki.current & 1), t = lu(t, r, o), t !== null ? t.sibling : null);
        Oi(Ki, Ki.current & 1);
        break;
    case 19:
        if (u = (o & r.childLanes) !== 0, t.flags & 128) {
            if (u)
                return f3(t, r, o);
            r.flags |= 128;
        }
        if (g = r.memoizedState, g !== null && (g.rendering = null, g.tail = null, g.lastEffect = null), Oi(Ki, Ki.current), u)
            break;
        return null;
    case 22:
    case 23: return r.lanes = 0, c3(t, r, o);
} return lu(t, r, o); }
var p3, I2, m3, g3;
p3 = function (t, r) { for (var o = r.child; o !== null;) {
    if (o.tag === 5 || o.tag === 6)
        t.appendChild(o.stateNode);
    else if (o.tag !== 4 && o.child !== null) {
        o.child.return = o, o = o.child;
        continue;
    }
    if (o === r)
        break;
    for (; o.sibling === null;) {
        if (o.return === null || o.return === r)
            return;
        o = o.return;
    }
    o.sibling.return = o.return, o = o.sibling;
} };
I2 = function () { };
m3 = function (t, r, o, u) { var g = t.memoizedProps; if (g !== u) {
    t = r.stateNode, ff(oc.current);
    var y = null;
    switch (o) {
        case "input":
            g = KE(t, g), u = KE(t, u), y = [];
            break;
        case "select":
            g = Qi({}, g, { value: void 0 }), u = Qi({}, u, { value: void 0 }), y = [];
            break;
        case "textarea":
            g = JE(t, g), u = JE(t, u), y = [];
            break;
        default: typeof g.onClick != "function" && typeof u.onClick == "function" && (t.onclick = mw);
    }
    t2(o, u);
    var E;
    o = null;
    for (L in g)
        if (!u.hasOwnProperty(L) && g.hasOwnProperty(L) && g[L] != null)
            if (L === "style") {
                var s = g[L];
                for (E in s)
                    s.hasOwnProperty(E) && (o || (o = {}), o[E] = "");
            }
            else
                L !== "dangerouslySetInnerHTML" && L !== "children" && L !== "suppressContentEditableWarning" && L !== "suppressHydrationWarning" && L !== "autoFocus" && (uv.hasOwnProperty(L) ? y || (y = []) : (y = y || []).push(L, null));
    for (L in u) {
        var k = u[L];
        if (s = g != null ? g[L] : void 0, u.hasOwnProperty(L) && k !== s && (k != null || s != null))
            if (L === "style")
                if (s) {
                    for (E in s)
                        !s.hasOwnProperty(E) || k && k.hasOwnProperty(E) || (o || (o = {}), o[E] = "");
                    for (E in k)
                        k.hasOwnProperty(E) && s[E] !== k[E] && (o || (o = {}), o[E] = k[E]);
                }
                else
                    o || (y || (y = []), y.push(L, o)), o = k;
            else
                L === "dangerouslySetInnerHTML" ? (k = k ? k.__html : void 0, s = s ? s.__html : void 0, k != null && s !== k && (y = y || []).push(L, k)) : L === "children" ? typeof k != "string" && typeof k != "number" || (y = y || []).push(L, "" + k) : L !== "suppressContentEditableWarning" && L !== "suppressHydrationWarning" && (uv.hasOwnProperty(L) ? (k != null && L === "onScroll" && Ni("scroll", t), y || s === k || (y = [])) : (y = y || []).push(L, k));
    }
    o && (y = y || []).push("style", o);
    var L = y;
    (r.updateQueue = L) && (r.flags |= 4);
} };
g3 = function (t, r, o, u) { o !== u && (r.flags |= 4); };
function Iy(t, r) { if (!Ui)
    switch (t.tailMode) {
        case "hidden":
            r = t.tail;
            for (var o = null; r !== null;)
                r.alternate !== null && (o = r), r = r.sibling;
            o === null ? t.tail = null : o.sibling = null;
            break;
        case "collapsed":
            o = t.tail;
            for (var u = null; o !== null;)
                o.alternate !== null && (u = o), o = o.sibling;
            u === null ? r || t.tail === null ? t.tail = null : t.tail.sibling = null : u.sibling = null;
    } }
function oo(t) { var r = t.alternate !== null && t.alternate.child === t.child, o = 0, u = 0; if (r)
    for (var g = t.child; g !== null;)
        o |= g.lanes | g.childLanes, u |= g.subtreeFlags & 14680064, u |= g.flags & 14680064, g.return = t, g = g.sibling;
else
    for (g = t.child; g !== null;)
        o |= g.lanes | g.childLanes, u |= g.subtreeFlags, u |= g.flags, g.return = t, g = g.sibling; return t.subtreeFlags |= u, t.childLanes = o, r; }
function N$(t, r, o) { var u = r.pendingProps; switch (qC(r), r.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14: return oo(r), null;
    case 1: return Wo(r.type) && gw(), oo(r), null;
    case 3: return u = r.stateNode, cg(), Bi(Ho), Bi(ho), eA(), u.pendingContext && (u.context = u.pendingContext, u.pendingContext = null), (t === null || t.child === null) && (b1(r) ? r.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(r.flags & 256) || (r.flags |= 1024, dl !== null && (z2(dl), dl = null))), I2(t, r), oo(r), null;
    case 5:
        JC(r);
        var g = ff(bv.current);
        if (o = r.type, t !== null && r.stateNode != null)
            m3(t, r, o, u, g), t.ref !== r.ref && (r.flags |= 512, r.flags |= 2097152);
        else {
            if (!u) {
                if (r.stateNode === null)
                    throw Error(rr(166));
                return oo(r), null;
            }
            if (t = ff(oc.current), b1(r)) {
                u = r.stateNode, o = r.type;
                var y = r.memoizedProps;
                switch (u[rc] = r, u[xv] = y, t = (r.mode & 1) !== 0, o) {
                    case "dialog":
                        Ni("cancel", u), Ni("close", u);
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        Ni("load", u);
                        break;
                    case "video":
                    case "audio":
                        for (g = 0; g < Vy.length; g++)
                            Ni(Vy[g], u);
                        break;
                    case "source":
                        Ni("error", u);
                        break;
                    case "img":
                    case "image":
                    case "link":
                        Ni("error", u), Ni("load", u);
                        break;
                    case "details":
                        Ni("toggle", u);
                        break;
                    case "input":
                        Mk(u, y), Ni("invalid", u);
                        break;
                    case "select":
                        u._wrapperState = { wasMultiple: !!y.multiple }, Ni("invalid", u);
                        break;
                    case "textarea": kk(u, y), Ni("invalid", u);
                }
                t2(o, y), g = null;
                for (var E in y)
                    if (y.hasOwnProperty(E)) {
                        var s = y[E];
                        E === "children" ? typeof s == "string" ? u.textContent !== s && (y.suppressHydrationWarning !== !0 && w1(u.textContent, s, t), g = ["children", s]) : typeof s == "number" && u.textContent !== "" + s && (y.suppressHydrationWarning !== !0 && w1(u.textContent, s, t), g = ["children", "" + s]) : uv.hasOwnProperty(E) && s != null && E === "onScroll" && Ni("scroll", u);
                    }
                switch (o) {
                    case "input":
                        f1(u), Rk(u, y, !0);
                        break;
                    case "textarea":
                        f1(u), Dk(u);
                        break;
                    case "select":
                    case "option": break;
                    default: typeof y.onClick == "function" && (u.onclick = mw);
                }
                u = g, r.updateQueue = u, u !== null && (r.flags |= 4);
            }
            else {
                E = g.nodeType === 9 ? g : g.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = GO(o)), t === "http://www.w3.org/1999/xhtml" ? o === "script" ? (t = E.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof u.is == "string" ? t = E.createElement(o, { is: u.is }) : (t = E.createElement(o), o === "select" && (E = t, u.multiple ? E.multiple = !0 : u.size && (E.size = u.size))) : t = E.createElementNS(t, o), t[rc] = r, t[xv] = u, p3(t, r, !1, !1), r.stateNode = t;
                e: {
                    switch (E = r2(o, u), o) {
                        case "dialog":
                            Ni("cancel", t), Ni("close", t), g = u;
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            Ni("load", t), g = u;
                            break;
                        case "video":
                        case "audio":
                            for (g = 0; g < Vy.length; g++)
                                Ni(Vy[g], t);
                            g = u;
                            break;
                        case "source":
                            Ni("error", t), g = u;
                            break;
                        case "img":
                        case "image":
                        case "link":
                            Ni("error", t), Ni("load", t), g = u;
                            break;
                        case "details":
                            Ni("toggle", t), g = u;
                            break;
                        case "input":
                            Mk(t, u), g = KE(t, u), Ni("invalid", t);
                            break;
                        case "option":
                            g = u;
                            break;
                        case "select":
                            t._wrapperState = { wasMultiple: !!u.multiple }, g = Qi({}, u, { value: void 0 }), Ni("invalid", t);
                            break;
                        case "textarea":
                            kk(t, u), g = JE(t, u), Ni("invalid", t);
                            break;
                        default: g = u;
                    }
                    t2(o, g), s = g;
                    for (y in s)
                        if (s.hasOwnProperty(y)) {
                            var k = s[y];
                            y === "style" ? WO(t, k) : y === "dangerouslySetInnerHTML" ? (k = k ? k.__html : void 0, k != null && qO(t, k)) : y === "children" ? typeof k == "string" ? (o !== "textarea" || k !== "") && hv(t, k) : typeof k == "number" && hv(t, "" + k) : y !== "suppressContentEditableWarning" && y !== "suppressHydrationWarning" && y !== "autoFocus" && (uv.hasOwnProperty(y) ? k != null && y === "onScroll" && Ni("scroll", t) : k != null && MC(t, y, k, E));
                        }
                    switch (o) {
                        case "input":
                            f1(t), Rk(t, u, !1);
                            break;
                        case "textarea":
                            f1(t), Dk(t);
                            break;
                        case "option":
                            u.value != null && t.setAttribute("value", "" + Gh(u.value));
                            break;
                        case "select":
                            t.multiple = !!u.multiple, y = u.value, y != null ? Lm(t, !!u.multiple, y, !1) : u.defaultValue != null && Lm(t, !!u.multiple, u.defaultValue, !0);
                            break;
                        default: typeof g.onClick == "function" && (t.onclick = mw);
                    }
                    switch (o) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                            u = !!u.autoFocus;
                            break e;
                        case "img":
                            u = !0;
                            break e;
                        default: u = !1;
                    }
                }
                u && (r.flags |= 4);
            }
            r.ref !== null && (r.flags |= 512, r.flags |= 2097152);
        }
        return oo(r), null;
    case 6:
        if (t && r.stateNode != null)
            g3(t, r, t.memoizedProps, u);
        else {
            if (typeof u != "string" && r.stateNode === null)
                throw Error(rr(166));
            if (o = ff(bv.current), ff(oc.current), b1(r)) {
                if (u = r.stateNode, o = r.memoizedProps, u[rc] = r, (y = u.nodeValue !== o) && (t = pa, t !== null))
                    switch (t.tag) {
                        case 3:
                            w1(u.nodeValue, o, (t.mode & 1) !== 0);
                            break;
                        case 5: t.memoizedProps.suppressHydrationWarning !== !0 && w1(u.nodeValue, o, (t.mode & 1) !== 0);
                    }
                y && (r.flags |= 4);
            }
            else
                u = (o.nodeType === 9 ? o : o.ownerDocument).createTextNode(u), u[rc] = r, r.stateNode = u;
        }
        return oo(r), null;
    case 13:
        if (Bi(Ki), u = r.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
            if (Ui && fa !== null && r.mode & 1 && !(r.flags & 128))
                Lz(), ag(), r.flags |= 98560, y = !1;
            else if (y = b1(r), u !== null && u.dehydrated !== null) {
                if (t === null) {
                    if (!y)
                        throw Error(rr(318));
                    if (y = r.memoizedState, y = y !== null ? y.dehydrated : null, !y)
                        throw Error(rr(317));
                    y[rc] = r;
                }
                else
                    ag(), !(r.flags & 128) && (r.memoizedState = null), r.flags |= 4;
                oo(r), y = !1;
            }
            else
                dl !== null && (z2(dl), dl = null), y = !0;
            if (!y)
                return r.flags & 65536 ? r : null;
        }
        return r.flags & 128 ? (r.lanes = o, r) : (u = u !== null, u !== (t !== null && t.memoizedState !== null) && u && (r.child.flags |= 8192, r.mode & 1 && (t === null || Ki.current & 1 ? Cs === 0 && (Cs = 3) : dA())), r.updateQueue !== null && (r.flags |= 4), oo(r), null);
    case 4: return cg(), I2(t, r), t === null && yv(r.stateNode.containerInfo), oo(r), null;
    case 10: return XC(r.type._context), oo(r), null;
    case 17: return Wo(r.type) && gw(), oo(r), null;
    case 19:
        if (Bi(Ki), y = r.memoizedState, y === null)
            return oo(r), null;
        if (u = (r.flags & 128) !== 0, E = y.rendering, E === null)
            if (u)
                Iy(y, !1);
            else {
                if (Cs !== 0 || t !== null && t.flags & 128)
                    for (t = r.child; t !== null;) {
                        if (E = Tw(t), E !== null) {
                            for (r.flags |= 128, Iy(y, !1), u = E.updateQueue, u !== null && (r.updateQueue = u, r.flags |= 4), r.subtreeFlags = 0, u = o, o = r.child; o !== null;)
                                y = o, t = u, y.flags &= 14680066, E = y.alternate, E === null ? (y.childLanes = 0, y.lanes = t, y.child = null, y.subtreeFlags = 0, y.memoizedProps = null, y.memoizedState = null, y.updateQueue = null, y.dependencies = null, y.stateNode = null) : (y.childLanes = E.childLanes, y.lanes = E.lanes, y.child = E.child, y.subtreeFlags = 0, y.deletions = null, y.memoizedProps = E.memoizedProps, y.memoizedState = E.memoizedState, y.updateQueue = E.updateQueue, y.type = E.type, t = E.dependencies, y.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }), o = o.sibling;
                            return Oi(Ki, Ki.current & 1 | 2), r.child;
                        }
                        t = t.sibling;
                    }
                y.tail !== null && cs() > hg && (r.flags |= 128, u = !0, Iy(y, !1), r.lanes = 4194304);
            }
        else {
            if (!u)
                if (t = Tw(E), t !== null) {
                    if (r.flags |= 128, u = !0, o = t.updateQueue, o !== null && (r.updateQueue = o, r.flags |= 4), Iy(y, !0), y.tail === null && y.tailMode === "hidden" && !E.alternate && !Ui)
                        return oo(r), null;
                }
                else
                    2 * cs() - y.renderingStartTime > hg && o !== 1073741824 && (r.flags |= 128, u = !0, Iy(y, !1), r.lanes = 4194304);
            y.isBackwards ? (E.sibling = r.child, r.child = E) : (o = y.last, o !== null ? o.sibling = E : r.child = E, y.last = E);
        }
        return y.tail !== null ? (r = y.tail, y.rendering = r, y.tail = r.sibling, y.renderingStartTime = cs(), r.sibling = null, o = Ki.current, Oi(Ki, u ? o & 1 | 2 : o & 1), r) : (oo(r), null);
    case 22:
    case 23: return hA(), u = r.memoizedState !== null, t !== null && t.memoizedState !== null !== u && (r.flags |= 8192), u && r.mode & 1 ? ha & 1073741824 && (oo(r), r.subtreeFlags & 6 && (r.flags |= 8192)) : oo(r), null;
    case 24: return null;
    case 25: return null;
} throw Error(rr(156, r.tag)); }
function B$(t, r) { switch (qC(r), r.tag) {
    case 1: return Wo(r.type) && gw(), t = r.flags, t & 65536 ? (r.flags = t & -65537 | 128, r) : null;
    case 3: return cg(), Bi(Ho), Bi(ho), eA(), t = r.flags, t & 65536 && !(t & 128) ? (r.flags = t & -65537 | 128, r) : null;
    case 5: return JC(r), null;
    case 13:
        if (Bi(Ki), t = r.memoizedState, t !== null && t.dehydrated !== null) {
            if (r.alternate === null)
                throw Error(rr(340));
            ag();
        }
        return t = r.flags, t & 65536 ? (r.flags = t & -65537 | 128, r) : null;
    case 19: return Bi(Ki), null;
    case 4: return cg(), null;
    case 10: return XC(r.type._context), null;
    case 22:
    case 23: return hA(), null;
    case 24: return null;
    default: return null;
} }
var E1 = !1, co = !1, j$ = typeof WeakSet == "function" ? WeakSet : Set, Dr = null;
function Mm(t, r) { var o = t.ref; if (o !== null)
    if (typeof o == "function")
        try {
            o(null);
        }
        catch (u) {
            ns(t, r, u);
        }
    else
        o.current = null; }
function P2(t, r, o) { try {
    o();
}
catch (u) {
    ns(t, r, u);
} }
var bD = !1;
function V$(t, r) { if (d2 = dw, t = wz(), $C(t)) {
    if ("selectionStart" in t)
        var o = { start: t.selectionStart, end: t.selectionEnd };
    else
        e: {
            o = (o = t.ownerDocument) && o.defaultView || window;
            var u = o.getSelection && o.getSelection();
            if (u && u.rangeCount !== 0) {
                o = u.anchorNode;
                var g = u.anchorOffset, y = u.focusNode;
                u = u.focusOffset;
                try {
                    o.nodeType, y.nodeType;
                }
                catch {
                    o = null;
                    break e;
                }
                var E = 0, s = -1, k = -1, L = 0, N = 0, V = t, H = null;
                t: for (;;) {
                    for (var ee; V !== o || g !== 0 && V.nodeType !== 3 || (s = E + g), V !== y || u !== 0 && V.nodeType !== 3 || (k = E + u), V.nodeType === 3 && (E += V.nodeValue.length), (ee = V.firstChild) !== null;)
                        H = V, V = ee;
                    for (;;) {
                        if (V === t)
                            break t;
                        if (H === o && ++L === g && (s = E), H === y && ++N === u && (k = E), (ee = V.nextSibling) !== null)
                            break;
                        V = H, H = V.parentNode;
                    }
                    V = ee;
                }
                o = s === -1 || k === -1 ? null : { start: s, end: k };
            }
            else
                o = null;
        }
    o = o || { start: 0, end: 0 };
}
else
    o = null; for (f2 = { focusedElem: t, selectionRange: o }, dw = !1, Dr = r; Dr !== null;)
    if (r = Dr, t = r.child, (r.subtreeFlags & 1028) !== 0 && t !== null)
        t.return = r, Dr = t;
    else
        for (; Dr !== null;) {
            r = Dr;
            try {
                var ce = r.alternate;
                if (r.flags & 1024)
                    switch (r.tag) {
                        case 0:
                        case 11:
                        case 15: break;
                        case 1:
                            if (ce !== null) {
                                var J = ce.memoizedProps, ye = ce.memoizedState, ie = r.stateNode, Q = ie.getSnapshotBeforeUpdate(r.elementType === r.type ? J : ll(r.type, J), ye);
                                ie.__reactInternalSnapshotBeforeUpdate = Q;
                            }
                            break;
                        case 3:
                            var ue = r.stateNode.containerInfo;
                            ue.nodeType === 1 ? ue.textContent = "" : ue.nodeType === 9 && ue.documentElement && ue.removeChild(ue.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17: break;
                        default: throw Error(rr(163));
                    }
            }
            catch (be) {
                ns(r, r.return, be);
            }
            if (t = r.sibling, t !== null) {
                t.return = r.return, Dr = t;
                break;
            }
            Dr = r.return;
        } return ce = bD, bD = !1, ce; }
function ev(t, r, o) { var u = r.updateQueue; if (u = u !== null ? u.lastEffect : null, u !== null) {
    var g = u = u.next;
    do {
        if ((g.tag & t) === t) {
            var y = g.destroy;
            g.destroy = void 0, y !== void 0 && P2(r, o, y);
        }
        g = g.next;
    } while (g !== u);
} }
function lb(t, r) { if (r = r.updateQueue, r = r !== null ? r.lastEffect : null, r !== null) {
    var o = r = r.next;
    do {
        if ((o.tag & t) === t) {
            var u = o.create;
            o.destroy = u();
        }
        o = o.next;
    } while (o !== r);
} }
function M2(t) { var r = t.ref; if (r !== null) {
    var o = t.stateNode;
    switch (t.tag) {
        case 5:
            t = o;
            break;
        default: t = o;
    }
    typeof r == "function" ? r(t) : r.current = t;
} }
function _3(t) { var r = t.alternate; r !== null && (t.alternate = null, _3(r)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (r = t.stateNode, r !== null && (delete r[rc], delete r[xv], delete r[g2], delete r[T$], delete r[S$])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null; }
function y3(t) { return t.tag === 5 || t.tag === 3 || t.tag === 4; }
function TD(t) { e: for (;;) {
    for (; t.sibling === null;) {
        if (t.return === null || y3(t.return))
            return null;
        t = t.return;
    }
    for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) {
        if (t.flags & 2 || t.child === null || t.tag === 4)
            continue e;
        t.child.return = t, t = t.child;
    }
    if (!(t.flags & 2))
        return t.stateNode;
} }
function R2(t, r, o) { var u = t.tag; if (u === 5 || u === 6)
    t = t.stateNode, r ? o.nodeType === 8 ? o.parentNode.insertBefore(t, r) : o.insertBefore(t, r) : (o.nodeType === 8 ? (r = o.parentNode, r.insertBefore(t, o)) : (r = o, r.appendChild(t)), o = o._reactRootContainer, o != null || r.onclick !== null || (r.onclick = mw));
else if (u !== 4 && (t = t.child, t !== null))
    for (R2(t, r, o), t = t.sibling; t !== null;)
        R2(t, r, o), t = t.sibling; }
function k2(t, r, o) { var u = t.tag; if (u === 5 || u === 6)
    t = t.stateNode, r ? o.insertBefore(t, r) : o.appendChild(t);
else if (u !== 4 && (t = t.child, t !== null))
    for (k2(t, r, o), t = t.sibling; t !== null;)
        k2(t, r, o), t = t.sibling; }
var qs = null, ul = !1;
function oh(t, r, o) { for (o = o.child; o !== null;)
    v3(t, r, o), o = o.sibling; }
function v3(t, r, o) { if (sc && typeof sc.onCommitFiberUnmount == "function")
    try {
        sc.onCommitFiberUnmount(eb, o);
    }
    catch { } switch (o.tag) {
    case 5: co || Mm(o, r);
    case 6:
        var u = qs, g = ul;
        qs = null, oh(t, r, o), qs = u, ul = g, qs !== null && (ul ? (t = qs, o = o.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(o) : t.removeChild(o)) : qs.removeChild(o.stateNode));
        break;
    case 18:
        qs !== null && (ul ? (t = qs, o = o.stateNode, t.nodeType === 8 ? aE(t.parentNode, o) : t.nodeType === 1 && aE(t, o), mv(t)) : aE(qs, o.stateNode));
        break;
    case 4:
        u = qs, g = ul, qs = o.stateNode.containerInfo, ul = !0, oh(t, r, o), qs = u, ul = g;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!co && (u = o.updateQueue, u !== null && (u = u.lastEffect, u !== null))) {
            g = u = u.next;
            do {
                var y = g, E = y.destroy;
                y = y.tag, E !== void 0 && (y & 2 || y & 4) && P2(o, r, E), g = g.next;
            } while (g !== u);
        }
        oh(t, r, o);
        break;
    case 1:
        if (!co && (Mm(o, r), u = o.stateNode, typeof u.componentWillUnmount == "function"))
            try {
                u.props = o.memoizedProps, u.state = o.memoizedState, u.componentWillUnmount();
            }
            catch (s) {
                ns(o, r, s);
            }
        oh(t, r, o);
        break;
    case 21:
        oh(t, r, o);
        break;
    case 22:
        o.mode & 1 ? (co = (u = co) || o.memoizedState !== null, oh(t, r, o), co = u) : oh(t, r, o);
        break;
    default: oh(t, r, o);
} }
function SD(t) { var r = t.updateQueue; if (r !== null) {
    t.updateQueue = null;
    var o = t.stateNode;
    o === null && (o = t.stateNode = new j$), r.forEach(function (u) { var g = K$.bind(null, t, u); o.has(u) || (o.add(u), u.then(g, g)); });
} }
function al(t, r) { var o = r.deletions; if (o !== null)
    for (var u = 0; u < o.length; u++) {
        var g = o[u];
        try {
            var y = t, E = r, s = E;
            e: for (; s !== null;) {
                switch (s.tag) {
                    case 5:
                        qs = s.stateNode, ul = !1;
                        break e;
                    case 3:
                        qs = s.stateNode.containerInfo, ul = !0;
                        break e;
                    case 4:
                        qs = s.stateNode.containerInfo, ul = !0;
                        break e;
                }
                s = s.return;
            }
            if (qs === null)
                throw Error(rr(160));
            v3(y, E, g), qs = null, ul = !1;
            var k = g.alternate;
            k !== null && (k.return = null), g.return = null;
        }
        catch (L) {
            ns(g, r, L);
        }
    } if (r.subtreeFlags & 12854)
    for (r = r.child; r !== null;)
        x3(r, t), r = r.sibling; }
function x3(t, r) { var o = t.alternate, u = t.flags; switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (al(r, t), Zl(t), u & 4) {
            try {
                ev(3, t, t.return), lb(3, t);
            }
            catch (J) {
                ns(t, t.return, J);
            }
            try {
                ev(5, t, t.return);
            }
            catch (J) {
                ns(t, t.return, J);
            }
        }
        break;
    case 1:
        al(r, t), Zl(t), u & 512 && o !== null && Mm(o, o.return);
        break;
    case 5:
        if (al(r, t), Zl(t), u & 512 && o !== null && Mm(o, o.return), t.flags & 32) {
            var g = t.stateNode;
            try {
                hv(g, "");
            }
            catch (J) {
                ns(t, t.return, J);
            }
        }
        if (u & 4 && (g = t.stateNode, g != null)) {
            var y = t.memoizedProps, E = o !== null ? o.memoizedProps : y, s = t.type, k = t.updateQueue;
            if (t.updateQueue = null, k !== null)
                try {
                    s === "input" && y.type === "radio" && y.name != null && UO(g, y), r2(s, E);
                    var L = r2(s, y);
                    for (E = 0; E < k.length; E += 2) {
                        var N = k[E], V = k[E + 1];
                        N === "style" ? WO(g, V) : N === "dangerouslySetInnerHTML" ? qO(g, V) : N === "children" ? hv(g, V) : MC(g, N, V, L);
                    }
                    switch (s) {
                        case "input":
                            YE(g, y);
                            break;
                        case "textarea":
                            $O(g, y);
                            break;
                        case "select":
                            var H = g._wrapperState.wasMultiple;
                            g._wrapperState.wasMultiple = !!y.multiple;
                            var ee = y.value;
                            ee != null ? Lm(g, !!y.multiple, ee, !1) : H !== !!y.multiple && (y.defaultValue != null ? Lm(g, !!y.multiple, y.defaultValue, !0) : Lm(g, !!y.multiple, y.multiple ? [] : "", !1));
                    }
                    g[xv] = y;
                }
                catch (J) {
                    ns(t, t.return, J);
                }
        }
        break;
    case 6:
        if (al(r, t), Zl(t), u & 4) {
            if (t.stateNode === null)
                throw Error(rr(162));
            g = t.stateNode, y = t.memoizedProps;
            try {
                g.nodeValue = y;
            }
            catch (J) {
                ns(t, t.return, J);
            }
        }
        break;
    case 3:
        if (al(r, t), Zl(t), u & 4 && o !== null && o.memoizedState.isDehydrated)
            try {
                mv(r.containerInfo);
            }
            catch (J) {
                ns(t, t.return, J);
            }
        break;
    case 4:
        al(r, t), Zl(t);
        break;
    case 13:
        al(r, t), Zl(t), g = t.child, g.flags & 8192 && (y = g.memoizedState !== null, g.stateNode.isHidden = y, !y || g.alternate !== null && g.alternate.memoizedState !== null || (cA = cs())), u & 4 && SD(t);
        break;
    case 22:
        if (N = o !== null && o.memoizedState !== null, t.mode & 1 ? (co = (L = co) || N, al(r, t), co = L) : al(r, t), Zl(t), u & 8192) {
            if (L = t.memoizedState !== null, (t.stateNode.isHidden = L) && !N && t.mode & 1)
                for (Dr = t, N = t.child; N !== null;) {
                    for (V = Dr = N; Dr !== null;) {
                        switch (H = Dr, ee = H.child, H.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                ev(4, H, H.return);
                                break;
                            case 1:
                                Mm(H, H.return);
                                var ce = H.stateNode;
                                if (typeof ce.componentWillUnmount == "function") {
                                    u = H, o = H.return;
                                    try {
                                        r = u, ce.props = r.memoizedProps, ce.state = r.memoizedState, ce.componentWillUnmount();
                                    }
                                    catch (J) {
                                        ns(u, o, J);
                                    }
                                }
                                break;
                            case 5:
                                Mm(H, H.return);
                                break;
                            case 22: if (H.memoizedState !== null) {
                                CD(V);
                                continue;
                            }
                        }
                        ee !== null ? (ee.return = H, Dr = ee) : CD(V);
                    }
                    N = N.sibling;
                }
            e: for (N = null, V = t;;) {
                if (V.tag === 5) {
                    if (N === null) {
                        N = V;
                        try {
                            g = V.stateNode, L ? (y = g.style, typeof y.setProperty == "function" ? y.setProperty("display", "none", "important") : y.display = "none") : (s = V.stateNode, k = V.memoizedProps.style, E = k != null && k.hasOwnProperty("display") ? k.display : null, s.style.display = HO("display", E));
                        }
                        catch (J) {
                            ns(t, t.return, J);
                        }
                    }
                }
                else if (V.tag === 6) {
                    if (N === null)
                        try {
                            V.stateNode.nodeValue = L ? "" : V.memoizedProps;
                        }
                        catch (J) {
                            ns(t, t.return, J);
                        }
                }
                else if ((V.tag !== 22 && V.tag !== 23 || V.memoizedState === null || V === t) && V.child !== null) {
                    V.child.return = V, V = V.child;
                    continue;
                }
                if (V === t)
                    break e;
                for (; V.sibling === null;) {
                    if (V.return === null || V.return === t)
                        break e;
                    N === V && (N = null), V = V.return;
                }
                N === V && (N = null), V.sibling.return = V.return, V = V.sibling;
            }
        }
        break;
    case 19:
        al(r, t), Zl(t), u & 4 && SD(t);
        break;
    case 21: break;
    default: al(r, t), Zl(t);
} }
function Zl(t) { var r = t.flags; if (r & 2) {
    try {
        e: {
            for (var o = t.return; o !== null;) {
                if (y3(o)) {
                    var u = o;
                    break e;
                }
                o = o.return;
            }
            throw Error(rr(160));
        }
        switch (u.tag) {
            case 5:
                var g = u.stateNode;
                u.flags & 32 && (hv(g, ""), u.flags &= -33);
                var y = TD(t);
                k2(t, y, g);
                break;
            case 3:
            case 4:
                var E = u.stateNode.containerInfo, s = TD(t);
                R2(t, s, E);
                break;
            default: throw Error(rr(161));
        }
    }
    catch (k) {
        ns(t, t.return, k);
    }
    t.flags &= -3;
} r & 4096 && (t.flags &= -4097); }
function U$(t, r, o) { Dr = t, w3(t); }
function w3(t, r, o) { for (var u = (t.mode & 1) !== 0; Dr !== null;) {
    var g = Dr, y = g.child;
    if (g.tag === 22 && u) {
        var E = g.memoizedState !== null || E1;
        if (!E) {
            var s = g.alternate, k = s !== null && s.memoizedState !== null || co;
            s = E1;
            var L = co;
            if (E1 = E, (co = k) && !L)
                for (Dr = g; Dr !== null;)
                    E = Dr, k = E.child, E.tag === 22 && E.memoizedState !== null ? AD(g) : k !== null ? (k.return = E, Dr = k) : AD(g);
            for (; y !== null;)
                Dr = y, w3(y), y = y.sibling;
            Dr = g, E1 = s, co = L;
        }
        ED(t);
    }
    else
        g.subtreeFlags & 8772 && y !== null ? (y.return = g, Dr = y) : ED(t);
} }
function ED(t) { for (; Dr !== null;) {
    var r = Dr;
    if (r.flags & 8772) {
        var o = r.alternate;
        try {
            if (r.flags & 8772)
                switch (r.tag) {
                    case 0:
                    case 11:
                    case 15:
                        co || lb(5, r);
                        break;
                    case 1:
                        var u = r.stateNode;
                        if (r.flags & 4 && !co)
                            if (o === null)
                                u.componentDidMount();
                            else {
                                var g = r.elementType === r.type ? o.memoizedProps : ll(r.type, o.memoizedProps);
                                u.componentDidUpdate(g, o.memoizedState, u.__reactInternalSnapshotBeforeUpdate);
                            }
                        var y = r.updateQueue;
                        y !== null && cD(r, y, u);
                        break;
                    case 3:
                        var E = r.updateQueue;
                        if (E !== null) {
                            if (o = null, r.child !== null)
                                switch (r.child.tag) {
                                    case 5:
                                        o = r.child.stateNode;
                                        break;
                                    case 1: o = r.child.stateNode;
                                }
                            cD(r, E, o);
                        }
                        break;
                    case 5:
                        var s = r.stateNode;
                        if (o === null && r.flags & 4) {
                            o = s;
                            var k = r.memoizedProps;
                            switch (r.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    k.autoFocus && o.focus();
                                    break;
                                case "img": k.src && (o.src = k.src);
                            }
                        }
                        break;
                    case 6: break;
                    case 4: break;
                    case 12: break;
                    case 13:
                        if (r.memoizedState === null) {
                            var L = r.alternate;
                            if (L !== null) {
                                var N = L.memoizedState;
                                if (N !== null) {
                                    var V = N.dehydrated;
                                    V !== null && mv(V);
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25: break;
                    default: throw Error(rr(163));
                }
            co || r.flags & 512 && M2(r);
        }
        catch (H) {
            ns(r, r.return, H);
        }
    }
    if (r === t) {
        Dr = null;
        break;
    }
    if (o = r.sibling, o !== null) {
        o.return = r.return, Dr = o;
        break;
    }
    Dr = r.return;
} }
function CD(t) { for (; Dr !== null;) {
    var r = Dr;
    if (r === t) {
        Dr = null;
        break;
    }
    var o = r.sibling;
    if (o !== null) {
        o.return = r.return, Dr = o;
        break;
    }
    Dr = r.return;
} }
function AD(t) { for (; Dr !== null;) {
    var r = Dr;
    try {
        switch (r.tag) {
            case 0:
            case 11:
            case 15:
                var o = r.return;
                try {
                    lb(4, r);
                }
                catch (k) {
                    ns(r, o, k);
                }
                break;
            case 1:
                var u = r.stateNode;
                if (typeof u.componentDidMount == "function") {
                    var g = r.return;
                    try {
                        u.componentDidMount();
                    }
                    catch (k) {
                        ns(r, g, k);
                    }
                }
                var y = r.return;
                try {
                    M2(r);
                }
                catch (k) {
                    ns(r, y, k);
                }
                break;
            case 5:
                var E = r.return;
                try {
                    M2(r);
                }
                catch (k) {
                    ns(r, E, k);
                }
        }
    }
    catch (k) {
        ns(r, r.return, k);
    }
    if (r === t) {
        Dr = null;
        break;
    }
    var s = r.sibling;
    if (s !== null) {
        s.return = r.return, Dr = s;
        break;
    }
    Dr = r.return;
} }
var $$ = Math.ceil, Cw = du.ReactCurrentDispatcher, aA = du.ReactCurrentOwner, Fa = du.ReactCurrentBatchConfig, fi = 0, Ns = null, gs = null, Ws = 0, ha = 0, Rm = td(0), Cs = 0, Cv = null, Pf = 0, cb = 0, lA = 0, tv = null, $o = null, cA = 0, hg = 1 / 0, Kc = null, Aw = !1, D2 = null, Nh = null, C1 = !1, Rh = null, Iw = 0, rv = 0, L2 = null, X1 = -1, K1 = 0;
function bo() { return fi & 6 ? cs() : X1 !== -1 ? X1 : X1 = cs(); }
function Bh(t) { return t.mode & 1 ? fi & 2 && Ws !== 0 ? Ws & -Ws : C$.transition !== null ? (K1 === 0 && (K1 = sz()), K1) : (t = Ti, t !== 0 || (t = window.event, t = t === void 0 ? 16 : dz(t.type)), t) : 1; }
function yl(t, r, o, u) { if (50 < rv)
    throw rv = 0, L2 = null, Error(rr(185)); Qv(t, o, u), (!(fi & 2) || t !== Ns) && (t === Ns && (!(fi & 2) && (cb |= o), Cs === 4 && yh(t, Ws)), Zo(t, u), o === 1 && fi === 0 && !(r.mode & 1) && (hg = cs() + 500, sb && rd())); }
function Zo(t, r) { var o = t.callbackNode; C6(t, r); var u = hw(t, t === Ns ? Ws : 0); if (u === 0)
    o !== null && zk(o), t.callbackNode = null, t.callbackPriority = 0;
else if (r = u & -u, t.callbackPriority !== r) {
    if (o != null && zk(o), r === 1)
        t.tag === 0 ? E$(ID.bind(null, t)) : Rz(ID.bind(null, t)), w$(function () { !(fi & 6) && rd(); }), o = null;
    else {
        switch (oz(u)) {
            case 1:
                o = OC;
                break;
            case 4:
                o = nz;
                break;
            case 16:
                o = uw;
                break;
            case 536870912:
                o = iz;
                break;
            default: o = uw;
        }
        o = P3(o, b3.bind(null, t));
    }
    t.callbackPriority = r, t.callbackNode = o;
} }
function b3(t, r) { if (X1 = -1, K1 = 0, fi & 6)
    throw Error(rr(327)); var o = t.callbackNode; if (Bm() && t.callbackNode !== o)
    return null; var u = hw(t, t === Ns ? Ws : 0); if (u === 0)
    return null; if (u & 30 || u & t.expiredLanes || r)
    r = Pw(t, u);
else {
    r = u;
    var g = fi;
    fi |= 2;
    var y = S3();
    (Ns !== t || Ws !== r) && (Kc = null, hg = cs() + 500, bf(t, r));
    do
        try {
            H$();
            break;
        }
        catch (s) {
            T3(t, s);
        }
    while (!0);
    ZC(), Cw.current = y, fi = g, gs !== null ? r = 0 : (Ns = null, Ws = 0, r = Cs);
} if (r !== 0) {
    if (r === 2 && (g = a2(t), g !== 0 && (u = g, r = O2(t, g))), r === 1)
        throw o = Cv, bf(t, 0), yh(t, u), Zo(t, cs()), o;
    if (r === 6)
        yh(t, u);
    else {
        if (g = t.current.alternate, !(u & 30) && !G$(g) && (r = Pw(t, u), r === 2 && (y = a2(t), y !== 0 && (u = y, r = O2(t, y))), r === 1))
            throw o = Cv, bf(t, 0), yh(t, u), Zo(t, cs()), o;
        switch (t.finishedWork = g, t.finishedLanes = u, r) {
            case 0:
            case 1: throw Error(rr(345));
            case 2:
                af(t, $o, Kc);
                break;
            case 3:
                if (yh(t, u), (u & 130023424) === u && (r = cA + 500 - cs(), 10 < r)) {
                    if (hw(t, 0) !== 0)
                        break;
                    if (g = t.suspendedLanes, (g & u) !== u) {
                        bo(), t.pingedLanes |= t.suspendedLanes & g;
                        break;
                    }
                    t.timeoutHandle = m2(af.bind(null, t, $o, Kc), r);
                    break;
                }
                af(t, $o, Kc);
                break;
            case 4:
                if (yh(t, u), (u & 4194240) === u)
                    break;
                for (r = t.eventTimes, g = -1; 0 < u;) {
                    var E = 31 - _l(u);
                    y = 1 << E, E = r[E], E > g && (g = E), u &= ~y;
                }
                if (u = g, u = cs() - u, u = (120 > u ? 120 : 480 > u ? 480 : 1080 > u ? 1080 : 1920 > u ? 1920 : 3e3 > u ? 3e3 : 4320 > u ? 4320 : 1960 * $$(u / 1960)) - u, 10 < u) {
                    t.timeoutHandle = m2(af.bind(null, t, $o, Kc), u);
                    break;
                }
                af(t, $o, Kc);
                break;
            case 5:
                af(t, $o, Kc);
                break;
            default: throw Error(rr(329));
        }
    }
} return Zo(t, cs()), t.callbackNode === o ? b3.bind(null, t) : null; }
function O2(t, r) { var o = tv; return t.current.memoizedState.isDehydrated && (bf(t, r).flags |= 256), t = Pw(t, r), t !== 2 && (r = $o, $o = o, r !== null && z2(r)), t; }
function z2(t) { $o === null ? $o = t : $o.push.apply($o, t); }
function G$(t) { for (var r = t;;) {
    if (r.flags & 16384) {
        var o = r.updateQueue;
        if (o !== null && (o = o.stores, o !== null))
            for (var u = 0; u < o.length; u++) {
                var g = o[u], y = g.getSnapshot;
                g = g.value;
                try {
                    if (!xl(y(), g))
                        return !1;
                }
                catch {
                    return !1;
                }
            }
    }
    if (o = r.child, r.subtreeFlags & 16384 && o !== null)
        o.return = r, r = o;
    else {
        if (r === t)
            break;
        for (; r.sibling === null;) {
            if (r.return === null || r.return === t)
                return !0;
            r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
    }
} return !0; }
function yh(t, r) { for (r &= ~lA, r &= ~cb, t.suspendedLanes |= r, t.pingedLanes &= ~r, t = t.expirationTimes; 0 < r;) {
    var o = 31 - _l(r), u = 1 << o;
    t[o] = -1, r &= ~u;
} }
function ID(t) { if (fi & 6)
    throw Error(rr(327)); Bm(); var r = hw(t, 0); if (!(r & 1))
    return Zo(t, cs()), null; var o = Pw(t, r); if (t.tag !== 0 && o === 2) {
    var u = a2(t);
    u !== 0 && (r = u, o = O2(t, u));
} if (o === 1)
    throw o = Cv, bf(t, 0), yh(t, r), Zo(t, cs()), o; if (o === 6)
    throw Error(rr(345)); return t.finishedWork = t.current.alternate, t.finishedLanes = r, af(t, $o, Kc), Zo(t, cs()), null; }
function uA(t, r) { var o = fi; fi |= 1; try {
    return t(r);
}
finally {
    fi = o, fi === 0 && (hg = cs() + 500, sb && rd());
} }
function Mf(t) { Rh !== null && Rh.tag === 0 && !(fi & 6) && Bm(); var r = fi; fi |= 1; var o = Fa.transition, u = Ti; try {
    if (Fa.transition = null, Ti = 1, t)
        return t();
}
finally {
    Ti = u, Fa.transition = o, fi = r, !(fi & 6) && rd();
} }
function hA() { ha = Rm.current, Bi(Rm); }
function bf(t, r) { t.finishedWork = null, t.finishedLanes = 0; var o = t.timeoutHandle; if (o !== -1 && (t.timeoutHandle = -1, x$(o)), gs !== null)
    for (o = gs.return; o !== null;) {
        var u = o;
        switch (qC(u), u.tag) {
            case 1:
                u = u.type.childContextTypes, u != null && gw();
                break;
            case 3:
                cg(), Bi(Ho), Bi(ho), eA();
                break;
            case 5:
                JC(u);
                break;
            case 4:
                cg();
                break;
            case 13:
                Bi(Ki);
                break;
            case 19:
                Bi(Ki);
                break;
            case 10:
                XC(u.type._context);
                break;
            case 22:
            case 23: hA();
        }
        o = o.return;
    } if (Ns = t, gs = t = jh(t.current, null), Ws = ha = r, Cs = 0, Cv = null, lA = cb = Pf = 0, $o = tv = null, df !== null) {
    for (r = 0; r < df.length; r++)
        if (o = df[r], u = o.interleaved, u !== null) {
            o.interleaved = null;
            var g = u.next, y = o.pending;
            if (y !== null) {
                var E = y.next;
                y.next = g, u.next = E;
            }
            o.pending = u;
        }
    df = null;
} return t; }
function T3(t, r) { do {
    var o = gs;
    try {
        if (ZC(), H1.current = Ew, Sw) {
            for (var u = Yi.memoizedState; u !== null;) {
                var g = u.queue;
                g !== null && (g.pending = null), u = u.next;
            }
            Sw = !1;
        }
        if (If = 0, Fs = Ts = Yi = null, Jy = !1, Tv = 0, aA.current = null, o === null || o.return === null) {
            Cs = 1, Cv = r, gs = null;
            break;
        }
        e: {
            var y = t, E = o.return, s = o, k = r;
            if (r = Ws, s.flags |= 32768, k !== null && typeof k == "object" && typeof k.then == "function") {
                var L = k, N = s, V = N.tag;
                if (!(N.mode & 1) && (V === 0 || V === 11 || V === 15)) {
                    var H = N.alternate;
                    H ? (N.updateQueue = H.updateQueue, N.memoizedState = H.memoizedState, N.lanes = H.lanes) : (N.updateQueue = null, N.memoizedState = null);
                }
                var ee = mD(E);
                if (ee !== null) {
                    ee.flags &= -257, gD(ee, E, s, y, r), ee.mode & 1 && pD(y, L, r), r = ee, k = L;
                    var ce = r.updateQueue;
                    if (ce === null) {
                        var J = new Set;
                        J.add(k), r.updateQueue = J;
                    }
                    else
                        ce.add(k);
                    break e;
                }
                else {
                    if (!(r & 1)) {
                        pD(y, L, r), dA();
                        break e;
                    }
                    k = Error(rr(426));
                }
            }
            else if (Ui && s.mode & 1) {
                var ye = mD(E);
                if (ye !== null) {
                    !(ye.flags & 65536) && (ye.flags |= 256), gD(ye, E, s, y, r), HC(ug(k, s));
                    break e;
                }
            }
            y = k = ug(k, s), Cs !== 4 && (Cs = 2), tv === null ? tv = [y] : tv.push(y), y = E;
            do {
                switch (y.tag) {
                    case 3:
                        y.flags |= 65536, r &= -r, y.lanes |= r;
                        var ie = o3(y, k, r);
                        lD(y, ie);
                        break e;
                    case 1:
                        s = k;
                        var Q = y.type, ue = y.stateNode;
                        if (!(y.flags & 128) && (typeof Q.getDerivedStateFromError == "function" || ue !== null && typeof ue.componentDidCatch == "function" && (Nh === null || !Nh.has(ue)))) {
                            y.flags |= 65536, r &= -r, y.lanes |= r;
                            var be = a3(y, s, r);
                            lD(y, be);
                            break e;
                        }
                }
                y = y.return;
            } while (y !== null);
        }
        C3(o);
    }
    catch (Ie) {
        r = Ie, gs === o && o !== null && (gs = o = o.return);
        continue;
    }
    break;
} while (!0); }
function S3() { var t = Cw.current; return Cw.current = Ew, t === null ? Ew : t; }
function dA() { (Cs === 0 || Cs === 3 || Cs === 2) && (Cs = 4), Ns === null || !(Pf & 268435455) && !(cb & 268435455) || yh(Ns, Ws); }
function Pw(t, r) { var o = fi; fi |= 2; var u = S3(); (Ns !== t || Ws !== r) && (Kc = null, bf(t, r)); do
    try {
        q$();
        break;
    }
    catch (g) {
        T3(t, g);
    }
while (!0); if (ZC(), fi = o, Cw.current = u, gs !== null)
    throw Error(rr(261)); return Ns = null, Ws = 0, Cs; }
function q$() { for (; gs !== null;)
    E3(gs); }
function H$() { for (; gs !== null && !_6();)
    E3(gs); }
function E3(t) { var r = I3(t.alternate, t, ha); t.memoizedProps = t.pendingProps, r === null ? C3(t) : gs = r, aA.current = null; }
function C3(t) { var r = t; do {
    var o = r.alternate;
    if (t = r.return, r.flags & 32768) {
        if (o = B$(o, r), o !== null) {
            o.flags &= 32767, gs = o;
            return;
        }
        if (t !== null)
            t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null;
        else {
            Cs = 6, gs = null;
            return;
        }
    }
    else if (o = N$(o, r, ha), o !== null) {
        gs = o;
        return;
    }
    if (r = r.sibling, r !== null) {
        gs = r;
        return;
    }
    gs = r = t;
} while (r !== null); Cs === 0 && (Cs = 5); }
function af(t, r, o) { var u = Ti, g = Fa.transition; try {
    Fa.transition = null, Ti = 1, W$(t, r, o, u);
}
finally {
    Fa.transition = g, Ti = u;
} return null; }
function W$(t, r, o, u) { do
    Bm();
while (Rh !== null); if (fi & 6)
    throw Error(rr(327)); o = t.finishedWork; var g = t.finishedLanes; if (o === null)
    return null; if (t.finishedWork = null, t.finishedLanes = 0, o === t.current)
    throw Error(rr(177)); t.callbackNode = null, t.callbackPriority = 0; var y = o.lanes | o.childLanes; if (A6(t, y), t === Ns && (gs = Ns = null, Ws = 0), !(o.subtreeFlags & 2064) && !(o.flags & 2064) || C1 || (C1 = !0, P3(uw, function () { return Bm(), null; })), y = (o.flags & 15990) !== 0, o.subtreeFlags & 15990 || y) {
    y = Fa.transition, Fa.transition = null;
    var E = Ti;
    Ti = 1;
    var s = fi;
    fi |= 4, aA.current = null, V$(t, o), x3(o, t), f$(f2), dw = !!d2, f2 = d2 = null, t.current = o, U$(o), y6(), fi = s, Ti = E, Fa.transition = y;
}
else
    t.current = o; if (C1 && (C1 = !1, Rh = t, Iw = g), y = t.pendingLanes, y === 0 && (Nh = null), w6(o.stateNode), Zo(t, cs()), r !== null)
    for (u = t.onRecoverableError, o = 0; o < r.length; o++)
        g = r[o], u(g.value, { componentStack: g.stack, digest: g.digest }); if (Aw)
    throw Aw = !1, t = D2, D2 = null, t; return Iw & 1 && t.tag !== 0 && Bm(), y = t.pendingLanes, y & 1 ? t === L2 ? rv++ : (rv = 0, L2 = t) : rv = 0, rd(), null; }
function Bm() { if (Rh !== null) {
    var t = oz(Iw), r = Fa.transition, o = Ti;
    try {
        if (Fa.transition = null, Ti = 16 > t ? 16 : t, Rh === null)
            var u = !1;
        else {
            if (t = Rh, Rh = null, Iw = 0, fi & 6)
                throw Error(rr(331));
            var g = fi;
            for (fi |= 4, Dr = t.current; Dr !== null;) {
                var y = Dr, E = y.child;
                if (Dr.flags & 16) {
                    var s = y.deletions;
                    if (s !== null) {
                        for (var k = 0; k < s.length; k++) {
                            var L = s[k];
                            for (Dr = L; Dr !== null;) {
                                var N = Dr;
                                switch (N.tag) {
                                    case 0:
                                    case 11:
                                    case 15: ev(8, N, y);
                                }
                                var V = N.child;
                                if (V !== null)
                                    V.return = N, Dr = V;
                                else
                                    for (; Dr !== null;) {
                                        N = Dr;
                                        var H = N.sibling, ee = N.return;
                                        if (_3(N), N === L) {
                                            Dr = null;
                                            break;
                                        }
                                        if (H !== null) {
                                            H.return = ee, Dr = H;
                                            break;
                                        }
                                        Dr = ee;
                                    }
                            }
                        }
                        var ce = y.alternate;
                        if (ce !== null) {
                            var J = ce.child;
                            if (J !== null) {
                                ce.child = null;
                                do {
                                    var ye = J.sibling;
                                    J.sibling = null, J = ye;
                                } while (J !== null);
                            }
                        }
                        Dr = y;
                    }
                }
                if (y.subtreeFlags & 2064 && E !== null)
                    E.return = y, Dr = E;
                else
                    e: for (; Dr !== null;) {
                        if (y = Dr, y.flags & 2048)
                            switch (y.tag) {
                                case 0:
                                case 11:
                                case 15: ev(9, y, y.return);
                            }
                        var ie = y.sibling;
                        if (ie !== null) {
                            ie.return = y.return, Dr = ie;
                            break e;
                        }
                        Dr = y.return;
                    }
            }
            var Q = t.current;
            for (Dr = Q; Dr !== null;) {
                E = Dr;
                var ue = E.child;
                if (E.subtreeFlags & 2064 && ue !== null)
                    ue.return = E, Dr = ue;
                else
                    e: for (E = Q; Dr !== null;) {
                        if (s = Dr, s.flags & 2048)
                            try {
                                switch (s.tag) {
                                    case 0:
                                    case 11:
                                    case 15: lb(9, s);
                                }
                            }
                            catch (Ie) {
                                ns(s, s.return, Ie);
                            }
                        if (s === E) {
                            Dr = null;
                            break e;
                        }
                        var be = s.sibling;
                        if (be !== null) {
                            be.return = s.return, Dr = be;
                            break e;
                        }
                        Dr = s.return;
                    }
            }
            if (fi = g, rd(), sc && typeof sc.onPostCommitFiberRoot == "function")
                try {
                    sc.onPostCommitFiberRoot(eb, t);
                }
                catch { }
            u = !0;
        }
        return u;
    }
    finally {
        Ti = o, Fa.transition = r;
    }
} return !1; }
function PD(t, r, o) { r = ug(o, r), r = o3(t, r, 1), t = Fh(t, r, 1), r = bo(), t !== null && (Qv(t, 1, r), Zo(t, r)); }
function ns(t, r, o) { if (t.tag === 3)
    PD(t, t, o);
else
    for (; r !== null;) {
        if (r.tag === 3) {
            PD(r, t, o);
            break;
        }
        else if (r.tag === 1) {
            var u = r.stateNode;
            if (typeof r.type.getDerivedStateFromError == "function" || typeof u.componentDidCatch == "function" && (Nh === null || !Nh.has(u))) {
                t = ug(o, t), t = a3(r, t, 1), r = Fh(r, t, 1), t = bo(), r !== null && (Qv(r, 1, t), Zo(r, t));
                break;
            }
        }
        r = r.return;
    } }
function Z$(t, r, o) { var u = t.pingCache; u !== null && u.delete(r), r = bo(), t.pingedLanes |= t.suspendedLanes & o, Ns === t && (Ws & o) === o && (Cs === 4 || Cs === 3 && (Ws & 130023424) === Ws && 500 > cs() - cA ? bf(t, 0) : lA |= o), Zo(t, r); }
function A3(t, r) { r === 0 && (t.mode & 1 ? (r = g1, g1 <<= 1, !(g1 & 130023424) && (g1 = 4194304)) : r = 1); var o = bo(); t = au(t, r), t !== null && (Qv(t, r, o), Zo(t, o)); }
function X$(t) { var r = t.memoizedState, o = 0; r !== null && (o = r.retryLane), A3(t, o); }
function K$(t, r) { var o = 0; switch (t.tag) {
    case 13:
        var u = t.stateNode, g = t.memoizedState;
        g !== null && (o = g.retryLane);
        break;
    case 19:
        u = t.stateNode;
        break;
    default: throw Error(rr(314));
} u !== null && u.delete(r), A3(t, o); }
var I3;
I3 = function (t, r, o) { if (t !== null)
    if (t.memoizedProps !== r.pendingProps || Ho.current)
        qo = !0;
    else {
        if (!(t.lanes & o) && !(r.flags & 128))
            return qo = !1, F$(t, r, o);
        qo = !!(t.flags & 131072);
    }
else
    qo = !1, Ui && r.flags & 1048576 && kz(r, vw, r.index); switch (r.lanes = 0, r.tag) {
    case 2:
        var u = r.type;
        Z1(t, r), t = r.pendingProps;
        var g = og(r, ho.current);
        Nm(r, o), g = rA(null, r, u, t, g, o);
        var y = nA();
        return r.flags |= 1, typeof g == "object" && g !== null && typeof g.render == "function" && g.$$typeof === void 0 ? (r.tag = 1, r.memoizedState = null, r.updateQueue = null, Wo(u) ? (y = !0, _w(r)) : y = !1, r.memoizedState = g.state !== null && g.state !== void 0 ? g.state : null, YC(r), g.updater = ab, r.stateNode = g, g._reactInternals = r, b2(r, u, t, o), r = E2(null, r, u, !0, y, o)) : (r.tag = 0, Ui && y && GC(r), xo(null, r, g, o), r = r.child), r;
    case 16:
        u = r.elementType;
        e: {
            switch (Z1(t, r), t = r.pendingProps, g = u._init, u = g(u._payload), r.type = u, g = r.tag = Q$(u), t = ll(u, t), g) {
                case 0:
                    r = S2(null, r, u, t, o);
                    break e;
                case 1:
                    r = vD(null, r, u, t, o);
                    break e;
                case 11:
                    r = _D(null, r, u, t, o);
                    break e;
                case 14:
                    r = yD(null, r, u, ll(u.type, t), o);
                    break e;
            }
            throw Error(rr(306, u, ""));
        }
        return r;
    case 0: return u = r.type, g = r.pendingProps, g = r.elementType === u ? g : ll(u, g), S2(t, r, u, g, o);
    case 1: return u = r.type, g = r.pendingProps, g = r.elementType === u ? g : ll(u, g), vD(t, r, u, g, o);
    case 3:
        e: {
            if (h3(r), t === null)
                throw Error(rr(387));
            u = r.pendingProps, y = r.memoizedState, g = y.element, Nz(t, r), bw(r, u, null, o);
            var E = r.memoizedState;
            if (u = E.element, y.isDehydrated)
                if (y = { element: u, isDehydrated: !1, cache: E.cache, pendingSuspenseBoundaries: E.pendingSuspenseBoundaries, transitions: E.transitions }, r.updateQueue.baseState = y, r.memoizedState = y, r.flags & 256) {
                    g = ug(Error(rr(423)), r), r = xD(t, r, u, o, g);
                    break e;
                }
                else if (u !== g) {
                    g = ug(Error(rr(424)), r), r = xD(t, r, u, o, g);
                    break e;
                }
                else
                    for (fa = zh(r.stateNode.containerInfo.firstChild), pa = r, Ui = !0, dl = null, o = zz(r, null, u, o), r.child = o; o;)
                        o.flags = o.flags & -3 | 4096, o = o.sibling;
            else {
                if (ag(), u === g) {
                    r = lu(t, r, o);
                    break e;
                }
                xo(t, r, u, o);
            }
            r = r.child;
        }
        return r;
    case 5: return Bz(r), t === null && v2(r), u = r.type, g = r.pendingProps, y = t !== null ? t.memoizedProps : null, E = g.children, p2(u, g) ? E = null : y !== null && p2(u, y) && (r.flags |= 32), u3(t, r), xo(t, r, E, o), r.child;
    case 6: return t === null && v2(r), null;
    case 13: return d3(t, r, o);
    case 4: return QC(r, r.stateNode.containerInfo), u = r.pendingProps, t === null ? r.child = lg(r, null, u, o) : xo(t, r, u, o), r.child;
    case 11: return u = r.type, g = r.pendingProps, g = r.elementType === u ? g : ll(u, g), _D(t, r, u, g, o);
    case 7: return xo(t, r, r.pendingProps, o), r.child;
    case 8: return xo(t, r, r.pendingProps.children, o), r.child;
    case 12: return xo(t, r, r.pendingProps.children, o), r.child;
    case 10:
        e: {
            if (u = r.type._context, g = r.pendingProps, y = r.memoizedProps, E = g.value, Oi(xw, u._currentValue), u._currentValue = E, y !== null)
                if (xl(y.value, E)) {
                    if (y.children === g.children && !Ho.current) {
                        r = lu(t, r, o);
                        break e;
                    }
                }
                else
                    for (y = r.child, y !== null && (y.return = r); y !== null;) {
                        var s = y.dependencies;
                        if (s !== null) {
                            E = y.child;
                            for (var k = s.firstContext; k !== null;) {
                                if (k.context === u) {
                                    if (y.tag === 1) {
                                        k = nu(-1, o & -o), k.tag = 2;
                                        var L = y.updateQueue;
                                        if (L !== null) {
                                            L = L.shared;
                                            var N = L.pending;
                                            N === null ? k.next = k : (k.next = N.next, N.next = k), L.pending = k;
                                        }
                                    }
                                    y.lanes |= o, k = y.alternate, k !== null && (k.lanes |= o), x2(y.return, o, r), s.lanes |= o;
                                    break;
                                }
                                k = k.next;
                            }
                        }
                        else if (y.tag === 10)
                            E = y.type === r.type ? null : y.child;
                        else if (y.tag === 18) {
                            if (E = y.return, E === null)
                                throw Error(rr(341));
                            E.lanes |= o, s = E.alternate, s !== null && (s.lanes |= o), x2(E, o, r), E = y.sibling;
                        }
                        else
                            E = y.child;
                        if (E !== null)
                            E.return = y;
                        else
                            for (E = y; E !== null;) {
                                if (E === r) {
                                    E = null;
                                    break;
                                }
                                if (y = E.sibling, y !== null) {
                                    y.return = E.return, E = y;
                                    break;
                                }
                                E = E.return;
                            }
                        y = E;
                    }
            xo(t, r, g.children, o), r = r.child;
        }
        return r;
    case 9: return g = r.type, u = r.pendingProps.children, Nm(r, o), g = Ba(g), u = u(g), r.flags |= 1, xo(t, r, u, o), r.child;
    case 14: return u = r.type, g = ll(u, r.pendingProps), g = ll(u.type, g), yD(t, r, u, g, o);
    case 15: return l3(t, r, r.type, r.pendingProps, o);
    case 17: return u = r.type, g = r.pendingProps, g = r.elementType === u ? g : ll(u, g), Z1(t, r), r.tag = 1, Wo(u) ? (t = !0, _w(r)) : t = !1, Nm(r, o), s3(r, u, g), b2(r, u, g, o), E2(null, r, u, !0, t, o);
    case 19: return f3(t, r, o);
    case 22: return c3(t, r, o);
} throw Error(rr(156, r.tag)); };
function P3(t, r) { return rz(t, r); }
function Y$(t, r, o, u) { this.tag = t, this.key = o, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = r, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = u, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null; }
function Oa(t, r, o, u) { return new Y$(t, r, o, u); }
function fA(t) { return t = t.prototype, !(!t || !t.isReactComponent); }
function Q$(t) { if (typeof t == "function")
    return fA(t) ? 1 : 0; if (t != null) {
    if (t = t.$$typeof, t === kC)
        return 11;
    if (t === DC)
        return 14;
} return 2; }
function jh(t, r) { var o = t.alternate; return o === null ? (o = Oa(t.tag, r, t.key, t.mode), o.elementType = t.elementType, o.type = t.type, o.stateNode = t.stateNode, o.alternate = t, t.alternate = o) : (o.pendingProps = r, o.type = t.type, o.flags = 0, o.subtreeFlags = 0, o.deletions = null), o.flags = t.flags & 14680064, o.childLanes = t.childLanes, o.lanes = t.lanes, o.child = t.child, o.memoizedProps = t.memoizedProps, o.memoizedState = t.memoizedState, o.updateQueue = t.updateQueue, r = t.dependencies, o.dependencies = r === null ? null : { lanes: r.lanes, firstContext: r.firstContext }, o.sibling = t.sibling, o.index = t.index, o.ref = t.ref, o; }
function Y1(t, r, o, u, g, y) { var E = 2; if (u = t, typeof t == "function")
    fA(t) && (E = 1);
else if (typeof t == "string")
    E = 5;
else
    e: switch (t) {
        case wm: return Tf(o.children, g, y, r);
        case RC:
            E = 8, g |= 8;
            break;
        case HE: return t = Oa(12, o, r, g | 2), t.elementType = HE, t.lanes = y, t;
        case WE: return t = Oa(13, o, r, g), t.elementType = WE, t.lanes = y, t;
        case ZE: return t = Oa(19, o, r, g), t.elementType = ZE, t.lanes = y, t;
        case BO: return ub(o, g, y, r);
        default:
            if (typeof t == "object" && t !== null)
                switch (t.$$typeof) {
                    case FO:
                        E = 10;
                        break e;
                    case NO:
                        E = 9;
                        break e;
                    case kC:
                        E = 11;
                        break e;
                    case DC:
                        E = 14;
                        break e;
                    case ph:
                        E = 16, u = null;
                        break e;
                }
            throw Error(rr(130, t == null ? t : typeof t, ""));
    } return r = Oa(E, o, r, g), r.elementType = t, r.type = u, r.lanes = y, r; }
function Tf(t, r, o, u) { return t = Oa(7, t, u, r), t.lanes = o, t; }
function ub(t, r, o, u) { return t = Oa(22, t, u, r), t.elementType = BO, t.lanes = o, t.stateNode = { isHidden: !1 }, t; }
function mE(t, r, o) { return t = Oa(6, t, null, r), t.lanes = o, t; }
function gE(t, r, o) { return r = Oa(4, t.children !== null ? t.children : [], t.key, r), r.lanes = o, r.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }, r; }
function J$(t, r, o, u, g) { this.tag = r, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = KS(0), this.expirationTimes = KS(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = KS(0), this.identifierPrefix = u, this.onRecoverableError = g, this.mutableSourceEagerHydrationData = null; }
function pA(t, r, o, u, g, y, E, s, k) { return t = new J$(t, r, o, s, k), r === 1 ? (r = 1, y === !0 && (r |= 8)) : r = 0, y = Oa(3, null, null, r), t.current = y, y.stateNode = t, y.memoizedState = { element: u, isDehydrated: o, cache: null, transitions: null, pendingSuspenseBoundaries: null }, YC(y), t; }
function e8(t, r, o) { var u = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: xm, key: u == null ? null : "" + u, children: t, containerInfo: r, implementation: o }; }
function M3(t) { if (!t)
    return qh; t = t._reactInternals; e: {
    if (jf(t) !== t || t.tag !== 1)
        throw Error(rr(170));
    var r = t;
    do {
        switch (r.tag) {
            case 3:
                r = r.stateNode.context;
                break e;
            case 1: if (Wo(r.type)) {
                r = r.stateNode.__reactInternalMemoizedMergedChildContext;
                break e;
            }
        }
        r = r.return;
    } while (r !== null);
    throw Error(rr(171));
} if (t.tag === 1) {
    var o = t.type;
    if (Wo(o))
        return Mz(t, o, r);
} return r; }
function R3(t, r, o, u, g, y, E, s, k) { return t = pA(o, u, !0, t, g, y, E, s, k), t.context = M3(null), o = t.current, u = bo(), g = Bh(o), y = nu(u, g), y.callback = r ?? null, Fh(o, y, g), t.current.lanes = g, Qv(t, g, u), Zo(t, u), t; }
function hb(t, r, o, u) { var g = r.current, y = bo(), E = Bh(g); return o = M3(o), r.context === null ? r.context = o : r.pendingContext = o, r = nu(y, E), r.payload = { element: t }, u = u === void 0 ? null : u, u !== null && (r.callback = u), t = Fh(g, r, E), t !== null && (yl(t, g, E, y), q1(t, g, E)), E; }
function Mw(t) { if (t = t.current, !t.child)
    return null; switch (t.child.tag) {
    case 5: return t.child.stateNode;
    default: return t.child.stateNode;
} }
function MD(t, r) { if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
    var o = t.retryLane;
    t.retryLane = o !== 0 && o < r ? o : r;
} }
function mA(t, r) { MD(t, r), (t = t.alternate) && MD(t, r); }
function t8() { return null; }
var k3 = typeof reportError == "function" ? reportError : function (t) { console.error(t); };
function gA(t) { this._internalRoot = t; }
db.prototype.render = gA.prototype.render = function (t) { var r = this._internalRoot; if (r === null)
    throw Error(rr(409)); hb(t, r, null, null); };
db.prototype.unmount = gA.prototype.unmount = function () { var t = this._internalRoot; if (t !== null) {
    this._internalRoot = null;
    var r = t.containerInfo;
    Mf(function () { hb(null, t, null, null); }), r[ou] = null;
} };
function db(t) { this._internalRoot = t; }
db.prototype.unstable_scheduleHydration = function (t) { if (t) {
    var r = cz();
    t = { blockedOn: null, target: t, priority: r };
    for (var o = 0; o < _h.length && r !== 0 && r < _h[o].priority; o++)
        ;
    _h.splice(o, 0, t), o === 0 && hz(t);
} };
function _A(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11); }
function fb(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable ")); }
function RD() { }
function r8(t, r, o, u, g) { if (g) {
    if (typeof u == "function") {
        var y = u;
        u = function () { var L = Mw(E); y.call(L); };
    }
    var E = R3(r, u, t, 0, null, !1, !1, "", RD);
    return t._reactRootContainer = E, t[ou] = E.current, yv(t.nodeType === 8 ? t.parentNode : t), Mf(), E;
} for (; g = t.lastChild;)
    t.removeChild(g); if (typeof u == "function") {
    var s = u;
    u = function () { var L = Mw(k); s.call(L); };
} var k = pA(t, 0, !1, null, null, !1, !1, "", RD); return t._reactRootContainer = k, t[ou] = k.current, yv(t.nodeType === 8 ? t.parentNode : t), Mf(function () { hb(r, k, o, u); }), k; }
function pb(t, r, o, u, g) { var y = o._reactRootContainer; if (y) {
    var E = y;
    if (typeof g == "function") {
        var s = g;
        g = function () { var k = Mw(E); s.call(k); };
    }
    hb(r, E, t, g);
}
else
    E = r8(o, r, t, g, u); return Mw(E); }
az = function (t) { switch (t.tag) {
    case 3:
        var r = t.stateNode;
        if (r.current.memoizedState.isDehydrated) {
            var o = jy(r.pendingLanes);
            o !== 0 && (zC(r, o | 1), Zo(r, cs()), !(fi & 6) && (hg = cs() + 500, rd()));
        }
        break;
    case 13: Mf(function () { var u = au(t, 1); if (u !== null) {
        var g = bo();
        yl(u, t, 1, g);
    } }), mA(t, 1);
} };
FC = function (t) { if (t.tag === 13) {
    var r = au(t, 134217728);
    if (r !== null) {
        var o = bo();
        yl(r, t, 134217728, o);
    }
    mA(t, 134217728);
} };
lz = function (t) { if (t.tag === 13) {
    var r = Bh(t), o = au(t, r);
    if (o !== null) {
        var u = bo();
        yl(o, t, r, u);
    }
    mA(t, r);
} };
cz = function () { return Ti; };
uz = function (t, r) { var o = Ti; try {
    return Ti = t, r();
}
finally {
    Ti = o;
} };
i2 = function (t, r, o) { switch (r) {
    case "input":
        if (YE(t, o), r = o.name, o.type === "radio" && r != null) {
            for (o = t; o.parentNode;)
                o = o.parentNode;
            for (o = o.querySelectorAll("input[name=" + JSON.stringify("" + r) + "][type=\"radio\"]"), r = 0; r < o.length; r++) {
                var u = o[r];
                if (u !== t && u.form === t.form) {
                    var g = ib(u);
                    if (!g)
                        throw Error(rr(90));
                    VO(u), YE(u, g);
                }
            }
        }
        break;
    case "textarea":
        $O(t, o);
        break;
    case "select": r = o.value, r != null && Lm(t, !!o.multiple, r, !1);
} };
KO = uA;
YO = Mf;
var n8 = { usingClientEntryPoint: !1, Events: [e0, Em, ib, ZO, XO, uA] }, Py = { findFiberByHostInstance: hf, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, i8 = { bundleType: Py.bundleType, version: Py.version, rendererPackageName: Py.rendererPackageName, rendererConfig: Py.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: du.ReactCurrentDispatcher, findHostInstanceByFiber: function (t) { return t = ez(t), t === null ? null : t.stateNode; }, findFiberByHostInstance: Py.findFiberByHostInstance || t8, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var A1 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!A1.isDisabled && A1.supportsFiber)
        try {
            eb = A1.inject(i8), sc = A1;
        }
        catch { }
}
va.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = n8;
va.createPortal = function (t, r) { var o = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!_A(r))
    throw Error(rr(200)); return e8(t, r, null, o); };
va.createRoot = function (t, r) { if (!_A(t))
    throw Error(rr(299)); var o = !1, u = "", g = k3; return r != null && (r.unstable_strictMode === !0 && (o = !0), r.identifierPrefix !== void 0 && (u = r.identifierPrefix), r.onRecoverableError !== void 0 && (g = r.onRecoverableError)), r = pA(t, 1, !1, null, null, o, !1, u, g), t[ou] = r.current, yv(t.nodeType === 8 ? t.parentNode : t), new gA(r); };
va.findDOMNode = function (t) { if (t == null)
    return null; if (t.nodeType === 1)
    return t; var r = t._reactInternals; if (r === void 0)
    throw typeof t.render == "function" ? Error(rr(188)) : (t = Object.keys(t).join(","), Error(rr(268, t))); return t = ez(r), t = t === null ? null : t.stateNode, t; };
va.flushSync = function (t) { return Mf(t); };
va.hydrate = function (t, r, o) { if (!fb(r))
    throw Error(rr(200)); return pb(null, t, r, !0, o); };
va.hydrateRoot = function (t, r, o) { if (!_A(t))
    throw Error(rr(405)); var u = o != null && o.hydratedSources || null, g = !1, y = "", E = k3; if (o != null && (o.unstable_strictMode === !0 && (g = !0), o.identifierPrefix !== void 0 && (y = o.identifierPrefix), o.onRecoverableError !== void 0 && (E = o.onRecoverableError)), r = R3(r, null, t, 1, o ?? null, g, !1, y, E), t[ou] = r.current, yv(t), u)
    for (t = 0; t < u.length; t++)
        o = u[t], g = o._getVersion, g = g(o._source), r.mutableSourceEagerHydrationData == null ? r.mutableSourceEagerHydrationData = [o, g] : r.mutableSourceEagerHydrationData.push(o, g); return new db(r); };
va.render = function (t, r, o) { if (!fb(r))
    throw Error(rr(200)); return pb(null, t, r, !1, o); };
va.unmountComponentAtNode = function (t) { if (!fb(t))
    throw Error(rr(40)); return t._reactRootContainer ? (Mf(function () { pb(null, null, t, !1, function () { t._reactRootContainer = null, t[ou] = null; }); }), !0) : !1; };
va.unstable_batchedUpdates = uA;
va.unstable_renderSubtreeIntoContainer = function (t, r, o, u) { if (!fb(o))
    throw Error(rr(200)); if (t == null || t._reactInternals === void 0)
    throw Error(rr(38)); return pb(t, r, o, !1, u); };
va.version = "18.3.1-next-f1338f8080-20240426";
function D3() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
    try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(D3);
    }
    catch (t) {
        console.error(t);
    } }
D3(), DO.exports = va;
var r0 = DO.exports;
const s8 = TC(r0);
var L3, kD = r0;
L3 = kD.createRoot, kD.hydrateRoot;
function o8(t, r) { if (t instanceof RegExp)
    return { keys: !1, pattern: t }; var o, u, g, y, E = [], s = "", k = t.split("/"); for (k[0] || k.shift(); g = k.shift();)
    o = g[0], o === "*" ? (E.push(o), s += g[1] === "?" ? "(?:/(.*))?" : "/(.*)") : o === ":" ? (u = g.indexOf("?", 1), y = g.indexOf(".", 1), E.push(g.substring(1, ~u ? u : ~y ? y : g.length)), s += ~u && !~y ? "(?:/([^/]+?))?" : "/([^/]+?)", ~y && (s += (~u ? "?" : "") + "\\" + g.substring(y))) : s += "/" + g; return { keys: E, pattern: new RegExp("^" + s + (r ? "(?=$|/)" : "/?$"), "i") }; }
var O3 = { exports: {} }, z3 = {}; /**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dg = ne;
function a8(t, r) { return t === r && (t !== 0 || 1 / t === 1 / r) || t !== t && r !== r; }
var l8 = typeof Object.is == "function" ? Object.is : a8, c8 = dg.useState, u8 = dg.useEffect, h8 = dg.useLayoutEffect, d8 = dg.useDebugValue;
function f8(t, r) { var o = r(), u = c8({ inst: { value: o, getSnapshot: r } }), g = u[0].inst, y = u[1]; return h8(function () { g.value = o, g.getSnapshot = r, _E(g) && y({ inst: g }); }, [t, o, r]), u8(function () { return _E(g) && y({ inst: g }), t(function () { _E(g) && y({ inst: g }); }); }, [t]), d8(o), o; }
function _E(t) { var r = t.getSnapshot; t = t.value; try {
    var o = r();
    return !l8(t, o);
}
catch {
    return !0;
} }
function p8(t, r) { return r(); }
var m8 = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? p8 : f8;
z3.useSyncExternalStore = dg.useSyncExternalStore !== void 0 ? dg.useSyncExternalStore : m8;
O3.exports = z3;
var g8 = O3.exports;
const _8 = RO.useInsertionEffect, y8 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", v8 = y8 ? ne.useLayoutEffect : ne.useEffect, x8 = _8 || v8, F3 = t => { const r = ne.useRef([t, (...o) => r[0](...o)]).current; return x8(() => { r[0] = t; }), r[1]; }, w8 = "popstate", yA = "pushState", vA = "replaceState", b8 = "hashchange", DD = [w8, yA, vA, b8], T8 = t => { for (const r of DD)
    addEventListener(r, t); return () => { for (const r of DD)
    removeEventListener(r, t); }; }, N3 = (t, r) => g8.useSyncExternalStore(T8, t, r), S8 = () => location.search, E8 = ({ ssrSearch: t = "" } = {}) => N3(S8, () => t), LD = () => location.pathname, C8 = ({ ssrPath: t } = {}) => N3(LD, t ? () => t : LD), A8 = (t, { replace: r = !1, state: o = null } = {}) => history[r ? vA : yA](o, "", t), I8 = (t = {}) => [C8(t), A8], OD = Symbol.for("wouter_v3");
if (typeof history < "u" && typeof window[OD] > "u") {
    for (const t of [yA, vA]) {
        const r = history[t];
        history[t] = function () { const o = r.apply(this, arguments), u = new Event(t); return u.arguments = arguments, dispatchEvent(u), o; };
    }
    Object.defineProperty(window, OD, { value: !0 });
}
const P8 = (t, r) => r.toLowerCase().indexOf(t.toLowerCase()) ? "~" + r : r.slice(t.length) || "/", B3 = (t = "") => t === "/" ? "" : t, M8 = (t, r) => t[0] === "~" ? t.slice(1) : B3(r) + t, R8 = (t = "", r) => P8(zD(B3(t)), zD(r)), zD = t => { try {
    return decodeURI(t);
}
catch {
    return t;
} }, j3 = { hook: I8, searchHook: E8, parser: o8, base: "", ssrPath: void 0, ssrSearch: void 0, hrefs: t => t }, V3 = ne.createContext(j3), Sg = () => ne.useContext(V3), U3 = {}, $3 = ne.createContext(U3), k8 = () => ne.useContext($3), mb = t => { const [r, o] = t.hook(t); return [R8(t.base, r), F3((u, g) => o(M8(u, t.base), g))]; }, xA = () => mb(Sg()), wA = (t, r, o, u) => { const { pattern: g, keys: y } = r instanceof RegExp ? { keys: !1, pattern: r } : t(r || "*", u), E = g.exec(o) || [], [s, ...k] = E; return s !== void 0 ? [!0, (() => { const L = y !== !1 ? Object.fromEntries(y.map((V, H) => [V, k[H]])) : E.groups; let N = { ...k }; return L && Object.assign(N, L), N; })(), ...u ? [s] : []] : [!1, null]; }, D8 = t => wA(Sg().parser, t, xA()[0]), L8 = ({ children: t, ...r }) => { var N, V; const o = Sg(), u = r.hook ? j3 : o; let g = u; const [y, E] = ((N = r.ssrPath) == null ? void 0 : N.split("?")) ?? []; E && (r.ssrSearch = E, r.ssrPath = y), r.hrefs = r.hrefs ?? ((V = r.hook) == null ? void 0 : V.hrefs); let s = ne.useRef({}), k = s.current, L = k; for (let H in u) {
    const ee = H === "base" ? u[H] + (r[H] || "") : r[H] || u[H];
    k === L && ee !== L[H] && (s.current = L = { ...L }), L[H] = ee, ee !== u[H] && (g = L);
} return ne.createElement(V3.Provider, { value: g, children: t }); }, FD = ({ children: t, component: r }, o) => r ? ne.createElement(r, { params: o }) : typeof t == "function" ? t(o) : t, O8 = t => { let r = ne.useRef(U3), o = r.current; for (const u in t)
    t[u] !== o[u] && (o = t); return Object.keys(t).length === 0 && (o = t), r.current = o; }, yE = ({ path: t, nest: r, match: o, ...u }) => { const g = Sg(), [y] = mb(g), [E, s, k] = o ?? wA(g.parser, t, y, r), L = O8({ ...k8(), ...s }); if (!E)
    return null; const N = k ? ne.createElement(L8, { base: k }, FD(u, L)) : FD(u, L); return ne.createElement($3.Provider, { value: L, children: N }); };
ne.forwardRef((t, r) => { const o = Sg(), [u, g] = mb(o), { to: y = "", href: E = y, onClick: s, asChild: k, children: L, className: N, replace: V, state: H, ...ee } = t, ce = F3(ye => { ye.ctrlKey || ye.metaKey || ye.altKey || ye.shiftKey || ye.button !== 0 || (s == null || s(ye), ye.defaultPrevented || (ye.preventDefault(), g(E, t))); }), J = o.hrefs(E[0] === "~" ? E.slice(1) : o.base + E, o); return k && ne.isValidElement(L) ? ne.cloneElement(L, { onClick: ce, href: J }) : ne.createElement("a", { ...ee, onClick: ce, href: J, className: N != null && N.call ? N(u === E) : N, children: L, ref: r }); });
const G3 = t => Array.isArray(t) ? t.flatMap(r => G3(r && r.type === ne.Fragment ? r.props.children : r)) : [t], z8 = ({ children: t, location: r }) => { const o = Sg(), [u] = mb(o); for (const g of G3(t)) {
    let y = 0;
    if (ne.isValidElement(g) && (y = wA(o.parser, g.props.path, r || u, g.props.nest))[0])
        return ne.cloneElement(g, { match: y });
} return null; };
var Eg = class {
    constructor() { this.listeners = new Set, this.subscribe = this.subscribe.bind(this); }
    subscribe(t) { return this.listeners.add(t), this.onSubscribe(), () => { this.listeners.delete(t), this.onUnsubscribe(); }; }
    hasListeners() { return this.listeners.size > 0; }
    onSubscribe() { }
    onUnsubscribe() { }
}, Rf = typeof window > "u" || "Deno" in globalThis;
function ka() { }
function F8(t, r) { return typeof t == "function" ? t(r) : t; }
function F2(t) { return typeof t == "number" && t >= 0 && t !== 1 / 0; }
function q3(t, r) { return Math.max(t + (r || 0) - Date.now(), 0); }
function jm(t, r) { return typeof t == "function" ? t(r) : t; }
function fl(t, r) { return typeof t == "function" ? t(r) : t; }
function ND(t, r) { const { type: o = "all", exact: u, fetchStatus: g, predicate: y, queryKey: E, stale: s } = t; if (E) {
    if (u) {
        if (r.queryHash !== bA(E, r.options))
            return !1;
    }
    else if (!Av(r.queryKey, E))
        return !1;
} if (o !== "all") {
    const k = r.isActive();
    if (o === "active" && !k || o === "inactive" && k)
        return !1;
} return !(typeof s == "boolean" && r.isStale() !== s || g && g !== r.state.fetchStatus || y && !y(r)); }
function BD(t, r) { const { exact: o, status: u, predicate: g, mutationKey: y } = t; if (y) {
    if (!r.options.mutationKey)
        return !1;
    if (o) {
        if (kf(r.options.mutationKey) !== kf(y))
            return !1;
    }
    else if (!Av(r.options.mutationKey, y))
        return !1;
} return !(u && r.state.status !== u || g && !g(r)); }
function bA(t, r) { return ((r == null ? void 0 : r.queryKeyHashFn) || kf)(t); }
function kf(t) { return JSON.stringify(t, (r, o) => N2(o) ? Object.keys(o).sort().reduce((u, g) => (u[g] = o[g], u), {}) : o); }
function Av(t, r) { return t === r ? !0 : typeof t != typeof r ? !1 : t && r && typeof t == "object" && typeof r == "object" ? !Object.keys(r).some(o => !Av(t[o], r[o])) : !1; }
function H3(t, r) { if (t === r)
    return t; const o = jD(t) && jD(r); if (o || N2(t) && N2(r)) {
    const u = o ? t : Object.keys(t), g = u.length, y = o ? r : Object.keys(r), E = y.length, s = o ? [] : {};
    let k = 0;
    for (let L = 0; L < E; L++) {
        const N = o ? L : y[L];
        (!o && u.includes(N) || o) && t[N] === void 0 && r[N] === void 0 ? (s[N] = void 0, k++) : (s[N] = H3(t[N], r[N]), s[N] === t[N] && t[N] !== void 0 && k++);
    }
    return g === E && k === g ? t : s;
} return r; }
function Rw(t, r) { if (!r || Object.keys(t).length !== Object.keys(r).length)
    return !1; for (const o in t)
    if (t[o] !== r[o])
        return !1; return !0; }
function jD(t) { return Array.isArray(t) && t.length === Object.keys(t).length; }
function N2(t) { if (!VD(t))
    return !1; const r = t.constructor; if (r === void 0)
    return !0; const o = r.prototype; return !(!VD(o) || !o.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype); }
function VD(t) { return Object.prototype.toString.call(t) === "[object Object]"; }
function N8(t) { return new Promise(r => { setTimeout(r, t); }); }
function B2(t, r, o) { return typeof o.structuralSharing == "function" ? o.structuralSharing(t, r) : o.structuralSharing !== !1 ? H3(t, r) : r; }
function B8(t, r, o = 0) { const u = [...t, r]; return o && u.length > o ? u.slice(1) : u; }
function j8(t, r, o = 0) { const u = [r, ...t]; return o && u.length > o ? u.slice(0, -1) : u; }
var TA = Symbol();
function W3(t, r) { return !t.queryFn && (r != null && r.initialPromise) ? () => r.initialPromise : !t.queryFn || t.queryFn === TA ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn; }
var mf, wh, Hm, hO, V8 = (hO = class extends Eg {
    constructor() { super(); rn(this, mf); rn(this, wh); rn(this, Hm); Sr(this, Hm, r => { if (!Rf && window.addEventListener) {
        const o = () => r();
        return window.addEventListener("visibilitychange", o, !1), () => { window.removeEventListener("visibilitychange", o); };
    } }); }
    onSubscribe() { Ke(this, wh) || this.setEventListener(Ke(this, Hm)); }
    onUnsubscribe() { var r; this.hasListeners() || ((r = Ke(this, wh)) == null || r.call(this), Sr(this, wh, void 0)); }
    setEventListener(r) { var o; Sr(this, Hm, r), (o = Ke(this, wh)) == null || o.call(this), Sr(this, wh, r(u => { typeof u == "boolean" ? this.setFocused(u) : this.onFocus(); })); }
    setFocused(r) { Ke(this, mf) !== r && (Sr(this, mf, r), this.onFocus()); }
    onFocus() { const r = this.isFocused(); this.listeners.forEach(o => { o(r); }); }
    isFocused() { var r; return typeof Ke(this, mf) == "boolean" ? Ke(this, mf) : ((r = globalThis.document) == null ? void 0 : r.visibilityState) !== "hidden"; }
}, mf = new WeakMap, wh = new WeakMap, Hm = new WeakMap, hO), SA = new V8, Wm, bh, Zm, dO, U8 = (dO = class extends Eg {
    constructor() { super(); rn(this, Wm, !0); rn(this, bh); rn(this, Zm); Sr(this, Zm, r => { if (!Rf && window.addEventListener) {
        const o = () => r(!0), u = () => r(!1);
        return window.addEventListener("online", o, !1), window.addEventListener("offline", u, !1), () => { window.removeEventListener("online", o), window.removeEventListener("offline", u); };
    } }); }
    onSubscribe() { Ke(this, bh) || this.setEventListener(Ke(this, Zm)); }
    onUnsubscribe() { var r; this.hasListeners() || ((r = Ke(this, bh)) == null || r.call(this), Sr(this, bh, void 0)); }
    setEventListener(r) { var o; Sr(this, Zm, r), (o = Ke(this, bh)) == null || o.call(this), Sr(this, bh, r(this.setOnline.bind(this))); }
    setOnline(r) { Ke(this, Wm) !== r && (Sr(this, Wm, r), this.listeners.forEach(u => { u(r); })); }
    isOnline() { return Ke(this, Wm); }
}, Wm = new WeakMap, bh = new WeakMap, Zm = new WeakMap, dO), kw = new U8;
function j2() { let t, r; const o = new Promise((g, y) => { t = g, r = y; }); o.status = "pending", o.catch(() => { }); function u(g) { Object.assign(o, g), delete o.resolve, delete o.reject; } return o.resolve = g => { u({ status: "fulfilled", value: g }), t(g); }, o.reject = g => { u({ status: "rejected", reason: g }), r(g); }, o; }
function $8(t) { return Math.min(1e3 * 2 ** t, 3e4); }
function Z3(t) { return (t ?? "online") === "online" ? kw.isOnline() : !0; }
var X3 = class extends Error {
    constructor(t) { super("CancelledError"), this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent; }
};
function vE(t) { return t instanceof X3; }
function K3(t) { let r = !1, o = 0, u = !1, g; const y = j2(), E = J => { var ye; u || (H(new X3(J)), (ye = t.abort) == null || ye.call(t)); }, s = () => { r = !0; }, k = () => { r = !1; }, L = () => SA.isFocused() && (t.networkMode === "always" || kw.isOnline()) && t.canRun(), N = () => Z3(t.networkMode) && t.canRun(), V = J => { var ye; u || (u = !0, (ye = t.onSuccess) == null || ye.call(t, J), g == null || g(), y.resolve(J)); }, H = J => { var ye; u || (u = !0, (ye = t.onError) == null || ye.call(t, J), g == null || g(), y.reject(J)); }, ee = () => new Promise(J => { var ye; g = ie => { (u || L()) && J(ie); }, (ye = t.onPause) == null || ye.call(t); }).then(() => { var J; g = void 0, u || (J = t.onContinue) == null || J.call(t); }), ce = () => { if (u)
    return; let J; const ye = o === 0 ? t.initialPromise : void 0; try {
    J = ye ?? t.fn();
}
catch (ie) {
    J = Promise.reject(ie);
} Promise.resolve(J).then(V).catch(ie => { var Be; if (u)
    return; const Q = t.retry ?? (Rf ? 0 : 3), ue = t.retryDelay ?? $8, be = typeof ue == "function" ? ue(o, ie) : ue, Ie = Q === !0 || typeof Q == "number" && o < Q || typeof Q == "function" && Q(o, ie); if (r || !Ie) {
    H(ie);
    return;
} o++, (Be = t.onFail) == null || Be.call(t, o, ie), N8(be).then(() => L() ? void 0 : ee()).then(() => { r ? H(ie) : ce(); }); }); }; return { promise: y, cancel: E, continue: () => (g == null || g(), y), cancelRetry: s, continueRetry: k, canStart: N, start: () => (N() ? ce() : ee().then(ce), y) }; }
function G8() { let t = [], r = 0, o = s => { s(); }, u = s => { s(); }, g = s => setTimeout(s, 0); const y = s => { r ? t.push(s) : g(() => { o(s); }); }, E = () => { const s = t; t = [], s.length && g(() => { u(() => { s.forEach(k => { o(k); }); }); }); }; return { batch: s => { let k; r++; try {
        k = s();
    }
    finally {
        r--, r || E();
    } return k; }, batchCalls: s => (...k) => { y(() => { s(...k); }); }, schedule: y, setNotifyFunction: s => { o = s; }, setBatchNotifyFunction: s => { u = s; }, setScheduler: s => { g = s; } }; }
var Ss = G8(), gf, fO, Y3 = (fO = class {
    constructor() { rn(this, gf); }
    destroy() { this.clearGcTimeout(); }
    scheduleGc() { this.clearGcTimeout(), F2(this.gcTime) && Sr(this, gf, setTimeout(() => { this.optionalRemove(); }, this.gcTime)); }
    updateGcTime(t) { this.gcTime = Math.max(this.gcTime || 0, t ?? (Rf ? 1 / 0 : 5 * 60 * 1e3)); }
    clearGcTimeout() { Ke(this, gf) && (clearTimeout(Ke(this, gf)), Sr(this, gf, void 0)); }
}, gf = new WeakMap, fO), Xm, Km, Ra, lo, Wv, _f, cl, Zc, pO, q8 = (pO = class extends Y3 {
    constructor(r) { super(); rn(this, cl); rn(this, Xm); rn(this, Km); rn(this, Ra); rn(this, lo); rn(this, Wv); rn(this, _f); Sr(this, _f, !1), Sr(this, Wv, r.defaultOptions), this.setOptions(r.options), this.observers = [], Sr(this, Ra, r.cache), this.queryKey = r.queryKey, this.queryHash = r.queryHash, Sr(this, Xm, H8(this.options)), this.state = r.state ?? Ke(this, Xm), this.scheduleGc(); }
    get meta() { return this.options.meta; }
    get promise() { var r; return (r = Ke(this, lo)) == null ? void 0 : r.promise; }
    setOptions(r) { this.options = { ...Ke(this, Wv), ...r }, this.updateGcTime(this.options.gcTime); }
    optionalRemove() { !this.observers.length && this.state.fetchStatus === "idle" && Ke(this, Ra).remove(this); }
    setData(r, o) { const u = B2(this.state.data, r, this.options); return Nn(this, cl, Zc).call(this, { data: u, type: "success", dataUpdatedAt: o == null ? void 0 : o.updatedAt, manual: o == null ? void 0 : o.manual }), u; }
    setState(r, o) { Nn(this, cl, Zc).call(this, { type: "setState", state: r, setStateOptions: o }); }
    cancel(r) { var u, g; const o = (u = Ke(this, lo)) == null ? void 0 : u.promise; return (g = Ke(this, lo)) == null || g.cancel(r), o ? o.then(ka).catch(ka) : Promise.resolve(); }
    destroy() { super.destroy(), this.cancel({ silent: !0 }); }
    reset() { this.destroy(), this.setState(Ke(this, Xm)); }
    isActive() { return this.observers.some(r => fl(r.options.enabled, this) !== !1); }
    isDisabled() { return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === TA || this.state.dataUpdateCount + this.state.errorUpdateCount === 0; }
    isStale() { return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(r => r.getCurrentResult().isStale) : this.state.data === void 0; }
    isStaleByTime(r = 0) { return this.state.isInvalidated || this.state.data === void 0 || !q3(this.state.dataUpdatedAt, r); }
    onFocus() { var o; const r = this.observers.find(u => u.shouldFetchOnWindowFocus()); r == null || r.refetch({ cancelRefetch: !1 }), (o = Ke(this, lo)) == null || o.continue(); }
    onOnline() { var o; const r = this.observers.find(u => u.shouldFetchOnReconnect()); r == null || r.refetch({ cancelRefetch: !1 }), (o = Ke(this, lo)) == null || o.continue(); }
    addObserver(r) { this.observers.includes(r) || (this.observers.push(r), this.clearGcTimeout(), Ke(this, Ra).notify({ type: "observerAdded", query: this, observer: r })); }
    removeObserver(r) { this.observers.includes(r) && (this.observers = this.observers.filter(o => o !== r), this.observers.length || (Ke(this, lo) && (Ke(this, _f) ? Ke(this, lo).cancel({ revert: !0 }) : Ke(this, lo).cancelRetry()), this.scheduleGc()), Ke(this, Ra).notify({ type: "observerRemoved", query: this, observer: r })); }
    getObserversCount() { return this.observers.length; }
    invalidate() { this.state.isInvalidated || Nn(this, cl, Zc).call(this, { type: "invalidate" }); }
    fetch(r, o) { var k, L, N; if (this.state.fetchStatus !== "idle") {
        if (this.state.data !== void 0 && (o != null && o.cancelRefetch))
            this.cancel({ silent: !0 });
        else if (Ke(this, lo))
            return Ke(this, lo).continueRetry(), Ke(this, lo).promise;
    } if (r && this.setOptions(r), !this.options.queryFn) {
        const V = this.observers.find(H => H.options.queryFn);
        V && this.setOptions(V.options);
    } const u = new AbortController, g = V => { Object.defineProperty(V, "signal", { enumerable: !0, get: () => (Sr(this, _f, !0), u.signal) }); }, y = () => { const V = W3(this.options, o), H = { queryKey: this.queryKey, meta: this.meta }; return g(H), Sr(this, _f, !1), this.options.persister ? this.options.persister(V, H, this) : V(H); }, E = { fetchOptions: o, options: this.options, queryKey: this.queryKey, state: this.state, fetchFn: y }; g(E), (k = this.options.behavior) == null || k.onFetch(E, this), Sr(this, Km, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((L = E.fetchOptions) == null ? void 0 : L.meta)) && Nn(this, cl, Zc).call(this, { type: "fetch", meta: (N = E.fetchOptions) == null ? void 0 : N.meta }); const s = V => { var H, ee, ce, J; vE(V) && V.silent || Nn(this, cl, Zc).call(this, { type: "error", error: V }), vE(V) || ((ee = (H = Ke(this, Ra).config).onError) == null || ee.call(H, V, this), (J = (ce = Ke(this, Ra).config).onSettled) == null || J.call(ce, this.state.data, V, this)), this.scheduleGc(); }; return Sr(this, lo, K3({ initialPromise: o == null ? void 0 : o.initialPromise, fn: E.fetchFn, abort: u.abort.bind(u), onSuccess: V => { var H, ee, ce, J; if (V === void 0) {
            s(new Error(`${this.queryHash} data is undefined`));
            return;
        } try {
            this.setData(V);
        }
        catch (ye) {
            s(ye);
            return;
        } (ee = (H = Ke(this, Ra).config).onSuccess) == null || ee.call(H, V, this), (J = (ce = Ke(this, Ra).config).onSettled) == null || J.call(ce, V, this.state.error, this), this.scheduleGc(); }, onError: s, onFail: (V, H) => { Nn(this, cl, Zc).call(this, { type: "failed", failureCount: V, error: H }); }, onPause: () => { Nn(this, cl, Zc).call(this, { type: "pause" }); }, onContinue: () => { Nn(this, cl, Zc).call(this, { type: "continue" }); }, retry: E.options.retry, retryDelay: E.options.retryDelay, networkMode: E.options.networkMode, canRun: () => !0 })), Ke(this, lo).start(); }
}, Xm = new WeakMap, Km = new WeakMap, Ra = new WeakMap, lo = new WeakMap, Wv = new WeakMap, _f = new WeakMap, cl = new WeakSet, Zc = function (r) { const o = u => { switch (r.type) {
    case "failed": return { ...u, fetchFailureCount: r.failureCount, fetchFailureReason: r.error };
    case "pause": return { ...u, fetchStatus: "paused" };
    case "continue": return { ...u, fetchStatus: "fetching" };
    case "fetch": return { ...u, ...Q3(u.data, this.options), fetchMeta: r.meta ?? null };
    case "success": return { ...u, data: r.data, dataUpdateCount: u.dataUpdateCount + 1, dataUpdatedAt: r.dataUpdatedAt ?? Date.now(), error: null, isInvalidated: !1, status: "success", ...!r.manual && { fetchStatus: "idle", fetchFailureCount: 0, fetchFailureReason: null } };
    case "error":
        const g = r.error;
        return vE(g) && g.revert && Ke(this, Km) ? { ...Ke(this, Km), fetchStatus: "idle" } : { ...u, error: g, errorUpdateCount: u.errorUpdateCount + 1, errorUpdatedAt: Date.now(), fetchFailureCount: u.fetchFailureCount + 1, fetchFailureReason: g, fetchStatus: "idle", status: "error" };
    case "invalidate": return { ...u, isInvalidated: !0 };
    case "setState": return { ...u, ...r.state };
} }; this.state = o(this.state), Ss.batch(() => { this.observers.forEach(u => { u.onQueryUpdate(); }), Ke(this, Ra).notify({ query: this, type: "updated", action: r }); }); }, pO);
function Q3(t, r) { return { fetchFailureCount: 0, fetchFailureReason: null, fetchStatus: Z3(r.networkMode) ? "fetching" : "paused", ...t === void 0 && { error: null, status: "pending" } }; }
function H8(t) { const r = typeof t.initialData == "function" ? t.initialData() : t.initialData, o = r !== void 0, u = o ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0; return { data: r, dataUpdateCount: 0, dataUpdatedAt: o ? u ?? Date.now() : 0, error: null, errorUpdateCount: 0, errorUpdatedAt: 0, fetchFailureCount: 0, fetchFailureReason: null, fetchMeta: null, isInvalidated: !1, status: o ? "success" : "pending", fetchStatus: "idle" }; }
var Ql, mO, W8 = (mO = class extends Eg {
    constructor(r = {}) { super(); rn(this, Ql); this.config = r, Sr(this, Ql, new Map); }
    build(r, o, u) { const g = o.queryKey, y = o.queryHash ?? bA(g, o); let E = this.get(y); return E || (E = new q8({ cache: this, queryKey: g, queryHash: y, options: r.defaultQueryOptions(o), state: u, defaultOptions: r.getQueryDefaults(g) }), this.add(E)), E; }
    add(r) { Ke(this, Ql).has(r.queryHash) || (Ke(this, Ql).set(r.queryHash, r), this.notify({ type: "added", query: r })); }
    remove(r) { const o = Ke(this, Ql).get(r.queryHash); o && (r.destroy(), o === r && Ke(this, Ql).delete(r.queryHash), this.notify({ type: "removed", query: r })); }
    clear() { Ss.batch(() => { this.getAll().forEach(r => { this.remove(r); }); }); }
    get(r) { return Ke(this, Ql).get(r); }
    getAll() { return [...Ke(this, Ql).values()]; }
    find(r) { const o = { exact: !0, ...r }; return this.getAll().find(u => ND(o, u)); }
    findAll(r = {}) { const o = this.getAll(); return Object.keys(r).length > 0 ? o.filter(u => ND(r, u)) : o; }
    notify(r) { Ss.batch(() => { this.listeners.forEach(o => { o(r); }); }); }
    onFocus() { Ss.batch(() => { this.getAll().forEach(r => { r.onFocus(); }); }); }
    onOnline() { Ss.batch(() => { this.getAll().forEach(r => { r.onOnline(); }); }); }
}, Ql = new WeakMap, mO), Jl, _o, yf, ec, uh, gO, Z8 = (gO = class extends Y3 {
    constructor(r) { super(); rn(this, ec); rn(this, Jl); rn(this, _o); rn(this, yf); this.mutationId = r.mutationId, Sr(this, _o, r.mutationCache), Sr(this, Jl, []), this.state = r.state || J3(), this.setOptions(r.options), this.scheduleGc(); }
    setOptions(r) { this.options = r, this.updateGcTime(this.options.gcTime); }
    get meta() { return this.options.meta; }
    addObserver(r) { Ke(this, Jl).includes(r) || (Ke(this, Jl).push(r), this.clearGcTimeout(), Ke(this, _o).notify({ type: "observerAdded", mutation: this, observer: r })); }
    removeObserver(r) { Sr(this, Jl, Ke(this, Jl).filter(o => o !== r)), this.scheduleGc(), Ke(this, _o).notify({ type: "observerRemoved", mutation: this, observer: r }); }
    optionalRemove() { Ke(this, Jl).length || (this.state.status === "pending" ? this.scheduleGc() : Ke(this, _o).remove(this)); }
    continue() { var r; return ((r = Ke(this, yf)) == null ? void 0 : r.continue()) ?? this.execute(this.state.variables); }
    async execute(r) { var g, y, E, s, k, L, N, V, H, ee, ce, J, ye, ie, Q, ue, be, Ie, Be, Ze; Sr(this, yf, K3({ fn: () => this.options.mutationFn ? this.options.mutationFn(r) : Promise.reject(new Error("No mutationFn found")), onFail: (ot, At) => { Nn(this, ec, uh).call(this, { type: "failed", failureCount: ot, error: At }); }, onPause: () => { Nn(this, ec, uh).call(this, { type: "pause" }); }, onContinue: () => { Nn(this, ec, uh).call(this, { type: "continue" }); }, retry: this.options.retry ?? 0, retryDelay: this.options.retryDelay, networkMode: this.options.networkMode, canRun: () => Ke(this, _o).canRun(this) })); const o = this.state.status === "pending", u = !Ke(this, yf).canStart(); try {
        if (!o) {
            Nn(this, ec, uh).call(this, { type: "pending", variables: r, isPaused: u }), await ((y = (g = Ke(this, _o).config).onMutate) == null ? void 0 : y.call(g, r, this));
            const At = await ((s = (E = this.options).onMutate) == null ? void 0 : s.call(E, r));
            At !== this.state.context && Nn(this, ec, uh).call(this, { type: "pending", context: At, variables: r, isPaused: u });
        }
        const ot = await Ke(this, yf).start();
        return await ((L = (k = Ke(this, _o).config).onSuccess) == null ? void 0 : L.call(k, ot, r, this.state.context, this)), await ((V = (N = this.options).onSuccess) == null ? void 0 : V.call(N, ot, r, this.state.context)), await ((ee = (H = Ke(this, _o).config).onSettled) == null ? void 0 : ee.call(H, ot, null, this.state.variables, this.state.context, this)), await ((J = (ce = this.options).onSettled) == null ? void 0 : J.call(ce, ot, null, r, this.state.context)), Nn(this, ec, uh).call(this, { type: "success", data: ot }), ot;
    }
    catch (ot) {
        try {
            throw await ((ie = (ye = Ke(this, _o).config).onError) == null ? void 0 : ie.call(ye, ot, r, this.state.context, this)), await ((ue = (Q = this.options).onError) == null ? void 0 : ue.call(Q, ot, r, this.state.context)), await ((Ie = (be = Ke(this, _o).config).onSettled) == null ? void 0 : Ie.call(be, void 0, ot, this.state.variables, this.state.context, this)), await ((Ze = (Be = this.options).onSettled) == null ? void 0 : Ze.call(Be, void 0, ot, r, this.state.context)), ot;
        }
        finally {
            Nn(this, ec, uh).call(this, { type: "error", error: ot });
        }
    }
    finally {
        Ke(this, _o).runNext(this);
    } }
}, Jl = new WeakMap, _o = new WeakMap, yf = new WeakMap, ec = new WeakSet, uh = function (r) { const o = u => { switch (r.type) {
    case "failed": return { ...u, failureCount: r.failureCount, failureReason: r.error };
    case "pause": return { ...u, isPaused: !0 };
    case "continue": return { ...u, isPaused: !1 };
    case "pending": return { ...u, context: r.context, data: void 0, failureCount: 0, failureReason: null, error: null, isPaused: r.isPaused, status: "pending", variables: r.variables, submittedAt: Date.now() };
    case "success": return { ...u, data: r.data, failureCount: 0, failureReason: null, error: null, status: "success", isPaused: !1 };
    case "error": return { ...u, data: void 0, error: r.error, failureCount: u.failureCount + 1, failureReason: r.error, isPaused: !1, status: "error" };
} }; this.state = o(this.state), Ss.batch(() => { Ke(this, Jl).forEach(u => { u.onMutationUpdate(r); }), Ke(this, _o).notify({ mutation: this, type: "updated", action: r }); }); }, gO);
function J3() { return { context: void 0, data: void 0, error: null, failureCount: 0, failureReason: null, isPaused: !1, status: "idle", variables: void 0, submittedAt: 0 }; }
var ua, Zv, _O, X8 = (_O = class extends Eg {
    constructor(r = {}) { super(); rn(this, ua); rn(this, Zv); this.config = r, Sr(this, ua, new Map), Sr(this, Zv, Date.now()); }
    build(r, o, u) { const g = new Z8({ mutationCache: this, mutationId: ++u1(this, Zv)._, options: r.defaultMutationOptions(o), state: u }); return this.add(g), g; }
    add(r) { const o = I1(r), u = Ke(this, ua).get(o) ?? []; u.push(r), Ke(this, ua).set(o, u), this.notify({ type: "added", mutation: r }); }
    remove(r) { var u; const o = I1(r); if (Ke(this, ua).has(o)) {
        const g = (u = Ke(this, ua).get(o)) == null ? void 0 : u.filter(y => y !== r);
        g && (g.length === 0 ? Ke(this, ua).delete(o) : Ke(this, ua).set(o, g));
    } this.notify({ type: "removed", mutation: r }); }
    canRun(r) { var u; const o = (u = Ke(this, ua).get(I1(r))) == null ? void 0 : u.find(g => g.state.status === "pending"); return !o || o === r; }
    runNext(r) { var u; const o = (u = Ke(this, ua).get(I1(r))) == null ? void 0 : u.find(g => g !== r && g.state.isPaused); return (o == null ? void 0 : o.continue()) ?? Promise.resolve(); }
    clear() { Ss.batch(() => { this.getAll().forEach(r => { this.remove(r); }); }); }
    getAll() { return [...Ke(this, ua).values()].flat(); }
    find(r) { const o = { exact: !0, ...r }; return this.getAll().find(u => BD(o, u)); }
    findAll(r = {}) { return this.getAll().filter(o => BD(r, o)); }
    notify(r) { Ss.batch(() => { this.listeners.forEach(o => { o(r); }); }); }
    resumePausedMutations() { const r = this.getAll().filter(o => o.state.isPaused); return Ss.batch(() => Promise.all(r.map(o => o.continue().catch(ka)))); }
}, ua = new WeakMap, Zv = new WeakMap, _O);
function I1(t) { var r; return ((r = t.options.scope) == null ? void 0 : r.id) ?? String(t.mutationId); }
function UD(t) { return { onFetch: (r, o) => { var N, V, H, ee, ce; const u = r.options, g = (H = (V = (N = r.fetchOptions) == null ? void 0 : N.meta) == null ? void 0 : V.fetchMore) == null ? void 0 : H.direction, y = ((ee = r.state.data) == null ? void 0 : ee.pages) || [], E = ((ce = r.state.data) == null ? void 0 : ce.pageParams) || []; let s = { pages: [], pageParams: [] }, k = 0; const L = async () => { let J = !1; const ye = ue => { Object.defineProperty(ue, "signal", { enumerable: !0, get: () => (r.signal.aborted ? J = !0 : r.signal.addEventListener("abort", () => { J = !0; }), r.signal) }); }, ie = W3(r.options, r.fetchOptions), Q = async (ue, be, Ie) => { if (J)
        return Promise.reject(); if (be == null && ue.pages.length)
        return Promise.resolve(ue); const Be = { queryKey: r.queryKey, pageParam: be, direction: Ie ? "backward" : "forward", meta: r.options.meta }; ye(Be); const Ze = await ie(Be), { maxPages: ot } = r.options, At = Ie ? j8 : B8; return { pages: At(ue.pages, Ze, ot), pageParams: At(ue.pageParams, be, ot) }; }; if (g && y.length) {
        const ue = g === "backward", be = ue ? K8 : $D, Ie = { pages: y, pageParams: E }, Be = be(u, Ie);
        s = await Q(Ie, Be, ue);
    }
    else {
        const ue = t ?? y.length;
        do {
            const be = k === 0 ? E[0] ?? u.initialPageParam : $D(u, s);
            if (k > 0 && be == null)
                break;
            s = await Q(s, be), k++;
        } while (k < ue);
    } return s; }; r.options.persister ? r.fetchFn = () => { var J, ye; return (ye = (J = r.options).persister) == null ? void 0 : ye.call(J, L, { queryKey: r.queryKey, meta: r.options.meta, signal: r.signal }, o); } : r.fetchFn = L; } }; }
function $D(t, { pages: r, pageParams: o }) { const u = r.length - 1; return r.length > 0 ? t.getNextPageParam(r[u], r, o[u], o) : void 0; }
function K8(t, { pages: r, pageParams: o }) { var u; return r.length > 0 ? (u = t.getPreviousPageParam) == null ? void 0 : u.call(t, r[0], r, o[0], o) : void 0; }
var rs, Th, Sh, Ym, Qm, Eh, Jm, eg, yO, Y8 = (yO = class {
    constructor(t = {}) { rn(this, rs); rn(this, Th); rn(this, Sh); rn(this, Ym); rn(this, Qm); rn(this, Eh); rn(this, Jm); rn(this, eg); Sr(this, rs, t.queryCache || new W8), Sr(this, Th, t.mutationCache || new X8), Sr(this, Sh, t.defaultOptions || {}), Sr(this, Ym, new Map), Sr(this, Qm, new Map), Sr(this, Eh, 0); }
    mount() { u1(this, Eh)._++, Ke(this, Eh) === 1 && (Sr(this, Jm, SA.subscribe(async (t) => { t && (await this.resumePausedMutations(), Ke(this, rs).onFocus()); })), Sr(this, eg, kw.subscribe(async (t) => { t && (await this.resumePausedMutations(), Ke(this, rs).onOnline()); }))); }
    unmount() { var t, r; u1(this, Eh)._--, Ke(this, Eh) === 0 && ((t = Ke(this, Jm)) == null || t.call(this), Sr(this, Jm, void 0), (r = Ke(this, eg)) == null || r.call(this), Sr(this, eg, void 0)); }
    isFetching(t) { return Ke(this, rs).findAll({ ...t, fetchStatus: "fetching" }).length; }
    isMutating(t) { return Ke(this, Th).findAll({ ...t, status: "pending" }).length; }
    getQueryData(t) { var o; const r = this.defaultQueryOptions({ queryKey: t }); return (o = Ke(this, rs).get(r.queryHash)) == null ? void 0 : o.state.data; }
    ensureQueryData(t) { const r = this.getQueryData(t.queryKey); if (r === void 0)
        return this.fetchQuery(t); {
        const o = this.defaultQueryOptions(t), u = Ke(this, rs).build(this, o);
        return t.revalidateIfStale && u.isStaleByTime(jm(o.staleTime, u)) && this.prefetchQuery(o), Promise.resolve(r);
    } }
    getQueriesData(t) { return Ke(this, rs).findAll(t).map(({ queryKey: r, state: o }) => { const u = o.data; return [r, u]; }); }
    setQueryData(t, r, o) { const u = this.defaultQueryOptions({ queryKey: t }), g = Ke(this, rs).get(u.queryHash), y = g == null ? void 0 : g.state.data, E = F8(r, y); if (E !== void 0)
        return Ke(this, rs).build(this, u).setData(E, { ...o, manual: !0 }); }
    setQueriesData(t, r, o) { return Ss.batch(() => Ke(this, rs).findAll(t).map(({ queryKey: u }) => [u, this.setQueryData(u, r, o)])); }
    getQueryState(t) { var o; const r = this.defaultQueryOptions({ queryKey: t }); return (o = Ke(this, rs).get(r.queryHash)) == null ? void 0 : o.state; }
    removeQueries(t) { const r = Ke(this, rs); Ss.batch(() => { r.findAll(t).forEach(o => { r.remove(o); }); }); }
    resetQueries(t, r) { const o = Ke(this, rs), u = { type: "active", ...t }; return Ss.batch(() => (o.findAll(t).forEach(g => { g.reset(); }), this.refetchQueries(u, r))); }
    cancelQueries(t = {}, r = {}) { const o = { revert: !0, ...r }, u = Ss.batch(() => Ke(this, rs).findAll(t).map(g => g.cancel(o))); return Promise.all(u).then(ka).catch(ka); }
    invalidateQueries(t = {}, r = {}) { return Ss.batch(() => { if (Ke(this, rs).findAll(t).forEach(u => { u.invalidate(); }), t.refetchType === "none")
        return Promise.resolve(); const o = { ...t, type: t.refetchType ?? t.type ?? "active" }; return this.refetchQueries(o, r); }); }
    refetchQueries(t = {}, r) { const o = { ...r, cancelRefetch: (r == null ? void 0 : r.cancelRefetch) ?? !0 }, u = Ss.batch(() => Ke(this, rs).findAll(t).filter(g => !g.isDisabled()).map(g => { let y = g.fetch(void 0, o); return o.throwOnError || (y = y.catch(ka)), g.state.fetchStatus === "paused" ? Promise.resolve() : y; })); return Promise.all(u).then(ka); }
    fetchQuery(t) { const r = this.defaultQueryOptions(t); r.retry === void 0 && (r.retry = !1); const o = Ke(this, rs).build(this, r); return o.isStaleByTime(jm(r.staleTime, o)) ? o.fetch(r) : Promise.resolve(o.state.data); }
    prefetchQuery(t) { return this.fetchQuery(t).then(ka).catch(ka); }
    fetchInfiniteQuery(t) { return t.behavior = UD(t.pages), this.fetchQuery(t); }
    prefetchInfiniteQuery(t) { return this.fetchInfiniteQuery(t).then(ka).catch(ka); }
    ensureInfiniteQueryData(t) { return t.behavior = UD(t.pages), this.ensureQueryData(t); }
    resumePausedMutations() { return kw.isOnline() ? Ke(this, Th).resumePausedMutations() : Promise.resolve(); }
    getQueryCache() { return Ke(this, rs); }
    getMutationCache() { return Ke(this, Th); }
    getDefaultOptions() { return Ke(this, Sh); }
    setDefaultOptions(t) { Sr(this, Sh, t); }
    setQueryDefaults(t, r) { Ke(this, Ym).set(kf(t), { queryKey: t, defaultOptions: r }); }
    getQueryDefaults(t) { const r = [...Ke(this, Ym).values()]; let o = {}; return r.forEach(u => { Av(t, u.queryKey) && (o = { ...o, ...u.defaultOptions }); }), o; }
    setMutationDefaults(t, r) { Ke(this, Qm).set(kf(t), { mutationKey: t, defaultOptions: r }); }
    getMutationDefaults(t) { const r = [...Ke(this, Qm).values()]; let o = {}; return r.forEach(u => { Av(t, u.mutationKey) && (o = { ...o, ...u.defaultOptions }); }), o; }
    defaultQueryOptions(t) { if (t._defaulted)
        return t; const r = { ...Ke(this, Sh).queries, ...this.getQueryDefaults(t.queryKey), ...t, _defaulted: !0 }; return r.queryHash || (r.queryHash = bA(r.queryKey, r)), r.refetchOnReconnect === void 0 && (r.refetchOnReconnect = r.networkMode !== "always"), r.throwOnError === void 0 && (r.throwOnError = !!r.suspense), !r.networkMode && r.persister && (r.networkMode = "offlineFirst"), r.enabled !== !0 && r.queryFn === TA && (r.enabled = !1), r; }
    defaultMutationOptions(t) { return t != null && t._defaulted ? t : { ...Ke(this, Sh).mutations, ...(t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey), ...t, _defaulted: !0 }; }
    clear() { Ke(this, rs).clear(), Ke(this, Th).clear(); }
}, rs = new WeakMap, Th = new WeakMap, Sh = new WeakMap, Ym = new WeakMap, Qm = new WeakMap, Eh = new WeakMap, Jm = new WeakMap, eg = new WeakMap, yO), Vo, ii, Xv, yo, vf, tg, Ch, tc, Kv, rg, ng, xf, wf, Ah, ig, xi, Uy, V2, U2, $2, G2, q2, H2, W2, eF, vO, Q8 = (vO = class extends Eg {
    constructor(r, o) { super(); rn(this, xi); rn(this, Vo); rn(this, ii); rn(this, Xv); rn(this, yo); rn(this, vf); rn(this, tg); rn(this, Ch); rn(this, tc); rn(this, Kv); rn(this, rg); rn(this, ng); rn(this, xf); rn(this, wf); rn(this, Ah); rn(this, ig, new Set); this.options = o, Sr(this, Vo, r), Sr(this, tc, null), Sr(this, Ch, j2()), this.options.experimental_prefetchInRender || Ke(this, Ch).reject(new Error("experimental_prefetchInRender feature flag is not enabled")), this.bindMethods(), this.setOptions(o); }
    bindMethods() { this.refetch = this.refetch.bind(this); }
    onSubscribe() { this.listeners.size === 1 && (Ke(this, ii).addObserver(this), GD(Ke(this, ii), this.options) ? Nn(this, xi, Uy).call(this) : this.updateResult(), Nn(this, xi, G2).call(this)); }
    onUnsubscribe() { this.hasListeners() || this.destroy(); }
    shouldFetchOnReconnect() { return Z2(Ke(this, ii), this.options, this.options.refetchOnReconnect); }
    shouldFetchOnWindowFocus() { return Z2(Ke(this, ii), this.options, this.options.refetchOnWindowFocus); }
    destroy() { this.listeners = new Set, Nn(this, xi, q2).call(this), Nn(this, xi, H2).call(this), Ke(this, ii).removeObserver(this); }
    setOptions(r, o) { const u = this.options, g = Ke(this, ii); if (this.options = Ke(this, Vo).defaultQueryOptions(r), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof fl(this.options.enabled, Ke(this, ii)) != "boolean")
        throw new Error("Expected enabled to be a boolean or a callback that returns a boolean"); Nn(this, xi, W2).call(this), Ke(this, ii).setOptions(this.options), u._defaulted && !Rw(this.options, u) && Ke(this, Vo).getQueryCache().notify({ type: "observerOptionsUpdated", query: Ke(this, ii), observer: this }); const y = this.hasListeners(); y && qD(Ke(this, ii), g, this.options, u) && Nn(this, xi, Uy).call(this), this.updateResult(o), y && (Ke(this, ii) !== g || fl(this.options.enabled, Ke(this, ii)) !== fl(u.enabled, Ke(this, ii)) || jm(this.options.staleTime, Ke(this, ii)) !== jm(u.staleTime, Ke(this, ii))) && Nn(this, xi, V2).call(this); const E = Nn(this, xi, U2).call(this); y && (Ke(this, ii) !== g || fl(this.options.enabled, Ke(this, ii)) !== fl(u.enabled, Ke(this, ii)) || E !== Ke(this, Ah)) && Nn(this, xi, $2).call(this, E); }
    getOptimisticResult(r) { const o = Ke(this, Vo).getQueryCache().build(Ke(this, Vo), r), u = this.createResult(o, r); return eG(this, u) && (Sr(this, yo, u), Sr(this, tg, this.options), Sr(this, vf, Ke(this, ii).state)), u; }
    getCurrentResult() { return Ke(this, yo); }
    trackResult(r, o) { const u = {}; return Object.keys(r).forEach(g => { Object.defineProperty(u, g, { configurable: !1, enumerable: !0, get: () => (this.trackProp(g), o == null || o(g), r[g]) }); }), u; }
    trackProp(r) { Ke(this, ig).add(r); }
    getCurrentQuery() { return Ke(this, ii); }
    refetch({ ...r } = {}) { return this.fetch({ ...r }); }
    fetchOptimistic(r) { const o = Ke(this, Vo).defaultQueryOptions(r), u = Ke(this, Vo).getQueryCache().build(Ke(this, Vo), o); return u.fetch().then(() => this.createResult(u, o)); }
    fetch(r) { return Nn(this, xi, Uy).call(this, { ...r, cancelRefetch: r.cancelRefetch ?? !0 }).then(() => (this.updateResult(), Ke(this, yo))); }
    createResult(r, o) { var ot; const u = Ke(this, ii), g = this.options, y = Ke(this, yo), E = Ke(this, vf), s = Ke(this, tg), L = r !== u ? r.state : Ke(this, Xv), { state: N } = r; let V = { ...N }, H = !1, ee; if (o._optimisticResults) {
        const At = this.hasListeners(), kt = !At && GD(r, o), ct = At && qD(r, u, o, g);
        (kt || ct) && (V = { ...V, ...Q3(N.data, r.options) }), o._optimisticResults === "isRestoring" && (V.fetchStatus = "idle");
    } let { error: ce, errorUpdatedAt: J, status: ye } = V; if (o.select && V.data !== void 0)
        if (y && V.data === (E == null ? void 0 : E.data) && o.select === Ke(this, Kv))
            ee = Ke(this, rg);
        else
            try {
                Sr(this, Kv, o.select), ee = o.select(V.data), ee = B2(y == null ? void 0 : y.data, ee, o), Sr(this, rg, ee), Sr(this, tc, null);
            }
            catch (At) {
                Sr(this, tc, At);
            }
    else
        ee = V.data; if (o.placeholderData !== void 0 && ee === void 0 && ye === "pending") {
        let At;
        if (y != null && y.isPlaceholderData && o.placeholderData === (s == null ? void 0 : s.placeholderData))
            At = y.data;
        else if (At = typeof o.placeholderData == "function" ? o.placeholderData((ot = Ke(this, ng)) == null ? void 0 : ot.state.data, Ke(this, ng)) : o.placeholderData, o.select && At !== void 0)
            try {
                At = o.select(At), Sr(this, tc, null);
            }
            catch (kt) {
                Sr(this, tc, kt);
            }
        At !== void 0 && (ye = "success", ee = B2(y == null ? void 0 : y.data, At, o), H = !0);
    } Ke(this, tc) && (ce = Ke(this, tc), ee = Ke(this, rg), J = Date.now(), ye = "error"); const ie = V.fetchStatus === "fetching", Q = ye === "pending", ue = ye === "error", be = Q && ie, Ie = ee !== void 0, Ze = { status: ye, fetchStatus: V.fetchStatus, isPending: Q, isSuccess: ye === "success", isError: ue, isInitialLoading: be, isLoading: be, data: ee, dataUpdatedAt: V.dataUpdatedAt, error: ce, errorUpdatedAt: J, failureCount: V.fetchFailureCount, failureReason: V.fetchFailureReason, errorUpdateCount: V.errorUpdateCount, isFetched: V.dataUpdateCount > 0 || V.errorUpdateCount > 0, isFetchedAfterMount: V.dataUpdateCount > L.dataUpdateCount || V.errorUpdateCount > L.errorUpdateCount, isFetching: ie, isRefetching: ie && !Q, isLoadingError: ue && !Ie, isPaused: V.fetchStatus === "paused", isPlaceholderData: H, isRefetchError: ue && Ie, isStale: EA(r, o), refetch: this.refetch, promise: Ke(this, Ch) }; if (this.options.experimental_prefetchInRender) {
        const At = St => { Ze.status === "error" ? St.reject(Ze.error) : Ze.data !== void 0 && St.resolve(Ze.data); }, kt = () => { const St = Sr(this, Ch, Ze.promise = j2()); At(St); }, ct = Ke(this, Ch);
        switch (ct.status) {
            case "pending":
                r.queryHash === u.queryHash && At(ct);
                break;
            case "fulfilled":
                (Ze.status === "error" || Ze.data !== ct.value) && kt();
                break;
            case "rejected":
                (Ze.status !== "error" || Ze.error !== ct.reason) && kt();
                break;
        }
    } return Ze; }
    updateResult(r) { const o = Ke(this, yo), u = this.createResult(Ke(this, ii), this.options); if (Sr(this, vf, Ke(this, ii).state), Sr(this, tg, this.options), Ke(this, vf).data !== void 0 && Sr(this, ng, Ke(this, ii)), Rw(u, o))
        return; Sr(this, yo, u); const g = {}, y = () => { if (!o)
        return !0; const { notifyOnChangeProps: E } = this.options, s = typeof E == "function" ? E() : E; if (s === "all" || !s && !Ke(this, ig).size)
        return !0; const k = new Set(s ?? Ke(this, ig)); return this.options.throwOnError && k.add("error"), Object.keys(Ke(this, yo)).some(L => { const N = L; return Ke(this, yo)[N] !== o[N] && k.has(N); }); }; (r == null ? void 0 : r.listeners) !== !1 && y() && (g.listeners = !0), Nn(this, xi, eF).call(this, { ...g, ...r }); }
    onQueryUpdate() { this.updateResult(), this.hasListeners() && Nn(this, xi, G2).call(this); }
}, Vo = new WeakMap, ii = new WeakMap, Xv = new WeakMap, yo = new WeakMap, vf = new WeakMap, tg = new WeakMap, Ch = new WeakMap, tc = new WeakMap, Kv = new WeakMap, rg = new WeakMap, ng = new WeakMap, xf = new WeakMap, wf = new WeakMap, Ah = new WeakMap, ig = new WeakMap, xi = new WeakSet, Uy = function (r) { Nn(this, xi, W2).call(this); let o = Ke(this, ii).fetch(this.options, r); return r != null && r.throwOnError || (o = o.catch(ka)), o; }, V2 = function () { Nn(this, xi, q2).call(this); const r = jm(this.options.staleTime, Ke(this, ii)); if (Rf || Ke(this, yo).isStale || !F2(r))
    return; const u = q3(Ke(this, yo).dataUpdatedAt, r) + 1; Sr(this, xf, setTimeout(() => { Ke(this, yo).isStale || this.updateResult(); }, u)); }, U2 = function () { return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(Ke(this, ii)) : this.options.refetchInterval) ?? !1; }, $2 = function (r) { Nn(this, xi, H2).call(this), Sr(this, Ah, r), !(Rf || fl(this.options.enabled, Ke(this, ii)) === !1 || !F2(Ke(this, Ah)) || Ke(this, Ah) === 0) && Sr(this, wf, setInterval(() => { (this.options.refetchIntervalInBackground || SA.isFocused()) && Nn(this, xi, Uy).call(this); }, Ke(this, Ah))); }, G2 = function () { Nn(this, xi, V2).call(this), Nn(this, xi, $2).call(this, Nn(this, xi, U2).call(this)); }, q2 = function () { Ke(this, xf) && (clearTimeout(Ke(this, xf)), Sr(this, xf, void 0)); }, H2 = function () { Ke(this, wf) && (clearInterval(Ke(this, wf)), Sr(this, wf, void 0)); }, W2 = function () { const r = Ke(this, Vo).getQueryCache().build(Ke(this, Vo), this.options); if (r === Ke(this, ii))
    return; const o = Ke(this, ii); Sr(this, ii, r), Sr(this, Xv, r.state), this.hasListeners() && (o == null || o.removeObserver(this), r.addObserver(this)); }, eF = function (r) { Ss.batch(() => { r.listeners && this.listeners.forEach(o => { o(Ke(this, yo)); }), Ke(this, Vo).getQueryCache().notify({ query: Ke(this, ii), type: "observerResultsUpdated" }); }); }, vO);
function J8(t, r) { return fl(r.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && r.retryOnMount === !1); }
function GD(t, r) { return J8(t, r) || t.state.data !== void 0 && Z2(t, r, r.refetchOnMount); }
function Z2(t, r, o) { if (fl(r.enabled, t) !== !1) {
    const u = typeof o == "function" ? o(t) : o;
    return u === "always" || u !== !1 && EA(t, r);
} return !1; }
function qD(t, r, o, u) { return (t !== r || fl(u.enabled, t) === !1) && (!o.suspense || t.state.status !== "error") && EA(t, o); }
function EA(t, r) { return fl(r.enabled, t) !== !1 && t.isStaleByTime(jm(r.staleTime, t)); }
function eG(t, r) { return !Rw(t.getCurrentResult(), r); }
var Ih, Ph, Uo, eu, iu, Q1, X2, xO, tG = (xO = class extends Eg {
    constructor(o, u) { super(); rn(this, iu); rn(this, Ih); rn(this, Ph); rn(this, Uo); rn(this, eu); Sr(this, Ih, o), this.setOptions(u), this.bindMethods(), Nn(this, iu, Q1).call(this); }
    bindMethods() { this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this); }
    setOptions(o) { var g; const u = this.options; this.options = Ke(this, Ih).defaultMutationOptions(o), Rw(this.options, u) || Ke(this, Ih).getMutationCache().notify({ type: "observerOptionsUpdated", mutation: Ke(this, Uo), observer: this }), u != null && u.mutationKey && this.options.mutationKey && kf(u.mutationKey) !== kf(this.options.mutationKey) ? this.reset() : ((g = Ke(this, Uo)) == null ? void 0 : g.state.status) === "pending" && Ke(this, Uo).setOptions(this.options); }
    onUnsubscribe() { var o; this.hasListeners() || (o = Ke(this, Uo)) == null || o.removeObserver(this); }
    onMutationUpdate(o) { Nn(this, iu, Q1).call(this), Nn(this, iu, X2).call(this, o); }
    getCurrentResult() { return Ke(this, Ph); }
    reset() { var o; (o = Ke(this, Uo)) == null || o.removeObserver(this), Sr(this, Uo, void 0), Nn(this, iu, Q1).call(this), Nn(this, iu, X2).call(this); }
    mutate(o, u) { var g; return Sr(this, eu, u), (g = Ke(this, Uo)) == null || g.removeObserver(this), Sr(this, Uo, Ke(this, Ih).getMutationCache().build(Ke(this, Ih), this.options)), Ke(this, Uo).addObserver(this), Ke(this, Uo).execute(o); }
}, Ih = new WeakMap, Ph = new WeakMap, Uo = new WeakMap, eu = new WeakMap, iu = new WeakSet, Q1 = function () { var u; const o = ((u = Ke(this, Uo)) == null ? void 0 : u.state) ?? J3(); Sr(this, Ph, { ...o, isPending: o.status === "pending", isSuccess: o.status === "success", isError: o.status === "error", isIdle: o.status === "idle", mutate: this.mutate, reset: this.reset }); }, X2 = function (o) { Ss.batch(() => { var u, g, y, E, s, k, L, N; if (Ke(this, eu) && this.hasListeners()) {
    const V = Ke(this, Ph).variables, H = Ke(this, Ph).context;
    (o == null ? void 0 : o.type) === "success" ? ((g = (u = Ke(this, eu)).onSuccess) == null || g.call(u, o.data, V, H), (E = (y = Ke(this, eu)).onSettled) == null || E.call(y, o.data, null, V, H)) : (o == null ? void 0 : o.type) === "error" && ((k = (s = Ke(this, eu)).onError) == null || k.call(s, o.error, V, H), (N = (L = Ke(this, eu)).onSettled) == null || N.call(L, void 0, o.error, V, H));
} this.listeners.forEach(V => { V(Ke(this, Ph)); }); }); }, xO), tF = ne.createContext(void 0), n0 = t => { const r = ne.useContext(tF); if (!r)
    throw new Error("No QueryClient set, use QueryClientProvider to set one"); return r; }, rG = ({ client: t, children: r }) => (ne.useEffect(() => (t.mount(), () => { t.unmount(); }), [t]), j.jsx(tF.Provider, { value: t, children: r })), rF = ne.createContext(!1), nG = () => ne.useContext(rF);
rF.Provider;
function iG() { let t = !1; return { clearReset: () => { t = !1; }, reset: () => { t = !0; }, isReset: () => t }; }
var sG = ne.createContext(iG()), oG = () => ne.useContext(sG);
function nF(t, r) { return typeof t == "function" ? t(...r) : !!t; }
function K2() { }
var aG = (t, r) => { (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (r.isReset() || (t.retryOnMount = !1)); }, lG = t => { ne.useEffect(() => { t.clearReset(); }, [t]); }, cG = ({ result: t, errorResetBoundary: r, throwOnError: o, query: u }) => t.isError && !r.isReset() && !t.isFetching && u && nF(o, [t.error, u]), uG = t => { t.suspense && (t.staleTime === void 0 && (t.staleTime = 1e3), typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3))); }, hG = (t, r) => t.isLoading && t.isFetching && !r, dG = (t, r) => (t == null ? void 0 : t.suspense) && r.isPending, HD = (t, r, o) => r.fetchOptimistic(t).catch(() => { o.clearReset(); });
function fG(t, r, o) { var N, V, H, ee, ce; const u = n0(), g = nG(), y = oG(), E = u.defaultQueryOptions(t); (V = (N = u.getDefaultOptions().queries) == null ? void 0 : N._experimental_beforeQuery) == null || V.call(N, E), E._optimisticResults = g ? "isRestoring" : "optimistic", uG(E), aG(E, y), lG(y); const s = !u.getQueryCache().get(E.queryHash), [k] = ne.useState(() => new r(u, E)), L = k.getOptimisticResult(E); if (ne.useSyncExternalStore(ne.useCallback(J => { const ye = g ? K2 : k.subscribe(Ss.batchCalls(J)); return k.updateResult(), ye; }, [k, g]), () => k.getCurrentResult(), () => k.getCurrentResult()), ne.useEffect(() => { k.setOptions(E, { listeners: !1 }); }, [E, k]), dG(E, L))
    throw HD(E, k, y); if (cG({ result: L, errorResetBoundary: y, throwOnError: E.throwOnError, query: u.getQueryCache().get(E.queryHash) }))
    throw L.error; if ((ee = (H = u.getDefaultOptions().queries) == null ? void 0 : H._experimental_afterQuery) == null || ee.call(H, E, L), E.experimental_prefetchInRender && !Rf && hG(L, g)) {
    const J = s ? HD(E, k, y) : (ce = u.getQueryCache().get(E.queryHash)) == null ? void 0 : ce.promise;
    J == null || J.catch(K2).finally(() => { k.updateResult(); });
} return E.notifyOnChangeProps ? L : k.trackResult(L); }
function nv(t, r) { return fG(t, Q8); }
function uo(t, r) { const o = n0(), [u] = ne.useState(() => new tG(o, t)); ne.useEffect(() => { u.setOptions(t); }, [u, t]); const g = ne.useSyncExternalStore(ne.useCallback(E => u.subscribe(Ss.batchCalls(E)), [u]), () => u.getCurrentResult(), () => u.getCurrentResult()), y = ne.useCallback((E, s) => { u.mutate(E, s).catch(K2); }, [u]); if (g.error && nF(u.options.throwOnError, [g.error]))
    throw g.error; return { ...g, mutate: y, mutateAsync: g.mutate }; }
async function iF(t) { if (!t.ok) {
    const r = await t.text() || t.statusText;
    throw new Error(`${t.status}: ${r}`);
} }
async function Es(t, r, o) { const u = await fetch(r, { method: t, headers: o ? { "Content-Type": "application/json" } : {}, body: o ? JSON.stringify(o) : void 0, credentials: "include" }); return await iF(u), u; }
const pG = ({ on401: t }) => async ({ queryKey: r }) => { const o = await fetch(r[0], { credentials: "include" }); return t === "returnNull" && o.status === 401 ? null : (await iF(o), await o.json()); }, ac = new Y8({ defaultOptions: { queries: { queryFn: pG({ on401: "throw" }), refetchInterval: !1, refetchOnWindowFocus: !1, staleTime: 1 / 0, retry: !1 }, mutations: { retry: !1 } } }), mG = 1, gG = 1e6;
let xE = 0;
function _G() { return xE = (xE + 1) % Number.MAX_SAFE_INTEGER, xE.toString(); }
const wE = new Map, WD = t => { if (wE.has(t))
    return; const r = setTimeout(() => { wE.delete(t), iv({ type: "REMOVE_TOAST", toastId: t }); }, gG); wE.set(t, r); }, yG = (t, r) => { switch (r.type) {
    case "ADD_TOAST": return { ...t, toasts: [r.toast, ...t.toasts].slice(0, mG) };
    case "UPDATE_TOAST": return { ...t, toasts: t.toasts.map(o => o.id === r.toast.id ? { ...o, ...r.toast } : o) };
    case "DISMISS_TOAST": {
        const { toastId: o } = r;
        return o ? WD(o) : t.toasts.forEach(u => { WD(u.id); }), { ...t, toasts: t.toasts.map(u => u.id === o || o === void 0 ? { ...u, open: !1 } : u) };
    }
    case "REMOVE_TOAST": return r.toastId === void 0 ? { ...t, toasts: [] } : { ...t, toasts: t.toasts.filter(o => o.id !== r.toastId) };
} }, J1 = [];
let ew = { toasts: [] };
function iv(t) { ew = yG(ew, t), J1.forEach(r => { r(ew); }); }
function vG({ ...t }) { const r = _G(), o = g => iv({ type: "UPDATE_TOAST", toast: { ...g, id: r } }), u = () => iv({ type: "DISMISS_TOAST", toastId: r }); return iv({ type: "ADD_TOAST", toast: { ...t, id: r, open: !0, onOpenChange: g => { g || u(); } } }), { id: r, dismiss: u, update: o }; }
function fc() { const [t, r] = ne.useState(ew); return ne.useEffect(() => (J1.push(r), () => { const o = J1.indexOf(r); o > -1 && J1.splice(o, 1); }), [t]), { ...t, toast: vG, dismiss: o => iv({ type: "DISMISS_TOAST", toastId: o }) }; }
function qr(t, r, { checkForDefaultPrevented: o = !0 } = {}) { return function (g) { if (t == null || t(g), o === !1 || !g.defaultPrevented)
    return r == null ? void 0 : r(g); }; }
function ZD(t, r) { if (typeof t == "function")
    return t(r); t != null && (t.current = r); }
function gb(...t) { return r => { let o = !1; const u = t.map(g => { const y = ZD(g, r); return !o && typeof y == "function" && (o = !0), y; }); if (o)
    return () => { for (let g = 0; g < u.length; g++) {
        const y = u[g];
        typeof y == "function" ? y() : ZD(t[g], null);
    } }; }; }
function is(...t) { return ne.useCallback(gb(...t), t); }
function xG(t, r) { const o = ne.createContext(r), u = y => { const { children: E, ...s } = y, k = ne.useMemo(() => s, Object.values(s)); return j.jsx(o.Provider, { value: k, children: E }); }; u.displayName = t + "Provider"; function g(y) { const E = ne.useContext(o); if (E)
    return E; if (r !== void 0)
    return r; throw new Error(`\`${y}\` must be used within \`${t}\``); } return [u, g]; }
function pc(t, r = []) { let o = []; function u(y, E) { const s = ne.createContext(E), k = o.length; o = [...o, E]; const L = V => { var ie; const { scope: H, children: ee, ...ce } = V, J = ((ie = H == null ? void 0 : H[t]) == null ? void 0 : ie[k]) || s, ye = ne.useMemo(() => ce, Object.values(ce)); return j.jsx(J.Provider, { value: ye, children: ee }); }; L.displayName = y + "Provider"; function N(V, H) { var J; const ee = ((J = H == null ? void 0 : H[t]) == null ? void 0 : J[k]) || s, ce = ne.useContext(ee); if (ce)
    return ce; if (E !== void 0)
    return E; throw new Error(`\`${V}\` must be used within \`${y}\``); } return [L, N]; } const g = () => { const y = o.map(E => ne.createContext(E)); return function (s) { const k = (s == null ? void 0 : s[t]) || y; return ne.useMemo(() => ({ [`__scope${t}`]: { ...s, [t]: k } }), [s, k]); }; }; return g.scopeName = t, [u, wG(g, ...r)]; }
function wG(...t) { const r = t[0]; if (t.length === 1)
    return r; const o = () => { const u = t.map(g => ({ useScope: g(), scopeName: g.scopeName })); return function (y) { const E = u.reduce((s, { useScope: k, scopeName: L }) => { const V = k(y)[`__scope${L}`]; return { ...s, ...V }; }, {}); return ne.useMemo(() => ({ [`__scope${r.scopeName}`]: E }), [E]); }; }; return o.scopeName = r.scopeName, o; }
function fg(t) { const r = TG(t), o = ne.forwardRef((u, g) => { const { children: y, ...E } = u, s = ne.Children.toArray(y), k = s.find(EG); if (k) {
    const L = k.props.children, N = s.map(V => V === k ? ne.Children.count(L) > 1 ? ne.Children.only(null) : ne.isValidElement(L) ? L.props.children : null : V);
    return j.jsx(r, { ...E, ref: g, children: ne.isValidElement(L) ? ne.cloneElement(L, void 0, N) : null });
} return j.jsx(r, { ...E, ref: g, children: y }); }); return o.displayName = `${t}.Slot`, o; }
var bG = fg("Slot");
function TG(t) { const r = ne.forwardRef((o, u) => { const { children: g, ...y } = o; if (ne.isValidElement(g)) {
    const E = AG(g), s = CG(y, g.props);
    return g.type !== ne.Fragment && (s.ref = u ? gb(u, E) : E), ne.cloneElement(g, s);
} return ne.Children.count(g) > 1 ? ne.Children.only(null) : null; }); return r.displayName = `${t}.SlotClone`, r; }
var sF = Symbol("radix.slottable");
function SG(t) { const r = ({ children: o }) => j.jsx(j.Fragment, { children: o }); return r.displayName = `${t}.Slottable`, r.__radixId = sF, r; }
function EG(t) { return ne.isValidElement(t) && typeof t.type == "function" && "__radixId" in t.type && t.type.__radixId === sF; }
function CG(t, r) { const o = { ...r }; for (const u in r) {
    const g = t[u], y = r[u];
    /^on[A-Z]/.test(u) ? g && y ? o[u] = (...s) => { y(...s), g(...s); } : g && (o[u] = g) : u === "style" ? o[u] = { ...g, ...y } : u === "className" && (o[u] = [g, y].filter(Boolean).join(" "));
} return { ...t, ...o }; }
function AG(t) { var u, g; let r = (u = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : u.get, o = r && "isReactWarning" in r && r.isReactWarning; return o ? t.ref : (r = (g = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : g.get, o = r && "isReactWarning" in r && r.isReactWarning, o ? t.props.ref : t.props.ref || t.ref); }
function CA(t) { const r = t + "CollectionProvider", [o, u] = pc(r), [g, y] = o(r, { collectionRef: { current: null }, itemMap: new Map }), E = J => { const { scope: ye, children: ie } = J, Q = bs.useRef(null), ue = bs.useRef(new Map).current; return j.jsx(g, { scope: ye, itemMap: ue, collectionRef: Q, children: ie }); }; E.displayName = r; const s = t + "CollectionSlot", k = fg(s), L = bs.forwardRef((J, ye) => { const { scope: ie, children: Q } = J, ue = y(s, ie), be = is(ye, ue.collectionRef); return j.jsx(k, { ref: be, children: Q }); }); L.displayName = s; const N = t + "CollectionItemSlot", V = "data-radix-collection-item", H = fg(N), ee = bs.forwardRef((J, ye) => { const { scope: ie, children: Q, ...ue } = J, be = bs.useRef(null), Ie = is(ye, be), Be = y(N, ie); return bs.useEffect(() => (Be.itemMap.set(be, { ref: be, ...ue }), () => void Be.itemMap.delete(be))), j.jsx(H, { [V]: "", ref: Ie, children: Q }); }); ee.displayName = N; function ce(J) { const ye = y(t + "CollectionConsumer", J); return bs.useCallback(() => { const Q = ye.collectionRef.current; if (!Q)
    return []; const ue = Array.from(Q.querySelectorAll(`[${V}]`)); return Array.from(ye.itemMap.values()).sort((Be, Ze) => ue.indexOf(Be.ref.current) - ue.indexOf(Ze.ref.current)); }, [ye.collectionRef, ye.itemMap]); } return [{ Provider: E, Slot: L, ItemSlot: ee }, ce, u]; }
var IG = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"], si = IG.reduce((t, r) => { const o = fg(`Primitive.${r}`), u = ne.forwardRef((g, y) => { const { asChild: E, ...s } = g, k = E ? o : r; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), j.jsx(k, { ...s, ref: y }); }); return u.displayName = `Primitive.${r}`, { ...t, [r]: u }; }, {});
function AA(t, r) { t && r0.flushSync(() => t.dispatchEvent(r)); }
function To(t) { const r = ne.useRef(t); return ne.useEffect(() => { r.current = t; }), ne.useMemo(() => (...o) => { var u; return (u = r.current) == null ? void 0 : u.call(r, ...o); }, []); }
function PG(t, r = globalThis == null ? void 0 : globalThis.document) { const o = To(t); ne.useEffect(() => { const u = g => { g.key === "Escape" && o(g); }; return r.addEventListener("keydown", u, { capture: !0 }), () => r.removeEventListener("keydown", u, { capture: !0 }); }, [o, r]); }
var MG = "DismissableLayer", Y2 = "dismissableLayer.update", RG = "dismissableLayer.pointerDownOutside", kG = "dismissableLayer.focusOutside", XD, oF = ne.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), i0 = ne.forwardRef((t, r) => { const { disableOutsidePointerEvents: o = !1, onEscapeKeyDown: u, onPointerDownOutside: g, onFocusOutside: y, onInteractOutside: E, onDismiss: s, ...k } = t, L = ne.useContext(oF), [N, V] = ne.useState(null), H = (N == null ? void 0 : N.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, ee] = ne.useState({}), ce = is(r, Ze => V(Ze)), J = Array.from(L.layers), [ye] = [...L.layersWithOutsidePointerEventsDisabled].slice(-1), ie = J.indexOf(ye), Q = N ? J.indexOf(N) : -1, ue = L.layersWithOutsidePointerEventsDisabled.size > 0, be = Q >= ie, Ie = LG(Ze => { const ot = Ze.target, At = [...L.branches].some(kt => kt.contains(ot)); !be || At || (g == null || g(Ze), E == null || E(Ze), Ze.defaultPrevented || s == null || s()); }, H), Be = OG(Ze => { const ot = Ze.target; [...L.branches].some(kt => kt.contains(ot)) || (y == null || y(Ze), E == null || E(Ze), Ze.defaultPrevented || s == null || s()); }, H); return PG(Ze => { Q === L.layers.size - 1 && (u == null || u(Ze), !Ze.defaultPrevented && s && (Ze.preventDefault(), s())); }, H), ne.useEffect(() => { if (N)
    return o && (L.layersWithOutsidePointerEventsDisabled.size === 0 && (XD = H.body.style.pointerEvents, H.body.style.pointerEvents = "none"), L.layersWithOutsidePointerEventsDisabled.add(N)), L.layers.add(N), KD(), () => { o && L.layersWithOutsidePointerEventsDisabled.size === 1 && (H.body.style.pointerEvents = XD); }; }, [N, H, o, L]), ne.useEffect(() => () => { N && (L.layers.delete(N), L.layersWithOutsidePointerEventsDisabled.delete(N), KD()); }, [N, L]), ne.useEffect(() => { const Ze = () => ee({}); return document.addEventListener(Y2, Ze), () => document.removeEventListener(Y2, Ze); }, []), j.jsx(si.div, { ...k, ref: ce, style: { pointerEvents: ue ? be ? "auto" : "none" : void 0, ...t.style }, onFocusCapture: qr(t.onFocusCapture, Be.onFocusCapture), onBlurCapture: qr(t.onBlurCapture, Be.onBlurCapture), onPointerDownCapture: qr(t.onPointerDownCapture, Ie.onPointerDownCapture) }); });
i0.displayName = MG;
var DG = "DismissableLayerBranch", aF = ne.forwardRef((t, r) => { const o = ne.useContext(oF), u = ne.useRef(null), g = is(r, u); return ne.useEffect(() => { const y = u.current; if (y)
    return o.branches.add(y), () => { o.branches.delete(y); }; }, [o.branches]), j.jsx(si.div, { ...t, ref: g }); });
aF.displayName = DG;
function LG(t, r = globalThis == null ? void 0 : globalThis.document) { const o = To(t), u = ne.useRef(!1), g = ne.useRef(() => { }); return ne.useEffect(() => { const y = s => { if (s.target && !u.current) {
    let k = function () { lF(RG, o, L, { discrete: !0 }); };
    const L = { originalEvent: s };
    s.pointerType === "touch" ? (r.removeEventListener("click", g.current), g.current = k, r.addEventListener("click", g.current, { once: !0 })) : k();
}
else
    r.removeEventListener("click", g.current); u.current = !1; }, E = window.setTimeout(() => { r.addEventListener("pointerdown", y); }, 0); return () => { window.clearTimeout(E), r.removeEventListener("pointerdown", y), r.removeEventListener("click", g.current); }; }, [r, o]), { onPointerDownCapture: () => u.current = !0 }; }
function OG(t, r = globalThis == null ? void 0 : globalThis.document) { const o = To(t), u = ne.useRef(!1); return ne.useEffect(() => { const g = y => { y.target && !u.current && lF(kG, o, { originalEvent: y }, { discrete: !1 }); }; return r.addEventListener("focusin", g), () => r.removeEventListener("focusin", g); }, [r, o]), { onFocusCapture: () => u.current = !0, onBlurCapture: () => u.current = !1 }; }
function KD() { const t = new CustomEvent(Y2); document.dispatchEvent(t); }
function lF(t, r, o, { discrete: u }) { const g = o.originalEvent.target, y = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: o }); r && g.addEventListener(t, r, { once: !0 }), u ? AA(g, y) : g.dispatchEvent(y); }
var zG = i0, FG = aF, Hh = globalThis != null && globalThis.document ? ne.useLayoutEffect : () => { }, NG = "Portal", _b = ne.forwardRef((t, r) => { var s; const { container: o, ...u } = t, [g, y] = ne.useState(!1); Hh(() => y(!0), []); const E = o || g && ((s = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : s.body); return E ? s8.createPortal(j.jsx(si.div, { ...u, ref: r }), E) : null; });
_b.displayName = NG;
function BG(t, r) { return ne.useReducer((o, u) => r[o][u] ?? o, t); }
var Va = t => { const { present: r, children: o } = t, u = jG(r), g = typeof o == "function" ? o({ present: u.isPresent }) : ne.Children.only(o), y = is(u.ref, VG(g)); return typeof o == "function" || u.isPresent ? ne.cloneElement(g, { ref: y }) : null; };
Va.displayName = "Presence";
function jG(t) { const [r, o] = ne.useState(), u = ne.useRef({}), g = ne.useRef(t), y = ne.useRef("none"), E = t ? "mounted" : "unmounted", [s, k] = BG(E, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }); return ne.useEffect(() => { const L = P1(u.current); y.current = s === "mounted" ? L : "none"; }, [s]), Hh(() => { const L = u.current, N = g.current; if (N !== t) {
    const H = y.current, ee = P1(L);
    t ? k("MOUNT") : ee === "none" || (L == null ? void 0 : L.display) === "none" ? k("UNMOUNT") : k(N && H !== ee ? "ANIMATION_OUT" : "UNMOUNT"), g.current = t;
} }, [t, k]), Hh(() => { if (r) {
    let L;
    const N = r.ownerDocument.defaultView ?? window, V = ee => { const J = P1(u.current).includes(ee.animationName); if (ee.target === r && J && (k("ANIMATION_END"), !g.current)) {
        const ye = r.style.animationFillMode;
        r.style.animationFillMode = "forwards", L = N.setTimeout(() => { r.style.animationFillMode === "forwards" && (r.style.animationFillMode = ye); });
    } }, H = ee => { ee.target === r && (y.current = P1(u.current)); };
    return r.addEventListener("animationstart", H), r.addEventListener("animationcancel", V), r.addEventListener("animationend", V), () => { N.clearTimeout(L), r.removeEventListener("animationstart", H), r.removeEventListener("animationcancel", V), r.removeEventListener("animationend", V); };
}
else
    k("ANIMATION_END"); }, [r, k]), { isPresent: ["mounted", "unmountSuspended"].includes(s), ref: ne.useCallback(L => { L && (u.current = getComputedStyle(L)), o(L); }, []) }; }
function P1(t) { return (t == null ? void 0 : t.animationName) || "none"; }
function VG(t) { var u, g; let r = (u = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : u.get, o = r && "isReactWarning" in r && r.isReactWarning; return o ? t.ref : (r = (g = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : g.get, o = r && "isReactWarning" in r && r.isReactWarning, o ? t.props.ref : t.props.ref || t.ref); }
function Cg({ prop: t, defaultProp: r, onChange: o = () => { } }) { const [u, g] = UG({ defaultProp: r, onChange: o }), y = t !== void 0, E = y ? t : u, s = To(o), k = ne.useCallback(L => { if (y) {
    const V = typeof L == "function" ? L(t) : L;
    V !== t && s(V);
}
else
    g(L); }, [y, t, g, s]); return [E, k]; }
function UG({ defaultProp: t, onChange: r }) { const o = ne.useState(t), [u] = o, g = ne.useRef(u), y = To(r); return ne.useEffect(() => { g.current !== u && (y(u), g.current = u); }, [u, g, y]), o; }
var $G = "VisuallyHidden", yb = ne.forwardRef((t, r) => j.jsx(si.span, { ...t, ref: r, style: { position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal", ...t.style } }));
yb.displayName = $G;
var GG = yb, IA = "ToastProvider", [PA, qG, HG] = CA("Toast"), [cF, aee] = pc("Toast", [HG]), [WG, vb] = cF(IA), uF = t => { const { __scopeToast: r, label: o = "Notification", duration: u = 5e3, swipeDirection: g = "right", swipeThreshold: y = 50, children: E } = t, [s, k] = ne.useState(null), [L, N] = ne.useState(0), V = ne.useRef(!1), H = ne.useRef(!1); return o.trim() || console.error(`Invalid prop \`label\` supplied to \`${IA}\`. Expected non-empty \`string\`.`), j.jsx(PA.Provider, { scope: r, children: j.jsx(WG, { scope: r, label: o, duration: u, swipeDirection: g, swipeThreshold: y, toastCount: L, viewport: s, onViewportChange: k, onToastAdd: ne.useCallback(() => N(ee => ee + 1), []), onToastRemove: ne.useCallback(() => N(ee => ee - 1), []), isFocusedToastEscapeKeyDownRef: V, isClosePausedRef: H, children: E }) }); };
uF.displayName = IA;
var hF = "ToastViewport", ZG = ["F8"], Q2 = "toast.viewportPause", J2 = "toast.viewportResume", dF = ne.forwardRef((t, r) => { const { __scopeToast: o, hotkey: u = ZG, label: g = "Notifications ({hotkey})", ...y } = t, E = vb(hF, o), s = qG(o), k = ne.useRef(null), L = ne.useRef(null), N = ne.useRef(null), V = ne.useRef(null), H = is(r, V, E.onViewportChange), ee = u.join("+").replace(/Key/g, "").replace(/Digit/g, ""), ce = E.toastCount > 0; ne.useEffect(() => { const ye = ie => { var ue; u.length !== 0 && u.every(be => ie[be] || ie.code === be) && ((ue = V.current) == null || ue.focus()); }; return document.addEventListener("keydown", ye), () => document.removeEventListener("keydown", ye); }, [u]), ne.useEffect(() => { const ye = k.current, ie = V.current; if (ce && ye && ie) {
    const Q = () => { if (!E.isClosePausedRef.current) {
        const Be = new CustomEvent(Q2);
        ie.dispatchEvent(Be), E.isClosePausedRef.current = !0;
    } }, ue = () => { if (E.isClosePausedRef.current) {
        const Be = new CustomEvent(J2);
        ie.dispatchEvent(Be), E.isClosePausedRef.current = !1;
    } }, be = Be => { !ye.contains(Be.relatedTarget) && ue(); }, Ie = () => { ye.contains(document.activeElement) || ue(); };
    return ye.addEventListener("focusin", Q), ye.addEventListener("focusout", be), ye.addEventListener("pointermove", Q), ye.addEventListener("pointerleave", Ie), window.addEventListener("blur", Q), window.addEventListener("focus", ue), () => { ye.removeEventListener("focusin", Q), ye.removeEventListener("focusout", be), ye.removeEventListener("pointermove", Q), ye.removeEventListener("pointerleave", Ie), window.removeEventListener("blur", Q), window.removeEventListener("focus", ue); };
} }, [ce, E.isClosePausedRef]); const J = ne.useCallback(({ tabbingDirection: ye }) => { const Q = s().map(ue => { const be = ue.ref.current, Ie = [be, ...aq(be)]; return ye === "forwards" ? Ie : Ie.reverse(); }); return (ye === "forwards" ? Q.reverse() : Q).flat(); }, [s]); return ne.useEffect(() => { const ye = V.current; if (ye) {
    const ie = Q => { var Ie, Be, Ze; const ue = Q.altKey || Q.ctrlKey || Q.metaKey; if (Q.key === "Tab" && !ue) {
        const ot = document.activeElement, At = Q.shiftKey;
        if (Q.target === ye && At) {
            (Ie = L.current) == null || Ie.focus();
            return;
        }
        const St = J({ tabbingDirection: At ? "backwards" : "forwards" }), Kt = St.findIndex(bt => bt === ot);
        bE(St.slice(Kt + 1)) ? Q.preventDefault() : At ? (Be = L.current) == null || Be.focus() : (Ze = N.current) == null || Ze.focus();
    } };
    return ye.addEventListener("keydown", ie), () => ye.removeEventListener("keydown", ie);
} }, [s, J]), j.jsxs(FG, { ref: k, role: "region", "aria-label": g.replace("{hotkey}", ee), tabIndex: -1, style: { pointerEvents: ce ? void 0 : "none" }, children: [ce && j.jsx(eC, { ref: L, onFocusFromOutsideViewport: () => { const ye = J({ tabbingDirection: "forwards" }); bE(ye); } }), j.jsx(PA.Slot, { scope: o, children: j.jsx(si.ol, { tabIndex: -1, ...y, ref: H }) }), ce && j.jsx(eC, { ref: N, onFocusFromOutsideViewport: () => { const ye = J({ tabbingDirection: "backwards" }); bE(ye); } })] }); });
dF.displayName = hF;
var fF = "ToastFocusProxy", eC = ne.forwardRef((t, r) => { const { __scopeToast: o, onFocusFromOutsideViewport: u, ...g } = t, y = vb(fF, o); return j.jsx(yb, { "aria-hidden": !0, tabIndex: 0, ...g, ref: r, style: { position: "fixed" }, onFocus: E => { var L; const s = E.relatedTarget; !((L = y.viewport) != null && L.contains(s)) && u(); } }); });
eC.displayName = fF;
var xb = "Toast", XG = "toast.swipeStart", KG = "toast.swipeMove", YG = "toast.swipeCancel", QG = "toast.swipeEnd", pF = ne.forwardRef((t, r) => { const { forceMount: o, open: u, defaultOpen: g, onOpenChange: y, ...E } = t, [s = !0, k] = Cg({ prop: u, defaultProp: g, onChange: y }); return j.jsx(Va, { present: o || s, children: j.jsx(tq, { open: s, ...E, ref: r, onClose: () => k(!1), onPause: To(t.onPause), onResume: To(t.onResume), onSwipeStart: qr(t.onSwipeStart, L => { L.currentTarget.setAttribute("data-swipe", "start"); }), onSwipeMove: qr(t.onSwipeMove, L => { const { x: N, y: V } = L.detail.delta; L.currentTarget.setAttribute("data-swipe", "move"), L.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${N}px`), L.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${V}px`); }), onSwipeCancel: qr(t.onSwipeCancel, L => { L.currentTarget.setAttribute("data-swipe", "cancel"), L.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), L.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), L.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), L.currentTarget.style.removeProperty("--radix-toast-swipe-end-y"); }), onSwipeEnd: qr(t.onSwipeEnd, L => { const { x: N, y: V } = L.detail.delta; L.currentTarget.setAttribute("data-swipe", "end"), L.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), L.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), L.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${N}px`), L.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${V}px`), k(!1); }) }) }); });
pF.displayName = xb;
var [JG, eq] = cF(xb, { onClose() { } }), tq = ne.forwardRef((t, r) => { const { __scopeToast: o, type: u = "foreground", duration: g, open: y, onClose: E, onEscapeKeyDown: s, onPause: k, onResume: L, onSwipeStart: N, onSwipeMove: V, onSwipeCancel: H, onSwipeEnd: ee, ...ce } = t, J = vb(xb, o), [ye, ie] = ne.useState(null), Q = is(r, bt => ie(bt)), ue = ne.useRef(null), be = ne.useRef(null), Ie = g || J.duration, Be = ne.useRef(0), Ze = ne.useRef(Ie), ot = ne.useRef(0), { onToastAdd: At, onToastRemove: kt } = J, ct = To(() => { var ir; (ye == null ? void 0 : ye.contains(document.activeElement)) && ((ir = J.viewport) == null || ir.focus()), E(); }), St = ne.useCallback(bt => { !bt || bt === 1 / 0 || (window.clearTimeout(ot.current), Be.current = new Date().getTime(), ot.current = window.setTimeout(ct, bt)); }, [ct]); ne.useEffect(() => { const bt = J.viewport; if (bt) {
    const ir = () => { St(Ze.current), L == null || L(); }, tr = () => { const Or = new Date().getTime() - Be.current; Ze.current = Ze.current - Or, window.clearTimeout(ot.current), k == null || k(); };
    return bt.addEventListener(Q2, tr), bt.addEventListener(J2, ir), () => { bt.removeEventListener(Q2, tr), bt.removeEventListener(J2, ir); };
} }, [J.viewport, Ie, k, L, St]), ne.useEffect(() => { y && !J.isClosePausedRef.current && St(Ie); }, [y, Ie, J.isClosePausedRef, St]), ne.useEffect(() => (At(), () => kt()), [At, kt]); const Kt = ne.useMemo(() => ye ? wF(ye) : null, [ye]); return J.viewport ? j.jsxs(j.Fragment, { children: [Kt && j.jsx(rq, { __scopeToast: o, role: "status", "aria-live": u === "foreground" ? "assertive" : "polite", "aria-atomic": !0, children: Kt }), j.jsx(JG, { scope: o, onClose: ct, children: r0.createPortal(j.jsx(PA.ItemSlot, { scope: o, children: j.jsx(zG, { asChild: !0, onEscapeKeyDown: qr(s, () => { J.isFocusedToastEscapeKeyDownRef.current || ct(), J.isFocusedToastEscapeKeyDownRef.current = !1; }), children: j.jsx(si.li, { role: "status", "aria-live": "off", "aria-atomic": !0, tabIndex: 0, "data-state": y ? "open" : "closed", "data-swipe-direction": J.swipeDirection, ...ce, ref: Q, style: { userSelect: "none", touchAction: "none", ...t.style }, onKeyDown: qr(t.onKeyDown, bt => { bt.key === "Escape" && (s == null || s(bt.nativeEvent), bt.nativeEvent.defaultPrevented || (J.isFocusedToastEscapeKeyDownRef.current = !0, ct())); }), onPointerDown: qr(t.onPointerDown, bt => { bt.button === 0 && (ue.current = { x: bt.clientX, y: bt.clientY }); }), onPointerMove: qr(t.onPointerMove, bt => { if (!ue.current)
                            return; const ir = bt.clientX - ue.current.x, tr = bt.clientY - ue.current.y, Or = !!be.current, xt = ["left", "right"].includes(J.swipeDirection), Pt = ["left", "up"].includes(J.swipeDirection) ? Math.min : Math.max, Ft = xt ? Pt(0, ir) : 0, gr = xt ? 0 : Pt(0, tr), Jr = bt.pointerType === "touch" ? 10 : 2, pi = { x: Ft, y: gr }, Si = { originalEvent: bt, delta: pi }; Or ? (be.current = pi, M1(KG, V, Si, { discrete: !1 })) : YD(pi, J.swipeDirection, Jr) ? (be.current = pi, M1(XG, N, Si, { discrete: !1 }), bt.target.setPointerCapture(bt.pointerId)) : (Math.abs(ir) > Jr || Math.abs(tr) > Jr) && (ue.current = null); }), onPointerUp: qr(t.onPointerUp, bt => { const ir = be.current, tr = bt.target; if (tr.hasPointerCapture(bt.pointerId) && tr.releasePointerCapture(bt.pointerId), be.current = null, ue.current = null, ir) {
                            const Or = bt.currentTarget, xt = { originalEvent: bt, delta: ir };
                            YD(ir, J.swipeDirection, J.swipeThreshold) ? M1(QG, ee, xt, { discrete: !0 }) : M1(YG, H, xt, { discrete: !0 }), Or.addEventListener("click", Pt => Pt.preventDefault(), { once: !0 });
                        } }) }) }) }), J.viewport) })] }) : null; }), rq = t => { const { __scopeToast: r, children: o, ...u } = t, g = vb(xb, r), [y, E] = ne.useState(!1), [s, k] = ne.useState(!1); return sq(() => E(!0)), ne.useEffect(() => { const L = window.setTimeout(() => k(!0), 1e3); return () => window.clearTimeout(L); }, []), s ? null : j.jsx(_b, { asChild: !0, children: j.jsx(yb, { ...u, children: y && j.jsxs(j.Fragment, { children: [g.label, " ", o] }) }) }); }, nq = "ToastTitle", mF = ne.forwardRef((t, r) => { const { __scopeToast: o, ...u } = t; return j.jsx(si.div, { ...u, ref: r }); });
mF.displayName = nq;
var iq = "ToastDescription", gF = ne.forwardRef((t, r) => { const { __scopeToast: o, ...u } = t; return j.jsx(si.div, { ...u, ref: r }); });
gF.displayName = iq;
var _F = "ToastAction", yF = ne.forwardRef((t, r) => { const { altText: o, ...u } = t; return o.trim() ? j.jsx(xF, { altText: o, asChild: !0, children: j.jsx(MA, { ...u, ref: r }) }) : (console.error(`Invalid prop \`altText\` supplied to \`${_F}\`. Expected non-empty \`string\`.`), null); });
yF.displayName = _F;
var vF = "ToastClose", MA = ne.forwardRef((t, r) => { const { __scopeToast: o, ...u } = t, g = eq(vF, o); return j.jsx(xF, { asChild: !0, children: j.jsx(si.button, { type: "button", ...u, ref: r, onClick: qr(t.onClick, g.onClose) }) }); });
MA.displayName = vF;
var xF = ne.forwardRef((t, r) => { const { __scopeToast: o, altText: u, ...g } = t; return j.jsx(si.div, { "data-radix-toast-announce-exclude": "", "data-radix-toast-announce-alt": u || void 0, ...g, ref: r }); });
function wF(t) { const r = []; return Array.from(t.childNodes).forEach(u => { if (u.nodeType === u.TEXT_NODE && u.textContent && r.push(u.textContent), oq(u)) {
    const g = u.ariaHidden || u.hidden || u.style.display === "none", y = u.dataset.radixToastAnnounceExclude === "";
    if (!g)
        if (y) {
            const E = u.dataset.radixToastAnnounceAlt;
            E && r.push(E);
        }
        else
            r.push(...wF(u));
} }), r; }
function M1(t, r, o, { discrete: u }) { const g = o.originalEvent.currentTarget, y = new CustomEvent(t, { bubbles: !0, cancelable: !0, detail: o }); r && g.addEventListener(t, r, { once: !0 }), u ? AA(g, y) : g.dispatchEvent(y); }
var YD = (t, r, o = 0) => { const u = Math.abs(t.x), g = Math.abs(t.y), y = u > g; return r === "left" || r === "right" ? y && u > o : !y && g > o; };
function sq(t = () => { }) { const r = To(t); Hh(() => { let o = 0, u = 0; return o = window.requestAnimationFrame(() => u = window.requestAnimationFrame(r)), () => { window.cancelAnimationFrame(o), window.cancelAnimationFrame(u); }; }, [r]); }
function oq(t) { return t.nodeType === t.ELEMENT_NODE; }
function aq(t) { const r = [], o = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, { acceptNode: u => { const g = u.tagName === "INPUT" && u.type === "hidden"; return u.disabled || u.hidden || g ? NodeFilter.FILTER_SKIP : u.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; } }); for (; o.nextNode();)
    r.push(o.currentNode); return r; }
function bE(t) { const r = document.activeElement; return t.some(o => o === r ? !0 : (o.focus(), document.activeElement !== r)); }
var lq = uF, bF = dF, TF = pF, SF = mF, EF = gF, CF = yF, AF = MA;
function IF(t) { var r, o, u = ""; if (typeof t == "string" || typeof t == "number")
    u += t;
else if (typeof t == "object")
    if (Array.isArray(t)) {
        var g = t.length;
        for (r = 0; r < g; r++)
            t[r] && (o = IF(t[r])) && (u && (u += " "), u += o);
    }
    else
        for (o in t)
            t[o] && (u && (u += " "), u += o); return u; }
function PF() { for (var t, r, o = 0, u = "", g = arguments.length; o < g; o++)
    (t = arguments[o]) && (r = IF(t)) && (u && (u += " "), u += r); return u; }
const QD = t => typeof t == "boolean" ? `${t}` : t === 0 ? "0" : t, JD = PF, wb = (t, r) => o => { var u; if ((r == null ? void 0 : r.variants) == null)
    return JD(t, o == null ? void 0 : o.class, o == null ? void 0 : o.className); const { variants: g, defaultVariants: y } = r, E = Object.keys(g).map(L => { const N = o == null ? void 0 : o[L], V = y == null ? void 0 : y[L]; if (N === null)
    return null; const H = QD(N) || QD(V); return g[L][H]; }), s = o && Object.entries(o).reduce((L, N) => { let [V, H] = N; return H === void 0 || (L[V] = H), L; }, {}), k = r == null || (u = r.compoundVariants) === null || u === void 0 ? void 0 : u.reduce((L, N) => { let { class: V, className: H, ...ee } = N; return Object.entries(ee).every(ce => { let [J, ye] = ce; return Array.isArray(ye) ? ye.includes({ ...y, ...s }[J]) : { ...y, ...s }[J] === ye; }) ? [...L, V, H] : L; }, []); return JD(t, E, k, o == null ? void 0 : o.class, o == null ? void 0 : o.className); }; /**
* @license lucide-react v0.453.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const cq = t => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), MF = (...t) => t.filter((r, o, u) => !!r && u.indexOf(r) === o).join(" "); /**
* @license lucide-react v0.453.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
var uq = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }; /**
* @license lucide-react v0.453.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const hq = ne.forwardRef(({ color: t = "currentColor", size: r = 24, strokeWidth: o = 2, absoluteStrokeWidth: u, className: g = "", children: y, iconNode: E, ...s }, k) => ne.createElement("svg", { ref: k, ...uq, width: r, height: r, stroke: t, strokeWidth: u ? Number(o) * 24 / Number(r) : o, className: MF("lucide", g), ...s }, [...E.map(([L, N]) => ne.createElement(L, N)), ...Array.isArray(y) ? y : [y]])); /**
* @license lucide-react v0.453.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const fu = (t, r) => { const o = ne.forwardRef(({ className: u, ...g }, y) => ne.createElement(hq, { ref: y, iconNode: r, className: MF(`lucide-${cq(t)}`, u), ...g })); return o.displayName = `${t}`, o; }; /**
* @license lucide-react v0.453.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const RF = fu("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]); /**
* @license lucide-react v0.453.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const dq = fu("ChevronRight", [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]]); /**
* @license lucide-react v0.453.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const RA = fu("CircleAlert", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]]); /**
* @license lucide-react v0.453.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const fq = fu("Circle", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]]); /**
* @license lucide-react v0.453.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const pq = fu("LogOut", [["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }], ["polyline", { points: "16 17 21 12 16 7", key: "1gabdz" }], ["line", { x1: "21", x2: "9", y1: "12", y2: "12", key: "1uyos4" }]]); /**
* @license lucide-react v0.453.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const mq = fu("Search", [["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }], ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]]); /**
* @license lucide-react v0.453.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const gq = fu("SquarePen", [["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7", key: "1m0v6g" }], ["path", { d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z", key: "ohrbg2" }]]); /**
* @license lucide-react v0.453.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const _q = fu("Trash2", [["path", { d: "M3 6h18", key: "d0wm0j" }], ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }], ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }], ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }], ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]]); /**
* @license lucide-react v0.453.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const kF = fu("X", [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]]), kA = "-", yq = t => { const r = xq(t), { conflictingClassGroups: o, conflictingClassGroupModifiers: u } = t; return { getClassGroupId: E => { const s = E.split(kA); return s[0] === "" && s.length !== 1 && s.shift(), DF(s, r) || vq(E); }, getConflictingClassGroupIds: (E, s) => { const k = o[E] || []; return s && u[E] ? [...k, ...u[E]] : k; } }; }, DF = (t, r) => { var E; if (t.length === 0)
    return r.classGroupId; const o = t[0], u = r.nextPart.get(o), g = u ? DF(t.slice(1), u) : void 0; if (g)
    return g; if (r.validators.length === 0)
    return; const y = t.join(kA); return (E = r.validators.find(({ validator: s }) => s(y))) == null ? void 0 : E.classGroupId; }, eL = /^\[(.+)\]$/, vq = t => { if (eL.test(t)) {
    const r = eL.exec(t)[1], o = r == null ? void 0 : r.substring(0, r.indexOf(":"));
    if (o)
        return "arbitrary.." + o;
} }, xq = t => { const { theme: r, prefix: o } = t, u = { nextPart: new Map, validators: [] }; return bq(Object.entries(t.classGroups), o).forEach(([y, E]) => { tC(E, u, y, r); }), u; }, tC = (t, r, o, u) => { t.forEach(g => { if (typeof g == "string") {
    const y = g === "" ? r : tL(r, g);
    y.classGroupId = o;
    return;
} if (typeof g == "function") {
    if (wq(g)) {
        tC(g(u), r, o, u);
        return;
    }
    r.validators.push({ validator: g, classGroupId: o });
    return;
} Object.entries(g).forEach(([y, E]) => { tC(E, tL(r, y), o, u); }); }); }, tL = (t, r) => { let o = t; return r.split(kA).forEach(u => { o.nextPart.has(u) || o.nextPart.set(u, { nextPart: new Map, validators: [] }), o = o.nextPart.get(u); }), o; }, wq = t => t.isThemeGetter, bq = (t, r) => r ? t.map(([o, u]) => { const g = u.map(y => typeof y == "string" ? r + y : typeof y == "object" ? Object.fromEntries(Object.entries(y).map(([E, s]) => [r + E, s])) : y); return [o, g]; }) : t, Tq = t => { if (t < 1)
    return { get: () => { }, set: () => { } }; let r = 0, o = new Map, u = new Map; const g = (y, E) => { o.set(y, E), r++, r > t && (r = 0, u = o, o = new Map); }; return { get(y) { let E = o.get(y); if (E !== void 0)
        return E; if ((E = u.get(y)) !== void 0)
        return g(y, E), E; }, set(y, E) { o.has(y) ? o.set(y, E) : g(y, E); } }; }, LF = "!", Sq = t => { const { separator: r, experimentalParseClassName: o } = t, u = r.length === 1, g = r[0], y = r.length, E = s => { const k = []; let L = 0, N = 0, V; for (let ye = 0; ye < s.length; ye++) {
    let ie = s[ye];
    if (L === 0) {
        if (ie === g && (u || s.slice(ye, ye + y) === r)) {
            k.push(s.slice(N, ye)), N = ye + y;
            continue;
        }
        if (ie === "/") {
            V = ye;
            continue;
        }
    }
    ie === "[" ? L++ : ie === "]" && L--;
} const H = k.length === 0 ? s : s.substring(N), ee = H.startsWith(LF), ce = ee ? H.substring(1) : H, J = V && V > N ? V - N : void 0; return { modifiers: k, hasImportantModifier: ee, baseClassName: ce, maybePostfixModifierPosition: J }; }; return o ? s => o({ className: s, parseClassName: E }) : E; }, Eq = t => { if (t.length <= 1)
    return t; const r = []; let o = []; return t.forEach(u => { u[0] === "[" ? (r.push(...o.sort(), u), o = []) : o.push(u); }), r.push(...o.sort()), r; }, Cq = t => ({ cache: Tq(t.cacheSize), parseClassName: Sq(t), ...yq(t) }), Aq = /\s+/, Iq = (t, r) => { const { parseClassName: o, getClassGroupId: u, getConflictingClassGroupIds: g } = r, y = [], E = t.trim().split(Aq); let s = ""; for (let k = E.length - 1; k >= 0; k -= 1) {
    const L = E[k], { modifiers: N, hasImportantModifier: V, baseClassName: H, maybePostfixModifierPosition: ee } = o(L);
    let ce = !!ee, J = u(ce ? H.substring(0, ee) : H);
    if (!J) {
        if (!ce) {
            s = L + (s.length > 0 ? " " + s : s);
            continue;
        }
        if (J = u(H), !J) {
            s = L + (s.length > 0 ? " " + s : s);
            continue;
        }
        ce = !1;
    }
    const ye = Eq(N).join(":"), ie = V ? ye + LF : ye, Q = ie + J;
    if (y.includes(Q))
        continue;
    y.push(Q);
    const ue = g(J, ce);
    for (let be = 0; be < ue.length; ++be) {
        const Ie = ue[be];
        y.push(ie + Ie);
    }
    s = L + (s.length > 0 ? " " + s : s);
} return s; };
function Pq() { let t = 0, r, o, u = ""; for (; t < arguments.length;)
    (r = arguments[t++]) && (o = OF(r)) && (u && (u += " "), u += o); return u; }
const OF = t => { if (typeof t == "string")
    return t; let r, o = ""; for (let u = 0; u < t.length; u++)
    t[u] && (r = OF(t[u])) && (o && (o += " "), o += r); return o; };
function Mq(t, ...r) { let o, u, g, y = E; function E(k) { const L = r.reduce((N, V) => V(N), t()); return o = Cq(L), u = o.cache.get, g = o.cache.set, y = s, s(k); } function s(k) { const L = u(k); if (L)
    return L; const N = Iq(k, o); return g(k, N), N; } return function () { return y(Pq.apply(null, arguments)); }; }
const Fi = t => { const r = o => o[t] || []; return r.isThemeGetter = !0, r; }, zF = /^\[(?:([a-z-]+):)?(.+)\]$/i, Rq = /^\d+\/\d+$/, kq = new Set(["px", "full", "screen"]), Dq = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, Lq = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, Oq = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, zq = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, Fq = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Hc = t => Vm(t) || kq.has(t) || Rq.test(t), ah = t => Ag(t, "length", qq), Vm = t => !!t && !Number.isNaN(Number(t)), TE = t => Ag(t, "number", Vm), My = t => !!t && Number.isInteger(Number(t)), Nq = t => t.endsWith("%") && Vm(t.slice(0, -1)), Rn = t => zF.test(t), lh = t => Dq.test(t), Bq = new Set(["length", "size", "percentage"]), jq = t => Ag(t, Bq, FF), Vq = t => Ag(t, "position", FF), Uq = new Set(["image", "url"]), $q = t => Ag(t, Uq, Wq), Gq = t => Ag(t, "", Hq), Ry = () => !0, Ag = (t, r, o) => { const u = zF.exec(t); return u ? u[1] ? typeof r == "string" ? u[1] === r : r.has(u[1]) : o(u[2]) : !1; }, qq = t => Lq.test(t) && !Oq.test(t), FF = () => !1, Hq = t => zq.test(t), Wq = t => Fq.test(t), Zq = () => { const t = Fi("colors"), r = Fi("spacing"), o = Fi("blur"), u = Fi("brightness"), g = Fi("borderColor"), y = Fi("borderRadius"), E = Fi("borderSpacing"), s = Fi("borderWidth"), k = Fi("contrast"), L = Fi("grayscale"), N = Fi("hueRotate"), V = Fi("invert"), H = Fi("gap"), ee = Fi("gradientColorStops"), ce = Fi("gradientColorStopPositions"), J = Fi("inset"), ye = Fi("margin"), ie = Fi("opacity"), Q = Fi("padding"), ue = Fi("saturate"), be = Fi("scale"), Ie = Fi("sepia"), Be = Fi("skew"), Ze = Fi("space"), ot = Fi("translate"), At = () => ["auto", "contain", "none"], kt = () => ["auto", "hidden", "clip", "visible", "scroll"], ct = () => ["auto", Rn, r], St = () => [Rn, r], Kt = () => ["", Hc, ah], bt = () => ["auto", Vm, Rn], ir = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], tr = () => ["solid", "dashed", "dotted", "double", "none"], Or = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], xt = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], Pt = () => ["", "0", Rn], Ft = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], gr = () => [Vm, Rn]; return { cacheSize: 500, separator: ":", theme: { colors: [Ry], spacing: [Hc, ah], blur: ["none", "", lh, Rn], brightness: gr(), borderColor: [t], borderRadius: ["none", "", "full", lh, Rn], borderSpacing: St(), borderWidth: Kt(), contrast: gr(), grayscale: Pt(), hueRotate: gr(), invert: Pt(), gap: St(), gradientColorStops: [t], gradientColorStopPositions: [Nq, ah], inset: ct(), margin: ct(), opacity: gr(), padding: St(), saturate: gr(), scale: gr(), sepia: Pt(), skew: gr(), space: St(), translate: St() }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", Rn] }], container: ["container"], columns: [{ columns: [lh] }], "break-after": [{ "break-after": Ft() }], "break-before": [{ "break-before": Ft() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [...ir(), Rn] }], overflow: [{ overflow: kt() }], "overflow-x": [{ "overflow-x": kt() }], "overflow-y": [{ "overflow-y": kt() }], overscroll: [{ overscroll: At() }], "overscroll-x": [{ "overscroll-x": At() }], "overscroll-y": [{ "overscroll-y": At() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [J] }], "inset-x": [{ "inset-x": [J] }], "inset-y": [{ "inset-y": [J] }], start: [{ start: [J] }], end: [{ end: [J] }], top: [{ top: [J] }], right: [{ right: [J] }], bottom: [{ bottom: [J] }], left: [{ left: [J] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", My, Rn] }], basis: [{ basis: ct() }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", Rn] }], grow: [{ grow: Pt() }], shrink: [{ shrink: Pt() }], order: [{ order: ["first", "last", "none", My, Rn] }], "grid-cols": [{ "grid-cols": [Ry] }], "col-start-end": [{ col: ["auto", { span: ["full", My, Rn] }, Rn] }], "col-start": [{ "col-start": bt() }], "col-end": [{ "col-end": bt() }], "grid-rows": [{ "grid-rows": [Ry] }], "row-start-end": [{ row: ["auto", { span: [My, Rn] }, Rn] }], "row-start": [{ "row-start": bt() }], "row-end": [{ "row-end": bt() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", Rn] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", Rn] }], gap: [{ gap: [H] }], "gap-x": [{ "gap-x": [H] }], "gap-y": [{ "gap-y": [H] }], "justify-content": [{ justify: ["normal", ...xt()] }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal", ...xt(), "baseline"] }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [...xt(), "baseline"] }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [Q] }], px: [{ px: [Q] }], py: [{ py: [Q] }], ps: [{ ps: [Q] }], pe: [{ pe: [Q] }], pt: [{ pt: [Q] }], pr: [{ pr: [Q] }], pb: [{ pb: [Q] }], pl: [{ pl: [Q] }], m: [{ m: [ye] }], mx: [{ mx: [ye] }], my: [{ my: [ye] }], ms: [{ ms: [ye] }], me: [{ me: [ye] }], mt: [{ mt: [ye] }], mr: [{ mr: [ye] }], mb: [{ mb: [ye] }], ml: [{ ml: [ye] }], "space-x": [{ "space-x": [Ze] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [Ze] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Rn, r] }], "min-w": [{ "min-w": [Rn, r, "min", "max", "fit"] }], "max-w": [{ "max-w": [Rn, r, "none", "full", "min", "max", "fit", "prose", { screen: [lh] }, lh] }], h: [{ h: [Rn, r, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }], "min-h": [{ "min-h": [Rn, r, "min", "max", "fit", "svh", "lvh", "dvh"] }], "max-h": [{ "max-h": [Rn, r, "min", "max", "fit", "svh", "lvh", "dvh"] }], size: [{ size: [Rn, r, "auto", "min", "max", "fit"] }], "font-size": [{ text: ["base", lh, ah] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", TE] }], "font-family": [{ font: [Ry] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Rn] }], "line-clamp": [{ "line-clamp": ["none", Vm, TE] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Hc, Rn] }], "list-image": [{ "list-image": ["none", Rn] }], "list-style-type": [{ list: ["none", "disc", "decimal", Rn] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [t] }], "placeholder-opacity": [{ "placeholder-opacity": [ie] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [t] }], "text-opacity": [{ "text-opacity": [ie] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...tr(), "wavy"] }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", Hc, ah] }], "underline-offset": [{ "underline-offset": ["auto", Hc, Rn] }], "text-decoration-color": [{ decoration: [t] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: St() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Rn] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", Rn] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [ie] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [...ir(), Vq] }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", jq] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, $q] }], "bg-color": [{ bg: [t] }], "gradient-from-pos": [{ from: [ce] }], "gradient-via-pos": [{ via: [ce] }], "gradient-to-pos": [{ to: [ce] }], "gradient-from": [{ from: [ee] }], "gradient-via": [{ via: [ee] }], "gradient-to": [{ to: [ee] }], rounded: [{ rounded: [y] }], "rounded-s": [{ "rounded-s": [y] }], "rounded-e": [{ "rounded-e": [y] }], "rounded-t": [{ "rounded-t": [y] }], "rounded-r": [{ "rounded-r": [y] }], "rounded-b": [{ "rounded-b": [y] }], "rounded-l": [{ "rounded-l": [y] }], "rounded-ss": [{ "rounded-ss": [y] }], "rounded-se": [{ "rounded-se": [y] }], "rounded-ee": [{ "rounded-ee": [y] }], "rounded-es": [{ "rounded-es": [y] }], "rounded-tl": [{ "rounded-tl": [y] }], "rounded-tr": [{ "rounded-tr": [y] }], "rounded-br": [{ "rounded-br": [y] }], "rounded-bl": [{ "rounded-bl": [y] }], "border-w": [{ border: [s] }], "border-w-x": [{ "border-x": [s] }], "border-w-y": [{ "border-y": [s] }], "border-w-s": [{ "border-s": [s] }], "border-w-e": [{ "border-e": [s] }], "border-w-t": [{ "border-t": [s] }], "border-w-r": [{ "border-r": [s] }], "border-w-b": [{ "border-b": [s] }], "border-w-l": [{ "border-l": [s] }], "border-opacity": [{ "border-opacity": [ie] }], "border-style": [{ border: [...tr(), "hidden"] }], "divide-x": [{ "divide-x": [s] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [s] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [ie] }], "divide-style": [{ divide: tr() }], "border-color": [{ border: [g] }], "border-color-x": [{ "border-x": [g] }], "border-color-y": [{ "border-y": [g] }], "border-color-s": [{ "border-s": [g] }], "border-color-e": [{ "border-e": [g] }], "border-color-t": [{ "border-t": [g] }], "border-color-r": [{ "border-r": [g] }], "border-color-b": [{ "border-b": [g] }], "border-color-l": [{ "border-l": [g] }], "divide-color": [{ divide: [g] }], "outline-style": [{ outline: ["", ...tr()] }], "outline-offset": [{ "outline-offset": [Hc, Rn] }], "outline-w": [{ outline: [Hc, ah] }], "outline-color": [{ outline: [t] }], "ring-w": [{ ring: Kt() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [t] }], "ring-opacity": [{ "ring-opacity": [ie] }], "ring-offset-w": [{ "ring-offset": [Hc, ah] }], "ring-offset-color": [{ "ring-offset": [t] }], shadow: [{ shadow: ["", "inner", "none", lh, Gq] }], "shadow-color": [{ shadow: [Ry] }], opacity: [{ opacity: [ie] }], "mix-blend": [{ "mix-blend": [...Or(), "plus-lighter", "plus-darker"] }], "bg-blend": [{ "bg-blend": Or() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [o] }], brightness: [{ brightness: [u] }], contrast: [{ contrast: [k] }], "drop-shadow": [{ "drop-shadow": ["", "none", lh, Rn] }], grayscale: [{ grayscale: [L] }], "hue-rotate": [{ "hue-rotate": [N] }], invert: [{ invert: [V] }], saturate: [{ saturate: [ue] }], sepia: [{ sepia: [Ie] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [o] }], "backdrop-brightness": [{ "backdrop-brightness": [u] }], "backdrop-contrast": [{ "backdrop-contrast": [k] }], "backdrop-grayscale": [{ "backdrop-grayscale": [L] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [N] }], "backdrop-invert": [{ "backdrop-invert": [V] }], "backdrop-opacity": [{ "backdrop-opacity": [ie] }], "backdrop-saturate": [{ "backdrop-saturate": [ue] }], "backdrop-sepia": [{ "backdrop-sepia": [Ie] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [E] }], "border-spacing-x": [{ "border-spacing-x": [E] }], "border-spacing-y": [{ "border-spacing-y": [E] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Rn] }], duration: [{ duration: gr() }], ease: [{ ease: ["linear", "in", "out", "in-out", Rn] }], delay: [{ delay: gr() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", Rn] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [be] }], "scale-x": [{ "scale-x": [be] }], "scale-y": [{ "scale-y": [be] }], rotate: [{ rotate: [My, Rn] }], "translate-x": [{ "translate-x": [ot] }], "translate-y": [{ "translate-y": [ot] }], "skew-x": [{ "skew-x": [Be] }], "skew-y": [{ "skew-y": [Be] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Rn] }], accent: [{ accent: ["auto", t] }], appearance: [{ appearance: ["none", "auto"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Rn] }], "caret-color": [{ caret: [t] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": St() }], "scroll-mx": [{ "scroll-mx": St() }], "scroll-my": [{ "scroll-my": St() }], "scroll-ms": [{ "scroll-ms": St() }], "scroll-me": [{ "scroll-me": St() }], "scroll-mt": [{ "scroll-mt": St() }], "scroll-mr": [{ "scroll-mr": St() }], "scroll-mb": [{ "scroll-mb": St() }], "scroll-ml": [{ "scroll-ml": St() }], "scroll-p": [{ "scroll-p": St() }], "scroll-px": [{ "scroll-px": St() }], "scroll-py": [{ "scroll-py": St() }], "scroll-ps": [{ "scroll-ps": St() }], "scroll-pe": [{ "scroll-pe": St() }], "scroll-pt": [{ "scroll-pt": St() }], "scroll-pr": [{ "scroll-pr": St() }], "scroll-pb": [{ "scroll-pb": St() }], "scroll-pl": [{ "scroll-pl": St() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", Rn] }], fill: [{ fill: [t, "none"] }], "stroke-w": [{ stroke: [Hc, ah, TE] }], stroke: [{ stroke: [t, "none"] }], sr: ["sr-only", "not-sr-only"], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } }; }, Xq = Mq(Zq);
function $n(...t) { return Xq(PF(t)); }
const Kq = lq, NF = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(bF, { ref: o, className: $n("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", t), ...r }));
NF.displayName = bF.displayName;
const Yq = wb("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", { variants: { variant: { default: "border bg-background text-foreground", destructive: "destructive group border-destructive bg-destructive text-destructive-foreground" } }, defaultVariants: { variant: "default" } }), BF = ne.forwardRef(({ className: t, variant: r, ...o }, u) => j.jsx(TF, { ref: u, className: $n(Yq({ variant: r }), t), ...o }));
BF.displayName = TF.displayName;
const Qq = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(CF, { ref: o, className: $n("inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive", t), ...r }));
Qq.displayName = CF.displayName;
const jF = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(AF, { ref: o, className: $n("absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", t), "toast-close": "", ...r, children: j.jsx(kF, { className: "h-4 w-4" }) }));
jF.displayName = AF.displayName;
const VF = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(SF, { ref: o, className: $n("text-sm font-semibold", t), ...r }));
VF.displayName = SF.displayName;
const UF = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(EF, { ref: o, className: $n("text-sm opacity-90", t), ...r }));
UF.displayName = EF.displayName;
function Jq() { const { toasts: t } = fc(); return j.jsxs(Kq, { children: [t.map(function ({ id: r, title: o, description: u, action: g, ...y }) { return j.jsxs(BF, { ...y, children: [j.jsxs("div", { className: "grid gap-1", children: [o && j.jsx(VF, { children: o }), u && j.jsx(UF, { children: u })] }), g, j.jsx(jF, {})] }, r); }), j.jsx(NF, {})] }); }
var eH = RO[" useId ".trim().toString()] || (() => { }), tH = 0;
function Sf(t) { const [r, o] = ne.useState(eH()); return Hh(() => { t || o(u => u ?? String(tH++)); }, [t]), t || (r ? `radix-${r}` : ""); }
const rH = ["top", "right", "bottom", "left"], Wh = Math.min, da = Math.max, Dw = Math.round, R1 = Math.floor, lc = t => ({ x: t, y: t }), nH = { left: "right", right: "left", bottom: "top", top: "bottom" }, iH = { start: "end", end: "start" };
function rC(t, r, o) { return da(t, Wh(r, o)); }
function cu(t, r) { return typeof t == "function" ? t(r) : t; }
function uu(t) { return t.split("-")[0]; }
function Ig(t) { return t.split("-")[1]; }
function DA(t) { return t === "x" ? "y" : "x"; }
function LA(t) { return t === "y" ? "height" : "width"; }
function Zh(t) { return ["top", "bottom"].includes(uu(t)) ? "y" : "x"; }
function OA(t) { return DA(Zh(t)); }
function sH(t, r, o) { o === void 0 && (o = !1); const u = Ig(t), g = OA(t), y = LA(g); let E = g === "x" ? u === (o ? "end" : "start") ? "right" : "left" : u === "start" ? "bottom" : "top"; return r.reference[y] > r.floating[y] && (E = Lw(E)), [E, Lw(E)]; }
function oH(t) { const r = Lw(t); return [nC(t), r, nC(r)]; }
function nC(t) { return t.replace(/start|end/g, r => iH[r]); }
function aH(t, r, o) { const u = ["left", "right"], g = ["right", "left"], y = ["top", "bottom"], E = ["bottom", "top"]; switch (t) {
    case "top":
    case "bottom": return o ? r ? g : u : r ? u : g;
    case "left":
    case "right": return r ? y : E;
    default: return [];
} }
function lH(t, r, o, u) { const g = Ig(t); let y = aH(uu(t), o === "start", u); return g && (y = y.map(E => E + "-" + g), r && (y = y.concat(y.map(nC)))), y; }
function Lw(t) { return t.replace(/left|right|bottom|top/g, r => nH[r]); }
function cH(t) { return { top: 0, right: 0, bottom: 0, left: 0, ...t }; }
function $F(t) { return typeof t != "number" ? cH(t) : { top: t, right: t, bottom: t, left: t }; }
function Ow(t) { const { x: r, y: o, width: u, height: g } = t; return { width: u, height: g, top: o, left: r, right: r + u, bottom: o + g, x: r, y: o }; }
function rL(t, r, o) { let { reference: u, floating: g } = t; const y = Zh(r), E = OA(r), s = LA(E), k = uu(r), L = y === "y", N = u.x + u.width / 2 - g.width / 2, V = u.y + u.height / 2 - g.height / 2, H = u[s] / 2 - g[s] / 2; let ee; switch (k) {
    case "top":
        ee = { x: N, y: u.y - g.height };
        break;
    case "bottom":
        ee = { x: N, y: u.y + u.height };
        break;
    case "right":
        ee = { x: u.x + u.width, y: V };
        break;
    case "left":
        ee = { x: u.x - g.width, y: V };
        break;
    default: ee = { x: u.x, y: u.y };
} switch (Ig(r)) {
    case "start":
        ee[E] -= H * (o && L ? -1 : 1);
        break;
    case "end":
        ee[E] += H * (o && L ? -1 : 1);
        break;
} return ee; }
const uH = async (t, r, o) => { const { placement: u = "bottom", strategy: g = "absolute", middleware: y = [], platform: E } = o, s = y.filter(Boolean), k = await (E.isRTL == null ? void 0 : E.isRTL(r)); let L = await E.getElementRects({ reference: t, floating: r, strategy: g }), { x: N, y: V } = rL(L, u, k), H = u, ee = {}, ce = 0; for (let J = 0; J < s.length; J++) {
    const { name: ye, fn: ie } = s[J], { x: Q, y: ue, data: be, reset: Ie } = await ie({ x: N, y: V, initialPlacement: u, placement: H, strategy: g, middlewareData: ee, rects: L, platform: E, elements: { reference: t, floating: r } });
    N = Q ?? N, V = ue ?? V, ee = { ...ee, [ye]: { ...ee[ye], ...be } }, Ie && ce <= 50 && (ce++, typeof Ie == "object" && (Ie.placement && (H = Ie.placement), Ie.rects && (L = Ie.rects === !0 ? await E.getElementRects({ reference: t, floating: r, strategy: g }) : Ie.rects), { x: N, y: V } = rL(L, H, k)), J = -1);
} return { x: N, y: V, placement: H, strategy: g, middlewareData: ee }; };
async function Iv(t, r) { var o; r === void 0 && (r = {}); const { x: u, y: g, platform: y, rects: E, elements: s, strategy: k } = t, { boundary: L = "clippingAncestors", rootBoundary: N = "viewport", elementContext: V = "floating", altBoundary: H = !1, padding: ee = 0 } = cu(r, t), ce = $F(ee), ye = s[H ? V === "floating" ? "reference" : "floating" : V], ie = Ow(await y.getClippingRect({ element: (o = await (y.isElement == null ? void 0 : y.isElement(ye))) == null || o ? ye : ye.contextElement || await (y.getDocumentElement == null ? void 0 : y.getDocumentElement(s.floating)), boundary: L, rootBoundary: N, strategy: k })), Q = V === "floating" ? { x: u, y: g, width: E.floating.width, height: E.floating.height } : E.reference, ue = await (y.getOffsetParent == null ? void 0 : y.getOffsetParent(s.floating)), be = await (y.isElement == null ? void 0 : y.isElement(ue)) ? await (y.getScale == null ? void 0 : y.getScale(ue)) || { x: 1, y: 1 } : { x: 1, y: 1 }, Ie = Ow(y.convertOffsetParentRelativeRectToViewportRelativeRect ? await y.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: s, rect: Q, offsetParent: ue, strategy: k }) : Q); return { top: (ie.top - Ie.top + ce.top) / be.y, bottom: (Ie.bottom - ie.bottom + ce.bottom) / be.y, left: (ie.left - Ie.left + ce.left) / be.x, right: (Ie.right - ie.right + ce.right) / be.x }; }
const hH = t => ({ name: "arrow", options: t, async fn(r) { const { x: o, y: u, placement: g, rects: y, platform: E, elements: s, middlewareData: k } = r, { element: L, padding: N = 0 } = cu(t, r) || {}; if (L == null)
        return {}; const V = $F(N), H = { x: o, y: u }, ee = OA(g), ce = LA(ee), J = await E.getDimensions(L), ye = ee === "y", ie = ye ? "top" : "left", Q = ye ? "bottom" : "right", ue = ye ? "clientHeight" : "clientWidth", be = y.reference[ce] + y.reference[ee] - H[ee] - y.floating[ce], Ie = H[ee] - y.reference[ee], Be = await (E.getOffsetParent == null ? void 0 : E.getOffsetParent(L)); let Ze = Be ? Be[ue] : 0; (!Ze || !await (E.isElement == null ? void 0 : E.isElement(Be))) && (Ze = s.floating[ue] || y.floating[ce]); const ot = be / 2 - Ie / 2, At = Ze / 2 - J[ce] / 2 - 1, kt = Wh(V[ie], At), ct = Wh(V[Q], At), St = kt, Kt = Ze - J[ce] - ct, bt = Ze / 2 - J[ce] / 2 + ot, ir = rC(St, bt, Kt), tr = !k.arrow && Ig(g) != null && bt !== ir && y.reference[ce] / 2 - (bt < St ? kt : ct) - J[ce] / 2 < 0, Or = tr ? bt < St ? bt - St : bt - Kt : 0; return { [ee]: H[ee] + Or, data: { [ee]: ir, centerOffset: bt - ir - Or, ...tr && { alignmentOffset: Or } }, reset: tr }; } }), dH = function (t) { return t === void 0 && (t = {}), { name: "flip", options: t, async fn(r) { var o, u; const { placement: g, middlewareData: y, rects: E, initialPlacement: s, platform: k, elements: L } = r, { mainAxis: N = !0, crossAxis: V = !0, fallbackPlacements: H, fallbackStrategy: ee = "bestFit", fallbackAxisSideDirection: ce = "none", flipAlignment: J = !0, ...ye } = cu(t, r); if ((o = y.arrow) != null && o.alignmentOffset)
        return {}; const ie = uu(g), Q = Zh(s), ue = uu(s) === s, be = await (k.isRTL == null ? void 0 : k.isRTL(L.floating)), Ie = H || (ue || !J ? [Lw(s)] : oH(s)), Be = ce !== "none"; !H && Be && Ie.push(...lH(s, J, ce, be)); const Ze = [s, ...Ie], ot = await Iv(r, ye), At = []; let kt = ((u = y.flip) == null ? void 0 : u.overflows) || []; if (N && At.push(ot[ie]), V) {
        const bt = sH(g, E, be);
        At.push(ot[bt[0]], ot[bt[1]]);
    } if (kt = [...kt, { placement: g, overflows: At }], !At.every(bt => bt <= 0)) {
        var ct, St;
        const bt = (((ct = y.flip) == null ? void 0 : ct.index) || 0) + 1, ir = Ze[bt];
        if (ir)
            return { data: { index: bt, overflows: kt }, reset: { placement: ir } };
        let tr = (St = kt.filter(Or => Or.overflows[0] <= 0).sort((Or, xt) => Or.overflows[1] - xt.overflows[1])[0]) == null ? void 0 : St.placement;
        if (!tr)
            switch (ee) {
                case "bestFit": {
                    var Kt;
                    const Or = (Kt = kt.filter(xt => { if (Be) {
                        const Pt = Zh(xt.placement);
                        return Pt === Q || Pt === "y";
                    } return !0; }).map(xt => [xt.placement, xt.overflows.filter(Pt => Pt > 0).reduce((Pt, Ft) => Pt + Ft, 0)]).sort((xt, Pt) => xt[1] - Pt[1])[0]) == null ? void 0 : Kt[0];
                    Or && (tr = Or);
                    break;
                }
                case "initialPlacement":
                    tr = s;
                    break;
            }
        if (g !== tr)
            return { reset: { placement: tr } };
    } return {}; } }; };
function nL(t, r) { return { top: t.top - r.height, right: t.right - r.width, bottom: t.bottom - r.height, left: t.left - r.width }; }
function iL(t) { return rH.some(r => t[r] >= 0); }
const fH = function (t) { return t === void 0 && (t = {}), { name: "hide", options: t, async fn(r) { const { rects: o } = r, { strategy: u = "referenceHidden", ...g } = cu(t, r); switch (u) {
        case "referenceHidden": {
            const y = await Iv(r, { ...g, elementContext: "reference" }), E = nL(y, o.reference);
            return { data: { referenceHiddenOffsets: E, referenceHidden: iL(E) } };
        }
        case "escaped": {
            const y = await Iv(r, { ...g, altBoundary: !0 }), E = nL(y, o.floating);
            return { data: { escapedOffsets: E, escaped: iL(E) } };
        }
        default: return {};
    } } }; };
async function pH(t, r) { const { placement: o, platform: u, elements: g } = t, y = await (u.isRTL == null ? void 0 : u.isRTL(g.floating)), E = uu(o), s = Ig(o), k = Zh(o) === "y", L = ["left", "top"].includes(E) ? -1 : 1, N = y && k ? -1 : 1, V = cu(r, t); let { mainAxis: H, crossAxis: ee, alignmentAxis: ce } = typeof V == "number" ? { mainAxis: V, crossAxis: 0, alignmentAxis: null } : { mainAxis: V.mainAxis || 0, crossAxis: V.crossAxis || 0, alignmentAxis: V.alignmentAxis }; return s && typeof ce == "number" && (ee = s === "end" ? ce * -1 : ce), k ? { x: ee * N, y: H * L } : { x: H * L, y: ee * N }; }
const mH = function (t) { return t === void 0 && (t = 0), { name: "offset", options: t, async fn(r) { var o, u; const { x: g, y, placement: E, middlewareData: s } = r, k = await pH(r, t); return E === ((o = s.offset) == null ? void 0 : o.placement) && (u = s.arrow) != null && u.alignmentOffset ? {} : { x: g + k.x, y: y + k.y, data: { ...k, placement: E } }; } }; }, gH = function (t) { return t === void 0 && (t = {}), { name: "shift", options: t, async fn(r) { const { x: o, y: u, placement: g } = r, { mainAxis: y = !0, crossAxis: E = !1, limiter: s = { fn: ye => { let { x: ie, y: Q } = ye; return { x: ie, y: Q }; } }, ...k } = cu(t, r), L = { x: o, y: u }, N = await Iv(r, k), V = Zh(uu(g)), H = DA(V); let ee = L[H], ce = L[V]; if (y) {
        const ye = H === "y" ? "top" : "left", ie = H === "y" ? "bottom" : "right", Q = ee + N[ye], ue = ee - N[ie];
        ee = rC(Q, ee, ue);
    } if (E) {
        const ye = V === "y" ? "top" : "left", ie = V === "y" ? "bottom" : "right", Q = ce + N[ye], ue = ce - N[ie];
        ce = rC(Q, ce, ue);
    } const J = s.fn({ ...r, [H]: ee, [V]: ce }); return { ...J, data: { x: J.x - o, y: J.y - u, enabled: { [H]: y, [V]: E } } }; } }; }, _H = function (t) { return t === void 0 && (t = {}), { options: t, fn(r) { const { x: o, y: u, placement: g, rects: y, middlewareData: E } = r, { offset: s = 0, mainAxis: k = !0, crossAxis: L = !0 } = cu(t, r), N = { x: o, y: u }, V = Zh(g), H = DA(V); let ee = N[H], ce = N[V]; const J = cu(s, r), ye = typeof J == "number" ? { mainAxis: J, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...J }; if (k) {
        const ue = H === "y" ? "height" : "width", be = y.reference[H] - y.floating[ue] + ye.mainAxis, Ie = y.reference[H] + y.reference[ue] - ye.mainAxis;
        ee < be ? ee = be : ee > Ie && (ee = Ie);
    } if (L) {
        var ie, Q;
        const ue = H === "y" ? "width" : "height", be = ["top", "left"].includes(uu(g)), Ie = y.reference[V] - y.floating[ue] + (be && ((ie = E.offset) == null ? void 0 : ie[V]) || 0) + (be ? 0 : ye.crossAxis), Be = y.reference[V] + y.reference[ue] + (be ? 0 : ((Q = E.offset) == null ? void 0 : Q[V]) || 0) - (be ? ye.crossAxis : 0);
        ce < Ie ? ce = Ie : ce > Be && (ce = Be);
    } return { [H]: ee, [V]: ce }; } }; }, yH = function (t) { return t === void 0 && (t = {}), { name: "size", options: t, async fn(r) { var o, u; const { placement: g, rects: y, platform: E, elements: s } = r, { apply: k = () => { }, ...L } = cu(t, r), N = await Iv(r, L), V = uu(g), H = Ig(g), ee = Zh(g) === "y", { width: ce, height: J } = y.floating; let ye, ie; V === "top" || V === "bottom" ? (ye = V, ie = H === (await (E.isRTL == null ? void 0 : E.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (ie = V, ye = H === "end" ? "top" : "bottom"); const Q = J - N.top - N.bottom, ue = ce - N.left - N.right, be = Wh(J - N[ye], Q), Ie = Wh(ce - N[ie], ue), Be = !r.middlewareData.shift; let Ze = be, ot = Ie; if ((o = r.middlewareData.shift) != null && o.enabled.x && (ot = ue), (u = r.middlewareData.shift) != null && u.enabled.y && (Ze = Q), Be && !H) {
        const kt = da(N.left, 0), ct = da(N.right, 0), St = da(N.top, 0), Kt = da(N.bottom, 0);
        ee ? ot = ce - 2 * (kt !== 0 || ct !== 0 ? kt + ct : da(N.left, N.right)) : Ze = J - 2 * (St !== 0 || Kt !== 0 ? St + Kt : da(N.top, N.bottom));
    } await k({ ...r, availableWidth: ot, availableHeight: Ze }); const At = await E.getDimensions(s.floating); return ce !== At.width || J !== At.height ? { reset: { rects: !0 } } : {}; } }; };
function bb() { return typeof window < "u"; }
function Pg(t) { return GF(t) ? (t.nodeName || "").toLowerCase() : "#document"; }
function ma(t) { var r; return (t == null || (r = t.ownerDocument) == null ? void 0 : r.defaultView) || window; }
function mc(t) { var r; return (r = (GF(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : r.documentElement; }
function GF(t) { return bb() ? t instanceof Node || t instanceof ma(t).Node : !1; }
function wl(t) { return bb() ? t instanceof Element || t instanceof ma(t).Element : !1; }
function uc(t) { return bb() ? t instanceof HTMLElement || t instanceof ma(t).HTMLElement : !1; }
function sL(t) { return !bb() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof ma(t).ShadowRoot; }
function s0(t) { const { overflow: r, overflowX: o, overflowY: u, display: g } = bl(t); return /auto|scroll|overlay|hidden|clip/.test(r + u + o) && !["inline", "contents"].includes(g); }
function vH(t) { return ["table", "td", "th"].includes(Pg(t)); }
function Tb(t) { return [":popover-open", ":modal"].some(r => { try {
    return t.matches(r);
}
catch {
    return !1;
} }); }
function zA(t) { const r = FA(), o = wl(t) ? bl(t) : t; return ["transform", "translate", "scale", "rotate", "perspective"].some(u => o[u] ? o[u] !== "none" : !1) || (o.containerType ? o.containerType !== "normal" : !1) || !r && (o.backdropFilter ? o.backdropFilter !== "none" : !1) || !r && (o.filter ? o.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some(u => (o.willChange || "").includes(u)) || ["paint", "layout", "strict", "content"].some(u => (o.contain || "").includes(u)); }
function xH(t) { let r = Xh(t); for (; uc(r) && !pg(r);) {
    if (zA(r))
        return r;
    if (Tb(r))
        return null;
    r = Xh(r);
} return null; }
function FA() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none"); }
function pg(t) { return ["html", "body", "#document"].includes(Pg(t)); }
function bl(t) { return ma(t).getComputedStyle(t); }
function Sb(t) { return wl(t) ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } : { scrollLeft: t.scrollX, scrollTop: t.scrollY }; }
function Xh(t) { if (Pg(t) === "html")
    return t; const r = t.assignedSlot || t.parentNode || sL(t) && t.host || mc(t); return sL(r) ? r.host : r; }
function qF(t) { const r = Xh(t); return pg(r) ? t.ownerDocument ? t.ownerDocument.body : t.body : uc(r) && s0(r) ? r : qF(r); }
function Pv(t, r, o) { var u; r === void 0 && (r = []), o === void 0 && (o = !0); const g = qF(t), y = g === ((u = t.ownerDocument) == null ? void 0 : u.body), E = ma(g); if (y) {
    const s = iC(E);
    return r.concat(E, E.visualViewport || [], s0(g) ? g : [], s && o ? Pv(s) : []);
} return r.concat(g, Pv(g, [], o)); }
function iC(t) { return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null; }
function HF(t) { const r = bl(t); let o = parseFloat(r.width) || 0, u = parseFloat(r.height) || 0; const g = uc(t), y = g ? t.offsetWidth : o, E = g ? t.offsetHeight : u, s = Dw(o) !== y || Dw(u) !== E; return s && (o = y, u = E), { width: o, height: u, $: s }; }
function NA(t) { return wl(t) ? t : t.contextElement; }
function Um(t) { const r = NA(t); if (!uc(r))
    return lc(1); const o = r.getBoundingClientRect(), { width: u, height: g, $: y } = HF(r); let E = (y ? Dw(o.width) : o.width) / u, s = (y ? Dw(o.height) : o.height) / g; return (!E || !Number.isFinite(E)) && (E = 1), (!s || !Number.isFinite(s)) && (s = 1), { x: E, y: s }; }
const wH = lc(0);
function WF(t) { const r = ma(t); return !FA() || !r.visualViewport ? wH : { x: r.visualViewport.offsetLeft, y: r.visualViewport.offsetTop }; }
function bH(t, r, o) { return r === void 0 && (r = !1), !o || r && o !== ma(t) ? !1 : r; }
function Df(t, r, o, u) { r === void 0 && (r = !1), o === void 0 && (o = !1); const g = t.getBoundingClientRect(), y = NA(t); let E = lc(1); r && (u ? wl(u) && (E = Um(u)) : E = Um(t)); const s = bH(y, o, u) ? WF(y) : lc(0); let k = (g.left + s.x) / E.x, L = (g.top + s.y) / E.y, N = g.width / E.x, V = g.height / E.y; if (y) {
    const H = ma(y), ee = u && wl(u) ? ma(u) : u;
    let ce = H, J = iC(ce);
    for (; J && u && ee !== ce;) {
        const ye = Um(J), ie = J.getBoundingClientRect(), Q = bl(J), ue = ie.left + (J.clientLeft + parseFloat(Q.paddingLeft)) * ye.x, be = ie.top + (J.clientTop + parseFloat(Q.paddingTop)) * ye.y;
        k *= ye.x, L *= ye.y, N *= ye.x, V *= ye.y, k += ue, L += be, ce = ma(J), J = iC(ce);
    }
} return Ow({ width: N, height: V, x: k, y: L }); }
function BA(t, r) { const o = Sb(t).scrollLeft; return r ? r.left + o : Df(mc(t)).left + o; }
function ZF(t, r, o) { o === void 0 && (o = !1); const u = t.getBoundingClientRect(), g = u.left + r.scrollLeft - (o ? 0 : BA(t, u)), y = u.top + r.scrollTop; return { x: g, y }; }
function TH(t) { let { elements: r, rect: o, offsetParent: u, strategy: g } = t; const y = g === "fixed", E = mc(u), s = r ? Tb(r.floating) : !1; if (u === E || s && y)
    return o; let k = { scrollLeft: 0, scrollTop: 0 }, L = lc(1); const N = lc(0), V = uc(u); if ((V || !V && !y) && ((Pg(u) !== "body" || s0(E)) && (k = Sb(u)), uc(u))) {
    const ee = Df(u);
    L = Um(u), N.x = ee.x + u.clientLeft, N.y = ee.y + u.clientTop;
} const H = E && !V && !y ? ZF(E, k, !0) : lc(0); return { width: o.width * L.x, height: o.height * L.y, x: o.x * L.x - k.scrollLeft * L.x + N.x + H.x, y: o.y * L.y - k.scrollTop * L.y + N.y + H.y }; }
function SH(t) { return Array.from(t.getClientRects()); }
function EH(t) { const r = mc(t), o = Sb(t), u = t.ownerDocument.body, g = da(r.scrollWidth, r.clientWidth, u.scrollWidth, u.clientWidth), y = da(r.scrollHeight, r.clientHeight, u.scrollHeight, u.clientHeight); let E = -o.scrollLeft + BA(t); const s = -o.scrollTop; return bl(u).direction === "rtl" && (E += da(r.clientWidth, u.clientWidth) - g), { width: g, height: y, x: E, y: s }; }
function CH(t, r) { const o = ma(t), u = mc(t), g = o.visualViewport; let y = u.clientWidth, E = u.clientHeight, s = 0, k = 0; if (g) {
    y = g.width, E = g.height;
    const L = FA();
    (!L || L && r === "fixed") && (s = g.offsetLeft, k = g.offsetTop);
} return { width: y, height: E, x: s, y: k }; }
function AH(t, r) { const o = Df(t, !0, r === "fixed"), u = o.top + t.clientTop, g = o.left + t.clientLeft, y = uc(t) ? Um(t) : lc(1), E = t.clientWidth * y.x, s = t.clientHeight * y.y, k = g * y.x, L = u * y.y; return { width: E, height: s, x: k, y: L }; }
function oL(t, r, o) { let u; if (r === "viewport")
    u = CH(t, o);
else if (r === "document")
    u = EH(mc(t));
else if (wl(r))
    u = AH(r, o);
else {
    const g = WF(t);
    u = { x: r.x - g.x, y: r.y - g.y, width: r.width, height: r.height };
} return Ow(u); }
function XF(t, r) { const o = Xh(t); return o === r || !wl(o) || pg(o) ? !1 : bl(o).position === "fixed" || XF(o, r); }
function IH(t, r) { const o = r.get(t); if (o)
    return o; let u = Pv(t, [], !1).filter(s => wl(s) && Pg(s) !== "body"), g = null; const y = bl(t).position === "fixed"; let E = y ? Xh(t) : t; for (; wl(E) && !pg(E);) {
    const s = bl(E), k = zA(E);
    !k && s.position === "fixed" && (g = null), (y ? !k && !g : !k && s.position === "static" && !!g && ["absolute", "fixed"].includes(g.position) || s0(E) && !k && XF(t, E)) ? u = u.filter(N => N !== E) : g = s, E = Xh(E);
} return r.set(t, u), u; }
function PH(t) { let { element: r, boundary: o, rootBoundary: u, strategy: g } = t; const E = [...o === "clippingAncestors" ? Tb(r) ? [] : IH(r, this._c) : [].concat(o), u], s = E[0], k = E.reduce((L, N) => { const V = oL(r, N, g); return L.top = da(V.top, L.top), L.right = Wh(V.right, L.right), L.bottom = Wh(V.bottom, L.bottom), L.left = da(V.left, L.left), L; }, oL(r, s, g)); return { width: k.right - k.left, height: k.bottom - k.top, x: k.left, y: k.top }; }
function MH(t) { const { width: r, height: o } = HF(t); return { width: r, height: o }; }
function RH(t, r, o) { const u = uc(r), g = mc(r), y = o === "fixed", E = Df(t, !0, y, r); let s = { scrollLeft: 0, scrollTop: 0 }; const k = lc(0); if (u || !u && !y)
    if ((Pg(r) !== "body" || s0(g)) && (s = Sb(r)), u) {
        const H = Df(r, !0, y, r);
        k.x = H.x + r.clientLeft, k.y = H.y + r.clientTop;
    }
    else
        g && (k.x = BA(g)); const L = g && !u && !y ? ZF(g, s) : lc(0), N = E.left + s.scrollLeft - k.x - L.x, V = E.top + s.scrollTop - k.y - L.y; return { x: N, y: V, width: E.width, height: E.height }; }
function SE(t) { return bl(t).position === "static"; }
function aL(t, r) { if (!uc(t) || bl(t).position === "fixed")
    return null; if (r)
    return r(t); let o = t.offsetParent; return mc(t) === o && (o = o.ownerDocument.body), o; }
function KF(t, r) { const o = ma(t); if (Tb(t))
    return o; if (!uc(t)) {
    let g = Xh(t);
    for (; g && !pg(g);) {
        if (wl(g) && !SE(g))
            return g;
        g = Xh(g);
    }
    return o;
} let u = aL(t, r); for (; u && vH(u) && SE(u);)
    u = aL(u, r); return u && pg(u) && SE(u) && !zA(u) ? o : u || xH(t) || o; }
const kH = async function (t) { const r = this.getOffsetParent || KF, o = this.getDimensions, u = await o(t.floating); return { reference: RH(t.reference, await r(t.floating), t.strategy), floating: { x: 0, y: 0, width: u.width, height: u.height } }; };
function DH(t) { return bl(t).direction === "rtl"; }
const LH = { convertOffsetParentRelativeRectToViewportRelativeRect: TH, getDocumentElement: mc, getClippingRect: PH, getOffsetParent: KF, getElementRects: kH, getClientRects: SH, getDimensions: MH, getScale: Um, isElement: wl, isRTL: DH };
function YF(t, r) { return t.x === r.x && t.y === r.y && t.width === r.width && t.height === r.height; }
function OH(t, r) { let o = null, u; const g = mc(t); function y() { var s; clearTimeout(u), (s = o) == null || s.disconnect(), o = null; } function E(s, k) { s === void 0 && (s = !1), k === void 0 && (k = 1), y(); const L = t.getBoundingClientRect(), { left: N, top: V, width: H, height: ee } = L; if (s || r(), !H || !ee)
    return; const ce = R1(V), J = R1(g.clientWidth - (N + H)), ye = R1(g.clientHeight - (V + ee)), ie = R1(N), ue = { rootMargin: -ce + "px " + -J + "px " + -ye + "px " + -ie + "px", threshold: da(0, Wh(1, k)) || 1 }; let be = !0; function Ie(Be) { const Ze = Be[0].intersectionRatio; if (Ze !== k) {
    if (!be)
        return E();
    Ze ? E(!1, Ze) : u = setTimeout(() => { E(!1, 1e-7); }, 1e3);
} Ze === 1 && !YF(L, t.getBoundingClientRect()) && E(), be = !1; } try {
    o = new IntersectionObserver(Ie, { ...ue, root: g.ownerDocument });
}
catch {
    o = new IntersectionObserver(Ie, ue);
} o.observe(t); } return E(!0), y; }
function zH(t, r, o, u) { u === void 0 && (u = {}); const { ancestorScroll: g = !0, ancestorResize: y = !0, elementResize: E = typeof ResizeObserver == "function", layoutShift: s = typeof IntersectionObserver == "function", animationFrame: k = !1 } = u, L = NA(t), N = g || y ? [...L ? Pv(L) : [], ...Pv(r)] : []; N.forEach(ie => { g && ie.addEventListener("scroll", o, { passive: !0 }), y && ie.addEventListener("resize", o); }); const V = L && s ? OH(L, o) : null; let H = -1, ee = null; E && (ee = new ResizeObserver(ie => { let [Q] = ie; Q && Q.target === L && ee && (ee.unobserve(r), cancelAnimationFrame(H), H = requestAnimationFrame(() => { var ue; (ue = ee) == null || ue.observe(r); })), o(); }), L && !k && ee.observe(L), ee.observe(r)); let ce, J = k ? Df(t) : null; k && ye(); function ye() { const ie = Df(t); J && !YF(J, ie) && o(), J = ie, ce = requestAnimationFrame(ye); } return o(), () => { var ie; N.forEach(Q => { g && Q.removeEventListener("scroll", o), y && Q.removeEventListener("resize", o); }), V == null || V(), (ie = ee) == null || ie.disconnect(), ee = null, k && cancelAnimationFrame(ce); }; }
const FH = mH, NH = gH, BH = dH, jH = yH, VH = fH, lL = hH, UH = _H, $H = (t, r, o) => { const u = new Map, g = { platform: LH, ...o }, y = { ...g.platform, _c: u }; return uH(t, r, { ...g, platform: y }); };
var tw = typeof document < "u" ? ne.useLayoutEffect : ne.useEffect;
function zw(t, r) { if (t === r)
    return !0; if (typeof t != typeof r)
    return !1; if (typeof t == "function" && t.toString() === r.toString())
    return !0; let o, u, g; if (t && r && typeof t == "object") {
    if (Array.isArray(t)) {
        if (o = t.length, o !== r.length)
            return !1;
        for (u = o; u-- !== 0;)
            if (!zw(t[u], r[u]))
                return !1;
        return !0;
    }
    if (g = Object.keys(t), o = g.length, o !== Object.keys(r).length)
        return !1;
    for (u = o; u-- !== 0;)
        if (!{}.hasOwnProperty.call(r, g[u]))
            return !1;
    for (u = o; u-- !== 0;) {
        const y = g[u];
        if (!(y === "_owner" && t.$$typeof) && !zw(t[y], r[y]))
            return !1;
    }
    return !0;
} return t !== t && r !== r; }
function QF(t) { return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1; }
function cL(t, r) { const o = QF(t); return Math.round(r * o) / o; }
function EE(t) { const r = ne.useRef(t); return tw(() => { r.current = t; }), r; }
function GH(t) { t === void 0 && (t = {}); const { placement: r = "bottom", strategy: o = "absolute", middleware: u = [], platform: g, elements: { reference: y, floating: E } = {}, transform: s = !0, whileElementsMounted: k, open: L } = t, [N, V] = ne.useState({ x: 0, y: 0, strategy: o, placement: r, middlewareData: {}, isPositioned: !1 }), [H, ee] = ne.useState(u); zw(H, u) || ee(u); const [ce, J] = ne.useState(null), [ye, ie] = ne.useState(null), Q = ne.useCallback(xt => { xt !== Be.current && (Be.current = xt, J(xt)); }, []), ue = ne.useCallback(xt => { xt !== Ze.current && (Ze.current = xt, ie(xt)); }, []), be = y || ce, Ie = E || ye, Be = ne.useRef(null), Ze = ne.useRef(null), ot = ne.useRef(N), At = k != null, kt = EE(k), ct = EE(g), St = EE(L), Kt = ne.useCallback(() => { if (!Be.current || !Ze.current)
    return; const xt = { placement: r, strategy: o, middleware: H }; ct.current && (xt.platform = ct.current), $H(Be.current, Ze.current, xt).then(Pt => { const Ft = { ...Pt, isPositioned: St.current !== !1 }; bt.current && !zw(ot.current, Ft) && (ot.current = Ft, r0.flushSync(() => { V(Ft); })); }); }, [H, r, o, ct, St]); tw(() => { L === !1 && ot.current.isPositioned && (ot.current.isPositioned = !1, V(xt => ({ ...xt, isPositioned: !1 }))); }, [L]); const bt = ne.useRef(!1); tw(() => (bt.current = !0, () => { bt.current = !1; }), []), tw(() => { if (be && (Be.current = be), Ie && (Ze.current = Ie), be && Ie) {
    if (kt.current)
        return kt.current(be, Ie, Kt);
    Kt();
} }, [be, Ie, Kt, kt, At]); const ir = ne.useMemo(() => ({ reference: Be, floating: Ze, setReference: Q, setFloating: ue }), [Q, ue]), tr = ne.useMemo(() => ({ reference: be, floating: Ie }), [be, Ie]), Or = ne.useMemo(() => { const xt = { position: o, left: 0, top: 0 }; if (!tr.floating)
    return xt; const Pt = cL(tr.floating, N.x), Ft = cL(tr.floating, N.y); return s ? { ...xt, transform: "translate(" + Pt + "px, " + Ft + "px)", ...QF(tr.floating) >= 1.5 && { willChange: "transform" } } : { position: o, left: Pt, top: Ft }; }, [o, s, tr.floating, N.x, N.y]); return ne.useMemo(() => ({ ...N, update: Kt, refs: ir, elements: tr, floatingStyles: Or }), [N, Kt, ir, tr, Or]); }
const qH = t => { function r(o) { return {}.hasOwnProperty.call(o, "current"); } return { name: "arrow", options: t, fn(o) { const { element: u, padding: g } = typeof t == "function" ? t(o) : t; return u && r(u) ? u.current != null ? lL({ element: u.current, padding: g }).fn(o) : {} : u ? lL({ element: u, padding: g }).fn(o) : {}; } }; }, HH = (t, r) => ({ ...FH(t), options: [t, r] }), WH = (t, r) => ({ ...NH(t), options: [t, r] }), ZH = (t, r) => ({ ...UH(t), options: [t, r] }), XH = (t, r) => ({ ...BH(t), options: [t, r] }), KH = (t, r) => ({ ...jH(t), options: [t, r] }), YH = (t, r) => ({ ...VH(t), options: [t, r] }), QH = (t, r) => ({ ...qH(t), options: [t, r] });
var JH = "Arrow", JF = ne.forwardRef((t, r) => { const { children: o, width: u = 10, height: g = 5, ...y } = t; return j.jsx(si.svg, { ...y, ref: r, width: u, height: g, viewBox: "0 0 30 10", preserveAspectRatio: "none", children: t.asChild ? o : j.jsx("polygon", { points: "0,0 30,0 15,10" }) }); });
JF.displayName = JH;
var eW = JF;
function eN(t) { const [r, o] = ne.useState(void 0); return Hh(() => { if (t) {
    o({ width: t.offsetWidth, height: t.offsetHeight });
    const u = new ResizeObserver(g => { if (!Array.isArray(g) || !g.length)
        return; const y = g[0]; let E, s; if ("borderBoxSize" in y) {
        const k = y.borderBoxSize, L = Array.isArray(k) ? k[0] : k;
        E = L.inlineSize, s = L.blockSize;
    }
    else
        E = t.offsetWidth, s = t.offsetHeight; o({ width: E, height: s }); });
    return u.observe(t, { box: "border-box" }), () => u.unobserve(t);
}
else
    o(void 0); }, [t]), r; }
var jA = "Popper", [tN, Eb] = pc(jA), [tW, rN] = tN(jA), nN = t => { const { __scopePopper: r, children: o } = t, [u, g] = ne.useState(null); return j.jsx(tW, { scope: r, anchor: u, onAnchorChange: g, children: o }); };
nN.displayName = jA;
var iN = "PopperAnchor", sN = ne.forwardRef((t, r) => { const { __scopePopper: o, virtualRef: u, ...g } = t, y = rN(iN, o), E = ne.useRef(null), s = is(r, E); return ne.useEffect(() => { y.onAnchorChange((u == null ? void 0 : u.current) || E.current); }), u ? null : j.jsx(si.div, { ...g, ref: s }); });
sN.displayName = iN;
var VA = "PopperContent", [rW, nW] = tN(VA), oN = ne.forwardRef((t, r) => { var mn, Xs, ln, Bs, js, ss; const { __scopePopper: o, side: u = "bottom", sideOffset: g = 0, align: y = "center", alignOffset: E = 0, arrowPadding: s = 0, avoidCollisions: k = !0, collisionBoundary: L = [], collisionPadding: N = 0, sticky: V = "partial", hideWhenDetached: H = !1, updatePositionStrategy: ee = "optimized", onPlaced: ce, ...J } = t, ye = rN(VA, o), [ie, Q] = ne.useState(null), ue = is(r, Gn => Q(Gn)), [be, Ie] = ne.useState(null), Be = eN(be), Ze = (Be == null ? void 0 : Be.width) ?? 0, ot = (Be == null ? void 0 : Be.height) ?? 0, At = u + (y !== "center" ? "-" + y : ""), kt = typeof N == "number" ? N : { top: 0, right: 0, bottom: 0, left: 0, ...N }, ct = Array.isArray(L) ? L : [L], St = ct.length > 0, Kt = { padding: kt, boundary: ct.filter(sW), altBoundary: St }, { refs: bt, floatingStyles: ir, placement: tr, isPositioned: Or, middlewareData: xt } = GH({ strategy: "fixed", placement: At, whileElementsMounted: (...Gn) => zH(...Gn, { animationFrame: ee === "always" }), elements: { reference: ye.anchor }, middleware: [HH({ mainAxis: g + ot, alignmentAxis: E }), k && WH({ mainAxis: !0, crossAxis: !1, limiter: V === "partial" ? ZH() : void 0, ...Kt }), k && XH({ ...Kt }), KH({ ...Kt, apply: ({ elements: Gn, rects: Ua, availableWidth: Xo, availableHeight: $i }) => { const { width: Ks, height: Io } = Ua.reference, Gi = Gn.floating.style; Gi.setProperty("--radix-popper-available-width", `${Xo}px`), Gi.setProperty("--radix-popper-available-height", `${$i}px`), Gi.setProperty("--radix-popper-anchor-width", `${Ks}px`), Gi.setProperty("--radix-popper-anchor-height", `${Io}px`); } }), be && QH({ element: be, padding: s }), oW({ arrowWidth: Ze, arrowHeight: ot }), H && YH({ strategy: "referenceHidden", ...Kt })] }), [Pt, Ft] = cN(tr), gr = To(ce); Hh(() => { Or && (gr == null || gr()); }, [Or, gr]); const Jr = (mn = xt.arrow) == null ? void 0 : mn.x, pi = (Xs = xt.arrow) == null ? void 0 : Xs.y, Si = ((ln = xt.arrow) == null ? void 0 : ln.centerOffset) !== 0, [an, Kr] = ne.useState(); return Hh(() => { ie && Kr(window.getComputedStyle(ie).zIndex); }, [ie]), j.jsx("div", { ref: bt.setFloating, "data-radix-popper-content-wrapper": "", style: { ...ir, transform: Or ? ir.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: an, "--radix-popper-transform-origin": [(Bs = xt.transformOrigin) == null ? void 0 : Bs.x, (js = xt.transformOrigin) == null ? void 0 : js.y].join(" "), ...((ss = xt.hide) == null ? void 0 : ss.referenceHidden) && { visibility: "hidden", pointerEvents: "none" } }, dir: t.dir, children: j.jsx(rW, { scope: o, placedSide: Pt, onArrowChange: Ie, arrowX: Jr, arrowY: pi, shouldHideArrow: Si, children: j.jsx(si.div, { "data-side": Pt, "data-align": Ft, ...J, ref: ue, style: { ...J.style, animation: Or ? void 0 : "none" } }) }) }); });
oN.displayName = VA;
var aN = "PopperArrow", iW = { top: "bottom", right: "left", bottom: "top", left: "right" }, lN = ne.forwardRef(function (r, o) { const { __scopePopper: u, ...g } = r, y = nW(aN, u), E = iW[y.placedSide]; return j.jsx("span", { ref: y.onArrowChange, style: { position: "absolute", left: y.arrowX, top: y.arrowY, [E]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[y.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[y.placedSide], visibility: y.shouldHideArrow ? "hidden" : void 0 }, children: j.jsx(eW, { ...g, ref: o, style: { ...g.style, display: "block" } }) }); });
lN.displayName = aN;
function sW(t) { return t !== null; }
var oW = t => ({ name: "transformOrigin", options: t, fn(r) { var ye, ie, Q; const { placement: o, rects: u, middlewareData: g } = r, E = ((ye = g.arrow) == null ? void 0 : ye.centerOffset) !== 0, s = E ? 0 : t.arrowWidth, k = E ? 0 : t.arrowHeight, [L, N] = cN(o), V = { start: "0%", center: "50%", end: "100%" }[N], H = (((ie = g.arrow) == null ? void 0 : ie.x) ?? 0) + s / 2, ee = (((Q = g.arrow) == null ? void 0 : Q.y) ?? 0) + k / 2; let ce = "", J = ""; return L === "bottom" ? (ce = E ? V : `${H}px`, J = `${-k}px`) : L === "top" ? (ce = E ? V : `${H}px`, J = `${u.floating.height + k}px`) : L === "right" ? (ce = `${-k}px`, J = E ? V : `${ee}px`) : L === "left" && (ce = `${u.floating.width + k}px`, J = E ? V : `${ee}px`), { data: { x: ce, y: J } }; } });
function cN(t) { const [r, o = "center"] = t.split("-"); return [r, o]; }
var aW = nN, uN = sN, hN = oN, dN = lN, [Cb, lee] = pc("Tooltip", [Eb]), UA = Eb(), fN = "TooltipProvider", lW = 700, uL = "tooltip.open", [cW, pN] = Cb(fN), mN = t => { const { __scopeTooltip: r, delayDuration: o = lW, skipDelayDuration: u = 300, disableHoverableContent: g = !1, children: y } = t, E = ne.useRef(!0), s = ne.useRef(!1), k = ne.useRef(0); return ne.useEffect(() => { const L = k.current; return () => window.clearTimeout(L); }, []), j.jsx(cW, { scope: r, isOpenDelayedRef: E, delayDuration: o, onOpen: ne.useCallback(() => { window.clearTimeout(k.current), E.current = !1; }, []), onClose: ne.useCallback(() => { window.clearTimeout(k.current), k.current = window.setTimeout(() => E.current = !0, u); }, [u]), isPointerInTransitRef: s, onPointerInTransitChange: ne.useCallback(L => { s.current = L; }, []), disableHoverableContent: g, children: y }); };
mN.displayName = fN;
var gN = "Tooltip", [cee, Ab] = Cb(gN), sC = "TooltipTrigger", uW = ne.forwardRef((t, r) => { const { __scopeTooltip: o, ...u } = t, g = Ab(sC, o), y = pN(sC, o), E = UA(o), s = ne.useRef(null), k = is(r, s, g.onTriggerChange), L = ne.useRef(!1), N = ne.useRef(!1), V = ne.useCallback(() => L.current = !1, []); return ne.useEffect(() => () => document.removeEventListener("pointerup", V), [V]), j.jsx(uN, { asChild: !0, ...E, children: j.jsx(si.button, { "aria-describedby": g.open ? g.contentId : void 0, "data-state": g.stateAttribute, ...u, ref: k, onPointerMove: qr(t.onPointerMove, H => { H.pointerType !== "touch" && !N.current && !y.isPointerInTransitRef.current && (g.onTriggerEnter(), N.current = !0); }), onPointerLeave: qr(t.onPointerLeave, () => { g.onTriggerLeave(), N.current = !1; }), onPointerDown: qr(t.onPointerDown, () => { g.open && g.onClose(), L.current = !0, document.addEventListener("pointerup", V, { once: !0 }); }), onFocus: qr(t.onFocus, () => { L.current || g.onOpen(); }), onBlur: qr(t.onBlur, g.onClose), onClick: qr(t.onClick, g.onClose) }) }); });
uW.displayName = sC;
var hW = "TooltipPortal", [uee, dW] = Cb(hW, { forceMount: void 0 }), mg = "TooltipContent", _N = ne.forwardRef((t, r) => { const o = dW(mg, t.__scopeTooltip), { forceMount: u = o.forceMount, side: g = "top", ...y } = t, E = Ab(mg, t.__scopeTooltip); return j.jsx(Va, { present: u || E.open, children: E.disableHoverableContent ? j.jsx(yN, { side: g, ...y, ref: r }) : j.jsx(fW, { side: g, ...y, ref: r }) }); }), fW = ne.forwardRef((t, r) => { const o = Ab(mg, t.__scopeTooltip), u = pN(mg, t.__scopeTooltip), g = ne.useRef(null), y = is(r, g), [E, s] = ne.useState(null), { trigger: k, onClose: L } = o, N = g.current, { onPointerInTransitChange: V } = u, H = ne.useCallback(() => { s(null), V(!1); }, [V]), ee = ne.useCallback((ce, J) => { const ye = ce.currentTarget, ie = { x: ce.clientX, y: ce.clientY }, Q = yW(ie, ye.getBoundingClientRect()), ue = vW(ie, Q), be = xW(J.getBoundingClientRect()), Ie = bW([...ue, ...be]); s(Ie), V(!0); }, [V]); return ne.useEffect(() => () => H(), [H]), ne.useEffect(() => { if (k && N) {
    const ce = ye => ee(ye, N), J = ye => ee(ye, k);
    return k.addEventListener("pointerleave", ce), N.addEventListener("pointerleave", J), () => { k.removeEventListener("pointerleave", ce), N.removeEventListener("pointerleave", J); };
} }, [k, N, ee, H]), ne.useEffect(() => { if (E) {
    const ce = J => { const ye = J.target, ie = { x: J.clientX, y: J.clientY }, Q = (k == null ? void 0 : k.contains(ye)) || (N == null ? void 0 : N.contains(ye)), ue = !wW(ie, E); Q ? H() : ue && (H(), L()); };
    return document.addEventListener("pointermove", ce), () => document.removeEventListener("pointermove", ce);
} }, [k, N, E, L, H]), j.jsx(yN, { ...t, ref: y }); }), [pW, mW] = Cb(gN, { isInside: !1 }), gW = SG("TooltipContent"), yN = ne.forwardRef((t, r) => { const { __scopeTooltip: o, children: u, "aria-label": g, onEscapeKeyDown: y, onPointerDownOutside: E, ...s } = t, k = Ab(mg, o), L = UA(o), { onClose: N } = k; return ne.useEffect(() => (document.addEventListener(uL, N), () => document.removeEventListener(uL, N)), [N]), ne.useEffect(() => { if (k.trigger) {
    const V = H => { const ee = H.target; ee != null && ee.contains(k.trigger) && N(); };
    return window.addEventListener("scroll", V, { capture: !0 }), () => window.removeEventListener("scroll", V, { capture: !0 });
} }, [k.trigger, N]), j.jsx(i0, { asChild: !0, disableOutsidePointerEvents: !1, onEscapeKeyDown: y, onPointerDownOutside: E, onFocusOutside: V => V.preventDefault(), onDismiss: N, children: j.jsxs(hN, { "data-state": k.stateAttribute, ...L, ...s, ref: r, style: { ...s.style, "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)", "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)", "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)", "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)" }, children: [j.jsx(gW, { children: u }), j.jsx(pW, { scope: o, isInside: !0, children: j.jsx(GG, { id: k.contentId, role: "tooltip", children: g || u }) })] }) }); });
_N.displayName = mg;
var vN = "TooltipArrow", _W = ne.forwardRef((t, r) => { const { __scopeTooltip: o, ...u } = t, g = UA(o); return mW(vN, o).isInside ? null : j.jsx(dN, { ...g, ...u, ref: r }); });
_W.displayName = vN;
function yW(t, r) { const o = Math.abs(r.top - t.y), u = Math.abs(r.bottom - t.y), g = Math.abs(r.right - t.x), y = Math.abs(r.left - t.x); switch (Math.min(o, u, g, y)) {
    case y: return "left";
    case g: return "right";
    case o: return "top";
    case u: return "bottom";
    default: throw new Error("unreachable");
} }
function vW(t, r, o = 5) { const u = []; switch (r) {
    case "top":
        u.push({ x: t.x - o, y: t.y + o }, { x: t.x + o, y: t.y + o });
        break;
    case "bottom":
        u.push({ x: t.x - o, y: t.y - o }, { x: t.x + o, y: t.y - o });
        break;
    case "left":
        u.push({ x: t.x + o, y: t.y - o }, { x: t.x + o, y: t.y + o });
        break;
    case "right":
        u.push({ x: t.x - o, y: t.y - o }, { x: t.x - o, y: t.y + o });
        break;
} return u; }
function xW(t) { const { top: r, right: o, bottom: u, left: g } = t; return [{ x: g, y: r }, { x: o, y: r }, { x: o, y: u }, { x: g, y: u }]; }
function wW(t, r) { const { x: o, y: u } = t; let g = !1; for (let y = 0, E = r.length - 1; y < r.length; E = y++) {
    const s = r[y].x, k = r[y].y, L = r[E].x, N = r[E].y;
    k > u != N > u && o < (L - s) * (u - k) / (N - k) + s && (g = !g);
} return g; }
function bW(t) { const r = t.slice(); return r.sort((o, u) => o.x < u.x ? -1 : o.x > u.x ? 1 : o.y < u.y ? -1 : o.y > u.y ? 1 : 0), TW(r); }
function TW(t) { if (t.length <= 1)
    return t.slice(); const r = []; for (let u = 0; u < t.length; u++) {
    const g = t[u];
    for (; r.length >= 2;) {
        const y = r[r.length - 1], E = r[r.length - 2];
        if ((y.x - E.x) * (g.y - E.y) >= (y.y - E.y) * (g.x - E.x))
            r.pop();
        else
            break;
    }
    r.push(g);
} r.pop(); const o = []; for (let u = t.length - 1; u >= 0; u--) {
    const g = t[u];
    for (; o.length >= 2;) {
        const y = o[o.length - 1], E = o[o.length - 2];
        if ((y.x - E.x) * (g.y - E.y) >= (y.y - E.y) * (g.x - E.x))
            o.pop();
        else
            break;
    }
    o.push(g);
} return o.pop(), r.length === 1 && o.length === 1 && r[0].x === o[0].x && r[0].y === o[0].y ? r : r.concat(o); }
var SW = mN, xN = _N;
const EW = SW, CW = ne.forwardRef(({ className: t, sideOffset: r = 4, ...o }, u) => j.jsx(xN, { ref: u, sideOffset: r, className: $n("z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]", t), ...o }));
CW.displayName = xN.displayName;
const AW = "modulepreload", IW = function (t) { return "/" + t; }, hL = {}, gg = function (r, o, u) { let g = Promise.resolve(); if (o && o.length > 0) {
    document.getElementsByTagName("link");
    const E = document.querySelector("meta[property=csp-nonce]"), s = (E == null ? void 0 : E.nonce) || (E == null ? void 0 : E.getAttribute("nonce"));
    g = Promise.allSettled(o.map(k => { if (k = IW(k), k in hL)
        return; hL[k] = !0; const L = k.endsWith(".css"), N = L ? "[rel=\"stylesheet\"]" : ""; if (document.querySelector(`link[href="${k}"]${N}`))
        return; const V = document.createElement("link"); if (V.rel = L ? "stylesheet" : AW, L || (V.as = "script"), V.crossOrigin = "", V.href = k, s && V.setAttribute("nonce", s), document.head.appendChild(V), L)
        return new Promise((H, ee) => { V.addEventListener("load", H), V.addEventListener("error", () => ee(new Error(`Unable to preload CSS for ${k}`))); }); }));
} function y(E) { const s = new Event("vite:preloadError", { cancelable: !0 }); if (s.payload = E, window.dispatchEvent(s), !s.defaultPrevented)
    throw E; } return g.then(E => { for (const s of E || [])
    s.status === "rejected" && y(s.reason); return r().catch(y); }); }, PW = t => { let r; return t ? r = t : typeof fetch > "u" ? r = (...o) => gg(async () => { const { default: u } = await Promise.resolve().then(() => Mg); return { default: u }; }, void 0).then(({ default: u }) => u(...o)) : r = fetch, (...o) => r(...o); };
class $A extends Error {
    constructor(r, o = "FunctionsError", u) { super(r), this.name = o, this.context = u; }
}
class MW extends $A {
    constructor(r) { super("Failed to send a request to the Edge Function", "FunctionsFetchError", r); }
}
class RW extends $A {
    constructor(r) { super("Relay Error invoking the Edge Function", "FunctionsRelayError", r); }
}
class kW extends $A {
    constructor(r) { super("Edge Function returned a non-2xx status code", "FunctionsHttpError", r); }
}
var oC;
(function (t) { t.Any = "any", t.ApNortheast1 = "ap-northeast-1", t.ApNortheast2 = "ap-northeast-2", t.ApSouth1 = "ap-south-1", t.ApSoutheast1 = "ap-southeast-1", t.ApSoutheast2 = "ap-southeast-2", t.CaCentral1 = "ca-central-1", t.EuCentral1 = "eu-central-1", t.EuWest1 = "eu-west-1", t.EuWest2 = "eu-west-2", t.EuWest3 = "eu-west-3", t.SaEast1 = "sa-east-1", t.UsEast1 = "us-east-1", t.UsWest1 = "us-west-1", t.UsWest2 = "us-west-2"; })(oC || (oC = {}));
var DW = function (t, r, o, u) { function g(y) { return y instanceof o ? y : new o(function (E) { E(y); }); } return new (o || (o = Promise))(function (y, E) { function s(N) { try {
    L(u.next(N));
}
catch (V) {
    E(V);
} } function k(N) { try {
    L(u.throw(N));
}
catch (V) {
    E(V);
} } function L(N) { N.done ? y(N.value) : g(N.value).then(s, k); } L((u = u.apply(t, r || [])).next()); }); };
class LW {
    constructor(r, { headers: o = {}, customFetch: u, region: g = oC.Any } = {}) { this.url = r, this.headers = o, this.region = g, this.fetch = PW(u); }
    setAuth(r) { this.headers.Authorization = `Bearer ${r}`; }
    invoke(r, o = {}) { var u; return DW(this, void 0, void 0, function* () { try {
        const { headers: g, method: y, body: E } = o;
        let s = {}, { region: k } = o;
        k || (k = this.region), k && k !== "any" && (s["x-region"] = k);
        let L;
        E && (g && !Object.prototype.hasOwnProperty.call(g, "Content-Type") || !g) && (typeof Blob < "u" && E instanceof Blob || E instanceof ArrayBuffer ? (s["Content-Type"] = "application/octet-stream", L = E) : typeof E == "string" ? (s["Content-Type"] = "text/plain", L = E) : typeof FormData < "u" && E instanceof FormData ? L = E : (s["Content-Type"] = "application/json", L = JSON.stringify(E)));
        const N = yield this.fetch(`${this.url}/${r}`, { method: y || "POST", headers: Object.assign(Object.assign(Object.assign({}, s), this.headers), g), body: L }).catch(ce => { throw new MW(ce); }), V = N.headers.get("x-relay-error");
        if (V && V === "true")
            throw new RW(N);
        if (!N.ok)
            throw new kW(N);
        let H = ((u = N.headers.get("Content-Type")) !== null && u !== void 0 ? u : "text/plain").split(";")[0].trim(), ee;
        return H === "application/json" ? ee = yield N.json() : H === "application/octet-stream" ? ee = yield N.blob() : H === "text/event-stream" ? ee = N : H === "multipart/form-data" ? ee = yield N.formData() : ee = yield N.text(), { data: ee, error: null };
    }
    catch (g) {
        return { data: null, error: g };
    } }); }
}
var Go = {}, GA = {}, Ib = {}, o0 = {}, Pb = {}, Mb = {}, OW = function () { if (typeof self < "u")
    return self; if (typeof window < "u")
    return window; if (typeof global < "u")
    return global; throw new Error("unable to locate global object"); }, _g = OW();
const zW = _g.fetch, wN = _g.fetch.bind(_g), bN = _g.Headers, FW = _g.Request, NW = _g.Response, Mg = Object.freeze(Object.defineProperty({ __proto__: null, Headers: bN, Request: FW, Response: NW, default: wN, fetch: zW }, Symbol.toStringTag, { value: "Module" })), BW = DU(Mg);
var Rb = {};
Object.defineProperty(Rb, "__esModule", { value: !0 });
let jW = class extends Error {
    constructor(r) { super(r.message), this.name = "PostgrestError", this.details = r.details, this.hint = r.hint, this.code = r.code; }
};
Rb.default = jW;
var TN = _a && _a.__importDefault || function (t) { return t && t.__esModule ? t : { default: t }; };
Object.defineProperty(Mb, "__esModule", { value: !0 });
const VW = TN(BW), UW = TN(Rb);
let $W = class {
    constructor(r) { this.shouldThrowOnError = !1, this.method = r.method, this.url = r.url, this.headers = r.headers, this.schema = r.schema, this.body = r.body, this.shouldThrowOnError = r.shouldThrowOnError, this.signal = r.signal, this.isMaybeSingle = r.isMaybeSingle, r.fetch ? this.fetch = r.fetch : typeof fetch > "u" ? this.fetch = VW.default : this.fetch = fetch; }
    throwOnError() { return this.shouldThrowOnError = !0, this; }
    setHeader(r, o) { return this.headers = Object.assign({}, this.headers), this.headers[r] = o, this; }
    then(r, o) { this.schema === void 0 || (["GET", "HEAD"].includes(this.method) ? this.headers["Accept-Profile"] = this.schema : this.headers["Content-Profile"] = this.schema), this.method !== "GET" && this.method !== "HEAD" && (this.headers["Content-Type"] = "application/json"); const u = this.fetch; let g = u(this.url.toString(), { method: this.method, headers: this.headers, body: JSON.stringify(this.body), signal: this.signal }).then(async (y) => { var E, s, k; let L = null, N = null, V = null, H = y.status, ee = y.statusText; if (y.ok) {
        if (this.method !== "HEAD") {
            const ie = await y.text();
            ie === "" || (this.headers.Accept === "text/csv" || this.headers.Accept && this.headers.Accept.includes("application/vnd.pgrst.plan+text") ? N = ie : N = JSON.parse(ie));
        }
        const J = (E = this.headers.Prefer) === null || E === void 0 ? void 0 : E.match(/count=(exact|planned|estimated)/), ye = (s = y.headers.get("content-range")) === null || s === void 0 ? void 0 : s.split("/");
        J && ye && ye.length > 1 && (V = parseInt(ye[1])), this.isMaybeSingle && this.method === "GET" && Array.isArray(N) && (N.length > 1 ? (L = { code: "PGRST116", details: `Results contain ${N.length} rows, application/vnd.pgrst.object+json requires 1 row`, hint: null, message: "JSON object requested, multiple (or no) rows returned" }, N = null, V = null, H = 406, ee = "Not Acceptable") : N.length === 1 ? N = N[0] : N = null);
    }
    else {
        const J = await y.text();
        try {
            L = JSON.parse(J), Array.isArray(L) && y.status === 404 && (N = [], L = null, H = 200, ee = "OK");
        }
        catch {
            y.status === 404 && J === "" ? (H = 204, ee = "No Content") : L = { message: J };
        }
        if (L && this.isMaybeSingle && (!((k = L == null ? void 0 : L.details) === null || k === void 0) && k.includes("0 rows")) && (L = null, H = 200, ee = "OK"), L && this.shouldThrowOnError)
            throw new UW.default(L);
    } return { error: L, data: N, count: V, status: H, statusText: ee }; }); return this.shouldThrowOnError || (g = g.catch(y => { var E, s, k; return { error: { message: `${(E = y == null ? void 0 : y.name) !== null && E !== void 0 ? E : "FetchError"}: ${y == null ? void 0 : y.message}`, details: `${(s = y == null ? void 0 : y.stack) !== null && s !== void 0 ? s : ""}`, hint: "", code: `${(k = y == null ? void 0 : y.code) !== null && k !== void 0 ? k : ""}` }, data: null, count: null, status: 0, statusText: "" }; })), g.then(r, o); }
    returns() { return this; }
    overrideTypes() { return this; }
};
Mb.default = $W;
var GW = _a && _a.__importDefault || function (t) { return t && t.__esModule ? t : { default: t }; };
Object.defineProperty(Pb, "__esModule", { value: !0 });
const qW = GW(Mb);
let HW = class extends qW.default {
    select(r) { let o = !1; const u = (r ?? "*").split("").map(g => /\s/.test(g) && !o ? "" : (g === "\"" && (o = !o), g)).join(""); return this.url.searchParams.set("select", u), this.headers.Prefer && (this.headers.Prefer += ","), this.headers.Prefer += "return=representation", this; }
    order(r, { ascending: o = !0, nullsFirst: u, foreignTable: g, referencedTable: y = g } = {}) { const E = y ? `${y}.order` : "order", s = this.url.searchParams.get(E); return this.url.searchParams.set(E, `${s ? `${s},` : ""}${r}.${o ? "asc" : "desc"}${u === void 0 ? "" : u ? ".nullsfirst" : ".nullslast"}`), this; }
    limit(r, { foreignTable: o, referencedTable: u = o } = {}) { const g = typeof u > "u" ? "limit" : `${u}.limit`; return this.url.searchParams.set(g, `${r}`), this; }
    range(r, o, { foreignTable: u, referencedTable: g = u } = {}) { const y = typeof g > "u" ? "offset" : `${g}.offset`, E = typeof g > "u" ? "limit" : `${g}.limit`; return this.url.searchParams.set(y, `${r}`), this.url.searchParams.set(E, `${o - r + 1}`), this; }
    abortSignal(r) { return this.signal = r, this; }
    single() { return this.headers.Accept = "application/vnd.pgrst.object+json", this; }
    maybeSingle() { return this.method === "GET" ? this.headers.Accept = "application/json" : this.headers.Accept = "application/vnd.pgrst.object+json", this.isMaybeSingle = !0, this; }
    csv() { return this.headers.Accept = "text/csv", this; }
    geojson() { return this.headers.Accept = "application/geo+json", this; }
    explain({ analyze: r = !1, verbose: o = !1, settings: u = !1, buffers: g = !1, wal: y = !1, format: E = "text" } = {}) { var s; const k = [r ? "analyze" : null, o ? "verbose" : null, u ? "settings" : null, g ? "buffers" : null, y ? "wal" : null].filter(Boolean).join("|"), L = (s = this.headers.Accept) !== null && s !== void 0 ? s : "application/json"; return this.headers.Accept = `application/vnd.pgrst.plan+${E}; for="${L}"; options=${k};`, E === "json" ? this : this; }
    rollback() { var r; return ((r = this.headers.Prefer) !== null && r !== void 0 ? r : "").trim().length > 0 ? this.headers.Prefer += ",tx=rollback" : this.headers.Prefer = "tx=rollback", this; }
    returns() { return this; }
};
Pb.default = HW;
var WW = _a && _a.__importDefault || function (t) { return t && t.__esModule ? t : { default: t }; };
Object.defineProperty(o0, "__esModule", { value: !0 });
const ZW = WW(Pb);
let XW = class extends ZW.default {
    eq(r, o) { return this.url.searchParams.append(r, `eq.${o}`), this; }
    neq(r, o) { return this.url.searchParams.append(r, `neq.${o}`), this; }
    gt(r, o) { return this.url.searchParams.append(r, `gt.${o}`), this; }
    gte(r, o) { return this.url.searchParams.append(r, `gte.${o}`), this; }
    lt(r, o) { return this.url.searchParams.append(r, `lt.${o}`), this; }
    lte(r, o) { return this.url.searchParams.append(r, `lte.${o}`), this; }
    like(r, o) { return this.url.searchParams.append(r, `like.${o}`), this; }
    likeAllOf(r, o) { return this.url.searchParams.append(r, `like(all).{${o.join(",")}}`), this; }
    likeAnyOf(r, o) { return this.url.searchParams.append(r, `like(any).{${o.join(",")}}`), this; }
    ilike(r, o) { return this.url.searchParams.append(r, `ilike.${o}`), this; }
    ilikeAllOf(r, o) { return this.url.searchParams.append(r, `ilike(all).{${o.join(",")}}`), this; }
    ilikeAnyOf(r, o) { return this.url.searchParams.append(r, `ilike(any).{${o.join(",")}}`), this; }
    is(r, o) { return this.url.searchParams.append(r, `is.${o}`), this; }
    in(r, o) { const u = Array.from(new Set(o)).map(g => typeof g == "string" && new RegExp("[,()]").test(g) ? `"${g}"` : `${g}`).join(","); return this.url.searchParams.append(r, `in.(${u})`), this; }
    contains(r, o) { return typeof o == "string" ? this.url.searchParams.append(r, `cs.${o}`) : Array.isArray(o) ? this.url.searchParams.append(r, `cs.{${o.join(",")}}`) : this.url.searchParams.append(r, `cs.${JSON.stringify(o)}`), this; }
    containedBy(r, o) { return typeof o == "string" ? this.url.searchParams.append(r, `cd.${o}`) : Array.isArray(o) ? this.url.searchParams.append(r, `cd.{${o.join(",")}}`) : this.url.searchParams.append(r, `cd.${JSON.stringify(o)}`), this; }
    rangeGt(r, o) { return this.url.searchParams.append(r, `sr.${o}`), this; }
    rangeGte(r, o) { return this.url.searchParams.append(r, `nxl.${o}`), this; }
    rangeLt(r, o) { return this.url.searchParams.append(r, `sl.${o}`), this; }
    rangeLte(r, o) { return this.url.searchParams.append(r, `nxr.${o}`), this; }
    rangeAdjacent(r, o) { return this.url.searchParams.append(r, `adj.${o}`), this; }
    overlaps(r, o) { return typeof o == "string" ? this.url.searchParams.append(r, `ov.${o}`) : this.url.searchParams.append(r, `ov.{${o.join(",")}}`), this; }
    textSearch(r, o, { config: u, type: g } = {}) { let y = ""; g === "plain" ? y = "pl" : g === "phrase" ? y = "ph" : g === "websearch" && (y = "w"); const E = u === void 0 ? "" : `(${u})`; return this.url.searchParams.append(r, `${y}fts${E}.${o}`), this; }
    match(r) { return Object.entries(r).forEach(([o, u]) => { this.url.searchParams.append(o, `eq.${u}`); }), this; }
    not(r, o, u) { return this.url.searchParams.append(r, `not.${o}.${u}`), this; }
    or(r, { foreignTable: o, referencedTable: u = o } = {}) { const g = u ? `${u}.or` : "or"; return this.url.searchParams.append(g, `(${r})`), this; }
    filter(r, o, u) { return this.url.searchParams.append(r, `${o}.${u}`), this; }
};
o0.default = XW;
var KW = _a && _a.__importDefault || function (t) { return t && t.__esModule ? t : { default: t }; };
Object.defineProperty(Ib, "__esModule", { value: !0 });
const ky = KW(o0);
let YW = class {
    constructor(r, { headers: o = {}, schema: u, fetch: g }) { this.url = r, this.headers = o, this.schema = u, this.fetch = g; }
    select(r, { head: o = !1, count: u } = {}) { const g = o ? "HEAD" : "GET"; let y = !1; const E = (r ?? "*").split("").map(s => /\s/.test(s) && !y ? "" : (s === "\"" && (y = !y), s)).join(""); return this.url.searchParams.set("select", E), u && (this.headers.Prefer = `count=${u}`), new ky.default({ method: g, url: this.url, headers: this.headers, schema: this.schema, fetch: this.fetch, allowEmpty: !1 }); }
    insert(r, { count: o, defaultToNull: u = !0 } = {}) { const g = "POST", y = []; if (this.headers.Prefer && y.push(this.headers.Prefer), o && y.push(`count=${o}`), u || y.push("missing=default"), this.headers.Prefer = y.join(","), Array.isArray(r)) {
        const E = r.reduce((s, k) => s.concat(Object.keys(k)), []);
        if (E.length > 0) {
            const s = [...new Set(E)].map(k => `"${k}"`);
            this.url.searchParams.set("columns", s.join(","));
        }
    } return new ky.default({ method: g, url: this.url, headers: this.headers, schema: this.schema, body: r, fetch: this.fetch, allowEmpty: !1 }); }
    upsert(r, { onConflict: o, ignoreDuplicates: u = !1, count: g, defaultToNull: y = !0 } = {}) { const E = "POST", s = [`resolution=${u ? "ignore" : "merge"}-duplicates`]; if (o !== void 0 && this.url.searchParams.set("on_conflict", o), this.headers.Prefer && s.push(this.headers.Prefer), g && s.push(`count=${g}`), y || s.push("missing=default"), this.headers.Prefer = s.join(","), Array.isArray(r)) {
        const k = r.reduce((L, N) => L.concat(Object.keys(N)), []);
        if (k.length > 0) {
            const L = [...new Set(k)].map(N => `"${N}"`);
            this.url.searchParams.set("columns", L.join(","));
        }
    } return new ky.default({ method: E, url: this.url, headers: this.headers, schema: this.schema, body: r, fetch: this.fetch, allowEmpty: !1 }); }
    update(r, { count: o } = {}) { const u = "PATCH", g = []; return this.headers.Prefer && g.push(this.headers.Prefer), o && g.push(`count=${o}`), this.headers.Prefer = g.join(","), new ky.default({ method: u, url: this.url, headers: this.headers, schema: this.schema, body: r, fetch: this.fetch, allowEmpty: !1 }); }
    delete({ count: r } = {}) { const o = "DELETE", u = []; return r && u.push(`count=${r}`), this.headers.Prefer && u.unshift(this.headers.Prefer), this.headers.Prefer = u.join(","), new ky.default({ method: o, url: this.url, headers: this.headers, schema: this.schema, fetch: this.fetch, allowEmpty: !1 }); }
};
Ib.default = YW;
var kb = {}, Db = {};
Object.defineProperty(Db, "__esModule", { value: !0 });
Db.version = void 0;
Db.version = "0.0.0-automated";
Object.defineProperty(kb, "__esModule", { value: !0 });
kb.DEFAULT_HEADERS = void 0;
const QW = Db;
kb.DEFAULT_HEADERS = { "X-Client-Info": `postgrest-js/${QW.version}` };
var SN = _a && _a.__importDefault || function (t) { return t && t.__esModule ? t : { default: t }; };
Object.defineProperty(GA, "__esModule", { value: !0 });
const JW = SN(Ib), e9 = SN(o0), t9 = kb;
let r9 = class EN {
    constructor(r, { headers: o = {}, schema: u, fetch: g } = {}) { this.url = r, this.headers = Object.assign(Object.assign({}, t9.DEFAULT_HEADERS), o), this.schemaName = u, this.fetch = g; }
    from(r) { const o = new URL(`${this.url}/${r}`); return new JW.default(o, { headers: Object.assign({}, this.headers), schema: this.schemaName, fetch: this.fetch }); }
    schema(r) { return new EN(this.url, { headers: this.headers, schema: r, fetch: this.fetch }); }
    rpc(r, o = {}, { head: u = !1, get: g = !1, count: y } = {}) { let E; const s = new URL(`${this.url}/rpc/${r}`); let k; u || g ? (E = u ? "HEAD" : "GET", Object.entries(o).filter(([N, V]) => V !== void 0).map(([N, V]) => [N, Array.isArray(V) ? `{${V.join(",")}}` : `${V}`]).forEach(([N, V]) => { s.searchParams.append(N, V); })) : (E = "POST", k = o); const L = Object.assign({}, this.headers); return y && (L.Prefer = `count=${y}`), new e9.default({ method: E, url: s, headers: L, schema: this.schemaName, body: k, fetch: this.fetch, allowEmpty: !1 }); }
};
GA.default = r9;
var Rg = _a && _a.__importDefault || function (t) { return t && t.__esModule ? t : { default: t }; };
Object.defineProperty(Go, "__esModule", { value: !0 });
Go.PostgrestError = Go.PostgrestBuilder = Go.PostgrestTransformBuilder = Go.PostgrestFilterBuilder = Go.PostgrestQueryBuilder = Go.PostgrestClient = void 0;
const CN = Rg(GA);
Go.PostgrestClient = CN.default;
const AN = Rg(Ib);
Go.PostgrestQueryBuilder = AN.default;
const IN = Rg(o0);
Go.PostgrestFilterBuilder = IN.default;
const PN = Rg(Pb);
Go.PostgrestTransformBuilder = PN.default;
const MN = Rg(Mb);
Go.PostgrestBuilder = MN.default;
const RN = Rg(Rb);
Go.PostgrestError = RN.default;
var n9 = Go.default = { PostgrestClient: CN.default, PostgrestQueryBuilder: AN.default, PostgrestFilterBuilder: IN.default, PostgrestTransformBuilder: PN.default, PostgrestBuilder: MN.default, PostgrestError: RN.default };
const { PostgrestClient: i9, PostgrestQueryBuilder: gee, PostgrestFilterBuilder: _ee, PostgrestTransformBuilder: yee, PostgrestBuilder: vee, PostgrestError: xee } = n9, s9 = "2.11.2", o9 = { "X-Client-Info": `realtime-js/${s9}` }, a9 = "1.0.0", kN = 1e4, l9 = 1e3;
var $m;
(function (t) { t[t.connecting = 0] = "connecting", t[t.open = 1] = "open", t[t.closing = 2] = "closing", t[t.closed = 3] = "closed"; })($m || ($m = {}));
var ca;
(function (t) { t.closed = "closed", t.errored = "errored", t.joined = "joined", t.joining = "joining", t.leaving = "leaving"; })(ca || (ca = {}));
var hl;
(function (t) { t.close = "phx_close", t.error = "phx_error", t.join = "phx_join", t.reply = "phx_reply", t.leave = "phx_leave", t.access_token = "access_token"; })(hl || (hl = {}));
var aC;
(function (t) { t.websocket = "websocket"; })(aC || (aC = {}));
var uf;
(function (t) { t.Connecting = "connecting", t.Open = "open", t.Closing = "closing", t.Closed = "closed"; })(uf || (uf = {}));
class c9 {
    constructor() { this.HEADER_LENGTH = 1; }
    decode(r, o) { return r.constructor === ArrayBuffer ? o(this._binaryDecode(r)) : o(typeof r == "string" ? JSON.parse(r) : {}); }
    _binaryDecode(r) { const o = new DataView(r), u = new TextDecoder; return this._decodeBroadcast(r, o, u); }
    _decodeBroadcast(r, o, u) { const g = o.getUint8(1), y = o.getUint8(2); let E = this.HEADER_LENGTH + 2; const s = u.decode(r.slice(E, E + g)); E = E + g; const k = u.decode(r.slice(E, E + y)); E = E + y; const L = JSON.parse(u.decode(r.slice(E, r.byteLength))); return { ref: null, topic: s, event: k, payload: L }; }
}
class DN {
    constructor(r, o) { this.callback = r, this.timerCalc = o, this.timer = void 0, this.tries = 0, this.callback = r, this.timerCalc = o; }
    reset() { this.tries = 0, clearTimeout(this.timer); }
    scheduleTimeout() { clearTimeout(this.timer), this.timer = setTimeout(() => { this.tries = this.tries + 1, this.callback(); }, this.timerCalc(this.tries + 1)); }
}
var Li;
(function (t) { t.abstime = "abstime", t.bool = "bool", t.date = "date", t.daterange = "daterange", t.float4 = "float4", t.float8 = "float8", t.int2 = "int2", t.int4 = "int4", t.int4range = "int4range", t.int8 = "int8", t.int8range = "int8range", t.json = "json", t.jsonb = "jsonb", t.money = "money", t.numeric = "numeric", t.oid = "oid", t.reltime = "reltime", t.text = "text", t.time = "time", t.timestamp = "timestamp", t.timestamptz = "timestamptz", t.timetz = "timetz", t.tsrange = "tsrange", t.tstzrange = "tstzrange"; })(Li || (Li = {}));
const dL = (t, r, o = {}) => { var u; const g = (u = o.skipTypes) !== null && u !== void 0 ? u : []; return Object.keys(r).reduce((y, E) => (y[E] = u9(E, t, r, g), y), {}); }, u9 = (t, r, o, u) => { const g = r.find(s => s.name === t), y = g == null ? void 0 : g.type, E = o[t]; return y && !u.includes(y) ? LN(y, E) : lC(E); }, LN = (t, r) => { if (t.charAt(0) === "_") {
    const o = t.slice(1, t.length);
    return p9(r, o);
} switch (t) {
    case Li.bool: return h9(r);
    case Li.float4:
    case Li.float8:
    case Li.int2:
    case Li.int4:
    case Li.int8:
    case Li.numeric:
    case Li.oid: return d9(r);
    case Li.json:
    case Li.jsonb: return f9(r);
    case Li.timestamp: return m9(r);
    case Li.abstime:
    case Li.date:
    case Li.daterange:
    case Li.int4range:
    case Li.int8range:
    case Li.money:
    case Li.reltime:
    case Li.text:
    case Li.time:
    case Li.timestamptz:
    case Li.timetz:
    case Li.tsrange:
    case Li.tstzrange: return lC(r);
    default: return lC(r);
} }, lC = t => t, h9 = t => { switch (t) {
    case "t": return !0;
    case "f": return !1;
    default: return t;
} }, d9 = t => { if (typeof t == "string") {
    const r = parseFloat(t);
    if (!Number.isNaN(r))
        return r;
} return t; }, f9 = t => { if (typeof t == "string")
    try {
        return JSON.parse(t);
    }
    catch (r) {
        return console.log(`JSON parse error: ${r}`), t;
    } return t; }, p9 = (t, r) => { if (typeof t != "string")
    return t; const o = t.length - 1, u = t[o]; if (t[0] === "{" && u === "}") {
    let y;
    const E = t.slice(1, o);
    try {
        y = JSON.parse("[" + E + "]");
    }
    catch {
        y = E ? E.split(",") : [];
    }
    return y.map(s => LN(r, s));
} return t; }, m9 = t => typeof t == "string" ? t.replace(" ", "T") : t, ON = t => { let r = t; return r = r.replace(/^ws/i, "http"), r = r.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, ""), r.replace(/\/+$/, ""); };
class CE {
    constructor(r, o, u = {}, g = kN) { this.channel = r, this.event = o, this.payload = u, this.timeout = g, this.sent = !1, this.timeoutTimer = void 0, this.ref = "", this.receivedResp = null, this.recHooks = [], this.refEvent = null; }
    resend(r) { this.timeout = r, this._cancelRefEvent(), this.ref = "", this.refEvent = null, this.receivedResp = null, this.sent = !1, this.send(); }
    send() { this._hasReceived("timeout") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({ topic: this.channel.topic, event: this.event, payload: this.payload, ref: this.ref, join_ref: this.channel._joinRef() })); }
    updatePayload(r) { this.payload = Object.assign(Object.assign({}, this.payload), r); }
    receive(r, o) { var u; return this._hasReceived(r) && o((u = this.receivedResp) === null || u === void 0 ? void 0 : u.response), this.recHooks.push({ status: r, callback: o }), this; }
    startTimeout() { if (this.timeoutTimer)
        return; this.ref = this.channel.socket._makeRef(), this.refEvent = this.channel._replyEventName(this.ref); const r = o => { this._cancelRefEvent(), this._cancelTimeout(), this.receivedResp = o, this._matchReceive(o); }; this.channel._on(this.refEvent, {}, r), this.timeoutTimer = setTimeout(() => { this.trigger("timeout", {}); }, this.timeout); }
    trigger(r, o) { this.refEvent && this.channel._trigger(this.refEvent, { status: r, response: o }); }
    destroy() { this._cancelRefEvent(), this._cancelTimeout(); }
    _cancelRefEvent() { this.refEvent && this.channel._off(this.refEvent, {}); }
    _cancelTimeout() { clearTimeout(this.timeoutTimer), this.timeoutTimer = void 0; }
    _matchReceive({ status: r, response: o }) { this.recHooks.filter(u => u.status === r).forEach(u => u.callback(o)); }
    _hasReceived(r) { return this.receivedResp && this.receivedResp.status === r; }
}
var fL;
(function (t) { t.SYNC = "sync", t.JOIN = "join", t.LEAVE = "leave"; })(fL || (fL = {}));
class sv {
    constructor(r, o) { this.channel = r, this.state = {}, this.pendingDiffs = [], this.joinRef = null, this.caller = { onJoin: () => { }, onLeave: () => { }, onSync: () => { } }; const u = (o == null ? void 0 : o.events) || { state: "presence_state", diff: "presence_diff" }; this.channel._on(u.state, {}, g => { const { onJoin: y, onLeave: E, onSync: s } = this.caller; this.joinRef = this.channel._joinRef(), this.state = sv.syncState(this.state, g, y, E), this.pendingDiffs.forEach(k => { this.state = sv.syncDiff(this.state, k, y, E); }), this.pendingDiffs = [], s(); }), this.channel._on(u.diff, {}, g => { const { onJoin: y, onLeave: E, onSync: s } = this.caller; this.inPendingSyncState() ? this.pendingDiffs.push(g) : (this.state = sv.syncDiff(this.state, g, y, E), s()); }), this.onJoin((g, y, E) => { this.channel._trigger("presence", { event: "join", key: g, currentPresences: y, newPresences: E }); }), this.onLeave((g, y, E) => { this.channel._trigger("presence", { event: "leave", key: g, currentPresences: y, leftPresences: E }); }), this.onSync(() => { this.channel._trigger("presence", { event: "sync" }); }); }
    static syncState(r, o, u, g) { const y = this.cloneDeep(r), E = this.transformState(o), s = {}, k = {}; return this.map(y, (L, N) => { E[L] || (k[L] = N); }), this.map(E, (L, N) => { const V = y[L]; if (V) {
        const H = N.map(ye => ye.presence_ref), ee = V.map(ye => ye.presence_ref), ce = N.filter(ye => ee.indexOf(ye.presence_ref) < 0), J = V.filter(ye => H.indexOf(ye.presence_ref) < 0);
        ce.length > 0 && (s[L] = ce), J.length > 0 && (k[L] = J);
    }
    else
        s[L] = N; }), this.syncDiff(y, { joins: s, leaves: k }, u, g); }
    static syncDiff(r, o, u, g) { const { joins: y, leaves: E } = { joins: this.transformState(o.joins), leaves: this.transformState(o.leaves) }; return u || (u = () => { }), g || (g = () => { }), this.map(y, (s, k) => { var L; const N = (L = r[s]) !== null && L !== void 0 ? L : []; if (r[s] = this.cloneDeep(k), N.length > 0) {
        const V = r[s].map(ee => ee.presence_ref), H = N.filter(ee => V.indexOf(ee.presence_ref) < 0);
        r[s].unshift(...H);
    } u(s, N, k); }), this.map(E, (s, k) => { let L = r[s]; if (!L)
        return; const N = k.map(V => V.presence_ref); L = L.filter(V => N.indexOf(V.presence_ref) < 0), r[s] = L, g(s, L, k), L.length === 0 && delete r[s]; }), r; }
    static map(r, o) { return Object.getOwnPropertyNames(r).map(u => o(u, r[u])); }
    static transformState(r) { return r = this.cloneDeep(r), Object.getOwnPropertyNames(r).reduce((o, u) => { const g = r[u]; return "metas" in g ? o[u] = g.metas.map(y => (y.presence_ref = y.phx_ref, delete y.phx_ref, delete y.phx_ref_prev, y)) : o[u] = g, o; }, {}); }
    static cloneDeep(r) { return JSON.parse(JSON.stringify(r)); }
    onJoin(r) { this.caller.onJoin = r; }
    onLeave(r) { this.caller.onLeave = r; }
    onSync(r) { this.caller.onSync = r; }
    inPendingSyncState() { return !this.joinRef || this.joinRef !== this.channel._joinRef(); }
}
var pL;
(function (t) { t.ALL = "*", t.INSERT = "INSERT", t.UPDATE = "UPDATE", t.DELETE = "DELETE"; })(pL || (pL = {}));
var mL;
(function (t) { t.BROADCAST = "broadcast", t.PRESENCE = "presence", t.POSTGRES_CHANGES = "postgres_changes", t.SYSTEM = "system"; })(mL || (mL = {}));
var Yc;
(function (t) { t.SUBSCRIBED = "SUBSCRIBED", t.TIMED_OUT = "TIMED_OUT", t.CLOSED = "CLOSED", t.CHANNEL_ERROR = "CHANNEL_ERROR"; })(Yc || (Yc = {}));
class qA {
    constructor(r, o = { config: {} }, u) { this.topic = r, this.params = o, this.socket = u, this.bindings = {}, this.state = ca.closed, this.joinedOnce = !1, this.pushBuffer = [], this.subTopic = r.replace(/^realtime:/i, ""), this.params.config = Object.assign({ broadcast: { ack: !1, self: !1 }, presence: { key: "" }, private: !1 }, o.config), this.timeout = this.socket.timeout, this.joinPush = new CE(this, hl.join, this.params, this.timeout), this.rejoinTimer = new DN(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs), this.joinPush.receive("ok", () => { this.state = ca.joined, this.rejoinTimer.reset(), this.pushBuffer.forEach(g => g.send()), this.pushBuffer = []; }), this._onClose(() => { this.rejoinTimer.reset(), this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`), this.state = ca.closed, this.socket._remove(this); }), this._onError(g => { this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, g), this.state = ca.errored, this.rejoinTimer.scheduleTimeout()); }), this.joinPush.receive("timeout", () => { this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout), this.state = ca.errored, this.rejoinTimer.scheduleTimeout()); }), this._on(hl.reply, {}, (g, y) => { this._trigger(this._replyEventName(y), g); }), this.presence = new sv(this), this.broadcastEndpointURL = ON(this.socket.endPoint) + "/api/broadcast", this.private = this.params.config.private || !1; }
    subscribe(r, o = this.timeout) { var u, g; if (this.socket.isConnected() || this.socket.connect(), this.joinedOnce)
        throw "tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance"; {
        const { config: { broadcast: y, presence: E, private: s } } = this.params;
        this._onError(N => r == null ? void 0 : r(Yc.CHANNEL_ERROR, N)), this._onClose(() => r == null ? void 0 : r(Yc.CLOSED));
        const k = {}, L = { broadcast: y, presence: E, postgres_changes: (g = (u = this.bindings.postgres_changes) === null || u === void 0 ? void 0 : u.map(N => N.filter)) !== null && g !== void 0 ? g : [], private: s };
        this.socket.accessTokenValue && (k.access_token = this.socket.accessTokenValue), this.updateJoinPayload(Object.assign({ config: L }, k)), this.joinedOnce = !0, this._rejoin(o), this.joinPush.receive("ok", async ({ postgres_changes: N }) => { var V; if (this.socket.setAuth(), N === void 0) {
            r == null || r(Yc.SUBSCRIBED);
            return;
        }
        else {
            const H = this.bindings.postgres_changes, ee = (V = H == null ? void 0 : H.length) !== null && V !== void 0 ? V : 0, ce = [];
            for (let J = 0; J < ee; J++) {
                const ye = H[J], { filter: { event: ie, schema: Q, table: ue, filter: be } } = ye, Ie = N && N[J];
                if (Ie && Ie.event === ie && Ie.schema === Q && Ie.table === ue && Ie.filter === be)
                    ce.push(Object.assign(Object.assign({}, ye), { id: Ie.id }));
                else {
                    this.unsubscribe(), r == null || r(Yc.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
                    return;
                }
            }
            this.bindings.postgres_changes = ce, r && r(Yc.SUBSCRIBED);
            return;
        } }).receive("error", N => { r == null || r(Yc.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(N).join(", ") || "error"))); }).receive("timeout", () => { r == null || r(Yc.TIMED_OUT); });
    } return this; }
    presenceState() { return this.presence.state; }
    async track(r, o = {}) { return await this.send({ type: "presence", event: "track", payload: r }, o.timeout || this.timeout); }
    async untrack(r = {}) { return await this.send({ type: "presence", event: "untrack" }, r); }
    on(r, o, u) { return this._on(r, o, u); }
    async send(r, o = {}) { var u, g; if (!this._canPush() && r.type === "broadcast") {
        const { event: y, payload: E } = r, k = { method: "POST", headers: { Authorization: this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "", apikey: this.socket.apiKey ? this.socket.apiKey : "", "Content-Type": "application/json" }, body: JSON.stringify({ messages: [{ topic: this.subTopic, event: y, payload: E, private: this.private }] }) };
        try {
            const L = await this._fetchWithTimeout(this.broadcastEndpointURL, k, (u = o.timeout) !== null && u !== void 0 ? u : this.timeout);
            return await ((g = L.body) === null || g === void 0 ? void 0 : g.cancel()), L.ok ? "ok" : "error";
        }
        catch (L) {
            return L.name === "AbortError" ? "timed out" : "error";
        }
    }
    else
        return new Promise(y => { var E, s, k; const L = this._push(r.type, r, o.timeout || this.timeout); r.type === "broadcast" && !(!((k = (s = (E = this.params) === null || E === void 0 ? void 0 : E.config) === null || s === void 0 ? void 0 : s.broadcast) === null || k === void 0) && k.ack) && y("ok"), L.receive("ok", () => y("ok")), L.receive("error", () => y("error")), L.receive("timeout", () => y("timed out")); }); }
    updateJoinPayload(r) { this.joinPush.updatePayload(r); }
    unsubscribe(r = this.timeout) { this.state = ca.leaving; const o = () => { this.socket.log("channel", `leave ${this.topic}`), this._trigger(hl.close, "leave", this._joinRef()); }; return this.rejoinTimer.reset(), this.joinPush.destroy(), new Promise(u => { const g = new CE(this, hl.leave, {}, r); g.receive("ok", () => { o(), u("ok"); }).receive("timeout", () => { o(), u("timed out"); }).receive("error", () => { u("error"); }), g.send(), this._canPush() || g.trigger("ok", {}); }); }
    async _fetchWithTimeout(r, o, u) { const g = new AbortController, y = setTimeout(() => g.abort(), u), E = await this.socket.fetch(r, Object.assign(Object.assign({}, o), { signal: g.signal })); return clearTimeout(y), E; }
    _push(r, o, u = this.timeout) { if (!this.joinedOnce)
        throw `tried to push '${r}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`; let g = new CE(this, r, o, u); return this._canPush() ? g.send() : (g.startTimeout(), this.pushBuffer.push(g)), g; }
    _onMessage(r, o, u) { return o; }
    _isMember(r) { return this.topic === r; }
    _joinRef() { return this.joinPush.ref; }
    _trigger(r, o, u) { var g, y; const E = r.toLocaleLowerCase(), { close: s, error: k, leave: L, join: N } = hl; if (u && [s, k, L, N].indexOf(E) >= 0 && u !== this._joinRef())
        return; let H = this._onMessage(E, o, u); if (o && !H)
        throw "channel onMessage callbacks must return the payload, modified or unmodified"; ["insert", "update", "delete"].includes(E) ? (g = this.bindings.postgres_changes) === null || g === void 0 || g.filter(ee => { var ce, J, ye; return ((ce = ee.filter) === null || ce === void 0 ? void 0 : ce.event) === "*" || ((ye = (J = ee.filter) === null || J === void 0 ? void 0 : J.event) === null || ye === void 0 ? void 0 : ye.toLocaleLowerCase()) === E; }).map(ee => ee.callback(H, u)) : (y = this.bindings[E]) === null || y === void 0 || y.filter(ee => { var ce, J, ye, ie, Q, ue; if (["broadcast", "presence", "postgres_changes"].includes(E))
        if ("id" in ee) {
            const be = ee.id, Ie = (ce = ee.filter) === null || ce === void 0 ? void 0 : ce.event;
            return be && ((J = o.ids) === null || J === void 0 ? void 0 : J.includes(be)) && (Ie === "*" || (Ie == null ? void 0 : Ie.toLocaleLowerCase()) === ((ye = o.data) === null || ye === void 0 ? void 0 : ye.type.toLocaleLowerCase()));
        }
        else {
            const be = (Q = (ie = ee == null ? void 0 : ee.filter) === null || ie === void 0 ? void 0 : ie.event) === null || Q === void 0 ? void 0 : Q.toLocaleLowerCase();
            return be === "*" || be === ((ue = o == null ? void 0 : o.event) === null || ue === void 0 ? void 0 : ue.toLocaleLowerCase());
        }
    else
        return ee.type.toLocaleLowerCase() === E; }).map(ee => { if (typeof H == "object" && "ids" in H) {
        const ce = H.data, { schema: J, table: ye, commit_timestamp: ie, type: Q, errors: ue } = ce;
        H = Object.assign(Object.assign({}, { schema: J, table: ye, commit_timestamp: ie, eventType: Q, new: {}, old: {}, errors: ue }), this._getPayloadRecords(ce));
    } ee.callback(H, u); }); }
    _isClosed() { return this.state === ca.closed; }
    _isJoined() { return this.state === ca.joined; }
    _isJoining() { return this.state === ca.joining; }
    _isLeaving() { return this.state === ca.leaving; }
    _replyEventName(r) { return `chan_reply_${r}`; }
    _on(r, o, u) { const g = r.toLocaleLowerCase(), y = { type: g, filter: o, callback: u }; return this.bindings[g] ? this.bindings[g].push(y) : this.bindings[g] = [y], this; }
    _off(r, o) { const u = r.toLocaleLowerCase(); return this.bindings[u] = this.bindings[u].filter(g => { var y; return !(((y = g.type) === null || y === void 0 ? void 0 : y.toLocaleLowerCase()) === u && qA.isEqual(g.filter, o)); }), this; }
    static isEqual(r, o) { if (Object.keys(r).length !== Object.keys(o).length)
        return !1; for (const u in r)
        if (r[u] !== o[u])
            return !1; return !0; }
    _rejoinUntilConnected() { this.rejoinTimer.scheduleTimeout(), this.socket.isConnected() && this._rejoin(); }
    _onClose(r) { this._on(hl.close, {}, r); }
    _onError(r) { this._on(hl.error, {}, o => r(o)); }
    _canPush() { return this.socket.isConnected() && this._isJoined(); }
    _rejoin(r = this.timeout) { this._isLeaving() || (this.socket._leaveOpenTopic(this.topic), this.state = ca.joining, this.joinPush.resend(r)); }
    _getPayloadRecords(r) { const o = { new: {}, old: {} }; return (r.type === "INSERT" || r.type === "UPDATE") && (o.new = dL(r.columns, r.record)), (r.type === "UPDATE" || r.type === "DELETE") && (o.old = dL(r.columns, r.old_record)), o; }
}
const g9 = () => { }, _9 = typeof WebSocket < "u", y9 = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
class v9 {
    constructor(r, o) { var u; this.accessTokenValue = null, this.apiKey = null, this.channels = [], this.endPoint = "", this.httpEndpoint = "", this.headers = o9, this.params = {}, this.timeout = kN, this.heartbeatIntervalMs = 3e4, this.heartbeatTimer = void 0, this.pendingHeartbeatRef = null, this.ref = 0, this.logger = g9, this.conn = null, this.sendBuffer = [], this.serializer = new c9, this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] }, this.accessToken = null, this._resolveFetch = y => { let E; return y ? E = y : typeof fetch > "u" ? E = (...s) => gg(async () => { const { default: k } = await Promise.resolve().then(() => Mg); return { default: k }; }, void 0).then(({ default: k }) => k(...s)) : E = fetch, (...s) => E(...s); }, this.endPoint = `${r}/${aC.websocket}`, this.httpEndpoint = ON(r), o != null && o.transport ? this.transport = o.transport : this.transport = null, o != null && o.params && (this.params = o.params), o != null && o.headers && (this.headers = Object.assign(Object.assign({}, this.headers), o.headers)), o != null && o.timeout && (this.timeout = o.timeout), o != null && o.logger && (this.logger = o.logger), o != null && o.heartbeatIntervalMs && (this.heartbeatIntervalMs = o.heartbeatIntervalMs); const g = (u = o == null ? void 0 : o.params) === null || u === void 0 ? void 0 : u.apikey; if (g && (this.accessTokenValue = g, this.apiKey = g), this.reconnectAfterMs = o != null && o.reconnectAfterMs ? o.reconnectAfterMs : y => [1e3, 2e3, 5e3, 1e4][y - 1] || 1e4, this.encode = o != null && o.encode ? o.encode : (y, E) => E(JSON.stringify(y)), this.decode = o != null && o.decode ? o.decode : this.serializer.decode.bind(this.serializer), this.reconnectTimer = new DN(async () => { this.disconnect(), this.connect(); }, this.reconnectAfterMs), this.fetch = this._resolveFetch(o == null ? void 0 : o.fetch), o != null && o.worker) {
        if (typeof window < "u" && !window.Worker)
            throw new Error("Web Worker is not supported");
        this.worker = (o == null ? void 0 : o.worker) || !1, this.workerUrl = o == null ? void 0 : o.workerUrl;
    } this.accessToken = (o == null ? void 0 : o.accessToken) || null; }
    connect() { if (!this.conn) {
        if (this.transport) {
            this.conn = new this.transport(this.endpointURL(), void 0, { headers: this.headers });
            return;
        }
        if (_9) {
            this.conn = new WebSocket(this.endpointURL()), this.setupConnection();
            return;
        }
        this.conn = new x9(this.endpointURL(), void 0, { close: () => { this.conn = null; } }), gg(async () => { const { default: r } = await import("./browser-Cs8T0YlK.js").then(o => o.b); return { default: r }; }, []).then(({ default: r }) => { this.conn = new r(this.endpointURL(), void 0, { headers: this.headers }), this.setupConnection(); });
    } }
    endpointURL() { return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: a9 })); }
    disconnect(r, o) { this.conn && (this.conn.onclose = function () { }, r ? this.conn.close(r, o ?? "") : this.conn.close(), this.conn = null, this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.reconnectTimer.reset()); }
    getChannels() { return this.channels; }
    async removeChannel(r) { const o = await r.unsubscribe(); return this.channels.length === 0 && this.disconnect(), o; }
    async removeAllChannels() { const r = await Promise.all(this.channels.map(o => o.unsubscribe())); return this.disconnect(), r; }
    log(r, o, u) { this.logger(r, o, u); }
    connectionState() { switch (this.conn && this.conn.readyState) {
        case $m.connecting: return uf.Connecting;
        case $m.open: return uf.Open;
        case $m.closing: return uf.Closing;
        default: return uf.Closed;
    } }
    isConnected() { return this.connectionState() === uf.Open; }
    channel(r, o = { config: {} }) { const u = new qA(`realtime:${r}`, o, this); return this.channels.push(u), u; }
    push(r) { const { topic: o, event: u, payload: g, ref: y } = r, E = () => { this.encode(r, s => { var k; (k = this.conn) === null || k === void 0 || k.send(s); }); }; this.log("push", `${o} ${u} (${y})`, g), this.isConnected() ? E() : this.sendBuffer.push(E); }
    async setAuth(r = null) { let o = r || this.accessToken && await this.accessToken() || this.accessTokenValue; if (o) {
        let u = null;
        try {
            u = JSON.parse(atob(o.split(".")[1]));
        }
        catch { }
        if (u && u.exp && !(Math.floor(Date.now() / 1e3) - u.exp < 0))
            return this.log("auth", `InvalidJWTToken: Invalid value for JWT claim "exp" with value ${u.exp}`), Promise.reject(`InvalidJWTToken: Invalid value for JWT claim "exp" with value ${u.exp}`);
        this.accessTokenValue = o, this.channels.forEach(g => { o && g.updateJoinPayload({ access_token: o }), g.joinedOnce && g._isJoined() && g._push(hl.access_token, { access_token: o }); });
    } }
    async sendHeartbeat() { var r; if (this.isConnected()) {
        if (this.pendingHeartbeatRef) {
            this.pendingHeartbeatRef = null, this.log("transport", "heartbeat timeout. Attempting to re-establish connection"), (r = this.conn) === null || r === void 0 || r.close(l9, "hearbeat timeout");
            return;
        }
        this.pendingHeartbeatRef = this._makeRef(), this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef }), this.setAuth();
    } }
    flushSendBuffer() { this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(r => r()), this.sendBuffer = []); }
    _makeRef() { let r = this.ref + 1; return r === this.ref ? this.ref = 0 : this.ref = r, this.ref.toString(); }
    _leaveOpenTopic(r) { let o = this.channels.find(u => u.topic === r && (u._isJoined() || u._isJoining())); o && (this.log("transport", `leaving duplicate topic "${r}"`), o.unsubscribe()); }
    _remove(r) { this.channels = this.channels.filter(o => o._joinRef() !== r._joinRef()); }
    setupConnection() { this.conn && (this.conn.binaryType = "arraybuffer", this.conn.onopen = () => this._onConnOpen(), this.conn.onerror = r => this._onConnError(r), this.conn.onmessage = r => this._onConnMessage(r), this.conn.onclose = r => this._onConnClose(r)); }
    _onConnMessage(r) { this.decode(r.data, o => { let { topic: u, event: g, payload: y, ref: E } = o; E && E === this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null), this.log("receive", `${y.status || ""} ${u} ${g} ${E && "(" + E + ")" || ""}`, y), this.channels.filter(s => s._isMember(u)).forEach(s => s._trigger(g, y, E)), this.stateChangeCallbacks.message.forEach(s => s(o)); }); }
    async _onConnOpen() { if (this.log("transport", `connected to ${this.endpointURL()}`), this.flushSendBuffer(), this.reconnectTimer.reset(), !this.worker)
        this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    else {
        this.workerUrl ? this.log("worker", `starting worker for from ${this.workerUrl}`) : this.log("worker", "starting default worker");
        const r = this._workerObjectUrl(this.workerUrl);
        this.workerRef = new Worker(r), this.workerRef.onerror = o => { this.log("worker", "worker error", o.message), this.workerRef.terminate(); }, this.workerRef.onmessage = o => { o.data.event === "keepAlive" && this.sendHeartbeat(); }, this.workerRef.postMessage({ event: "start", interval: this.heartbeatIntervalMs });
    } this.stateChangeCallbacks.open.forEach(r => r()); }
    _onConnClose(r) { this.log("transport", "close", r), this._triggerChanError(), this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.reconnectTimer.scheduleTimeout(), this.stateChangeCallbacks.close.forEach(o => o(r)); }
    _onConnError(r) { this.log("transport", r.message), this._triggerChanError(), this.stateChangeCallbacks.error.forEach(o => o(r)); }
    _triggerChanError() { this.channels.forEach(r => r._trigger(hl.error)); }
    _appendParams(r, o) { if (Object.keys(o).length === 0)
        return r; const u = r.match(/\?/) ? "&" : "?", g = new URLSearchParams(o); return `${r}${u}${g}`; }
    _workerObjectUrl(r) { let o; if (r)
        o = r;
    else {
        const u = new Blob([y9], { type: "application/javascript" });
        o = URL.createObjectURL(u);
    } return o; }
}
class x9 {
    constructor(r, o, u) { this.binaryType = "arraybuffer", this.onclose = () => { }, this.onerror = () => { }, this.onmessage = () => { }, this.onopen = () => { }, this.readyState = $m.connecting, this.send = () => { }, this.url = null, this.url = r, this.close = u.close; }
}
class HA extends Error {
    constructor(r) { super(r), this.__isStorageError = !0, this.name = "StorageError"; }
}
function Os(t) { return typeof t == "object" && t !== null && "__isStorageError" in t; }
class w9 extends HA {
    constructor(r, o) { super(r), this.name = "StorageApiError", this.status = o; }
    toJSON() { return { name: this.name, message: this.message, status: this.status }; }
}
class cC extends HA {
    constructor(r, o) { super(r), this.name = "StorageUnknownError", this.originalError = o; }
}
var b9 = function (t, r, o, u) { function g(y) { return y instanceof o ? y : new o(function (E) { E(y); }); } return new (o || (o = Promise))(function (y, E) { function s(N) { try {
    L(u.next(N));
}
catch (V) {
    E(V);
} } function k(N) { try {
    L(u.throw(N));
}
catch (V) {
    E(V);
} } function L(N) { N.done ? y(N.value) : g(N.value).then(s, k); } L((u = u.apply(t, r || [])).next()); }); };
const zN = t => { let r; return t ? r = t : typeof fetch > "u" ? r = (...o) => gg(async () => { const { default: u } = await Promise.resolve().then(() => Mg); return { default: u }; }, void 0).then(({ default: u }) => u(...o)) : r = fetch, (...o) => r(...o); }, T9 = () => b9(void 0, void 0, void 0, function* () { return typeof Response > "u" ? (yield gg(() => Promise.resolve().then(() => Mg), void 0)).Response : Response; }), uC = t => { if (Array.isArray(t))
    return t.map(o => uC(o)); if (typeof t == "function" || t !== Object(t))
    return t; const r = {}; return Object.entries(t).forEach(([o, u]) => { const g = o.replace(/([-_][a-z])/gi, y => y.toUpperCase().replace(/[-_]/g, "")); r[g] = uC(u); }), r; };
var Vf = function (t, r, o, u) { function g(y) { return y instanceof o ? y : new o(function (E) { E(y); }); } return new (o || (o = Promise))(function (y, E) { function s(N) { try {
    L(u.next(N));
}
catch (V) {
    E(V);
} } function k(N) { try {
    L(u.throw(N));
}
catch (V) {
    E(V);
} } function L(N) { N.done ? y(N.value) : g(N.value).then(s, k); } L((u = u.apply(t, r || [])).next()); }); };
const AE = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t), S9 = (t, r, o) => Vf(void 0, void 0, void 0, function* () { const u = yield T9(); t instanceof u && !(o != null && o.noResolveJson) ? t.json().then(g => { r(new w9(AE(g), t.status || 500)); }).catch(g => { r(new cC(AE(g), g)); }) : r(new cC(AE(t), t)); }), E9 = (t, r, o, u) => { const g = { method: t, headers: (r == null ? void 0 : r.headers) || {} }; return t === "GET" ? g : (g.headers = Object.assign({ "Content-Type": "application/json" }, r == null ? void 0 : r.headers), u && (g.body = JSON.stringify(u)), Object.assign(Object.assign({}, g), o)); };
function a0(t, r, o, u, g, y) { return Vf(this, void 0, void 0, function* () { return new Promise((E, s) => { t(o, E9(r, u, g, y)).then(k => { if (!k.ok)
    throw k; return u != null && u.noResolveJson ? k : k.json(); }).then(k => E(k)).catch(k => S9(k, s, u)); }); }); }
function Fw(t, r, o, u) { return Vf(this, void 0, void 0, function* () { return a0(t, "GET", r, o, u); }); }
function gh(t, r, o, u, g) { return Vf(this, void 0, void 0, function* () { return a0(t, "POST", r, u, g, o); }); }
function C9(t, r, o, u, g) { return Vf(this, void 0, void 0, function* () { return a0(t, "PUT", r, u, g, o); }); }
function A9(t, r, o, u) { return Vf(this, void 0, void 0, function* () { return a0(t, "HEAD", r, Object.assign(Object.assign({}, o), { noResolveJson: !0 }), u); }); }
function FN(t, r, o, u, g) { return Vf(this, void 0, void 0, function* () { return a0(t, "DELETE", r, u, g, o); }); }
var jo = function (t, r, o, u) { function g(y) { return y instanceof o ? y : new o(function (E) { E(y); }); } return new (o || (o = Promise))(function (y, E) { function s(N) { try {
    L(u.next(N));
}
catch (V) {
    E(V);
} } function k(N) { try {
    L(u.throw(N));
}
catch (V) {
    E(V);
} } function L(N) { N.done ? y(N.value) : g(N.value).then(s, k); } L((u = u.apply(t, r || [])).next()); }); };
const I9 = { limit: 100, offset: 0, sortBy: { column: "name", order: "asc" } }, gL = { cacheControl: "3600", contentType: "text/plain;charset=UTF-8", upsert: !1 };
class P9 {
    constructor(r, o = {}, u, g) { this.url = r, this.headers = o, this.bucketId = u, this.fetch = zN(g); }
    uploadOrUpdate(r, o, u, g) { return jo(this, void 0, void 0, function* () { try {
        let y;
        const E = Object.assign(Object.assign({}, gL), g);
        let s = Object.assign(Object.assign({}, this.headers), r === "POST" && { "x-upsert": String(E.upsert) });
        const k = E.metadata;
        typeof Blob < "u" && u instanceof Blob ? (y = new FormData, y.append("cacheControl", E.cacheControl), k && y.append("metadata", this.encodeMetadata(k)), y.append("", u)) : typeof FormData < "u" && u instanceof FormData ? (y = u, y.append("cacheControl", E.cacheControl), k && y.append("metadata", this.encodeMetadata(k))) : (y = u, s["cache-control"] = `max-age=${E.cacheControl}`, s["content-type"] = E.contentType, k && (s["x-metadata"] = this.toBase64(this.encodeMetadata(k)))), g != null && g.headers && (s = Object.assign(Object.assign({}, s), g.headers));
        const L = this._removeEmptyFolders(o), N = this._getFinalPath(L), V = yield this.fetch(`${this.url}/object/${N}`, Object.assign({ method: r, body: y, headers: s }, E != null && E.duplex ? { duplex: E.duplex } : {})), H = yield V.json();
        return V.ok ? { data: { path: L, id: H.Id, fullPath: H.Key }, error: null } : { data: null, error: H };
    }
    catch (y) {
        if (Os(y))
            return { data: null, error: y };
        throw y;
    } }); }
    upload(r, o, u) { return jo(this, void 0, void 0, function* () { return this.uploadOrUpdate("POST", r, o, u); }); }
    uploadToSignedUrl(r, o, u, g) { return jo(this, void 0, void 0, function* () { const y = this._removeEmptyFolders(r), E = this._getFinalPath(y), s = new URL(this.url + `/object/upload/sign/${E}`); s.searchParams.set("token", o); try {
        let k;
        const L = Object.assign({ upsert: gL.upsert }, g), N = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(L.upsert) });
        typeof Blob < "u" && u instanceof Blob ? (k = new FormData, k.append("cacheControl", L.cacheControl), k.append("", u)) : typeof FormData < "u" && u instanceof FormData ? (k = u, k.append("cacheControl", L.cacheControl)) : (k = u, N["cache-control"] = `max-age=${L.cacheControl}`, N["content-type"] = L.contentType);
        const V = yield this.fetch(s.toString(), { method: "PUT", body: k, headers: N }), H = yield V.json();
        return V.ok ? { data: { path: y, fullPath: H.Key }, error: null } : { data: null, error: H };
    }
    catch (k) {
        if (Os(k))
            return { data: null, error: k };
        throw k;
    } }); }
    createSignedUploadUrl(r, o) { return jo(this, void 0, void 0, function* () { try {
        let u = this._getFinalPath(r);
        const g = Object.assign({}, this.headers);
        o != null && o.upsert && (g["x-upsert"] = "true");
        const y = yield gh(this.fetch, `${this.url}/object/upload/sign/${u}`, {}, { headers: g }), E = new URL(this.url + y.url), s = E.searchParams.get("token");
        if (!s)
            throw new HA("No token returned by API");
        return { data: { signedUrl: E.toString(), path: r, token: s }, error: null };
    }
    catch (u) {
        if (Os(u))
            return { data: null, error: u };
        throw u;
    } }); }
    update(r, o, u) { return jo(this, void 0, void 0, function* () { return this.uploadOrUpdate("PUT", r, o, u); }); }
    move(r, o, u) { return jo(this, void 0, void 0, function* () { try {
        return { data: yield gh(this.fetch, `${this.url}/object/move`, { bucketId: this.bucketId, sourceKey: r, destinationKey: o, destinationBucket: u == null ? void 0 : u.destinationBucket }, { headers: this.headers }), error: null };
    }
    catch (g) {
        if (Os(g))
            return { data: null, error: g };
        throw g;
    } }); }
    copy(r, o, u) { return jo(this, void 0, void 0, function* () { try {
        return { data: { path: (yield gh(this.fetch, `${this.url}/object/copy`, { bucketId: this.bucketId, sourceKey: r, destinationKey: o, destinationBucket: u == null ? void 0 : u.destinationBucket }, { headers: this.headers })).Key }, error: null };
    }
    catch (g) {
        if (Os(g))
            return { data: null, error: g };
        throw g;
    } }); }
    createSignedUrl(r, o, u) { return jo(this, void 0, void 0, function* () { try {
        let g = this._getFinalPath(r), y = yield gh(this.fetch, `${this.url}/object/sign/${g}`, Object.assign({ expiresIn: o }, u != null && u.transform ? { transform: u.transform } : {}), { headers: this.headers });
        const E = u != null && u.download ? `&download=${u.download === !0 ? "" : u.download}` : "";
        return y = { signedUrl: encodeURI(`${this.url}${y.signedURL}${E}`) }, { data: y, error: null };
    }
    catch (g) {
        if (Os(g))
            return { data: null, error: g };
        throw g;
    } }); }
    createSignedUrls(r, o, u) { return jo(this, void 0, void 0, function* () { try {
        const g = yield gh(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn: o, paths: r }, { headers: this.headers }), y = u != null && u.download ? `&download=${u.download === !0 ? "" : u.download}` : "";
        return { data: g.map(E => Object.assign(Object.assign({}, E), { signedUrl: E.signedURL ? encodeURI(`${this.url}${E.signedURL}${y}`) : null })), error: null };
    }
    catch (g) {
        if (Os(g))
            return { data: null, error: g };
        throw g;
    } }); }
    download(r, o) { return jo(this, void 0, void 0, function* () { const g = typeof (o == null ? void 0 : o.transform) < "u" ? "render/image/authenticated" : "object", y = this.transformOptsToQueryString((o == null ? void 0 : o.transform) || {}), E = y ? `?${y}` : ""; try {
        const s = this._getFinalPath(r);
        return { data: yield (yield Fw(this.fetch, `${this.url}/${g}/${s}${E}`, { headers: this.headers, noResolveJson: !0 })).blob(), error: null };
    }
    catch (s) {
        if (Os(s))
            return { data: null, error: s };
        throw s;
    } }); }
    info(r) { return jo(this, void 0, void 0, function* () { const o = this._getFinalPath(r); try {
        const u = yield Fw(this.fetch, `${this.url}/object/info/${o}`, { headers: this.headers });
        return { data: uC(u), error: null };
    }
    catch (u) {
        if (Os(u))
            return { data: null, error: u };
        throw u;
    } }); }
    exists(r) { return jo(this, void 0, void 0, function* () { const o = this._getFinalPath(r); try {
        return yield A9(this.fetch, `${this.url}/object/${o}`, { headers: this.headers }), { data: !0, error: null };
    }
    catch (u) {
        if (Os(u) && u instanceof cC) {
            const g = u.originalError;
            if ([400, 404].includes(g == null ? void 0 : g.status))
                return { data: !1, error: u };
        }
        throw u;
    } }); }
    getPublicUrl(r, o) { const u = this._getFinalPath(r), g = [], y = o != null && o.download ? `download=${o.download === !0 ? "" : o.download}` : ""; y !== "" && g.push(y); const s = typeof (o == null ? void 0 : o.transform) < "u" ? "render/image" : "object", k = this.transformOptsToQueryString((o == null ? void 0 : o.transform) || {}); k !== "" && g.push(k); let L = g.join("&"); return L !== "" && (L = `?${L}`), { data: { publicUrl: encodeURI(`${this.url}/${s}/public/${u}${L}`) } }; }
    remove(r) { return jo(this, void 0, void 0, function* () { try {
        return { data: yield FN(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: r }, { headers: this.headers }), error: null };
    }
    catch (o) {
        if (Os(o))
            return { data: null, error: o };
        throw o;
    } }); }
    list(r, o, u) { return jo(this, void 0, void 0, function* () { try {
        const g = Object.assign(Object.assign(Object.assign({}, I9), o), { prefix: r || "" });
        return { data: yield gh(this.fetch, `${this.url}/object/list/${this.bucketId}`, g, { headers: this.headers }, u), error: null };
    }
    catch (g) {
        if (Os(g))
            return { data: null, error: g };
        throw g;
    } }); }
    encodeMetadata(r) { return JSON.stringify(r); }
    toBase64(r) { return typeof Buffer < "u" ? Buffer.from(r).toString("base64") : btoa(r); }
    _getFinalPath(r) { return `${this.bucketId}/${r}`; }
    _removeEmptyFolders(r) { return r.replace(/^\/|\/$/g, "").replace(/\/+/g, "/"); }
    transformOptsToQueryString(r) { const o = []; return r.width && o.push(`width=${r.width}`), r.height && o.push(`height=${r.height}`), r.resize && o.push(`resize=${r.resize}`), r.format && o.push(`format=${r.format}`), r.quality && o.push(`quality=${r.quality}`), o.join("&"); }
}
const M9 = "2.7.1", R9 = { "X-Client-Info": `storage-js/${M9}` };
var cm = function (t, r, o, u) { function g(y) { return y instanceof o ? y : new o(function (E) { E(y); }); } return new (o || (o = Promise))(function (y, E) { function s(N) { try {
    L(u.next(N));
}
catch (V) {
    E(V);
} } function k(N) { try {
    L(u.throw(N));
}
catch (V) {
    E(V);
} } function L(N) { N.done ? y(N.value) : g(N.value).then(s, k); } L((u = u.apply(t, r || [])).next()); }); };
class k9 {
    constructor(r, o = {}, u) { this.url = r, this.headers = Object.assign(Object.assign({}, R9), o), this.fetch = zN(u); }
    listBuckets() { return cm(this, void 0, void 0, function* () { try {
        return { data: yield Fw(this.fetch, `${this.url}/bucket`, { headers: this.headers }), error: null };
    }
    catch (r) {
        if (Os(r))
            return { data: null, error: r };
        throw r;
    } }); }
    getBucket(r) { return cm(this, void 0, void 0, function* () { try {
        return { data: yield Fw(this.fetch, `${this.url}/bucket/${r}`, { headers: this.headers }), error: null };
    }
    catch (o) {
        if (Os(o))
            return { data: null, error: o };
        throw o;
    } }); }
    createBucket(r, o = { public: !1 }) { return cm(this, void 0, void 0, function* () { try {
        return { data: yield gh(this.fetch, `${this.url}/bucket`, { id: r, name: r, public: o.public, file_size_limit: o.fileSizeLimit, allowed_mime_types: o.allowedMimeTypes }, { headers: this.headers }), error: null };
    }
    catch (u) {
        if (Os(u))
            return { data: null, error: u };
        throw u;
    } }); }
    updateBucket(r, o) { return cm(this, void 0, void 0, function* () { try {
        return { data: yield C9(this.fetch, `${this.url}/bucket/${r}`, { id: r, name: r, public: o.public, file_size_limit: o.fileSizeLimit, allowed_mime_types: o.allowedMimeTypes }, { headers: this.headers }), error: null };
    }
    catch (u) {
        if (Os(u))
            return { data: null, error: u };
        throw u;
    } }); }
    emptyBucket(r) { return cm(this, void 0, void 0, function* () { try {
        return { data: yield gh(this.fetch, `${this.url}/bucket/${r}/empty`, {}, { headers: this.headers }), error: null };
    }
    catch (o) {
        if (Os(o))
            return { data: null, error: o };
        throw o;
    } }); }
    deleteBucket(r) { return cm(this, void 0, void 0, function* () { try {
        return { data: yield FN(this.fetch, `${this.url}/bucket/${r}`, {}, { headers: this.headers }), error: null };
    }
    catch (o) {
        if (Os(o))
            return { data: null, error: o };
        throw o;
    } }); }
}
class D9 extends k9 {
    constructor(r, o = {}, u) { super(r, o, u); }
    from(r) { return new P9(this.url, this.headers, r, this.fetch); }
}
const L9 = "2.49.7";
let $y = "";
typeof Deno < "u" ? $y = "deno" : typeof document < "u" ? $y = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? $y = "react-native" : $y = "node";
const O9 = { "X-Client-Info": `supabase-js-${$y}/${L9}` }, z9 = { headers: O9 }, F9 = { schema: "public" }, N9 = { autoRefreshToken: !0, persistSession: !0, detectSessionInUrl: !0, flowType: "implicit" }, B9 = {};
var j9 = function (t, r, o, u) { function g(y) { return y instanceof o ? y : new o(function (E) { E(y); }); } return new (o || (o = Promise))(function (y, E) { function s(N) { try {
    L(u.next(N));
}
catch (V) {
    E(V);
} } function k(N) { try {
    L(u.throw(N));
}
catch (V) {
    E(V);
} } function L(N) { N.done ? y(N.value) : g(N.value).then(s, k); } L((u = u.apply(t, r || [])).next()); }); };
const V9 = t => { let r; return t ? r = t : typeof fetch > "u" ? r = wN : r = fetch, (...o) => r(...o); }, U9 = () => typeof Headers > "u" ? bN : Headers, $9 = (t, r, o) => { const u = V9(o), g = U9(); return (y, E) => j9(void 0, void 0, void 0, function* () { var s; const k = (s = yield r()) !== null && s !== void 0 ? s : t; let L = new g(E == null ? void 0 : E.headers); return L.has("apikey") || L.set("apikey", t), L.has("Authorization") || L.set("Authorization", `Bearer ${k}`), u(y, Object.assign(Object.assign({}, E), { headers: L })); }); };
var G9 = function (t, r, o, u) { function g(y) { return y instanceof o ? y : new o(function (E) { E(y); }); } return new (o || (o = Promise))(function (y, E) { function s(N) { try {
    L(u.next(N));
}
catch (V) {
    E(V);
} } function k(N) { try {
    L(u.throw(N));
}
catch (V) {
    E(V);
} } function L(N) { N.done ? y(N.value) : g(N.value).then(s, k); } L((u = u.apply(t, r || [])).next()); }); };
function q9(t) { return t.replace(/\/$/, ""); }
function H9(t, r) { var o, u; const { db: g, auth: y, realtime: E, global: s } = t, { db: k, auth: L, realtime: N, global: V } = r, H = { db: Object.assign(Object.assign({}, k), g), auth: Object.assign(Object.assign({}, L), y), realtime: Object.assign(Object.assign({}, N), E), global: Object.assign(Object.assign(Object.assign({}, V), s), { headers: Object.assign(Object.assign({}, (o = V == null ? void 0 : V.headers) !== null && o !== void 0 ? o : {}), (u = s == null ? void 0 : s.headers) !== null && u !== void 0 ? u : {}) }), accessToken: () => G9(this, void 0, void 0, function* () { return ""; }) }; return t.accessToken ? H.accessToken = t.accessToken : delete H.accessToken, H; }
const NN = "2.69.1", ym = 30 * 1e3, hC = 3, IE = hC * ym, W9 = "http://localhost:9999", Z9 = "supabase.auth.token", X9 = { "X-Client-Info": `gotrue-js/${NN}` }, dC = "X-Supabase-Api-Version", BN = { "2024-01-01": { timestamp: Date.parse("2024-01-01T00:00:00.0Z"), name: "2024-01-01" } }, K9 = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i, Y9 = 6e5;
class WA extends Error {
    constructor(r, o, u) { super(r), this.__isAuthError = !0, this.name = "AuthError", this.status = o, this.code = u; }
}
function kn(t) { return typeof t == "object" && t !== null && "__isAuthError" in t; }
class Q9 extends WA {
    constructor(r, o, u) { super(r, o, u), this.name = "AuthApiError", this.status = o, this.code = u; }
}
function J9(t) { return kn(t) && t.name === "AuthApiError"; }
class jN extends WA {
    constructor(r, o) { super(r), this.name = "AuthUnknownError", this.originalError = o; }
}
class nd extends WA {
    constructor(r, o, u, g) { super(r, u, g), this.name = o, this.status = u; }
}
class hh extends nd {
    constructor() { super("Auth session missing!", "AuthSessionMissingError", 400, void 0); }
}
function eZ(t) { return kn(t) && t.name === "AuthSessionMissingError"; }
class PE extends nd {
    constructor() { super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0); }
}
class k1 extends nd {
    constructor(r) { super(r, "AuthInvalidCredentialsError", 400, void 0); }
}
class D1 extends nd {
    constructor(r, o = null) { super(r, "AuthImplicitGrantRedirectError", 500, void 0), this.details = null, this.details = o; }
    toJSON() { return { name: this.name, message: this.message, status: this.status, details: this.details }; }
}
function tZ(t) { return kn(t) && t.name === "AuthImplicitGrantRedirectError"; }
class _L extends nd {
    constructor(r, o = null) { super(r, "AuthPKCEGrantCodeExchangeError", 500, void 0), this.details = null, this.details = o; }
    toJSON() { return { name: this.name, message: this.message, status: this.status, details: this.details }; }
}
class fC extends nd {
    constructor(r, o) { super(r, "AuthRetryableFetchError", o, void 0); }
}
function ME(t) { return kn(t) && t.name === "AuthRetryableFetchError"; }
class yL extends nd {
    constructor(r, o, u) { super(r, "AuthWeakPasswordError", o, "weak_password"), this.reasons = u; }
}
class ov extends nd {
    constructor(r) { super(r, "AuthInvalidJwtError", 400, "invalid_jwt"); }
}
const vL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""), xL = ` 	
\r=`.split(""), rZ = (() => { const t = new Array(128); for (let r = 0; r < t.length; r += 1)
    t[r] = -1; for (let r = 0; r < xL.length; r += 1)
    t[xL[r].charCodeAt(0)] = -2; for (let r = 0; r < vL.length; r += 1)
    t[vL[r].charCodeAt(0)] = r; return t; })();
function VN(t, r, o) { const u = rZ[t]; if (u > -1)
    for (r.queue = r.queue << 6 | u, r.queuedBits += 6; r.queuedBits >= 8;)
        o(r.queue >> r.queuedBits - 8 & 255), r.queuedBits -= 8;
else {
    if (u === -2)
        return;
    throw new Error(`Invalid Base64-URL character "${String.fromCharCode(t)}"`);
} }
function wL(t) { const r = [], o = E => { r.push(String.fromCodePoint(E)); }, u = { utf8seq: 0, codepoint: 0 }, g = { queue: 0, queuedBits: 0 }, y = E => { sZ(E, u, o); }; for (let E = 0; E < t.length; E += 1)
    VN(t.charCodeAt(E), g, y); return r.join(""); }
function nZ(t, r) { if (t <= 127) {
    r(t);
    return;
}
else if (t <= 2047) {
    r(192 | t >> 6), r(128 | t & 63);
    return;
}
else if (t <= 65535) {
    r(224 | t >> 12), r(128 | t >> 6 & 63), r(128 | t & 63);
    return;
}
else if (t <= 1114111) {
    r(240 | t >> 18), r(128 | t >> 12 & 63), r(128 | t >> 6 & 63), r(128 | t & 63);
    return;
} throw new Error(`Unrecognized Unicode codepoint: ${t.toString(16)}`); }
function iZ(t, r) { for (let o = 0; o < t.length; o += 1) {
    let u = t.charCodeAt(o);
    if (u > 55295 && u <= 56319) {
        const g = (u - 55296) * 1024 & 65535;
        u = (t.charCodeAt(o + 1) - 56320 & 65535 | g) + 65536, o += 1;
    }
    nZ(u, r);
} }
function sZ(t, r, o) { if (r.utf8seq === 0) {
    if (t <= 127) {
        o(t);
        return;
    }
    for (let u = 1; u < 6; u += 1)
        if (!(t >> 7 - u & 1)) {
            r.utf8seq = u;
            break;
        }
    if (r.utf8seq === 2)
        r.codepoint = t & 31;
    else if (r.utf8seq === 3)
        r.codepoint = t & 15;
    else if (r.utf8seq === 4)
        r.codepoint = t & 7;
    else
        throw new Error("Invalid UTF-8 sequence");
    r.utf8seq -= 1;
}
else if (r.utf8seq > 0) {
    if (t <= 127)
        throw new Error("Invalid UTF-8 sequence");
    r.codepoint = r.codepoint << 6 | t & 63, r.utf8seq -= 1, r.utf8seq === 0 && o(r.codepoint);
} }
function oZ(t) { const r = [], o = { queue: 0, queuedBits: 0 }, u = g => { r.push(g); }; for (let g = 0; g < t.length; g += 1)
    VN(t.charCodeAt(g), o, u); return new Uint8Array(r); }
function aZ(t) { const r = []; return iZ(t, o => r.push(o)), new Uint8Array(r); }
function lZ(t) { return Math.round(Date.now() / 1e3) + t; }
function cZ() { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (t) { const r = Math.random() * 16 | 0; return (t == "x" ? r : r & 3 | 8).toString(16); }); }
const Xl = () => typeof window < "u" && typeof document < "u", nf = { tested: !1, writable: !1 }, av = () => { if (!Xl())
    return !1; try {
    if (typeof globalThis.localStorage != "object")
        return !1;
}
catch {
    return !1;
} if (nf.tested)
    return nf.writable; const t = `lswt-${Math.random()}${Math.random()}`; try {
    globalThis.localStorage.setItem(t, t), globalThis.localStorage.removeItem(t), nf.tested = !0, nf.writable = !0;
}
catch {
    nf.tested = !0, nf.writable = !1;
} return nf.writable; };
function uZ(t) { const r = {}, o = new URL(t); if (o.hash && o.hash[0] === "#")
    try {
        new URLSearchParams(o.hash.substring(1)).forEach((g, y) => { r[y] = g; });
    }
    catch { } return o.searchParams.forEach((u, g) => { r[g] = u; }), r; }
const UN = t => { let r; return t ? r = t : typeof fetch > "u" ? r = (...o) => gg(async () => { const { default: u } = await Promise.resolve().then(() => Mg); return { default: u }; }, void 0).then(({ default: u }) => u(...o)) : r = fetch, (...o) => r(...o); }, hZ = t => typeof t == "object" && t !== null && "status" in t && "ok" in t && "json" in t && typeof t.json == "function", $N = async (t, r, o) => { await t.setItem(r, JSON.stringify(o)); }, L1 = async (t, r) => { const o = await t.getItem(r); if (!o)
    return null; try {
    return JSON.parse(o);
}
catch {
    return o;
} }, O1 = async (t, r) => { await t.removeItem(r); };
class Lb {
    constructor() { this.promise = new Lb.promiseConstructor((r, o) => { this.resolve = r, this.reject = o; }); }
}
Lb.promiseConstructor = Promise;
function RE(t) { const r = t.split("."); if (r.length !== 3)
    throw new ov("Invalid JWT structure"); for (let u = 0; u < r.length; u++)
    if (!K9.test(r[u]))
        throw new ov("JWT not in base64url format"); return { header: JSON.parse(wL(r[0])), payload: JSON.parse(wL(r[1])), signature: oZ(r[2]), raw: { header: r[0], payload: r[1] } }; }
async function dZ(t) { return await new Promise(r => { setTimeout(() => r(null), t); }); }
function fZ(t, r) { return new Promise((u, g) => { (async () => { for (let y = 0; y < 1 / 0; y++)
    try {
        const E = await t(y);
        if (!r(y, null, E)) {
            u(E);
            return;
        }
    }
    catch (E) {
        if (!r(y, E)) {
            g(E);
            return;
        }
    } })(); }); }
function pZ(t) { return ("0" + t.toString(16)).substr(-2); }
function mZ() { const r = new Uint32Array(56); if (typeof crypto > "u") {
    const o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~", u = o.length;
    let g = "";
    for (let y = 0; y < 56; y++)
        g += o.charAt(Math.floor(Math.random() * u));
    return g;
} return crypto.getRandomValues(r), Array.from(r, pZ).join(""); }
async function gZ(t) { const o = new TextEncoder().encode(t), u = await crypto.subtle.digest("SHA-256", o), g = new Uint8Array(u); return Array.from(g).map(y => String.fromCharCode(y)).join(""); }
async function _Z(t) { if (!(typeof crypto < "u" && typeof crypto.subtle < "u" && typeof TextEncoder < "u"))
    return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."), t; const o = await gZ(t); return btoa(o).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, ""); }
async function um(t, r, o = !1) { const u = mZ(); let g = u; o && (g += "/PASSWORD_RECOVERY"), await $N(t, `${r}-code-verifier`, g); const y = await _Z(u); return [y, u === y ? "plain" : "s256"]; }
const yZ = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function vZ(t) { const r = t.headers.get(dC); if (!r || !r.match(yZ))
    return null; try {
    return new Date(`${r}T00:00:00.0Z`);
}
catch {
    return null;
} }
function xZ(t) { if (!t)
    throw new Error("Missing exp claim"); const r = Math.floor(Date.now() / 1e3); if (t <= r)
    throw new Error("JWT has expired"); }
function wZ(t) { switch (t) {
    case "RS256": return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } };
    case "ES256": return { name: "ECDSA", namedCurve: "P-256", hash: { name: "SHA-256" } };
    default: throw new Error("Invalid alg claim");
} }
var bZ = function (t, r) { var o = {}; for (var u in t)
    Object.prototype.hasOwnProperty.call(t, u) && r.indexOf(u) < 0 && (o[u] = t[u]); if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var g = 0, u = Object.getOwnPropertySymbols(t); g < u.length; g++)
        r.indexOf(u[g]) < 0 && Object.prototype.propertyIsEnumerable.call(t, u[g]) && (o[u[g]] = t[u[g]]); return o; };
const lf = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t), TZ = [502, 503, 504];
async function bL(t) { var r; if (!hZ(t))
    throw new fC(lf(t), 0); if (TZ.includes(t.status))
    throw new fC(lf(t), t.status); let o; try {
    o = await t.json();
}
catch (y) {
    throw new jN(lf(y), y);
} let u; const g = vZ(t); if (g && g.getTime() >= BN["2024-01-01"].timestamp && typeof o == "object" && o && typeof o.code == "string" ? u = o.code : typeof o == "object" && o && typeof o.error_code == "string" && (u = o.error_code), u) {
    if (u === "weak_password")
        throw new yL(lf(o), t.status, ((r = o.weak_password) === null || r === void 0 ? void 0 : r.reasons) || []);
    if (u === "session_not_found")
        throw new hh;
}
else if (typeof o == "object" && o && typeof o.weak_password == "object" && o.weak_password && Array.isArray(o.weak_password.reasons) && o.weak_password.reasons.length && o.weak_password.reasons.reduce((y, E) => y && typeof E == "string", !0))
    throw new yL(lf(o), t.status, o.weak_password.reasons); throw new Q9(lf(o), t.status || 500, u); }
const SZ = (t, r, o, u) => { const g = { method: t, headers: (r == null ? void 0 : r.headers) || {} }; return t === "GET" ? g : (g.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, r == null ? void 0 : r.headers), g.body = JSON.stringify(u), Object.assign(Object.assign({}, g), o)); };
async function ei(t, r, o, u) { var g; const y = Object.assign({}, u == null ? void 0 : u.headers); y[dC] || (y[dC] = BN["2024-01-01"].name), u != null && u.jwt && (y.Authorization = `Bearer ${u.jwt}`); const E = (g = u == null ? void 0 : u.query) !== null && g !== void 0 ? g : {}; u != null && u.redirectTo && (E.redirect_to = u.redirectTo); const s = Object.keys(E).length ? "?" + new URLSearchParams(E).toString() : "", k = await EZ(t, r, o + s, { headers: y, noResolveJson: u == null ? void 0 : u.noResolveJson }, {}, u == null ? void 0 : u.body); return u != null && u.xform ? u == null ? void 0 : u.xform(k) : { data: Object.assign({}, k), error: null }; }
async function EZ(t, r, o, u, g, y) { const E = SZ(r, u, g, y); let s; try {
    s = await t(o, Object.assign({}, E));
}
catch (k) {
    throw console.error(k), new fC(lf(k), 0);
} if (s.ok || await bL(s), u != null && u.noResolveJson)
    return s; try {
    return await s.json();
}
catch (k) {
    await bL(k);
} }
function dh(t) { var r; let o = null; PZ(t) && (o = Object.assign({}, t), t.expires_at || (o.expires_at = lZ(t.expires_in))); const u = (r = t.user) !== null && r !== void 0 ? r : t; return { data: { session: o, user: u }, error: null }; }
function TL(t) { const r = dh(t); return !r.error && t.weak_password && typeof t.weak_password == "object" && Array.isArray(t.weak_password.reasons) && t.weak_password.reasons.length && t.weak_password.message && typeof t.weak_password.message == "string" && t.weak_password.reasons.reduce((o, u) => o && typeof u == "string", !0) && (r.data.weak_password = t.weak_password), r; }
function vh(t) { var r; return { data: { user: (r = t.user) !== null && r !== void 0 ? r : t }, error: null }; }
function CZ(t) { return { data: t, error: null }; }
function AZ(t) { const { action_link: r, email_otp: o, hashed_token: u, redirect_to: g, verification_type: y } = t, E = bZ(t, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]), s = { action_link: r, email_otp: o, hashed_token: u, redirect_to: g, verification_type: y }, k = Object.assign({}, E); return { data: { properties: s, user: k }, error: null }; }
function IZ(t) { return t; }
function PZ(t) { return t.access_token && t.refresh_token && t.expires_in; }
var MZ = function (t, r) { var o = {}; for (var u in t)
    Object.prototype.hasOwnProperty.call(t, u) && r.indexOf(u) < 0 && (o[u] = t[u]); if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var g = 0, u = Object.getOwnPropertySymbols(t); g < u.length; g++)
        r.indexOf(u[g]) < 0 && Object.prototype.propertyIsEnumerable.call(t, u[g]) && (o[u[g]] = t[u[g]]); return o; };
class RZ {
    constructor({ url: r = "", headers: o = {}, fetch: u }) { this.url = r, this.headers = o, this.fetch = UN(u), this.mfa = { listFactors: this._listFactors.bind(this), deleteFactor: this._deleteFactor.bind(this) }; }
    async signOut(r, o = "global") { try {
        return await ei(this.fetch, "POST", `${this.url}/logout?scope=${o}`, { headers: this.headers, jwt: r, noResolveJson: !0 }), { data: null, error: null };
    }
    catch (u) {
        if (kn(u))
            return { data: null, error: u };
        throw u;
    } }
    async inviteUserByEmail(r, o = {}) { try {
        return await ei(this.fetch, "POST", `${this.url}/invite`, { body: { email: r, data: o.data }, headers: this.headers, redirectTo: o.redirectTo, xform: vh });
    }
    catch (u) {
        if (kn(u))
            return { data: { user: null }, error: u };
        throw u;
    } }
    async generateLink(r) { try {
        const { options: o } = r, u = MZ(r, ["options"]), g = Object.assign(Object.assign({}, u), o);
        return "newEmail" in u && (g.new_email = u == null ? void 0 : u.newEmail, delete g.newEmail), await ei(this.fetch, "POST", `${this.url}/admin/generate_link`, { body: g, headers: this.headers, xform: AZ, redirectTo: o == null ? void 0 : o.redirectTo });
    }
    catch (o) {
        if (kn(o))
            return { data: { properties: null, user: null }, error: o };
        throw o;
    } }
    async createUser(r) { try {
        return await ei(this.fetch, "POST", `${this.url}/admin/users`, { body: r, headers: this.headers, xform: vh });
    }
    catch (o) {
        if (kn(o))
            return { data: { user: null }, error: o };
        throw o;
    } }
    async listUsers(r) { var o, u, g, y, E, s, k; try {
        const L = { nextPage: null, lastPage: 0, total: 0 }, N = await ei(this.fetch, "GET", `${this.url}/admin/users`, { headers: this.headers, noResolveJson: !0, query: { page: (u = (o = r == null ? void 0 : r.page) === null || o === void 0 ? void 0 : o.toString()) !== null && u !== void 0 ? u : "", per_page: (y = (g = r == null ? void 0 : r.perPage) === null || g === void 0 ? void 0 : g.toString()) !== null && y !== void 0 ? y : "" }, xform: IZ });
        if (N.error)
            throw N.error;
        const V = await N.json(), H = (E = N.headers.get("x-total-count")) !== null && E !== void 0 ? E : 0, ee = (k = (s = N.headers.get("link")) === null || s === void 0 ? void 0 : s.split(",")) !== null && k !== void 0 ? k : [];
        return ee.length > 0 && (ee.forEach(ce => { const J = parseInt(ce.split(";")[0].split("=")[1].substring(0, 1)), ye = JSON.parse(ce.split(";")[1].split("=")[1]); L[`${ye}Page`] = J; }), L.total = parseInt(H)), { data: Object.assign(Object.assign({}, V), L), error: null };
    }
    catch (L) {
        if (kn(L))
            return { data: { users: [] }, error: L };
        throw L;
    } }
    async getUserById(r) { try {
        return await ei(this.fetch, "GET", `${this.url}/admin/users/${r}`, { headers: this.headers, xform: vh });
    }
    catch (o) {
        if (kn(o))
            return { data: { user: null }, error: o };
        throw o;
    } }
    async updateUserById(r, o) { try {
        return await ei(this.fetch, "PUT", `${this.url}/admin/users/${r}`, { body: o, headers: this.headers, xform: vh });
    }
    catch (u) {
        if (kn(u))
            return { data: { user: null }, error: u };
        throw u;
    } }
    async deleteUser(r, o = !1) { try {
        return await ei(this.fetch, "DELETE", `${this.url}/admin/users/${r}`, { headers: this.headers, body: { should_soft_delete: o }, xform: vh });
    }
    catch (u) {
        if (kn(u))
            return { data: { user: null }, error: u };
        throw u;
    } }
    async _listFactors(r) { try {
        const { data: o, error: u } = await ei(this.fetch, "GET", `${this.url}/admin/users/${r.userId}/factors`, { headers: this.headers, xform: g => ({ data: { factors: g }, error: null }) });
        return { data: o, error: u };
    }
    catch (o) {
        if (kn(o))
            return { data: null, error: o };
        throw o;
    } }
    async _deleteFactor(r) { try {
        return { data: await ei(this.fetch, "DELETE", `${this.url}/admin/users/${r.userId}/factors/${r.id}`, { headers: this.headers }), error: null };
    }
    catch (o) {
        if (kn(o))
            return { data: null, error: o };
        throw o;
    } }
}
const kZ = { getItem: t => av() ? globalThis.localStorage.getItem(t) : null, setItem: (t, r) => { av() && globalThis.localStorage.setItem(t, r); }, removeItem: t => { av() && globalThis.localStorage.removeItem(t); } };
function SL(t = {}) { return { getItem: r => t[r] || null, setItem: (r, o) => { t[r] = o; }, removeItem: r => { delete t[r]; } }; }
function DZ() { if (typeof globalThis != "object")
    try {
        Object.defineProperty(Object.prototype, "__magic__", { get: function () { return this; }, configurable: !0 }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__;
    }
    catch {
        typeof self < "u" && (self.globalThis = self);
    } }
const hm = { debug: !!(globalThis && av() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true") };
class GN extends Error {
    constructor(r) { super(r), this.isAcquireTimeout = !0; }
}
class LZ extends GN {
}
async function OZ(t, r, o) { hm.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", t, r); const u = new globalThis.AbortController; return r > 0 && setTimeout(() => { u.abort(), hm.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", t); }, r), await Promise.resolve().then(() => globalThis.navigator.locks.request(t, r === 0 ? { mode: "exclusive", ifAvailable: !0 } : { mode: "exclusive", signal: u.signal }, async (g) => { if (g) {
    hm.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", t, g.name);
    try {
        return await o();
    }
    finally {
        hm.debug && console.log("@supabase/gotrue-js: navigatorLock: released", t, g.name);
    }
}
else {
    if (r === 0)
        throw hm.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", t), new LZ(`Acquiring an exclusive Navigator LockManager lock "${t}" immediately failed`);
    if (hm.debug)
        try {
            const y = await globalThis.navigator.locks.query();
            console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(y, null, "  "));
        }
        catch (y) {
            console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", y);
        }
    return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"), await o();
} })); }
DZ();
const zZ = { url: W9, storageKey: Z9, autoRefreshToken: !0, persistSession: !0, detectSessionInUrl: !0, headers: X9, flowType: "implicit", debug: !1, hasCustomAuthorizationHeader: !1 };
async function EL(t, r, o) { return await o(); }
class Mv {
    constructor(r) { var o, u; this.memoryStorage = null, this.stateChangeEmitters = new Map, this.autoRefreshTicker = null, this.visibilityChangedCallback = null, this.refreshingDeferred = null, this.initializePromise = null, this.detectSessionInUrl = !0, this.hasCustomAuthorizationHeader = !1, this.suppressGetSessionWarning = !1, this.lockAcquired = !1, this.pendingInLock = [], this.broadcastChannel = null, this.logger = console.log, this.instanceID = Mv.nextInstanceID, Mv.nextInstanceID += 1, this.instanceID > 0 && Xl() && console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key."); const g = Object.assign(Object.assign({}, zZ), r); if (this.logDebugMessages = !!g.debug, typeof g.debug == "function" && (this.logger = g.debug), this.persistSession = g.persistSession, this.storageKey = g.storageKey, this.autoRefreshToken = g.autoRefreshToken, this.admin = new RZ({ url: g.url, headers: g.headers, fetch: g.fetch }), this.url = g.url, this.headers = g.headers, this.fetch = UN(g.fetch), this.lock = g.lock || EL, this.detectSessionInUrl = g.detectSessionInUrl, this.flowType = g.flowType, this.hasCustomAuthorizationHeader = g.hasCustomAuthorizationHeader, g.lock ? this.lock = g.lock : Xl() && (!((o = globalThis == null ? void 0 : globalThis.navigator) === null || o === void 0) && o.locks) ? this.lock = OZ : this.lock = EL, this.jwks = { keys: [] }, this.jwks_cached_at = Number.MIN_SAFE_INTEGER, this.mfa = { verify: this._verify.bind(this), enroll: this._enroll.bind(this), unenroll: this._unenroll.bind(this), challenge: this._challenge.bind(this), listFactors: this._listFactors.bind(this), challengeAndVerify: this._challengeAndVerify.bind(this), getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this) }, this.persistSession ? g.storage ? this.storage = g.storage : av() ? this.storage = kZ : (this.memoryStorage = {}, this.storage = SL(this.memoryStorage)) : (this.memoryStorage = {}, this.storage = SL(this.memoryStorage)), Xl() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
        try {
            this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
        }
        catch (y) {
            console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", y);
        }
        (u = this.broadcastChannel) === null || u === void 0 || u.addEventListener("message", async (y) => { this._debug("received broadcast notification from other tab or client", y), await this._notifyAllSubscribers(y.data.event, y.data.session, !1); });
    } this.initialize(); }
    _debug(...r) { return this.logDebugMessages && this.logger(`GoTrueClient@${this.instanceID} (${NN}) ${new Date().toISOString()}`, ...r), this; }
    async initialize() { return this.initializePromise ? await this.initializePromise : (this.initializePromise = (async () => await this._acquireLock(-1, async () => await this._initialize()))(), await this.initializePromise); }
    async _initialize() { var r; try {
        const o = uZ(window.location.href);
        let u = "none";
        if (this._isImplicitGrantCallback(o) ? u = "implicit" : await this._isPKCECallback(o) && (u = "pkce"), Xl() && this.detectSessionInUrl && u !== "none") {
            const { data: g, error: y } = await this._getSessionFromURL(o, u);
            if (y) {
                if (this._debug("#_initialize()", "error detecting session from URL", y), tZ(y)) {
                    const k = (r = y.details) === null || r === void 0 ? void 0 : r.code;
                    if (k === "identity_already_exists" || k === "identity_not_found" || k === "single_identity_not_deletable")
                        return { error: y };
                }
                return await this._removeSession(), { error: y };
            }
            const { session: E, redirectType: s } = g;
            return this._debug("#_initialize()", "detected session in URL", E, "redirect type", s), await this._saveSession(E), setTimeout(async () => { s === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", E) : await this._notifyAllSubscribers("SIGNED_IN", E); }, 0), { error: null };
        }
        return await this._recoverAndRefresh(), { error: null };
    }
    catch (o) {
        return kn(o) ? { error: o } : { error: new jN("Unexpected error during initialization", o) };
    }
    finally {
        await this._handleVisibilityChange(), this._debug("#_initialize()", "end");
    } }
    async signInAnonymously(r) { var o, u, g; try {
        const y = await ei(this.fetch, "POST", `${this.url}/signup`, { headers: this.headers, body: { data: (u = (o = r == null ? void 0 : r.options) === null || o === void 0 ? void 0 : o.data) !== null && u !== void 0 ? u : {}, gotrue_meta_security: { captcha_token: (g = r == null ? void 0 : r.options) === null || g === void 0 ? void 0 : g.captchaToken } }, xform: dh }), { data: E, error: s } = y;
        if (s || !E)
            return { data: { user: null, session: null }, error: s };
        const k = E.session, L = E.user;
        return E.session && (await this._saveSession(E.session), await this._notifyAllSubscribers("SIGNED_IN", k)), { data: { user: L, session: k }, error: null };
    }
    catch (y) {
        if (kn(y))
            return { data: { user: null, session: null }, error: y };
        throw y;
    } }
    async signUp(r) { var o, u, g; try {
        let y;
        if ("email" in r) {
            const { email: N, password: V, options: H } = r;
            let ee = null, ce = null;
            this.flowType === "pkce" && ([ee, ce] = await um(this.storage, this.storageKey)), y = await ei(this.fetch, "POST", `${this.url}/signup`, { headers: this.headers, redirectTo: H == null ? void 0 : H.emailRedirectTo, body: { email: N, password: V, data: (o = H == null ? void 0 : H.data) !== null && o !== void 0 ? o : {}, gotrue_meta_security: { captcha_token: H == null ? void 0 : H.captchaToken }, code_challenge: ee, code_challenge_method: ce }, xform: dh });
        }
        else if ("phone" in r) {
            const { phone: N, password: V, options: H } = r;
            y = await ei(this.fetch, "POST", `${this.url}/signup`, { headers: this.headers, body: { phone: N, password: V, data: (u = H == null ? void 0 : H.data) !== null && u !== void 0 ? u : {}, channel: (g = H == null ? void 0 : H.channel) !== null && g !== void 0 ? g : "sms", gotrue_meta_security: { captcha_token: H == null ? void 0 : H.captchaToken } }, xform: dh });
        }
        else
            throw new k1("You must provide either an email or phone number and a password");
        const { data: E, error: s } = y;
        if (s || !E)
            return { data: { user: null, session: null }, error: s };
        const k = E.session, L = E.user;
        return E.session && (await this._saveSession(E.session), await this._notifyAllSubscribers("SIGNED_IN", k)), { data: { user: L, session: k }, error: null };
    }
    catch (y) {
        if (kn(y))
            return { data: { user: null, session: null }, error: y };
        throw y;
    } }
    async signInWithPassword(r) { try {
        let o;
        if ("email" in r) {
            const { email: y, password: E, options: s } = r;
            o = await ei(this.fetch, "POST", `${this.url}/token?grant_type=password`, { headers: this.headers, body: { email: y, password: E, gotrue_meta_security: { captcha_token: s == null ? void 0 : s.captchaToken } }, xform: TL });
        }
        else if ("phone" in r) {
            const { phone: y, password: E, options: s } = r;
            o = await ei(this.fetch, "POST", `${this.url}/token?grant_type=password`, { headers: this.headers, body: { phone: y, password: E, gotrue_meta_security: { captcha_token: s == null ? void 0 : s.captchaToken } }, xform: TL });
        }
        else
            throw new k1("You must provide either an email or phone number and a password");
        const { data: u, error: g } = o;
        return g ? { data: { user: null, session: null }, error: g } : !u || !u.session || !u.user ? { data: { user: null, session: null }, error: new PE } : (u.session && (await this._saveSession(u.session), await this._notifyAllSubscribers("SIGNED_IN", u.session)), { data: Object.assign({ user: u.user, session: u.session }, u.weak_password ? { weakPassword: u.weak_password } : null), error: g });
    }
    catch (o) {
        if (kn(o))
            return { data: { user: null, session: null }, error: o };
        throw o;
    } }
    async signInWithOAuth(r) { var o, u, g, y; return await this._handleProviderSignIn(r.provider, { redirectTo: (o = r.options) === null || o === void 0 ? void 0 : o.redirectTo, scopes: (u = r.options) === null || u === void 0 ? void 0 : u.scopes, queryParams: (g = r.options) === null || g === void 0 ? void 0 : g.queryParams, skipBrowserRedirect: (y = r.options) === null || y === void 0 ? void 0 : y.skipBrowserRedirect }); }
    async exchangeCodeForSession(r) { return await this.initializePromise, this._acquireLock(-1, async () => this._exchangeCodeForSession(r)); }
    async _exchangeCodeForSession(r) { const o = await L1(this.storage, `${this.storageKey}-code-verifier`), [u, g] = (o ?? "").split("/"); try {
        const { data: y, error: E } = await ei(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, { headers: this.headers, body: { auth_code: r, code_verifier: u }, xform: dh });
        if (await O1(this.storage, `${this.storageKey}-code-verifier`), E)
            throw E;
        return !y || !y.session || !y.user ? { data: { user: null, session: null, redirectType: null }, error: new PE } : (y.session && (await this._saveSession(y.session), await this._notifyAllSubscribers("SIGNED_IN", y.session)), { data: Object.assign(Object.assign({}, y), { redirectType: g ?? null }), error: E });
    }
    catch (y) {
        if (kn(y))
            return { data: { user: null, session: null, redirectType: null }, error: y };
        throw y;
    } }
    async signInWithIdToken(r) { try {
        const { options: o, provider: u, token: g, access_token: y, nonce: E } = r, s = await ei(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, { headers: this.headers, body: { provider: u, id_token: g, access_token: y, nonce: E, gotrue_meta_security: { captcha_token: o == null ? void 0 : o.captchaToken } }, xform: dh }), { data: k, error: L } = s;
        return L ? { data: { user: null, session: null }, error: L } : !k || !k.session || !k.user ? { data: { user: null, session: null }, error: new PE } : (k.session && (await this._saveSession(k.session), await this._notifyAllSubscribers("SIGNED_IN", k.session)), { data: k, error: L });
    }
    catch (o) {
        if (kn(o))
            return { data: { user: null, session: null }, error: o };
        throw o;
    } }
    async signInWithOtp(r) { var o, u, g, y, E; try {
        if ("email" in r) {
            const { email: s, options: k } = r;
            let L = null, N = null;
            this.flowType === "pkce" && ([L, N] = await um(this.storage, this.storageKey));
            const { error: V } = await ei(this.fetch, "POST", `${this.url}/otp`, { headers: this.headers, body: { email: s, data: (o = k == null ? void 0 : k.data) !== null && o !== void 0 ? o : {}, create_user: (u = k == null ? void 0 : k.shouldCreateUser) !== null && u !== void 0 ? u : !0, gotrue_meta_security: { captcha_token: k == null ? void 0 : k.captchaToken }, code_challenge: L, code_challenge_method: N }, redirectTo: k == null ? void 0 : k.emailRedirectTo });
            return { data: { user: null, session: null }, error: V };
        }
        if ("phone" in r) {
            const { phone: s, options: k } = r, { data: L, error: N } = await ei(this.fetch, "POST", `${this.url}/otp`, { headers: this.headers, body: { phone: s, data: (g = k == null ? void 0 : k.data) !== null && g !== void 0 ? g : {}, create_user: (y = k == null ? void 0 : k.shouldCreateUser) !== null && y !== void 0 ? y : !0, gotrue_meta_security: { captcha_token: k == null ? void 0 : k.captchaToken }, channel: (E = k == null ? void 0 : k.channel) !== null && E !== void 0 ? E : "sms" } });
            return { data: { user: null, session: null, messageId: L == null ? void 0 : L.message_id }, error: N };
        }
        throw new k1("You must provide either an email or phone number.");
    }
    catch (s) {
        if (kn(s))
            return { data: { user: null, session: null }, error: s };
        throw s;
    } }
    async verifyOtp(r) { var o, u; try {
        let g, y;
        "options" in r && (g = (o = r.options) === null || o === void 0 ? void 0 : o.redirectTo, y = (u = r.options) === null || u === void 0 ? void 0 : u.captchaToken);
        const { data: E, error: s } = await ei(this.fetch, "POST", `${this.url}/verify`, { headers: this.headers, body: Object.assign(Object.assign({}, r), { gotrue_meta_security: { captcha_token: y } }), redirectTo: g, xform: dh });
        if (s)
            throw s;
        if (!E)
            throw new Error("An error occurred on token verification.");
        const k = E.session, L = E.user;
        return k != null && k.access_token && (await this._saveSession(k), await this._notifyAllSubscribers(r.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", k)), { data: { user: L, session: k }, error: null };
    }
    catch (g) {
        if (kn(g))
            return { data: { user: null, session: null }, error: g };
        throw g;
    } }
    async signInWithSSO(r) { var o, u, g; try {
        let y = null, E = null;
        return this.flowType === "pkce" && ([y, E] = await um(this.storage, this.storageKey)), await ei(this.fetch, "POST", `${this.url}/sso`, { body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in r ? { provider_id: r.providerId } : null), "domain" in r ? { domain: r.domain } : null), { redirect_to: (u = (o = r.options) === null || o === void 0 ? void 0 : o.redirectTo) !== null && u !== void 0 ? u : void 0 }), !((g = r == null ? void 0 : r.options) === null || g === void 0) && g.captchaToken ? { gotrue_meta_security: { captcha_token: r.options.captchaToken } } : null), { skip_http_redirect: !0, code_challenge: y, code_challenge_method: E }), headers: this.headers, xform: CZ });
    }
    catch (y) {
        if (kn(y))
            return { data: null, error: y };
        throw y;
    } }
    async reauthenticate() { return await this.initializePromise, await this._acquireLock(-1, async () => await this._reauthenticate()); }
    async _reauthenticate() { try {
        return await this._useSession(async (r) => { const { data: { session: o }, error: u } = r; if (u)
            throw u; if (!o)
            throw new hh; const { error: g } = await ei(this.fetch, "GET", `${this.url}/reauthenticate`, { headers: this.headers, jwt: o.access_token }); return { data: { user: null, session: null }, error: g }; });
    }
    catch (r) {
        if (kn(r))
            return { data: { user: null, session: null }, error: r };
        throw r;
    } }
    async resend(r) { try {
        const o = `${this.url}/resend`;
        if ("email" in r) {
            const { email: u, type: g, options: y } = r, { error: E } = await ei(this.fetch, "POST", o, { headers: this.headers, body: { email: u, type: g, gotrue_meta_security: { captcha_token: y == null ? void 0 : y.captchaToken } }, redirectTo: y == null ? void 0 : y.emailRedirectTo });
            return { data: { user: null, session: null }, error: E };
        }
        else if ("phone" in r) {
            const { phone: u, type: g, options: y } = r, { data: E, error: s } = await ei(this.fetch, "POST", o, { headers: this.headers, body: { phone: u, type: g, gotrue_meta_security: { captcha_token: y == null ? void 0 : y.captchaToken } } });
            return { data: { user: null, session: null, messageId: E == null ? void 0 : E.message_id }, error: s };
        }
        throw new k1("You must provide either an email or phone number and a type");
    }
    catch (o) {
        if (kn(o))
            return { data: { user: null, session: null }, error: o };
        throw o;
    } }
    async getSession() { return await this.initializePromise, await this._acquireLock(-1, async () => this._useSession(async (o) => o)); }
    async _acquireLock(r, o) { this._debug("#_acquireLock", "begin", r); try {
        if (this.lockAcquired) {
            const u = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve(), g = (async () => (await u, await o()))();
            return this.pendingInLock.push((async () => { try {
                await g;
            }
            catch { } })()), g;
        }
        return await this.lock(`lock:${this.storageKey}`, r, async () => { this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey); try {
            this.lockAcquired = !0;
            const u = o();
            for (this.pendingInLock.push((async () => { try {
                await u;
            }
            catch { } })()), await u; this.pendingInLock.length;) {
                const g = [...this.pendingInLock];
                await Promise.all(g), this.pendingInLock.splice(0, g.length);
            }
            return await u;
        }
        finally {
            this._debug("#_acquireLock", "lock released for storage key", this.storageKey), this.lockAcquired = !1;
        } });
    }
    finally {
        this._debug("#_acquireLock", "end");
    } }
    async _useSession(r) { this._debug("#_useSession", "begin"); try {
        const o = await this.__loadSession();
        return await r(o);
    }
    finally {
        this._debug("#_useSession", "end");
    } }
    async __loadSession() { this._debug("#__loadSession()", "begin"), this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack); try {
        let r = null;
        const o = await L1(this.storage, this.storageKey);
        if (this._debug("#getSession()", "session from storage", o), o !== null && (this._isValidSession(o) ? r = o : (this._debug("#getSession()", "session from storage is not valid"), await this._removeSession())), !r)
            return { data: { session: null }, error: null };
        const u = r.expires_at ? r.expires_at * 1e3 - Date.now() < IE : !1;
        if (this._debug("#__loadSession()", `session has${u ? "" : " not"} expired`, "expires_at", r.expires_at), !u) {
            if (this.storage.isServer) {
                let E = this.suppressGetSessionWarning;
                r = new Proxy(r, { get: (k, L, N) => (!E && L === "user" && (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."), E = !0, this.suppressGetSessionWarning = !0), Reflect.get(k, L, N)) });
            }
            return { data: { session: r }, error: null };
        }
        const { session: g, error: y } = await this._callRefreshToken(r.refresh_token);
        return y ? { data: { session: null }, error: y } : { data: { session: g }, error: null };
    }
    finally {
        this._debug("#__loadSession()", "end");
    } }
    async getUser(r) { return r ? await this._getUser(r) : (await this.initializePromise, await this._acquireLock(-1, async () => await this._getUser())); }
    async _getUser(r) { try {
        return r ? await ei(this.fetch, "GET", `${this.url}/user`, { headers: this.headers, jwt: r, xform: vh }) : await this._useSession(async (o) => { var u, g, y; const { data: E, error: s } = o; if (s)
            throw s; return !(!((u = E.session) === null || u === void 0) && u.access_token) && !this.hasCustomAuthorizationHeader ? { data: { user: null }, error: new hh } : await ei(this.fetch, "GET", `${this.url}/user`, { headers: this.headers, jwt: (y = (g = E.session) === null || g === void 0 ? void 0 : g.access_token) !== null && y !== void 0 ? y : void 0, xform: vh }); });
    }
    catch (o) {
        if (kn(o))
            return eZ(o) && (await this._removeSession(), await O1(this.storage, `${this.storageKey}-code-verifier`)), { data: { user: null }, error: o };
        throw o;
    } }
    async updateUser(r, o = {}) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._updateUser(r, o)); }
    async _updateUser(r, o = {}) { try {
        return await this._useSession(async (u) => { const { data: g, error: y } = u; if (y)
            throw y; if (!g.session)
            throw new hh; const E = g.session; let s = null, k = null; this.flowType === "pkce" && r.email != null && ([s, k] = await um(this.storage, this.storageKey)); const { data: L, error: N } = await ei(this.fetch, "PUT", `${this.url}/user`, { headers: this.headers, redirectTo: o == null ? void 0 : o.emailRedirectTo, body: Object.assign(Object.assign({}, r), { code_challenge: s, code_challenge_method: k }), jwt: E.access_token, xform: vh }); if (N)
            throw N; return E.user = L.user, await this._saveSession(E), await this._notifyAllSubscribers("USER_UPDATED", E), { data: { user: E.user }, error: null }; });
    }
    catch (u) {
        if (kn(u))
            return { data: { user: null }, error: u };
        throw u;
    } }
    async setSession(r) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._setSession(r)); }
    async _setSession(r) { try {
        if (!r.access_token || !r.refresh_token)
            throw new hh;
        const o = Date.now() / 1e3;
        let u = o, g = !0, y = null;
        const { payload: E } = RE(r.access_token);
        if (E.exp && (u = E.exp, g = u <= o), g) {
            const { session: s, error: k } = await this._callRefreshToken(r.refresh_token);
            if (k)
                return { data: { user: null, session: null }, error: k };
            if (!s)
                return { data: { user: null, session: null }, error: null };
            y = s;
        }
        else {
            const { data: s, error: k } = await this._getUser(r.access_token);
            if (k)
                throw k;
            y = { access_token: r.access_token, refresh_token: r.refresh_token, user: s.user, token_type: "bearer", expires_in: u - o, expires_at: u }, await this._saveSession(y), await this._notifyAllSubscribers("SIGNED_IN", y);
        }
        return { data: { user: y.user, session: y }, error: null };
    }
    catch (o) {
        if (kn(o))
            return { data: { session: null, user: null }, error: o };
        throw o;
    } }
    async refreshSession(r) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._refreshSession(r)); }
    async _refreshSession(r) { try {
        return await this._useSession(async (o) => { var u; if (!r) {
            const { data: E, error: s } = o;
            if (s)
                throw s;
            r = (u = E.session) !== null && u !== void 0 ? u : void 0;
        } if (!(r != null && r.refresh_token))
            throw new hh; const { session: g, error: y } = await this._callRefreshToken(r.refresh_token); return y ? { data: { user: null, session: null }, error: y } : g ? { data: { user: g.user, session: g }, error: null } : { data: { user: null, session: null }, error: null }; });
    }
    catch (o) {
        if (kn(o))
            return { data: { user: null, session: null }, error: o };
        throw o;
    } }
    async _getSessionFromURL(r, o) { try {
        if (!Xl())
            throw new D1("No browser detected.");
        if (r.error || r.error_description || r.error_code)
            throw new D1(r.error_description || "Error in URL with unspecified error_description", { error: r.error || "unspecified_error", code: r.error_code || "unspecified_code" });
        switch (o) {
            case "implicit":
                if (this.flowType === "pkce")
                    throw new _L("Not a valid PKCE flow url.");
                break;
            case "pkce":
                if (this.flowType === "implicit")
                    throw new D1("Not a valid implicit grant flow url.");
                break;
            default:
        }
        if (o === "pkce") {
            if (this._debug("#_initialize()", "begin", "is PKCE flow", !0), !r.code)
                throw new _L("No code detected.");
            const { data: Q, error: ue } = await this._exchangeCodeForSession(r.code);
            if (ue)
                throw ue;
            const be = new URL(window.location.href);
            return be.searchParams.delete("code"), window.history.replaceState(window.history.state, "", be.toString()), { data: { session: Q.session, redirectType: null }, error: null };
        }
        const { provider_token: u, provider_refresh_token: g, access_token: y, refresh_token: E, expires_in: s, expires_at: k, token_type: L } = r;
        if (!y || !s || !E || !L)
            throw new D1("No session defined in URL");
        const N = Math.round(Date.now() / 1e3), V = parseInt(s);
        let H = N + V;
        k && (H = parseInt(k));
        const ee = H - N;
        ee * 1e3 <= ym && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${ee}s, should have been closer to ${V}s`);
        const ce = H - V;
        N - ce >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", ce, H, N) : N - ce < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", ce, H, N);
        const { data: J, error: ye } = await this._getUser(y);
        if (ye)
            throw ye;
        const ie = { provider_token: u, provider_refresh_token: g, access_token: y, expires_in: V, expires_at: H, refresh_token: E, token_type: L, user: J.user };
        return window.location.hash = "", this._debug("#_getSessionFromURL()", "clearing window.location.hash"), { data: { session: ie, redirectType: r.type }, error: null };
    }
    catch (u) {
        if (kn(u))
            return { data: { session: null, redirectType: null }, error: u };
        throw u;
    } }
    _isImplicitGrantCallback(r) { return !!(r.access_token || r.error_description); }
    async _isPKCECallback(r) { const o = await L1(this.storage, `${this.storageKey}-code-verifier`); return !!(r.code && o); }
    async signOut(r = { scope: "global" }) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._signOut(r)); }
    async _signOut({ scope: r } = { scope: "global" }) { return await this._useSession(async (o) => { var u; const { data: g, error: y } = o; if (y)
        return { error: y }; const E = (u = g.session) === null || u === void 0 ? void 0 : u.access_token; if (E) {
        const { error: s } = await this.admin.signOut(E, r);
        if (s && !(J9(s) && (s.status === 404 || s.status === 401 || s.status === 403)))
            return { error: s };
    } return r !== "others" && (await this._removeSession(), await O1(this.storage, `${this.storageKey}-code-verifier`)), { error: null }; }); }
    onAuthStateChange(r) { const o = cZ(), u = { id: o, callback: r, unsubscribe: () => { this._debug("#unsubscribe()", "state change callback with id removed", o), this.stateChangeEmitters.delete(o); } }; return this._debug("#onAuthStateChange()", "registered callback with id", o), this.stateChangeEmitters.set(o, u), (async () => (await this.initializePromise, await this._acquireLock(-1, async () => { this._emitInitialSession(o); })))(), { data: { subscription: u } }; }
    async _emitInitialSession(r) { return await this._useSession(async (o) => { var u, g; try {
        const { data: { session: y }, error: E } = o;
        if (E)
            throw E;
        await ((u = this.stateChangeEmitters.get(r)) === null || u === void 0 ? void 0 : u.callback("INITIAL_SESSION", y)), this._debug("INITIAL_SESSION", "callback id", r, "session", y);
    }
    catch (y) {
        await ((g = this.stateChangeEmitters.get(r)) === null || g === void 0 ? void 0 : g.callback("INITIAL_SESSION", null)), this._debug("INITIAL_SESSION", "callback id", r, "error", y), console.error(y);
    } }); }
    async resetPasswordForEmail(r, o = {}) { let u = null, g = null; this.flowType === "pkce" && ([u, g] = await um(this.storage, this.storageKey, !0)); try {
        return await ei(this.fetch, "POST", `${this.url}/recover`, { body: { email: r, code_challenge: u, code_challenge_method: g, gotrue_meta_security: { captcha_token: o.captchaToken } }, headers: this.headers, redirectTo: o.redirectTo });
    }
    catch (y) {
        if (kn(y))
            return { data: null, error: y };
        throw y;
    } }
    async getUserIdentities() { var r; try {
        const { data: o, error: u } = await this.getUser();
        if (u)
            throw u;
        return { data: { identities: (r = o.user.identities) !== null && r !== void 0 ? r : [] }, error: null };
    }
    catch (o) {
        if (kn(o))
            return { data: null, error: o };
        throw o;
    } }
    async linkIdentity(r) { var o; try {
        const { data: u, error: g } = await this._useSession(async (y) => { var E, s, k, L, N; const { data: V, error: H } = y; if (H)
            throw H; const ee = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, r.provider, { redirectTo: (E = r.options) === null || E === void 0 ? void 0 : E.redirectTo, scopes: (s = r.options) === null || s === void 0 ? void 0 : s.scopes, queryParams: (k = r.options) === null || k === void 0 ? void 0 : k.queryParams, skipBrowserRedirect: !0 }); return await ei(this.fetch, "GET", ee, { headers: this.headers, jwt: (N = (L = V.session) === null || L === void 0 ? void 0 : L.access_token) !== null && N !== void 0 ? N : void 0 }); });
        if (g)
            throw g;
        return Xl() && !(!((o = r.options) === null || o === void 0) && o.skipBrowserRedirect) && window.location.assign(u == null ? void 0 : u.url), { data: { provider: r.provider, url: u == null ? void 0 : u.url }, error: null };
    }
    catch (u) {
        if (kn(u))
            return { data: { provider: r.provider, url: null }, error: u };
        throw u;
    } }
    async unlinkIdentity(r) { try {
        return await this._useSession(async (o) => { var u, g; const { data: y, error: E } = o; if (E)
            throw E; return await ei(this.fetch, "DELETE", `${this.url}/user/identities/${r.identity_id}`, { headers: this.headers, jwt: (g = (u = y.session) === null || u === void 0 ? void 0 : u.access_token) !== null && g !== void 0 ? g : void 0 }); });
    }
    catch (o) {
        if (kn(o))
            return { data: null, error: o };
        throw o;
    } }
    async _refreshAccessToken(r) { const o = `#_refreshAccessToken(${r.substring(0, 5)}...)`; this._debug(o, "begin"); try {
        const u = Date.now();
        return await fZ(async (g) => (g > 0 && await dZ(200 * Math.pow(2, g - 1)), this._debug(o, "refreshing attempt", g), await ei(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, { body: { refresh_token: r }, headers: this.headers, xform: dh })), (g, y) => { const E = 200 * Math.pow(2, g); return y && ME(y) && Date.now() + E - u < ym; });
    }
    catch (u) {
        if (this._debug(o, "error", u), kn(u))
            return { data: { session: null, user: null }, error: u };
        throw u;
    }
    finally {
        this._debug(o, "end");
    } }
    _isValidSession(r) { return typeof r == "object" && r !== null && "access_token" in r && "refresh_token" in r && "expires_at" in r; }
    async _handleProviderSignIn(r, o) { const u = await this._getUrlForProvider(`${this.url}/authorize`, r, { redirectTo: o.redirectTo, scopes: o.scopes, queryParams: o.queryParams }); return this._debug("#_handleProviderSignIn()", "provider", r, "options", o, "url", u), Xl() && !o.skipBrowserRedirect && window.location.assign(u), { data: { provider: r, url: u }, error: null }; }
    async _recoverAndRefresh() { var r; const o = "#_recoverAndRefresh()"; this._debug(o, "begin"); try {
        const u = await L1(this.storage, this.storageKey);
        if (this._debug(o, "session from storage", u), !this._isValidSession(u)) {
            this._debug(o, "session is not valid"), u !== null && await this._removeSession();
            return;
        }
        const g = ((r = u.expires_at) !== null && r !== void 0 ? r : 1 / 0) * 1e3 - Date.now() < IE;
        if (this._debug(o, `session has${g ? "" : " not"} expired with margin of ${IE}s`), g) {
            if (this.autoRefreshToken && u.refresh_token) {
                const { error: y } = await this._callRefreshToken(u.refresh_token);
                y && (console.error(y), ME(y) || (this._debug(o, "refresh failed with a non-retryable error, removing the session", y), await this._removeSession()));
            }
        }
        else
            await this._notifyAllSubscribers("SIGNED_IN", u);
    }
    catch (u) {
        this._debug(o, "error", u), console.error(u);
        return;
    }
    finally {
        this._debug(o, "end");
    } }
    async _callRefreshToken(r) { var o, u; if (!r)
        throw new hh; if (this.refreshingDeferred)
        return this.refreshingDeferred.promise; const g = `#_callRefreshToken(${r.substring(0, 5)}...)`; this._debug(g, "begin"); try {
        this.refreshingDeferred = new Lb;
        const { data: y, error: E } = await this._refreshAccessToken(r);
        if (E)
            throw E;
        if (!y.session)
            throw new hh;
        await this._saveSession(y.session), await this._notifyAllSubscribers("TOKEN_REFRESHED", y.session);
        const s = { session: y.session, error: null };
        return this.refreshingDeferred.resolve(s), s;
    }
    catch (y) {
        if (this._debug(g, "error", y), kn(y)) {
            const E = { session: null, error: y };
            return ME(y) || await this._removeSession(), (o = this.refreshingDeferred) === null || o === void 0 || o.resolve(E), E;
        }
        throw (u = this.refreshingDeferred) === null || u === void 0 || u.reject(y), y;
    }
    finally {
        this.refreshingDeferred = null, this._debug(g, "end");
    } }
    async _notifyAllSubscribers(r, o, u = !0) { const g = `#_notifyAllSubscribers(${r})`; this._debug(g, "begin", o, `broadcast = ${u}`); try {
        this.broadcastChannel && u && this.broadcastChannel.postMessage({ event: r, session: o });
        const y = [], E = Array.from(this.stateChangeEmitters.values()).map(async (s) => { try {
            await s.callback(r, o);
        }
        catch (k) {
            y.push(k);
        } });
        if (await Promise.all(E), y.length > 0) {
            for (let s = 0; s < y.length; s += 1)
                console.error(y[s]);
            throw y[0];
        }
    }
    finally {
        this._debug(g, "end");
    } }
    async _saveSession(r) { this._debug("#_saveSession()", r), this.suppressGetSessionWarning = !0, await $N(this.storage, this.storageKey, r); }
    async _removeSession() { this._debug("#_removeSession()"), await O1(this.storage, this.storageKey), await this._notifyAllSubscribers("SIGNED_OUT", null); }
    _removeVisibilityChangedCallback() { this._debug("#_removeVisibilityChangedCallback()"); const r = this.visibilityChangedCallback; this.visibilityChangedCallback = null; try {
        r && Xl() && (window != null && window.removeEventListener) && window.removeEventListener("visibilitychange", r);
    }
    catch (o) {
        console.error("removing visibilitychange callback failed", o);
    } }
    async _startAutoRefresh() { await this._stopAutoRefresh(), this._debug("#_startAutoRefresh()"); const r = setInterval(() => this._autoRefreshTokenTick(), ym); this.autoRefreshTicker = r, r && typeof r == "object" && typeof r.unref == "function" ? r.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(r), setTimeout(async () => { await this.initializePromise, await this._autoRefreshTokenTick(); }, 0); }
    async _stopAutoRefresh() { this._debug("#_stopAutoRefresh()"); const r = this.autoRefreshTicker; this.autoRefreshTicker = null, r && clearInterval(r); }
    async startAutoRefresh() { this._removeVisibilityChangedCallback(), await this._startAutoRefresh(); }
    async stopAutoRefresh() { this._removeVisibilityChangedCallback(), await this._stopAutoRefresh(); }
    async _autoRefreshTokenTick() { this._debug("#_autoRefreshTokenTick()", "begin"); try {
        await this._acquireLock(0, async () => { try {
            const r = Date.now();
            try {
                return await this._useSession(async (o) => { const { data: { session: u } } = o; if (!u || !u.refresh_token || !u.expires_at) {
                    this._debug("#_autoRefreshTokenTick()", "no session");
                    return;
                } const g = Math.floor((u.expires_at * 1e3 - r) / ym); this._debug("#_autoRefreshTokenTick()", `access token expires in ${g} ticks, a tick lasts ${ym}ms, refresh threshold is ${hC} ticks`), g <= hC && await this._callRefreshToken(u.refresh_token); });
            }
            catch (o) {
                console.error("Auto refresh tick failed with error. This is likely a transient error.", o);
            }
        }
        finally {
            this._debug("#_autoRefreshTokenTick()", "end");
        } });
    }
    catch (r) {
        if (r.isAcquireTimeout || r instanceof GN)
            this._debug("auto refresh token tick lock not available");
        else
            throw r;
    } }
    async _handleVisibilityChange() { if (this._debug("#_handleVisibilityChange()"), !Xl() || !(window != null && window.addEventListener))
        return this.autoRefreshToken && this.startAutoRefresh(), !1; try {
        this.visibilityChangedCallback = async () => await this._onVisibilityChanged(!1), window == null || window.addEventListener("visibilitychange", this.visibilityChangedCallback), await this._onVisibilityChanged(!0);
    }
    catch (r) {
        console.error("_handleVisibilityChange", r);
    } }
    async _onVisibilityChanged(r) { const o = `#_onVisibilityChanged(${r})`; this._debug(o, "visibilityState", document.visibilityState), document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(), r || (await this.initializePromise, await this._acquireLock(-1, async () => { if (document.visibilityState !== "visible") {
        this._debug(o, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
        return;
    } await this._recoverAndRefresh(); }))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh(); }
    async _getUrlForProvider(r, o, u) { const g = [`provider=${encodeURIComponent(o)}`]; if (u != null && u.redirectTo && g.push(`redirect_to=${encodeURIComponent(u.redirectTo)}`), u != null && u.scopes && g.push(`scopes=${encodeURIComponent(u.scopes)}`), this.flowType === "pkce") {
        const [y, E] = await um(this.storage, this.storageKey), s = new URLSearchParams({ code_challenge: `${encodeURIComponent(y)}`, code_challenge_method: `${encodeURIComponent(E)}` });
        g.push(s.toString());
    } if (u != null && u.queryParams) {
        const y = new URLSearchParams(u.queryParams);
        g.push(y.toString());
    } return u != null && u.skipBrowserRedirect && g.push(`skip_http_redirect=${u.skipBrowserRedirect}`), `${r}?${g.join("&")}`; }
    async _unenroll(r) { try {
        return await this._useSession(async (o) => { var u; const { data: g, error: y } = o; return y ? { data: null, error: y } : await ei(this.fetch, "DELETE", `${this.url}/factors/${r.factorId}`, { headers: this.headers, jwt: (u = g == null ? void 0 : g.session) === null || u === void 0 ? void 0 : u.access_token }); });
    }
    catch (o) {
        if (kn(o))
            return { data: null, error: o };
        throw o;
    } }
    async _enroll(r) { try {
        return await this._useSession(async (o) => { var u, g; const { data: y, error: E } = o; if (E)
            return { data: null, error: E }; const s = Object.assign({ friendly_name: r.friendlyName, factor_type: r.factorType }, r.factorType === "phone" ? { phone: r.phone } : { issuer: r.issuer }), { data: k, error: L } = await ei(this.fetch, "POST", `${this.url}/factors`, { body: s, headers: this.headers, jwt: (u = y == null ? void 0 : y.session) === null || u === void 0 ? void 0 : u.access_token }); return L ? { data: null, error: L } : (r.factorType === "totp" && (!((g = k == null ? void 0 : k.totp) === null || g === void 0) && g.qr_code) && (k.totp.qr_code = `data:image/svg+xml;utf-8,${k.totp.qr_code}`), { data: k, error: null }); });
    }
    catch (o) {
        if (kn(o))
            return { data: null, error: o };
        throw o;
    } }
    async _verify(r) { return this._acquireLock(-1, async () => { try {
        return await this._useSession(async (o) => { var u; const { data: g, error: y } = o; if (y)
            return { data: null, error: y }; const { data: E, error: s } = await ei(this.fetch, "POST", `${this.url}/factors/${r.factorId}/verify`, { body: { code: r.code, challenge_id: r.challengeId }, headers: this.headers, jwt: (u = g == null ? void 0 : g.session) === null || u === void 0 ? void 0 : u.access_token }); return s ? { data: null, error: s } : (await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + E.expires_in }, E)), await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", E), { data: E, error: s }); });
    }
    catch (o) {
        if (kn(o))
            return { data: null, error: o };
        throw o;
    } }); }
    async _challenge(r) { return this._acquireLock(-1, async () => { try {
        return await this._useSession(async (o) => { var u; const { data: g, error: y } = o; return y ? { data: null, error: y } : await ei(this.fetch, "POST", `${this.url}/factors/${r.factorId}/challenge`, { body: { channel: r.channel }, headers: this.headers, jwt: (u = g == null ? void 0 : g.session) === null || u === void 0 ? void 0 : u.access_token }); });
    }
    catch (o) {
        if (kn(o))
            return { data: null, error: o };
        throw o;
    } }); }
    async _challengeAndVerify(r) { const { data: o, error: u } = await this._challenge({ factorId: r.factorId }); return u ? { data: null, error: u } : await this._verify({ factorId: r.factorId, challengeId: o.id, code: r.code }); }
    async _listFactors() { const { data: { user: r }, error: o } = await this.getUser(); if (o)
        return { data: null, error: o }; const u = (r == null ? void 0 : r.factors) || [], g = u.filter(E => E.factor_type === "totp" && E.status === "verified"), y = u.filter(E => E.factor_type === "phone" && E.status === "verified"); return { data: { all: u, totp: g, phone: y }, error: null }; }
    async _getAuthenticatorAssuranceLevel() { return this._acquireLock(-1, async () => await this._useSession(async (r) => { var o, u; const { data: { session: g }, error: y } = r; if (y)
        return { data: null, error: y }; if (!g)
        return { data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] }, error: null }; const { payload: E } = RE(g.access_token); let s = null; E.aal && (s = E.aal); let k = s; ((u = (o = g.user.factors) === null || o === void 0 ? void 0 : o.filter(V => V.status === "verified")) !== null && u !== void 0 ? u : []).length > 0 && (k = "aal2"); const N = E.amr || []; return { data: { currentLevel: s, nextLevel: k, currentAuthenticationMethods: N }, error: null }; })); }
    async fetchJwk(r, o = { keys: [] }) { let u = o.keys.find(E => E.kid === r); if (u || (u = this.jwks.keys.find(E => E.kid === r), u && this.jwks_cached_at + Y9 > Date.now()))
        return u; const { data: g, error: y } = await ei(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, { headers: this.headers }); if (y)
        throw y; if (!g.keys || g.keys.length === 0)
        throw new ov("JWKS is empty"); if (this.jwks = g, this.jwks_cached_at = Date.now(), u = g.keys.find(E => E.kid === r), !u)
        throw new ov("No matching signing key found in JWKS"); return u; }
    async getClaims(r, o = { keys: [] }) { try {
        let u = r;
        if (!u) {
            const { data: ee, error: ce } = await this.getSession();
            if (ce || !ee.session)
                return { data: null, error: ce };
            u = ee.session.access_token;
        }
        const { header: g, payload: y, signature: E, raw: { header: s, payload: k } } = RE(u);
        if (xZ(y.exp), !g.kid || g.alg === "HS256" || !("crypto" in globalThis && "subtle" in globalThis.crypto)) {
            const { error: ee } = await this.getUser(u);
            if (ee)
                throw ee;
            return { data: { claims: y, header: g, signature: E }, error: null };
        }
        const L = wZ(g.alg), N = await this.fetchJwk(g.kid, o), V = await crypto.subtle.importKey("jwk", N, L, !0, ["verify"]);
        if (!await crypto.subtle.verify(L, V, E, aZ(`${s}.${k}`)))
            throw new ov("Invalid JWT signature");
        return { data: { claims: y, header: g, signature: E }, error: null };
    }
    catch (u) {
        if (kn(u))
            return { data: null, error: u };
        throw u;
    } }
}
Mv.nextInstanceID = 0;
const FZ = Mv;
class NZ extends FZ {
    constructor(r) { super(r); }
}
var BZ = function (t, r, o, u) { function g(y) { return y instanceof o ? y : new o(function (E) { E(y); }); } return new (o || (o = Promise))(function (y, E) { function s(N) { try {
    L(u.next(N));
}
catch (V) {
    E(V);
} } function k(N) { try {
    L(u.throw(N));
}
catch (V) {
    E(V);
} } function L(N) { N.done ? y(N.value) : g(N.value).then(s, k); } L((u = u.apply(t, r || [])).next()); }); };
class jZ {
    constructor(r, o, u) { var g, y, E; if (this.supabaseUrl = r, this.supabaseKey = o, !r)
        throw new Error("supabaseUrl is required."); if (!o)
        throw new Error("supabaseKey is required."); const s = q9(r), k = new URL(s); this.realtimeUrl = new URL("/realtime/v1", k), this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws"), this.authUrl = new URL("/auth/v1", k), this.storageUrl = new URL("/storage/v1", k), this.functionsUrl = new URL("/functions/v1", k); const L = `sb-${k.hostname.split(".")[0]}-auth-token`, N = { db: F9, realtime: B9, auth: Object.assign(Object.assign({}, N9), { storageKey: L }), global: z9 }, V = H9(u ?? {}, N); this.storageKey = (g = V.auth.storageKey) !== null && g !== void 0 ? g : "", this.headers = (y = V.global.headers) !== null && y !== void 0 ? y : {}, V.accessToken ? (this.accessToken = V.accessToken, this.auth = new Proxy({}, { get: (H, ee) => { throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(ee)} is not possible`); } })) : this.auth = this._initSupabaseAuthClient((E = V.auth) !== null && E !== void 0 ? E : {}, this.headers, V.global.fetch), this.fetch = $9(o, this._getAccessToken.bind(this), V.global.fetch), this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, V.realtime)), this.rest = new i9(`${s}/rest/v1`, { headers: this.headers, schema: V.db.schema, fetch: this.fetch }), V.accessToken || this._listenForAuthEvents(); }
    get functions() { return new LW(this.functionsUrl.href, { headers: this.headers, customFetch: this.fetch }); }
    get storage() { return new D9(this.storageUrl.href, this.headers, this.fetch); }
    from(r) { return this.rest.from(r); }
    schema(r) { return this.rest.schema(r); }
    rpc(r, o = {}, u = {}) { return this.rest.rpc(r, o, u); }
    channel(r, o = { config: {} }) { return this.realtime.channel(r, o); }
    getChannels() { return this.realtime.getChannels(); }
    removeChannel(r) { return this.realtime.removeChannel(r); }
    removeAllChannels() { return this.realtime.removeAllChannels(); }
    _getAccessToken() { var r, o; return BZ(this, void 0, void 0, function* () { if (this.accessToken)
        return yield this.accessToken(); const { data: u } = yield this.auth.getSession(); return (o = (r = u.session) === null || r === void 0 ? void 0 : r.access_token) !== null && o !== void 0 ? o : null; }); }
    _initSupabaseAuthClient({ autoRefreshToken: r, persistSession: o, detectSessionInUrl: u, storage: g, storageKey: y, flowType: E, lock: s, debug: k }, L, N) { const V = { Authorization: `Bearer ${this.supabaseKey}`, apikey: `${this.supabaseKey}` }; return new NZ({ url: this.authUrl.href, headers: Object.assign(Object.assign({}, V), L), storageKey: y, autoRefreshToken: r, persistSession: o, detectSessionInUrl: u, storage: g, flowType: E, lock: s, debug: k, fetch: N, hasCustomAuthorizationHeader: "Authorization" in this.headers }); }
    _initRealtimeClient(r) { return new v9(this.realtimeUrl.href, Object.assign(Object.assign({}, r), { params: Object.assign({ apikey: this.supabaseKey }, r == null ? void 0 : r.params) })); }
    _listenForAuthEvents() { return this.auth.onAuthStateChange((o, u) => { this._handleTokenChanged(o, "CLIENT", u == null ? void 0 : u.access_token); }); }
    _handleTokenChanged(r, o, u) { (r === "TOKEN_REFRESHED" || r === "SIGNED_IN") && this.changedAccessToken !== u ? this.changedAccessToken = u : r === "SIGNED_OUT" && (this.realtime.setAuth(), o == "STORAGE" && this.auth.signOut(), this.changedAccessToken = void 0); }
}
const VZ = (t, r, o) => new jZ(t, r, o), UZ = void 0, $Z = void 0, sf = VZ(UZ, $Z), dm = { signUp: async (t, r, o = {}) => { const { data: u, error: g } = await sf.auth.signUp({ email: t, password: r, options: { data: o } }); return { data: u, error: g }; }, signIn: async (t, r) => { const { data: o, error: u } = await sf.auth.signInWithPassword({ email: t, password: r }); return { data: o, error: u }; }, signInWithProvider: async (t) => { const { data: r, error: o } = await sf.auth.signInWithOAuth({ provider: t }); return { data: r, error: o }; }, signOut: async () => { const { error: t } = await sf.auth.signOut(); return { error: t }; }, getUser: async () => { const { data: t, error: r } = await sf.auth.getUser(); return { user: t.user, error: r }; }, getSession: async () => { const { data: t, error: r } = await sf.auth.getSession(); return { session: t.session, error: r }; }, onAuthStateChange: t => sf.auth.onAuthStateChange(t) }, qN = ne.createContext(void 0);
function GZ({ children: t }) { const [r, o] = ne.useState(null), [u, g] = ne.useState(!0), [y, E] = ne.useState(null), { toast: s } = fc(); ne.useEffect(() => { async function ee() { try {
    const { user: J, error: ye } = await dm.getUser();
    if (ye)
        throw new Error(ye.message);
    o(J);
}
catch (J) {
    console.error("Error loading user:", J), E(J.message);
}
finally {
    g(!1);
} } ee(); const { data: ce } = dm.onAuthStateChange((J, ye) => { o((ye == null ? void 0 : ye.user) || null), g(!1); }); return () => { ce != null && ce.subscription && ce.subscription.unsubscribe(); }; }, []); const H = { user: r, loading: u, error: y, signIn: async (ee, ce) => { try {
        g(!0), E(null);
        const { data: J, error: ye } = await dm.signIn(ee, ce);
        if (ye)
            throw new Error(ye.message);
        o(J.user), s({ title: "Welcome back!", description: "You have successfully signed in." });
    }
    catch (J) {
        throw console.error("Error signing in:", J), E(J.message), s({ title: "Sign-in failed", description: J.message, variant: "destructive" }), J;
    }
    finally {
        g(!1);
    } }, signUp: async (ee, ce, J = {}) => { try {
        g(!0), E(null);
        const { data: ye, error: ie } = await dm.signUp(ee, ce, J);
        if (ie)
            throw new Error(ie.message);
        if (ye.user)
            try {
                const Q = ee.split("@")[0], ue = await fetch("/api/users", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ auth_id: ye.user.id, username: Q, email: ee, display_name: J.hasOwnProperty("display_name") ? J.display_name : Q, avatar_url: J.hasOwnProperty("avatar_url") ? J.avatar_url : null }) });
                ue.ok || console.warn("User created in Supabase but failed to create in database:", await ue.json());
            }
            catch (Q) {
                console.error("Error creating user in database:", Q);
            }
        o(ye.user), s({ title: "Account created", description: "Your account has been successfully created." });
    }
    catch (ye) {
        throw console.error("Error signing up:", ye), E(ye.message), s({ title: "Sign-up failed", description: ye.message, variant: "destructive" }), ye;
    }
    finally {
        g(!1);
    } }, signOut: async () => { try {
        g(!0), E(null);
        const { error: ee } = await dm.signOut();
        if (ee)
            throw new Error(ee.message);
        o(null), s({ title: "Signed out", description: "You have been successfully signed out." });
    }
    catch (ee) {
        console.error("Error signing out:", ee), E(ee.message), s({ title: "Sign-out failed", description: ee.message, variant: "destructive" });
    }
    finally {
        g(!1);
    } }, signInWithProvider: async (ee) => { try {
        g(!0), E(null);
        const { data: ce, error: J } = await dm.signInWithProvider(ee);
        if (J)
            throw new Error(J.message);
        s({ title: "Redirecting...", description: `Redirecting to ${ee} for authentication.` });
    }
    catch (ce) {
        throw console.error(`Error signing in with ${ee}:`, ce), E(ce.message), s({ title: "Sign-in failed", description: ce.message, variant: "destructive" }), ce;
    }
    finally {
        g(!1);
    } } }; return j.jsx(qN.Provider, { value: H, children: t }); }
function ZA() { const t = ne.useContext(qN); if (t === void 0)
    throw new Error("useAuth must be used within an AuthProvider"); return t; }
const qZ = wb("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", { variants: { variant: { default: "bg-primary text-primary-foreground hover:bg-primary/90", destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90", outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground", secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80", ghost: "hover:bg-accent hover:text-accent-foreground", link: "text-primary underline-offset-4 hover:underline" }, size: { default: "h-10 px-4 py-2", sm: "h-9 rounded-md px-3", lg: "h-11 rounded-md px-8", icon: "h-10 w-10" } }, defaultVariants: { variant: "default", size: "default" } }), ci = ne.forwardRef(({ className: t, variant: r, size: o, asChild: u = !1, ...g }, y) => { const E = u ? bG : "button"; return j.jsx(E, { className: $n(qZ({ variant: r, size: o, className: t })), ref: y, ...g }); });
ci.displayName = "Button";
const Vh = ne.forwardRef(({ className: t, ...r }, o) => j.jsx("div", { ref: o, className: $n("rounded-lg border bg-card text-card-foreground shadow-sm", t), ...r }));
Vh.displayName = "Card";
const XA = ne.forwardRef(({ className: t, ...r }, o) => j.jsx("div", { ref: o, className: $n("flex flex-col space-y-1.5 p-6", t), ...r }));
XA.displayName = "CardHeader";
const KA = ne.forwardRef(({ className: t, ...r }, o) => j.jsx("div", { ref: o, className: $n("text-2xl font-semibold leading-none tracking-tight", t), ...r }));
KA.displayName = "CardTitle";
const YA = ne.forwardRef(({ className: t, ...r }, o) => j.jsx("div", { ref: o, className: $n("text-sm text-muted-foreground", t), ...r }));
YA.displayName = "CardDescription";
const Uh = ne.forwardRef(({ className: t, ...r }, o) => j.jsx("div", { ref: o, className: $n("p-6 pt-0", t), ...r }));
Uh.displayName = "CardContent";
const QA = ne.forwardRef(({ className: t, ...r }, o) => j.jsx("div", { ref: o, className: $n("flex items-center p-6 pt-0", t), ...r }));
QA.displayName = "CardFooter";
const En = { TRIPS: "/api/trips", ACTIVITIES: "/api/activities", TODOS: "/api/todos", NOTES: "/api/notes", AI: { SUMMARIZE_DAY: "/api/ai/summarize-day", SUGGEST_FOOD: "/api/ai/suggest-food", DETECT_CONFLICTS: "/api/ai/detect-conflicts", THEMED_ITINERARY: "/api/ai/themed-itinerary", ASSISTANT: "/api/ai/assistant", WEATHER_ACTIVITIES: "/api/ai/weather-activities", BUDGET_OPTIONS: "/api/ai/budget-options", FIND_LOCATION: "/api/ai/find-location" } }, HN = { CULTURE: { id: "culture", label: "Culture", color: "bg-[hsl(var(--tag-culture))]", icon: "" }, FOOD: { id: "food", label: "Food", color: "bg-[hsl(var(--tag-food))]", icon: "" }, EVENT: { id: "event", label: "Event", color: "bg-[hsl(var(--tag-event))]", icon: "" }, REST: { id: "rest", label: "Rest", color: "bg-[hsl(var(--tag-rest))]", icon: "" }, SHOP: { id: "shop", label: "Shop", color: "bg-[hsl(var(--primary))]", icon: "" } }, HZ = (t, r) => { const o = { month: "short", day: "numeric" }; return `${t.toLocaleDateString("en-US", o)} - ${r.toLocaleDateString("en-US", o)}`; }, WZ = t => { const r = { month: "short", day: "numeric" }; return t.toLocaleDateString("en-US", r); }, ZZ = (t, r) => { const o = [], u = new Date(t); for (; u <= r;)
    o.push(new Date(u)), u.setDate(u.getDate() + 1); return o; }, CL = { center: [-74.006, 40.7128], zoom: 12 }, XZ = "mapbox://styles/mapbox/streets-v12";
var ui;
(function (t) { t.assertEqual = g => g; function r(g) { } t.assertIs = r; function o(g) { throw new Error; } t.assertNever = o, t.arrayToEnum = g => { const y = {}; for (const E of g)
    y[E] = E; return y; }, t.getValidEnumValues = g => { const y = t.objectKeys(g).filter(s => typeof g[g[s]] != "number"), E = {}; for (const s of y)
    E[s] = g[s]; return t.objectValues(E); }, t.objectValues = g => t.objectKeys(g).map(function (y) { return g[y]; }), t.objectKeys = typeof Object.keys == "function" ? g => Object.keys(g) : g => { const y = []; for (const E in g)
    Object.prototype.hasOwnProperty.call(g, E) && y.push(E); return y; }, t.find = (g, y) => { for (const E of g)
    if (y(E))
        return E; }, t.isInteger = typeof Number.isInteger == "function" ? g => Number.isInteger(g) : g => typeof g == "number" && isFinite(g) && Math.floor(g) === g; function u(g, y = " | ") { return g.map(E => typeof E == "string" ? `'${E}'` : E).join(y); } t.joinValues = u, t.jsonStringifyReplacer = (g, y) => typeof y == "bigint" ? y.toString() : y; })(ui || (ui = {}));
var pC;
(function (t) { t.mergeShapes = (r, o) => ({ ...r, ...o }); })(pC || (pC = {}));
const Er = ui.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), Jc = t => { switch (typeof t) {
    case "undefined": return Er.undefined;
    case "string": return Er.string;
    case "number": return isNaN(t) ? Er.nan : Er.number;
    case "boolean": return Er.boolean;
    case "function": return Er.function;
    case "bigint": return Er.bigint;
    case "symbol": return Er.symbol;
    case "object": return Array.isArray(t) ? Er.array : t === null ? Er.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? Er.promise : typeof Map < "u" && t instanceof Map ? Er.map : typeof Set < "u" && t instanceof Set ? Er.set : typeof Date < "u" && t instanceof Date ? Er.date : Er.object;
    default: return Er.unknown;
} }, er = ui.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]), KZ = t => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class ga extends Error {
    get errors() { return this.issues; }
    constructor(r) { super(), this.issues = [], this.addIssue = u => { this.issues = [...this.issues, u]; }, this.addIssues = (u = []) => { this.issues = [...this.issues, ...u]; }; const o = new.target.prototype; Object.setPrototypeOf ? Object.setPrototypeOf(this, o) : this.__proto__ = o, this.name = "ZodError", this.issues = r; }
    format(r) { const o = r || function (y) { return y.message; }, u = { _errors: [] }, g = y => { for (const E of y.issues)
        if (E.code === "invalid_union")
            E.unionErrors.map(g);
        else if (E.code === "invalid_return_type")
            g(E.returnTypeError);
        else if (E.code === "invalid_arguments")
            g(E.argumentsError);
        else if (E.path.length === 0)
            u._errors.push(o(E));
        else {
            let s = u, k = 0;
            for (; k < E.path.length;) {
                const L = E.path[k];
                k === E.path.length - 1 ? (s[L] = s[L] || { _errors: [] }, s[L]._errors.push(o(E))) : s[L] = s[L] || { _errors: [] }, s = s[L], k++;
            }
        } }; return g(this), u; }
    static assert(r) { if (!(r instanceof ga))
        throw new Error(`Not a ZodError: ${r}`); }
    toString() { return this.message; }
    get message() { return JSON.stringify(this.issues, ui.jsonStringifyReplacer, 2); }
    get isEmpty() { return this.issues.length === 0; }
    flatten(r = o => o.message) { const o = {}, u = []; for (const g of this.issues)
        g.path.length > 0 ? (o[g.path[0]] = o[g.path[0]] || [], o[g.path[0]].push(r(g))) : u.push(r(g)); return { formErrors: u, fieldErrors: o }; }
    get formErrors() { return this.flatten(); }
}
ga.create = t => new ga(t);
const yg = (t, r) => { let o; switch (t.code) {
    case er.invalid_type:
        t.received === Er.undefined ? o = "Required" : o = `Expected ${t.expected}, received ${t.received}`;
        break;
    case er.invalid_literal:
        o = `Invalid literal value, expected ${JSON.stringify(t.expected, ui.jsonStringifyReplacer)}`;
        break;
    case er.unrecognized_keys:
        o = `Unrecognized key(s) in object: ${ui.joinValues(t.keys, ", ")}`;
        break;
    case er.invalid_union:
        o = "Invalid input";
        break;
    case er.invalid_union_discriminator:
        o = `Invalid discriminator value. Expected ${ui.joinValues(t.options)}`;
        break;
    case er.invalid_enum_value:
        o = `Invalid enum value. Expected ${ui.joinValues(t.options)}, received '${t.received}'`;
        break;
    case er.invalid_arguments:
        o = "Invalid function arguments";
        break;
    case er.invalid_return_type:
        o = "Invalid function return type";
        break;
    case er.invalid_date:
        o = "Invalid date";
        break;
    case er.invalid_string:
        typeof t.validation == "object" ? "includes" in t.validation ? (o = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (o = `${o} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? o = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? o = `Invalid input: must end with "${t.validation.endsWith}"` : ui.assertNever(t.validation) : t.validation !== "regex" ? o = `Invalid ${t.validation}` : o = "Invalid";
        break;
    case er.too_small:
        t.type === "array" ? o = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? o = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? o = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? o = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : o = "Invalid input";
        break;
    case er.too_big:
        t.type === "array" ? o = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? o = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? o = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? o = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? o = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : o = "Invalid input";
        break;
    case er.custom:
        o = "Invalid input";
        break;
    case er.invalid_intersection_types:
        o = "Intersection results could not be merged";
        break;
    case er.not_multiple_of:
        o = `Number must be a multiple of ${t.multipleOf}`;
        break;
    case er.not_finite:
        o = "Number must be finite";
        break;
    default: o = r.defaultError, ui.assertNever(t);
} return { message: o }; };
let WN = yg;
function YZ(t) { WN = t; }
function Nw() { return WN; }
const Bw = t => { const { data: r, path: o, errorMaps: u, issueData: g } = t, y = [...o, ...g.path || []], E = { ...g, path: y }; if (g.message !== void 0)
    return { ...g, path: y, message: g.message }; let s = ""; const k = u.filter(L => !!L).slice().reverse(); for (const L of k)
    s = L(E, { data: r, defaultError: s }).message; return { ...g, path: y, message: s }; }, QZ = [];
function yr(t, r) { const o = Nw(), u = Bw({ issueData: r, data: t.data, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, o, o === yg ? void 0 : yg].filter(g => !!g) }); t.common.issues.push(u); }
class fo {
    constructor() { this.value = "valid"; }
    dirty() { this.value === "valid" && (this.value = "dirty"); }
    abort() { this.value !== "aborted" && (this.value = "aborted"); }
    static mergeArray(r, o) { const u = []; for (const g of o) {
        if (g.status === "aborted")
            return cn;
        g.status === "dirty" && r.dirty(), u.push(g.value);
    } return { status: r.value, value: u }; }
    static async mergeObjectAsync(r, o) { const u = []; for (const g of o) {
        const y = await g.key, E = await g.value;
        u.push({ key: y, value: E });
    } return fo.mergeObjectSync(r, u); }
    static mergeObjectSync(r, o) { const u = {}; for (const g of o) {
        const { key: y, value: E } = g;
        if (y.status === "aborted" || E.status === "aborted")
            return cn;
        y.status === "dirty" && r.dirty(), E.status === "dirty" && r.dirty(), y.value !== "__proto__" && (typeof E.value < "u" || g.alwaysSet) && (u[y.value] = E.value);
    } return { status: r.value, value: u }; }
}
const cn = Object.freeze({ status: "aborted" }), km = t => ({ status: "dirty", value: t }), So = t => ({ status: "valid", value: t }), mC = t => t.status === "aborted", gC = t => t.status === "dirty", Lf = t => t.status === "valid", Rv = t => typeof Promise < "u" && t instanceof Promise;
function jw(t, r, o, u) { if (typeof r == "function" ? t !== r || !u : !r.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it"); return r.get(t); }
function ZN(t, r, o, u, g) { if (typeof r == "function" ? t !== r || !g : !r.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it"); return r.set(t, o), o; }
var Gr;
(function (t) { t.errToObj = r => typeof r == "string" ? { message: r } : r || {}, t.toString = r => typeof r == "string" ? r : r == null ? void 0 : r.message; })(Gr || (Gr = {}));
var Gy, qy;
class hc {
    constructor(r, o, u, g) { this._cachedPath = [], this.parent = r, this.data = o, this._path = u, this._key = g; }
    get path() { return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath; }
}
const AL = (t, r) => { if (Lf(r))
    return { success: !0, data: r.value }; if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected."); return { success: !1, get error() { if (this._error)
        return this._error; const o = new ga(t.common.issues); return this._error = o, this._error; } }; };
function Cn(t) { if (!t)
    return {}; const { errorMap: r, invalid_type_error: o, required_error: u, description: g } = t; if (r && (o || u))
    throw new Error("Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map."); return r ? { errorMap: r, description: g } : { errorMap: (E, s) => { var k, L; const { message: N } = t; return E.code === "invalid_enum_value" ? { message: N ?? s.defaultError } : typeof s.data > "u" ? { message: (k = N ?? u) !== null && k !== void 0 ? k : s.defaultError } : E.code !== "invalid_type" ? { message: s.defaultError } : { message: (L = N ?? o) !== null && L !== void 0 ? L : s.defaultError }; }, description: g }; }
class Bn {
    get description() { return this._def.description; }
    _getType(r) { return Jc(r.data); }
    _getOrReturnCtx(r, o) { return o || { common: r.parent.common, data: r.data, parsedType: Jc(r.data), schemaErrorMap: this._def.errorMap, path: r.path, parent: r.parent }; }
    _processInputParams(r) { return { status: new fo, ctx: { common: r.parent.common, data: r.data, parsedType: Jc(r.data), schemaErrorMap: this._def.errorMap, path: r.path, parent: r.parent } }; }
    _parseSync(r) { const o = this._parse(r); if (Rv(o))
        throw new Error("Synchronous parse encountered promise."); return o; }
    _parseAsync(r) { const o = this._parse(r); return Promise.resolve(o); }
    parse(r, o) { const u = this.safeParse(r, o); if (u.success)
        return u.data; throw u.error; }
    safeParse(r, o) { var u; const g = { common: { issues: [], async: (u = o == null ? void 0 : o.async) !== null && u !== void 0 ? u : !1, contextualErrorMap: o == null ? void 0 : o.errorMap }, path: (o == null ? void 0 : o.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: r, parsedType: Jc(r) }, y = this._parseSync({ data: r, path: g.path, parent: g }); return AL(g, y); }
    "~validate"(r) { var o, u; const g = { common: { issues: [], async: !!this["~standard"].async }, path: [], schemaErrorMap: this._def.errorMap, parent: null, data: r, parsedType: Jc(r) }; if (!this["~standard"].async)
        try {
            const y = this._parseSync({ data: r, path: [], parent: g });
            return Lf(y) ? { value: y.value } : { issues: g.common.issues };
        }
        catch (y) {
            !((u = (o = y == null ? void 0 : y.message) === null || o === void 0 ? void 0 : o.toLowerCase()) === null || u === void 0) && u.includes("encountered") && (this["~standard"].async = !0), g.common = { issues: [], async: !0 };
        } return this._parseAsync({ data: r, path: [], parent: g }).then(y => Lf(y) ? { value: y.value } : { issues: g.common.issues }); }
    async parseAsync(r, o) { const u = await this.safeParseAsync(r, o); if (u.success)
        return u.data; throw u.error; }
    async safeParseAsync(r, o) { const u = { common: { issues: [], contextualErrorMap: o == null ? void 0 : o.errorMap, async: !0 }, path: (o == null ? void 0 : o.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: r, parsedType: Jc(r) }, g = this._parse({ data: r, path: u.path, parent: u }), y = await (Rv(g) ? g : Promise.resolve(g)); return AL(u, y); }
    refine(r, o) { const u = g => typeof o == "string" || typeof o > "u" ? { message: o } : typeof o == "function" ? o(g) : o; return this._refinement((g, y) => { const E = r(g), s = () => y.addIssue({ code: er.custom, ...u(g) }); return typeof Promise < "u" && E instanceof Promise ? E.then(k => k ? !0 : (s(), !1)) : E ? !0 : (s(), !1); }); }
    refinement(r, o) { return this._refinement((u, g) => r(u) ? !0 : (g.addIssue(typeof o == "function" ? o(u, g) : o), !1)); }
    _refinement(r) { return new Tl({ schema: this, typeName: on.ZodEffects, effect: { type: "refinement", refinement: r } }); }
    superRefine(r) { return this._refinement(r); }
    constructor(r) { this.spa = this.safeParseAsync, this._def = r, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = { version: 1, vendor: "zod", validate: o => this["~validate"](o) }; }
    optional() { return cc.create(this, this._def); }
    nullable() { return Jh.create(this, this._def); }
    nullish() { return this.nullable().optional(); }
    array() { return vl.create(this); }
    promise() { return xg.create(this, this._def); }
    or(r) { return Ov.create([this, r], this._def); }
    and(r) { return zv.create(this, r, this._def); }
    transform(r) { return new Tl({ ...Cn(this._def), schema: this, typeName: on.ZodEffects, effect: { type: "transform", transform: r } }); }
    default(r) { const o = typeof r == "function" ? r : () => r; return new Vv({ ...Cn(this._def), innerType: this, defaultValue: o, typeName: on.ZodDefault }); }
    brand() { return new JA({ typeName: on.ZodBranded, type: this, ...Cn(this._def) }); }
    catch(r) { const o = typeof r == "function" ? r : () => r; return new Uv({ ...Cn(this._def), innerType: this, catchValue: o, typeName: on.ZodCatch }); }
    describe(r) { const o = this.constructor; return new o({ ...this._def, description: r }); }
    pipe(r) { return l0.create(this, r); }
    readonly() { return $v.create(this); }
    isOptional() { return this.safeParse(void 0).success; }
    isNullable() { return this.safeParse(null).success; }
}
const JZ = /^c[^\s-]{8,}$/i, e7 = /^[0-9a-z]+$/, t7 = /^[0-9A-HJKMNP-TV-Z]{26}$/i, r7 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, n7 = /^[a-z0-9_-]{21}$/i, i7 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, s7 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, o7 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, a7 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let kE;
const l7 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, c7 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, u7 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, h7 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, d7 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, f7 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, XN = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", p7 = new RegExp(`^${XN}$`);
function KN(t) { let r = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d"; return t.precision ? r = `${r}\\.\\d{${t.precision}}` : t.precision == null && (r = `${r}(\\.\\d+)?`), r; }
function m7(t) { return new RegExp(`^${KN(t)}$`); }
function YN(t) { let r = `${XN}T${KN(t)}`; const o = []; return o.push(t.local ? "Z?" : "Z"), t.offset && o.push("([+-]\\d{2}:?\\d{2})"), r = `${r}(${o.join("|")})`, new RegExp(`^${r}$`); }
function g7(t, r) { return !!((r === "v4" || !r) && l7.test(t) || (r === "v6" || !r) && u7.test(t)); }
function _7(t, r) { if (!i7.test(t))
    return !1; try {
    const [o] = t.split("."), u = o.replace(/-/g, "+").replace(/_/g, "/").padEnd(o.length + (4 - o.length % 4) % 4, "="), g = JSON.parse(atob(u));
    return !(typeof g != "object" || g === null || !g.typ || !g.alg || r && g.alg !== r);
}
catch {
    return !1;
} }
function y7(t, r) { return !!((r === "v4" || !r) && c7.test(t) || (r === "v6" || !r) && h7.test(t)); }
class gl extends Bn {
    _parse(r) { if (this._def.coerce && (r.data = String(r.data)), this._getType(r) !== Er.string) {
        const y = this._getOrReturnCtx(r);
        return yr(y, { code: er.invalid_type, expected: Er.string, received: y.parsedType }), cn;
    } const u = new fo; let g; for (const y of this._def.checks)
        if (y.kind === "min")
            r.data.length < y.value && (g = this._getOrReturnCtx(r, g), yr(g, { code: er.too_small, minimum: y.value, type: "string", inclusive: !0, exact: !1, message: y.message }), u.dirty());
        else if (y.kind === "max")
            r.data.length > y.value && (g = this._getOrReturnCtx(r, g), yr(g, { code: er.too_big, maximum: y.value, type: "string", inclusive: !0, exact: !1, message: y.message }), u.dirty());
        else if (y.kind === "length") {
            const E = r.data.length > y.value, s = r.data.length < y.value;
            (E || s) && (g = this._getOrReturnCtx(r, g), E ? yr(g, { code: er.too_big, maximum: y.value, type: "string", inclusive: !0, exact: !0, message: y.message }) : s && yr(g, { code: er.too_small, minimum: y.value, type: "string", inclusive: !0, exact: !0, message: y.message }), u.dirty());
        }
        else if (y.kind === "email")
            o7.test(r.data) || (g = this._getOrReturnCtx(r, g), yr(g, { validation: "email", code: er.invalid_string, message: y.message }), u.dirty());
        else if (y.kind === "emoji")
            kE || (kE = new RegExp(a7, "u")), kE.test(r.data) || (g = this._getOrReturnCtx(r, g), yr(g, { validation: "emoji", code: er.invalid_string, message: y.message }), u.dirty());
        else if (y.kind === "uuid")
            r7.test(r.data) || (g = this._getOrReturnCtx(r, g), yr(g, { validation: "uuid", code: er.invalid_string, message: y.message }), u.dirty());
        else if (y.kind === "nanoid")
            n7.test(r.data) || (g = this._getOrReturnCtx(r, g), yr(g, { validation: "nanoid", code: er.invalid_string, message: y.message }), u.dirty());
        else if (y.kind === "cuid")
            JZ.test(r.data) || (g = this._getOrReturnCtx(r, g), yr(g, { validation: "cuid", code: er.invalid_string, message: y.message }), u.dirty());
        else if (y.kind === "cuid2")
            e7.test(r.data) || (g = this._getOrReturnCtx(r, g), yr(g, { validation: "cuid2", code: er.invalid_string, message: y.message }), u.dirty());
        else if (y.kind === "ulid")
            t7.test(r.data) || (g = this._getOrReturnCtx(r, g), yr(g, { validation: "ulid", code: er.invalid_string, message: y.message }), u.dirty());
        else if (y.kind === "url")
            try {
                new URL(r.data);
            }
            catch {
                g = this._getOrReturnCtx(r, g), yr(g, { validation: "url", code: er.invalid_string, message: y.message }), u.dirty();
            }
        else
            y.kind === "regex" ? (y.regex.lastIndex = 0, y.regex.test(r.data) || (g = this._getOrReturnCtx(r, g), yr(g, { validation: "regex", code: er.invalid_string, message: y.message }), u.dirty())) : y.kind === "trim" ? r.data = r.data.trim() : y.kind === "includes" ? r.data.includes(y.value, y.position) || (g = this._getOrReturnCtx(r, g), yr(g, { code: er.invalid_string, validation: { includes: y.value, position: y.position }, message: y.message }), u.dirty()) : y.kind === "toLowerCase" ? r.data = r.data.toLowerCase() : y.kind === "toUpperCase" ? r.data = r.data.toUpperCase() : y.kind === "startsWith" ? r.data.startsWith(y.value) || (g = this._getOrReturnCtx(r, g), yr(g, { code: er.invalid_string, validation: { startsWith: y.value }, message: y.message }), u.dirty()) : y.kind === "endsWith" ? r.data.endsWith(y.value) || (g = this._getOrReturnCtx(r, g), yr(g, { code: er.invalid_string, validation: { endsWith: y.value }, message: y.message }), u.dirty()) : y.kind === "datetime" ? YN(y).test(r.data) || (g = this._getOrReturnCtx(r, g), yr(g, { code: er.invalid_string, validation: "datetime", message: y.message }), u.dirty()) : y.kind === "date" ? p7.test(r.data) || (g = this._getOrReturnCtx(r, g), yr(g, { code: er.invalid_string, validation: "date", message: y.message }), u.dirty()) : y.kind === "time" ? m7(y).test(r.data) || (g = this._getOrReturnCtx(r, g), yr(g, { code: er.invalid_string, validation: "time", message: y.message }), u.dirty()) : y.kind === "duration" ? s7.test(r.data) || (g = this._getOrReturnCtx(r, g), yr(g, { validation: "duration", code: er.invalid_string, message: y.message }), u.dirty()) : y.kind === "ip" ? g7(r.data, y.version) || (g = this._getOrReturnCtx(r, g), yr(g, { validation: "ip", code: er.invalid_string, message: y.message }), u.dirty()) : y.kind === "jwt" ? _7(r.data, y.alg) || (g = this._getOrReturnCtx(r, g), yr(g, { validation: "jwt", code: er.invalid_string, message: y.message }), u.dirty()) : y.kind === "cidr" ? y7(r.data, y.version) || (g = this._getOrReturnCtx(r, g), yr(g, { validation: "cidr", code: er.invalid_string, message: y.message }), u.dirty()) : y.kind === "base64" ? d7.test(r.data) || (g = this._getOrReturnCtx(r, g), yr(g, { validation: "base64", code: er.invalid_string, message: y.message }), u.dirty()) : y.kind === "base64url" ? f7.test(r.data) || (g = this._getOrReturnCtx(r, g), yr(g, { validation: "base64url", code: er.invalid_string, message: y.message }), u.dirty()) : ui.assertNever(y); return { status: u.value, value: r.data }; }
    _regex(r, o, u) { return this.refinement(g => r.test(g), { validation: o, code: er.invalid_string, ...Gr.errToObj(u) }); }
    _addCheck(r) { return new gl({ ...this._def, checks: [...this._def.checks, r] }); }
    email(r) { return this._addCheck({ kind: "email", ...Gr.errToObj(r) }); }
    url(r) { return this._addCheck({ kind: "url", ...Gr.errToObj(r) }); }
    emoji(r) { return this._addCheck({ kind: "emoji", ...Gr.errToObj(r) }); }
    uuid(r) { return this._addCheck({ kind: "uuid", ...Gr.errToObj(r) }); }
    nanoid(r) { return this._addCheck({ kind: "nanoid", ...Gr.errToObj(r) }); }
    cuid(r) { return this._addCheck({ kind: "cuid", ...Gr.errToObj(r) }); }
    cuid2(r) { return this._addCheck({ kind: "cuid2", ...Gr.errToObj(r) }); }
    ulid(r) { return this._addCheck({ kind: "ulid", ...Gr.errToObj(r) }); }
    base64(r) { return this._addCheck({ kind: "base64", ...Gr.errToObj(r) }); }
    base64url(r) { return this._addCheck({ kind: "base64url", ...Gr.errToObj(r) }); }
    jwt(r) { return this._addCheck({ kind: "jwt", ...Gr.errToObj(r) }); }
    ip(r) { return this._addCheck({ kind: "ip", ...Gr.errToObj(r) }); }
    cidr(r) { return this._addCheck({ kind: "cidr", ...Gr.errToObj(r) }); }
    datetime(r) { var o, u; return typeof r == "string" ? this._addCheck({ kind: "datetime", precision: null, offset: !1, local: !1, message: r }) : this._addCheck({ kind: "datetime", precision: typeof (r == null ? void 0 : r.precision) > "u" ? null : r == null ? void 0 : r.precision, offset: (o = r == null ? void 0 : r.offset) !== null && o !== void 0 ? o : !1, local: (u = r == null ? void 0 : r.local) !== null && u !== void 0 ? u : !1, ...Gr.errToObj(r == null ? void 0 : r.message) }); }
    date(r) { return this._addCheck({ kind: "date", message: r }); }
    time(r) { return typeof r == "string" ? this._addCheck({ kind: "time", precision: null, message: r }) : this._addCheck({ kind: "time", precision: typeof (r == null ? void 0 : r.precision) > "u" ? null : r == null ? void 0 : r.precision, ...Gr.errToObj(r == null ? void 0 : r.message) }); }
    duration(r) { return this._addCheck({ kind: "duration", ...Gr.errToObj(r) }); }
    regex(r, o) { return this._addCheck({ kind: "regex", regex: r, ...Gr.errToObj(o) }); }
    includes(r, o) { return this._addCheck({ kind: "includes", value: r, position: o == null ? void 0 : o.position, ...Gr.errToObj(o == null ? void 0 : o.message) }); }
    startsWith(r, o) { return this._addCheck({ kind: "startsWith", value: r, ...Gr.errToObj(o) }); }
    endsWith(r, o) { return this._addCheck({ kind: "endsWith", value: r, ...Gr.errToObj(o) }); }
    min(r, o) { return this._addCheck({ kind: "min", value: r, ...Gr.errToObj(o) }); }
    max(r, o) { return this._addCheck({ kind: "max", value: r, ...Gr.errToObj(o) }); }
    length(r, o) { return this._addCheck({ kind: "length", value: r, ...Gr.errToObj(o) }); }
    nonempty(r) { return this.min(1, Gr.errToObj(r)); }
    trim() { return new gl({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] }); }
    toLowerCase() { return new gl({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] }); }
    toUpperCase() { return new gl({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] }); }
    get isDatetime() { return !!this._def.checks.find(r => r.kind === "datetime"); }
    get isDate() { return !!this._def.checks.find(r => r.kind === "date"); }
    get isTime() { return !!this._def.checks.find(r => r.kind === "time"); }
    get isDuration() { return !!this._def.checks.find(r => r.kind === "duration"); }
    get isEmail() { return !!this._def.checks.find(r => r.kind === "email"); }
    get isURL() { return !!this._def.checks.find(r => r.kind === "url"); }
    get isEmoji() { return !!this._def.checks.find(r => r.kind === "emoji"); }
    get isUUID() { return !!this._def.checks.find(r => r.kind === "uuid"); }
    get isNANOID() { return !!this._def.checks.find(r => r.kind === "nanoid"); }
    get isCUID() { return !!this._def.checks.find(r => r.kind === "cuid"); }
    get isCUID2() { return !!this._def.checks.find(r => r.kind === "cuid2"); }
    get isULID() { return !!this._def.checks.find(r => r.kind === "ulid"); }
    get isIP() { return !!this._def.checks.find(r => r.kind === "ip"); }
    get isCIDR() { return !!this._def.checks.find(r => r.kind === "cidr"); }
    get isBase64() { return !!this._def.checks.find(r => r.kind === "base64"); }
    get isBase64url() { return !!this._def.checks.find(r => r.kind === "base64url"); }
    get minLength() { let r = null; for (const o of this._def.checks)
        o.kind === "min" && (r === null || o.value > r) && (r = o.value); return r; }
    get maxLength() { let r = null; for (const o of this._def.checks)
        o.kind === "max" && (r === null || o.value < r) && (r = o.value); return r; }
}
gl.create = t => { var r; return new gl({ checks: [], typeName: on.ZodString, coerce: (r = t == null ? void 0 : t.coerce) !== null && r !== void 0 ? r : !1, ...Cn(t) }); };
function v7(t, r) { const o = (t.toString().split(".")[1] || "").length, u = (r.toString().split(".")[1] || "").length, g = o > u ? o : u, y = parseInt(t.toFixed(g).replace(".", "")), E = parseInt(r.toFixed(g).replace(".", "")); return y % E / Math.pow(10, g); }
class Kh extends Bn {
    constructor() { super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf; }
    _parse(r) { if (this._def.coerce && (r.data = Number(r.data)), this._getType(r) !== Er.number) {
        const y = this._getOrReturnCtx(r);
        return yr(y, { code: er.invalid_type, expected: Er.number, received: y.parsedType }), cn;
    } let u; const g = new fo; for (const y of this._def.checks)
        y.kind === "int" ? ui.isInteger(r.data) || (u = this._getOrReturnCtx(r, u), yr(u, { code: er.invalid_type, expected: "integer", received: "float", message: y.message }), g.dirty()) : y.kind === "min" ? (y.inclusive ? r.data < y.value : r.data <= y.value) && (u = this._getOrReturnCtx(r, u), yr(u, { code: er.too_small, minimum: y.value, type: "number", inclusive: y.inclusive, exact: !1, message: y.message }), g.dirty()) : y.kind === "max" ? (y.inclusive ? r.data > y.value : r.data >= y.value) && (u = this._getOrReturnCtx(r, u), yr(u, { code: er.too_big, maximum: y.value, type: "number", inclusive: y.inclusive, exact: !1, message: y.message }), g.dirty()) : y.kind === "multipleOf" ? v7(r.data, y.value) !== 0 && (u = this._getOrReturnCtx(r, u), yr(u, { code: er.not_multiple_of, multipleOf: y.value, message: y.message }), g.dirty()) : y.kind === "finite" ? Number.isFinite(r.data) || (u = this._getOrReturnCtx(r, u), yr(u, { code: er.not_finite, message: y.message }), g.dirty()) : ui.assertNever(y); return { status: g.value, value: r.data }; }
    gte(r, o) { return this.setLimit("min", r, !0, Gr.toString(o)); }
    gt(r, o) { return this.setLimit("min", r, !1, Gr.toString(o)); }
    lte(r, o) { return this.setLimit("max", r, !0, Gr.toString(o)); }
    lt(r, o) { return this.setLimit("max", r, !1, Gr.toString(o)); }
    setLimit(r, o, u, g) { return new Kh({ ...this._def, checks: [...this._def.checks, { kind: r, value: o, inclusive: u, message: Gr.toString(g) }] }); }
    _addCheck(r) { return new Kh({ ...this._def, checks: [...this._def.checks, r] }); }
    int(r) { return this._addCheck({ kind: "int", message: Gr.toString(r) }); }
    positive(r) { return this._addCheck({ kind: "min", value: 0, inclusive: !1, message: Gr.toString(r) }); }
    negative(r) { return this._addCheck({ kind: "max", value: 0, inclusive: !1, message: Gr.toString(r) }); }
    nonpositive(r) { return this._addCheck({ kind: "max", value: 0, inclusive: !0, message: Gr.toString(r) }); }
    nonnegative(r) { return this._addCheck({ kind: "min", value: 0, inclusive: !0, message: Gr.toString(r) }); }
    multipleOf(r, o) { return this._addCheck({ kind: "multipleOf", value: r, message: Gr.toString(o) }); }
    finite(r) { return this._addCheck({ kind: "finite", message: Gr.toString(r) }); }
    safe(r) { return this._addCheck({ kind: "min", inclusive: !0, value: Number.MIN_SAFE_INTEGER, message: Gr.toString(r) })._addCheck({ kind: "max", inclusive: !0, value: Number.MAX_SAFE_INTEGER, message: Gr.toString(r) }); }
    get minValue() { let r = null; for (const o of this._def.checks)
        o.kind === "min" && (r === null || o.value > r) && (r = o.value); return r; }
    get maxValue() { let r = null; for (const o of this._def.checks)
        o.kind === "max" && (r === null || o.value < r) && (r = o.value); return r; }
    get isInt() { return !!this._def.checks.find(r => r.kind === "int" || r.kind === "multipleOf" && ui.isInteger(r.value)); }
    get isFinite() { let r = null, o = null; for (const u of this._def.checks) {
        if (u.kind === "finite" || u.kind === "int" || u.kind === "multipleOf")
            return !0;
        u.kind === "min" ? (o === null || u.value > o) && (o = u.value) : u.kind === "max" && (r === null || u.value < r) && (r = u.value);
    } return Number.isFinite(o) && Number.isFinite(r); }
}
Kh.create = t => new Kh({ checks: [], typeName: on.ZodNumber, coerce: (t == null ? void 0 : t.coerce) || !1, ...Cn(t) });
class Yh extends Bn {
    constructor() { super(...arguments), this.min = this.gte, this.max = this.lte; }
    _parse(r) { if (this._def.coerce)
        try {
            r.data = BigInt(r.data);
        }
        catch {
            return this._getInvalidInput(r);
        } if (this._getType(r) !== Er.bigint)
        return this._getInvalidInput(r); let u; const g = new fo; for (const y of this._def.checks)
        y.kind === "min" ? (y.inclusive ? r.data < y.value : r.data <= y.value) && (u = this._getOrReturnCtx(r, u), yr(u, { code: er.too_small, type: "bigint", minimum: y.value, inclusive: y.inclusive, message: y.message }), g.dirty()) : y.kind === "max" ? (y.inclusive ? r.data > y.value : r.data >= y.value) && (u = this._getOrReturnCtx(r, u), yr(u, { code: er.too_big, type: "bigint", maximum: y.value, inclusive: y.inclusive, message: y.message }), g.dirty()) : y.kind === "multipleOf" ? r.data % y.value !== BigInt(0) && (u = this._getOrReturnCtx(r, u), yr(u, { code: er.not_multiple_of, multipleOf: y.value, message: y.message }), g.dirty()) : ui.assertNever(y); return { status: g.value, value: r.data }; }
    _getInvalidInput(r) { const o = this._getOrReturnCtx(r); return yr(o, { code: er.invalid_type, expected: Er.bigint, received: o.parsedType }), cn; }
    gte(r, o) { return this.setLimit("min", r, !0, Gr.toString(o)); }
    gt(r, o) { return this.setLimit("min", r, !1, Gr.toString(o)); }
    lte(r, o) { return this.setLimit("max", r, !0, Gr.toString(o)); }
    lt(r, o) { return this.setLimit("max", r, !1, Gr.toString(o)); }
    setLimit(r, o, u, g) { return new Yh({ ...this._def, checks: [...this._def.checks, { kind: r, value: o, inclusive: u, message: Gr.toString(g) }] }); }
    _addCheck(r) { return new Yh({ ...this._def, checks: [...this._def.checks, r] }); }
    positive(r) { return this._addCheck({ kind: "min", value: BigInt(0), inclusive: !1, message: Gr.toString(r) }); }
    negative(r) { return this._addCheck({ kind: "max", value: BigInt(0), inclusive: !1, message: Gr.toString(r) }); }
    nonpositive(r) { return this._addCheck({ kind: "max", value: BigInt(0), inclusive: !0, message: Gr.toString(r) }); }
    nonnegative(r) { return this._addCheck({ kind: "min", value: BigInt(0), inclusive: !0, message: Gr.toString(r) }); }
    multipleOf(r, o) { return this._addCheck({ kind: "multipleOf", value: r, message: Gr.toString(o) }); }
    get minValue() { let r = null; for (const o of this._def.checks)
        o.kind === "min" && (r === null || o.value > r) && (r = o.value); return r; }
    get maxValue() { let r = null; for (const o of this._def.checks)
        o.kind === "max" && (r === null || o.value < r) && (r = o.value); return r; }
}
Yh.create = t => { var r; return new Yh({ checks: [], typeName: on.ZodBigInt, coerce: (r = t == null ? void 0 : t.coerce) !== null && r !== void 0 ? r : !1, ...Cn(t) }); };
class kv extends Bn {
    _parse(r) { if (this._def.coerce && (r.data = !!r.data), this._getType(r) !== Er.boolean) {
        const u = this._getOrReturnCtx(r);
        return yr(u, { code: er.invalid_type, expected: Er.boolean, received: u.parsedType }), cn;
    } return So(r.data); }
}
kv.create = t => new kv({ typeName: on.ZodBoolean, coerce: (t == null ? void 0 : t.coerce) || !1, ...Cn(t) });
class Of extends Bn {
    _parse(r) { if (this._def.coerce && (r.data = new Date(r.data)), this._getType(r) !== Er.date) {
        const y = this._getOrReturnCtx(r);
        return yr(y, { code: er.invalid_type, expected: Er.date, received: y.parsedType }), cn;
    } if (isNaN(r.data.getTime())) {
        const y = this._getOrReturnCtx(r);
        return yr(y, { code: er.invalid_date }), cn;
    } const u = new fo; let g; for (const y of this._def.checks)
        y.kind === "min" ? r.data.getTime() < y.value && (g = this._getOrReturnCtx(r, g), yr(g, { code: er.too_small, message: y.message, inclusive: !0, exact: !1, minimum: y.value, type: "date" }), u.dirty()) : y.kind === "max" ? r.data.getTime() > y.value && (g = this._getOrReturnCtx(r, g), yr(g, { code: er.too_big, message: y.message, inclusive: !0, exact: !1, maximum: y.value, type: "date" }), u.dirty()) : ui.assertNever(y); return { status: u.value, value: new Date(r.data.getTime()) }; }
    _addCheck(r) { return new Of({ ...this._def, checks: [...this._def.checks, r] }); }
    min(r, o) { return this._addCheck({ kind: "min", value: r.getTime(), message: Gr.toString(o) }); }
    max(r, o) { return this._addCheck({ kind: "max", value: r.getTime(), message: Gr.toString(o) }); }
    get minDate() { let r = null; for (const o of this._def.checks)
        o.kind === "min" && (r === null || o.value > r) && (r = o.value); return r != null ? new Date(r) : null; }
    get maxDate() { let r = null; for (const o of this._def.checks)
        o.kind === "max" && (r === null || o.value < r) && (r = o.value); return r != null ? new Date(r) : null; }
}
Of.create = t => new Of({ checks: [], coerce: (t == null ? void 0 : t.coerce) || !1, typeName: on.ZodDate, ...Cn(t) });
class Vw extends Bn {
    _parse(r) { if (this._getType(r) !== Er.symbol) {
        const u = this._getOrReturnCtx(r);
        return yr(u, { code: er.invalid_type, expected: Er.symbol, received: u.parsedType }), cn;
    } return So(r.data); }
}
Vw.create = t => new Vw({ typeName: on.ZodSymbol, ...Cn(t) });
class Dv extends Bn {
    _parse(r) { if (this._getType(r) !== Er.undefined) {
        const u = this._getOrReturnCtx(r);
        return yr(u, { code: er.invalid_type, expected: Er.undefined, received: u.parsedType }), cn;
    } return So(r.data); }
}
Dv.create = t => new Dv({ typeName: on.ZodUndefined, ...Cn(t) });
class Lv extends Bn {
    _parse(r) { if (this._getType(r) !== Er.null) {
        const u = this._getOrReturnCtx(r);
        return yr(u, { code: er.invalid_type, expected: Er.null, received: u.parsedType }), cn;
    } return So(r.data); }
}
Lv.create = t => new Lv({ typeName: on.ZodNull, ...Cn(t) });
class vg extends Bn {
    constructor() { super(...arguments), this._any = !0; }
    _parse(r) { return So(r.data); }
}
vg.create = t => new vg({ typeName: on.ZodAny, ...Cn(t) });
class Ef extends Bn {
    constructor() { super(...arguments), this._unknown = !0; }
    _parse(r) { return So(r.data); }
}
Ef.create = t => new Ef({ typeName: on.ZodUnknown, ...Cn(t) });
class hu extends Bn {
    _parse(r) { const o = this._getOrReturnCtx(r); return yr(o, { code: er.invalid_type, expected: Er.never, received: o.parsedType }), cn; }
}
hu.create = t => new hu({ typeName: on.ZodNever, ...Cn(t) });
class Uw extends Bn {
    _parse(r) { if (this._getType(r) !== Er.undefined) {
        const u = this._getOrReturnCtx(r);
        return yr(u, { code: er.invalid_type, expected: Er.void, received: u.parsedType }), cn;
    } return So(r.data); }
}
Uw.create = t => new Uw({ typeName: on.ZodVoid, ...Cn(t) });
class vl extends Bn {
    _parse(r) { const { ctx: o, status: u } = this._processInputParams(r), g = this._def; if (o.parsedType !== Er.array)
        return yr(o, { code: er.invalid_type, expected: Er.array, received: o.parsedType }), cn; if (g.exactLength !== null) {
        const E = o.data.length > g.exactLength.value, s = o.data.length < g.exactLength.value;
        (E || s) && (yr(o, { code: E ? er.too_big : er.too_small, minimum: s ? g.exactLength.value : void 0, maximum: E ? g.exactLength.value : void 0, type: "array", inclusive: !0, exact: !0, message: g.exactLength.message }), u.dirty());
    } if (g.minLength !== null && o.data.length < g.minLength.value && (yr(o, { code: er.too_small, minimum: g.minLength.value, type: "array", inclusive: !0, exact: !1, message: g.minLength.message }), u.dirty()), g.maxLength !== null && o.data.length > g.maxLength.value && (yr(o, { code: er.too_big, maximum: g.maxLength.value, type: "array", inclusive: !0, exact: !1, message: g.maxLength.message }), u.dirty()), o.common.async)
        return Promise.all([...o.data].map((E, s) => g.type._parseAsync(new hc(o, E, o.path, s)))).then(E => fo.mergeArray(u, E)); const y = [...o.data].map((E, s) => g.type._parseSync(new hc(o, E, o.path, s))); return fo.mergeArray(u, y); }
    get element() { return this._def.type; }
    min(r, o) { return new vl({ ...this._def, minLength: { value: r, message: Gr.toString(o) } }); }
    max(r, o) { return new vl({ ...this._def, maxLength: { value: r, message: Gr.toString(o) } }); }
    length(r, o) { return new vl({ ...this._def, exactLength: { value: r, message: Gr.toString(o) } }); }
    nonempty(r) { return this.min(1, r); }
}
vl.create = (t, r) => new vl({ type: t, minLength: null, maxLength: null, exactLength: null, typeName: on.ZodArray, ...Cn(r) });
function vm(t) { if (t instanceof Xi) {
    const r = {};
    for (const o in t.shape) {
        const u = t.shape[o];
        r[o] = cc.create(vm(u));
    }
    return new Xi({ ...t._def, shape: () => r });
}
else
    return t instanceof vl ? new vl({ ...t._def, type: vm(t.element) }) : t instanceof cc ? cc.create(vm(t.unwrap())) : t instanceof Jh ? Jh.create(vm(t.unwrap())) : t instanceof dc ? dc.create(t.items.map(r => vm(r))) : t; }
class Xi extends Bn {
    constructor() { super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend; }
    _getCached() { if (this._cached !== null)
        return this._cached; const r = this._def.shape(), o = ui.objectKeys(r); return this._cached = { shape: r, keys: o }; }
    _parse(r) { if (this._getType(r) !== Er.object) {
        const L = this._getOrReturnCtx(r);
        return yr(L, { code: er.invalid_type, expected: Er.object, received: L.parsedType }), cn;
    } const { status: u, ctx: g } = this._processInputParams(r), { shape: y, keys: E } = this._getCached(), s = []; if (!(this._def.catchall instanceof hu && this._def.unknownKeys === "strip"))
        for (const L in g.data)
            E.includes(L) || s.push(L); const k = []; for (const L of E) {
        const N = y[L], V = g.data[L];
        k.push({ key: { status: "valid", value: L }, value: N._parse(new hc(g, V, g.path, L)), alwaysSet: L in g.data });
    } if (this._def.catchall instanceof hu) {
        const L = this._def.unknownKeys;
        if (L === "passthrough")
            for (const N of s)
                k.push({ key: { status: "valid", value: N }, value: { status: "valid", value: g.data[N] } });
        else if (L === "strict")
            s.length > 0 && (yr(g, { code: er.unrecognized_keys, keys: s }), u.dirty());
        else if (L !== "strip")
            throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    }
    else {
        const L = this._def.catchall;
        for (const N of s) {
            const V = g.data[N];
            k.push({ key: { status: "valid", value: N }, value: L._parse(new hc(g, V, g.path, N)), alwaysSet: N in g.data });
        }
    } return g.common.async ? Promise.resolve().then(async () => { const L = []; for (const N of k) {
        const V = await N.key, H = await N.value;
        L.push({ key: V, value: H, alwaysSet: N.alwaysSet });
    } return L; }).then(L => fo.mergeObjectSync(u, L)) : fo.mergeObjectSync(u, k); }
    get shape() { return this._def.shape(); }
    strict(r) { return Gr.errToObj, new Xi({ ...this._def, unknownKeys: "strict", ...r !== void 0 ? { errorMap: (o, u) => { var g, y, E, s; const k = (E = (y = (g = this._def).errorMap) === null || y === void 0 ? void 0 : y.call(g, o, u).message) !== null && E !== void 0 ? E : u.defaultError; return o.code === "unrecognized_keys" ? { message: (s = Gr.errToObj(r).message) !== null && s !== void 0 ? s : k } : { message: k }; } } : {} }); }
    strip() { return new Xi({ ...this._def, unknownKeys: "strip" }); }
    passthrough() { return new Xi({ ...this._def, unknownKeys: "passthrough" }); }
    extend(r) { return new Xi({ ...this._def, shape: () => ({ ...this._def.shape(), ...r }) }); }
    merge(r) { return new Xi({ unknownKeys: r._def.unknownKeys, catchall: r._def.catchall, shape: () => ({ ...this._def.shape(), ...r._def.shape() }), typeName: on.ZodObject }); }
    setKey(r, o) { return this.augment({ [r]: o }); }
    catchall(r) { return new Xi({ ...this._def, catchall: r }); }
    pick(r) { const o = {}; return ui.objectKeys(r).forEach(u => { r[u] && this.shape[u] && (o[u] = this.shape[u]); }), new Xi({ ...this._def, shape: () => o }); }
    omit(r) { const o = {}; return ui.objectKeys(this.shape).forEach(u => { r[u] || (o[u] = this.shape[u]); }), new Xi({ ...this._def, shape: () => o }); }
    deepPartial() { return vm(this); }
    partial(r) { const o = {}; return ui.objectKeys(this.shape).forEach(u => { const g = this.shape[u]; r && !r[u] ? o[u] = g : o[u] = g.optional(); }), new Xi({ ...this._def, shape: () => o }); }
    required(r) { const o = {}; return ui.objectKeys(this.shape).forEach(u => { if (r && !r[u])
        o[u] = this.shape[u];
    else {
        let y = this.shape[u];
        for (; y instanceof cc;)
            y = y._def.innerType;
        o[u] = y;
    } }), new Xi({ ...this._def, shape: () => o }); }
    keyof() { return QN(ui.objectKeys(this.shape)); }
}
Xi.create = (t, r) => new Xi({ shape: () => t, unknownKeys: "strip", catchall: hu.create(), typeName: on.ZodObject, ...Cn(r) });
Xi.strictCreate = (t, r) => new Xi({ shape: () => t, unknownKeys: "strict", catchall: hu.create(), typeName: on.ZodObject, ...Cn(r) });
Xi.lazycreate = (t, r) => new Xi({ shape: t, unknownKeys: "strip", catchall: hu.create(), typeName: on.ZodObject, ...Cn(r) });
class Ov extends Bn {
    _parse(r) { const { ctx: o } = this._processInputParams(r), u = this._def.options; function g(y) { for (const s of y)
        if (s.result.status === "valid")
            return s.result; for (const s of y)
        if (s.result.status === "dirty")
            return o.common.issues.push(...s.ctx.common.issues), s.result; const E = y.map(s => new ga(s.ctx.common.issues)); return yr(o, { code: er.invalid_union, unionErrors: E }), cn; } if (o.common.async)
        return Promise.all(u.map(async (y) => { const E = { ...o, common: { ...o.common, issues: [] }, parent: null }; return { result: await y._parseAsync({ data: o.data, path: o.path, parent: E }), ctx: E }; })).then(g); {
        let y;
        const E = [];
        for (const k of u) {
            const L = { ...o, common: { ...o.common, issues: [] }, parent: null }, N = k._parseSync({ data: o.data, path: o.path, parent: L });
            if (N.status === "valid")
                return N;
            N.status === "dirty" && !y && (y = { result: N, ctx: L }), L.common.issues.length && E.push(L.common.issues);
        }
        if (y)
            return o.common.issues.push(...y.ctx.common.issues), y.result;
        const s = E.map(k => new ga(k));
        return yr(o, { code: er.invalid_union, unionErrors: s }), cn;
    } }
    get options() { return this._def.options; }
}
Ov.create = (t, r) => new Ov({ options: t, typeName: on.ZodUnion, ...Cn(r) });
const Xc = t => t instanceof Nv ? Xc(t.schema) : t instanceof Tl ? Xc(t.innerType()) : t instanceof Bv ? [t.value] : t instanceof Qh ? t.options : t instanceof jv ? ui.objectValues(t.enum) : t instanceof Vv ? Xc(t._def.innerType) : t instanceof Dv ? [void 0] : t instanceof Lv ? [null] : t instanceof cc ? [void 0, ...Xc(t.unwrap())] : t instanceof Jh ? [null, ...Xc(t.unwrap())] : t instanceof JA || t instanceof $v ? Xc(t.unwrap()) : t instanceof Uv ? Xc(t._def.innerType) : [];
class Ob extends Bn {
    _parse(r) { const { ctx: o } = this._processInputParams(r); if (o.parsedType !== Er.object)
        return yr(o, { code: er.invalid_type, expected: Er.object, received: o.parsedType }), cn; const u = this.discriminator, g = o.data[u], y = this.optionsMap.get(g); return y ? o.common.async ? y._parseAsync({ data: o.data, path: o.path, parent: o }) : y._parseSync({ data: o.data, path: o.path, parent: o }) : (yr(o, { code: er.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [u] }), cn); }
    get discriminator() { return this._def.discriminator; }
    get options() { return this._def.options; }
    get optionsMap() { return this._def.optionsMap; }
    static create(r, o, u) { const g = new Map; for (const y of o) {
        const E = Xc(y.shape[r]);
        if (!E.length)
            throw new Error(`A discriminator value for key \`${r}\` could not be extracted from all schema options`);
        for (const s of E) {
            if (g.has(s))
                throw new Error(`Discriminator property ${String(r)} has duplicate value ${String(s)}`);
            g.set(s, y);
        }
    } return new Ob({ typeName: on.ZodDiscriminatedUnion, discriminator: r, options: o, optionsMap: g, ...Cn(u) }); }
}
function _C(t, r) { const o = Jc(t), u = Jc(r); if (t === r)
    return { valid: !0, data: t }; if (o === Er.object && u === Er.object) {
    const g = ui.objectKeys(r), y = ui.objectKeys(t).filter(s => g.indexOf(s) !== -1), E = { ...t, ...r };
    for (const s of y) {
        const k = _C(t[s], r[s]);
        if (!k.valid)
            return { valid: !1 };
        E[s] = k.data;
    }
    return { valid: !0, data: E };
}
else if (o === Er.array && u === Er.array) {
    if (t.length !== r.length)
        return { valid: !1 };
    const g = [];
    for (let y = 0; y < t.length; y++) {
        const E = t[y], s = r[y], k = _C(E, s);
        if (!k.valid)
            return { valid: !1 };
        g.push(k.data);
    }
    return { valid: !0, data: g };
}
else
    return o === Er.date && u === Er.date && +t == +r ? { valid: !0, data: t } : { valid: !1 }; }
class zv extends Bn {
    _parse(r) { const { status: o, ctx: u } = this._processInputParams(r), g = (y, E) => { if (mC(y) || mC(E))
        return cn; const s = _C(y.value, E.value); return s.valid ? ((gC(y) || gC(E)) && o.dirty(), { status: o.value, value: s.data }) : (yr(u, { code: er.invalid_intersection_types }), cn); }; return u.common.async ? Promise.all([this._def.left._parseAsync({ data: u.data, path: u.path, parent: u }), this._def.right._parseAsync({ data: u.data, path: u.path, parent: u })]).then(([y, E]) => g(y, E)) : g(this._def.left._parseSync({ data: u.data, path: u.path, parent: u }), this._def.right._parseSync({ data: u.data, path: u.path, parent: u })); }
}
zv.create = (t, r, o) => new zv({ left: t, right: r, typeName: on.ZodIntersection, ...Cn(o) });
class dc extends Bn {
    _parse(r) { const { status: o, ctx: u } = this._processInputParams(r); if (u.parsedType !== Er.array)
        return yr(u, { code: er.invalid_type, expected: Er.array, received: u.parsedType }), cn; if (u.data.length < this._def.items.length)
        return yr(u, { code: er.too_small, minimum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), cn; !this._def.rest && u.data.length > this._def.items.length && (yr(u, { code: er.too_big, maximum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), o.dirty()); const y = [...u.data].map((E, s) => { const k = this._def.items[s] || this._def.rest; return k ? k._parse(new hc(u, E, u.path, s)) : null; }).filter(E => !!E); return u.common.async ? Promise.all(y).then(E => fo.mergeArray(o, E)) : fo.mergeArray(o, y); }
    get items() { return this._def.items; }
    rest(r) { return new dc({ ...this._def, rest: r }); }
}
dc.create = (t, r) => { if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])"); return new dc({ items: t, typeName: on.ZodTuple, rest: null, ...Cn(r) }); };
class Fv extends Bn {
    get keySchema() { return this._def.keyType; }
    get valueSchema() { return this._def.valueType; }
    _parse(r) { const { status: o, ctx: u } = this._processInputParams(r); if (u.parsedType !== Er.object)
        return yr(u, { code: er.invalid_type, expected: Er.object, received: u.parsedType }), cn; const g = [], y = this._def.keyType, E = this._def.valueType; for (const s in u.data)
        g.push({ key: y._parse(new hc(u, s, u.path, s)), value: E._parse(new hc(u, u.data[s], u.path, s)), alwaysSet: s in u.data }); return u.common.async ? fo.mergeObjectAsync(o, g) : fo.mergeObjectSync(o, g); }
    get element() { return this._def.valueType; }
    static create(r, o, u) { return o instanceof Bn ? new Fv({ keyType: r, valueType: o, typeName: on.ZodRecord, ...Cn(u) }) : new Fv({ keyType: gl.create(), valueType: r, typeName: on.ZodRecord, ...Cn(o) }); }
}
class $w extends Bn {
    get keySchema() { return this._def.keyType; }
    get valueSchema() { return this._def.valueType; }
    _parse(r) { const { status: o, ctx: u } = this._processInputParams(r); if (u.parsedType !== Er.map)
        return yr(u, { code: er.invalid_type, expected: Er.map, received: u.parsedType }), cn; const g = this._def.keyType, y = this._def.valueType, E = [...u.data.entries()].map(([s, k], L) => ({ key: g._parse(new hc(u, s, u.path, [L, "key"])), value: y._parse(new hc(u, k, u.path, [L, "value"])) })); if (u.common.async) {
        const s = new Map;
        return Promise.resolve().then(async () => { for (const k of E) {
            const L = await k.key, N = await k.value;
            if (L.status === "aborted" || N.status === "aborted")
                return cn;
            (L.status === "dirty" || N.status === "dirty") && o.dirty(), s.set(L.value, N.value);
        } return { status: o.value, value: s }; });
    }
    else {
        const s = new Map;
        for (const k of E) {
            const L = k.key, N = k.value;
            if (L.status === "aborted" || N.status === "aborted")
                return cn;
            (L.status === "dirty" || N.status === "dirty") && o.dirty(), s.set(L.value, N.value);
        }
        return { status: o.value, value: s };
    } }
}
$w.create = (t, r, o) => new $w({ valueType: r, keyType: t, typeName: on.ZodMap, ...Cn(o) });
class zf extends Bn {
    _parse(r) { const { status: o, ctx: u } = this._processInputParams(r); if (u.parsedType !== Er.set)
        return yr(u, { code: er.invalid_type, expected: Er.set, received: u.parsedType }), cn; const g = this._def; g.minSize !== null && u.data.size < g.minSize.value && (yr(u, { code: er.too_small, minimum: g.minSize.value, type: "set", inclusive: !0, exact: !1, message: g.minSize.message }), o.dirty()), g.maxSize !== null && u.data.size > g.maxSize.value && (yr(u, { code: er.too_big, maximum: g.maxSize.value, type: "set", inclusive: !0, exact: !1, message: g.maxSize.message }), o.dirty()); const y = this._def.valueType; function E(k) { const L = new Set; for (const N of k) {
        if (N.status === "aborted")
            return cn;
        N.status === "dirty" && o.dirty(), L.add(N.value);
    } return { status: o.value, value: L }; } const s = [...u.data.values()].map((k, L) => y._parse(new hc(u, k, u.path, L))); return u.common.async ? Promise.all(s).then(k => E(k)) : E(s); }
    min(r, o) { return new zf({ ...this._def, minSize: { value: r, message: Gr.toString(o) } }); }
    max(r, o) { return new zf({ ...this._def, maxSize: { value: r, message: Gr.toString(o) } }); }
    size(r, o) { return this.min(r, o).max(r, o); }
    nonempty(r) { return this.min(1, r); }
}
zf.create = (t, r) => new zf({ valueType: t, minSize: null, maxSize: null, typeName: on.ZodSet, ...Cn(r) });
class Gm extends Bn {
    constructor() { super(...arguments), this.validate = this.implement; }
    _parse(r) { const { ctx: o } = this._processInputParams(r); if (o.parsedType !== Er.function)
        return yr(o, { code: er.invalid_type, expected: Er.function, received: o.parsedType }), cn; function u(s, k) { return Bw({ data: s, path: o.path, errorMaps: [o.common.contextualErrorMap, o.schemaErrorMap, Nw(), yg].filter(L => !!L), issueData: { code: er.invalid_arguments, argumentsError: k } }); } function g(s, k) { return Bw({ data: s, path: o.path, errorMaps: [o.common.contextualErrorMap, o.schemaErrorMap, Nw(), yg].filter(L => !!L), issueData: { code: er.invalid_return_type, returnTypeError: k } }); } const y = { errorMap: o.common.contextualErrorMap }, E = o.data; if (this._def.returns instanceof xg) {
        const s = this;
        return So(async function (...k) { const L = new ga([]), N = await s._def.args.parseAsync(k, y).catch(ee => { throw L.addIssue(u(k, ee)), L; }), V = await Reflect.apply(E, this, N); return await s._def.returns._def.type.parseAsync(V, y).catch(ee => { throw L.addIssue(g(V, ee)), L; }); });
    }
    else {
        const s = this;
        return So(function (...k) { const L = s._def.args.safeParse(k, y); if (!L.success)
            throw new ga([u(k, L.error)]); const N = Reflect.apply(E, this, L.data), V = s._def.returns.safeParse(N, y); if (!V.success)
            throw new ga([g(N, V.error)]); return V.data; });
    } }
    parameters() { return this._def.args; }
    returnType() { return this._def.returns; }
    args(...r) { return new Gm({ ...this._def, args: dc.create(r).rest(Ef.create()) }); }
    returns(r) { return new Gm({ ...this._def, returns: r }); }
    implement(r) { return this.parse(r); }
    strictImplement(r) { return this.parse(r); }
    static create(r, o, u) { return new Gm({ args: r || dc.create([]).rest(Ef.create()), returns: o || Ef.create(), typeName: on.ZodFunction, ...Cn(u) }); }
}
class Nv extends Bn {
    get schema() { return this._def.getter(); }
    _parse(r) { const { ctx: o } = this._processInputParams(r); return this._def.getter()._parse({ data: o.data, path: o.path, parent: o }); }
}
Nv.create = (t, r) => new Nv({ getter: t, typeName: on.ZodLazy, ...Cn(r) });
class Bv extends Bn {
    _parse(r) { if (r.data !== this._def.value) {
        const o = this._getOrReturnCtx(r);
        return yr(o, { received: o.data, code: er.invalid_literal, expected: this._def.value }), cn;
    } return { status: "valid", value: r.data }; }
    get value() { return this._def.value; }
}
Bv.create = (t, r) => new Bv({ value: t, typeName: on.ZodLiteral, ...Cn(r) });
function QN(t, r) { return new Qh({ values: t, typeName: on.ZodEnum, ...Cn(r) }); }
class Qh extends Bn {
    constructor() { super(...arguments), Gy.set(this, void 0); }
    _parse(r) { if (typeof r.data != "string") {
        const o = this._getOrReturnCtx(r), u = this._def.values;
        return yr(o, { expected: ui.joinValues(u), received: o.parsedType, code: er.invalid_type }), cn;
    } if (jw(this, Gy) || ZN(this, Gy, new Set(this._def.values)), !jw(this, Gy).has(r.data)) {
        const o = this._getOrReturnCtx(r), u = this._def.values;
        return yr(o, { received: o.data, code: er.invalid_enum_value, options: u }), cn;
    } return So(r.data); }
    get options() { return this._def.values; }
    get enum() { const r = {}; for (const o of this._def.values)
        r[o] = o; return r; }
    get Values() { const r = {}; for (const o of this._def.values)
        r[o] = o; return r; }
    get Enum() { const r = {}; for (const o of this._def.values)
        r[o] = o; return r; }
    extract(r, o = this._def) { return Qh.create(r, { ...this._def, ...o }); }
    exclude(r, o = this._def) { return Qh.create(this.options.filter(u => !r.includes(u)), { ...this._def, ...o }); }
}
Gy = new WeakMap;
Qh.create = QN;
class jv extends Bn {
    constructor() { super(...arguments), qy.set(this, void 0); }
    _parse(r) { const o = ui.getValidEnumValues(this._def.values), u = this._getOrReturnCtx(r); if (u.parsedType !== Er.string && u.parsedType !== Er.number) {
        const g = ui.objectValues(o);
        return yr(u, { expected: ui.joinValues(g), received: u.parsedType, code: er.invalid_type }), cn;
    } if (jw(this, qy) || ZN(this, qy, new Set(ui.getValidEnumValues(this._def.values))), !jw(this, qy).has(r.data)) {
        const g = ui.objectValues(o);
        return yr(u, { received: u.data, code: er.invalid_enum_value, options: g }), cn;
    } return So(r.data); }
    get enum() { return this._def.values; }
}
qy = new WeakMap;
jv.create = (t, r) => new jv({ values: t, typeName: on.ZodNativeEnum, ...Cn(r) });
class xg extends Bn {
    unwrap() { return this._def.type; }
    _parse(r) { const { ctx: o } = this._processInputParams(r); if (o.parsedType !== Er.promise && o.common.async === !1)
        return yr(o, { code: er.invalid_type, expected: Er.promise, received: o.parsedType }), cn; const u = o.parsedType === Er.promise ? o.data : Promise.resolve(o.data); return So(u.then(g => this._def.type.parseAsync(g, { path: o.path, errorMap: o.common.contextualErrorMap }))); }
}
xg.create = (t, r) => new xg({ type: t, typeName: on.ZodPromise, ...Cn(r) });
class Tl extends Bn {
    innerType() { return this._def.schema; }
    sourceType() { return this._def.schema._def.typeName === on.ZodEffects ? this._def.schema.sourceType() : this._def.schema; }
    _parse(r) { const { status: o, ctx: u } = this._processInputParams(r), g = this._def.effect || null, y = { addIssue: E => { yr(u, E), E.fatal ? o.abort() : o.dirty(); }, get path() { return u.path; } }; if (y.addIssue = y.addIssue.bind(y), g.type === "preprocess") {
        const E = g.transform(u.data, y);
        if (u.common.async)
            return Promise.resolve(E).then(async (s) => { if (o.value === "aborted")
                return cn; const k = await this._def.schema._parseAsync({ data: s, path: u.path, parent: u }); return k.status === "aborted" ? cn : k.status === "dirty" || o.value === "dirty" ? km(k.value) : k; });
        {
            if (o.value === "aborted")
                return cn;
            const s = this._def.schema._parseSync({ data: E, path: u.path, parent: u });
            return s.status === "aborted" ? cn : s.status === "dirty" || o.value === "dirty" ? km(s.value) : s;
        }
    } if (g.type === "refinement") {
        const E = s => { const k = g.refinement(s, y); if (u.common.async)
            return Promise.resolve(k); if (k instanceof Promise)
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead."); return s; };
        if (u.common.async === !1) {
            const s = this._def.schema._parseSync({ data: u.data, path: u.path, parent: u });
            return s.status === "aborted" ? cn : (s.status === "dirty" && o.dirty(), E(s.value), { status: o.value, value: s.value });
        }
        else
            return this._def.schema._parseAsync({ data: u.data, path: u.path, parent: u }).then(s => s.status === "aborted" ? cn : (s.status === "dirty" && o.dirty(), E(s.value).then(() => ({ status: o.value, value: s.value }))));
    } if (g.type === "transform")
        if (u.common.async === !1) {
            const E = this._def.schema._parseSync({ data: u.data, path: u.path, parent: u });
            if (!Lf(E))
                return E;
            const s = g.transform(E.value, y);
            if (s instanceof Promise)
                throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
            return { status: o.value, value: s };
        }
        else
            return this._def.schema._parseAsync({ data: u.data, path: u.path, parent: u }).then(E => Lf(E) ? Promise.resolve(g.transform(E.value, y)).then(s => ({ status: o.value, value: s })) : E); ui.assertNever(g); }
}
Tl.create = (t, r, o) => new Tl({ schema: t, typeName: on.ZodEffects, effect: r, ...Cn(o) });
Tl.createWithPreprocess = (t, r, o) => new Tl({ schema: r, effect: { type: "preprocess", transform: t }, typeName: on.ZodEffects, ...Cn(o) });
class cc extends Bn {
    _parse(r) { return this._getType(r) === Er.undefined ? So(void 0) : this._def.innerType._parse(r); }
    unwrap() { return this._def.innerType; }
}
cc.create = (t, r) => new cc({ innerType: t, typeName: on.ZodOptional, ...Cn(r) });
class Jh extends Bn {
    _parse(r) { return this._getType(r) === Er.null ? So(null) : this._def.innerType._parse(r); }
    unwrap() { return this._def.innerType; }
}
Jh.create = (t, r) => new Jh({ innerType: t, typeName: on.ZodNullable, ...Cn(r) });
class Vv extends Bn {
    _parse(r) { const { ctx: o } = this._processInputParams(r); let u = o.data; return o.parsedType === Er.undefined && (u = this._def.defaultValue()), this._def.innerType._parse({ data: u, path: o.path, parent: o }); }
    removeDefault() { return this._def.innerType; }
}
Vv.create = (t, r) => new Vv({ innerType: t, typeName: on.ZodDefault, defaultValue: typeof r.default == "function" ? r.default : () => r.default, ...Cn(r) });
class Uv extends Bn {
    _parse(r) { const { ctx: o } = this._processInputParams(r), u = { ...o, common: { ...o.common, issues: [] } }, g = this._def.innerType._parse({ data: u.data, path: u.path, parent: { ...u } }); return Rv(g) ? g.then(y => ({ status: "valid", value: y.status === "valid" ? y.value : this._def.catchValue({ get error() { return new ga(u.common.issues); }, input: u.data }) })) : { status: "valid", value: g.status === "valid" ? g.value : this._def.catchValue({ get error() { return new ga(u.common.issues); }, input: u.data }) }; }
    removeCatch() { return this._def.innerType; }
}
Uv.create = (t, r) => new Uv({ innerType: t, typeName: on.ZodCatch, catchValue: typeof r.catch == "function" ? r.catch : () => r.catch, ...Cn(r) });
class Gw extends Bn {
    _parse(r) { if (this._getType(r) !== Er.nan) {
        const u = this._getOrReturnCtx(r);
        return yr(u, { code: er.invalid_type, expected: Er.nan, received: u.parsedType }), cn;
    } return { status: "valid", value: r.data }; }
}
Gw.create = t => new Gw({ typeName: on.ZodNaN, ...Cn(t) });
const x7 = Symbol("zod_brand");
class JA extends Bn {
    _parse(r) { const { ctx: o } = this._processInputParams(r), u = o.data; return this._def.type._parse({ data: u, path: o.path, parent: o }); }
    unwrap() { return this._def.type; }
}
class l0 extends Bn {
    _parse(r) { const { status: o, ctx: u } = this._processInputParams(r); if (u.common.async)
        return (async () => { const y = await this._def.in._parseAsync({ data: u.data, path: u.path, parent: u }); return y.status === "aborted" ? cn : y.status === "dirty" ? (o.dirty(), km(y.value)) : this._def.out._parseAsync({ data: y.value, path: u.path, parent: u }); })(); {
        const g = this._def.in._parseSync({ data: u.data, path: u.path, parent: u });
        return g.status === "aborted" ? cn : g.status === "dirty" ? (o.dirty(), { status: "dirty", value: g.value }) : this._def.out._parseSync({ data: g.value, path: u.path, parent: u });
    } }
    static create(r, o) { return new l0({ in: r, out: o, typeName: on.ZodPipeline }); }
}
class $v extends Bn {
    _parse(r) { const o = this._def.innerType._parse(r), u = g => (Lf(g) && (g.value = Object.freeze(g.value)), g); return Rv(o) ? o.then(g => u(g)) : u(o); }
    unwrap() { return this._def.innerType; }
}
$v.create = (t, r) => new $v({ innerType: t, typeName: on.ZodReadonly, ...Cn(r) });
function IL(t, r) { const o = typeof t == "function" ? t(r) : typeof t == "string" ? { message: t } : t; return typeof o == "string" ? { message: o } : o; }
function JN(t, r = {}, o) { return t ? vg.create().superRefine((u, g) => { var y, E; const s = t(u); if (s instanceof Promise)
    return s.then(k => { var L, N; if (!k) {
        const V = IL(r, u), H = (N = (L = V.fatal) !== null && L !== void 0 ? L : o) !== null && N !== void 0 ? N : !0;
        g.addIssue({ code: "custom", ...V, fatal: H });
    } }); if (!s) {
    const k = IL(r, u), L = (E = (y = k.fatal) !== null && y !== void 0 ? y : o) !== null && E !== void 0 ? E : !0;
    g.addIssue({ code: "custom", ...k, fatal: L });
} }) : vg.create(); }
const w7 = { object: Xi.lazycreate };
var on;
(function (t) { t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly"; })(on || (on = {}));
const b7 = (t, r = { message: `Input not instance of ${t.name}` }) => JN(o => o instanceof t, r), kh = gl.create, eB = Kh.create, T7 = Gw.create, S7 = Yh.create, tB = kv.create, E7 = Of.create, C7 = Vw.create, A7 = Dv.create, I7 = Lv.create, P7 = vg.create, M7 = Ef.create, R7 = hu.create, k7 = Uw.create, D7 = vl.create, eI = Xi.create, L7 = Xi.strictCreate, O7 = Ov.create, z7 = Ob.create, F7 = zv.create, N7 = dc.create, B7 = Fv.create, j7 = $w.create, V7 = zf.create, U7 = Gm.create, $7 = Nv.create, G7 = Bv.create, q7 = Qh.create, H7 = jv.create, W7 = xg.create, PL = Tl.create, Z7 = cc.create, X7 = Jh.create, K7 = Tl.createWithPreprocess, Y7 = l0.create, Q7 = () => kh().optional(), J7 = () => eB().optional(), eX = () => tB().optional(), tX = { string: t => gl.create({ ...t, coerce: !0 }), number: t => Kh.create({ ...t, coerce: !0 }), boolean: t => kv.create({ ...t, coerce: !0 }), bigint: t => Yh.create({ ...t, coerce: !0 }), date: t => Of.create({ ...t, coerce: !0 }) }, rX = cn;
var zs = Object.freeze({ __proto__: null, defaultErrorMap: yg, setErrorMap: YZ, getErrorMap: Nw, makeIssue: Bw, EMPTY_PATH: QZ, addIssueToContext: yr, ParseStatus: fo, INVALID: cn, DIRTY: km, OK: So, isAborted: mC, isDirty: gC, isValid: Lf, isAsync: Rv, get util() { return ui; }, get objectUtil() { return pC; }, ZodParsedType: Er, getParsedType: Jc, ZodType: Bn, datetimeRegex: YN, ZodString: gl, ZodNumber: Kh, ZodBigInt: Yh, ZodBoolean: kv, ZodDate: Of, ZodSymbol: Vw, ZodUndefined: Dv, ZodNull: Lv, ZodAny: vg, ZodUnknown: Ef, ZodNever: hu, ZodVoid: Uw, ZodArray: vl, ZodObject: Xi, ZodUnion: Ov, ZodDiscriminatedUnion: Ob, ZodIntersection: zv, ZodTuple: dc, ZodRecord: Fv, ZodMap: $w, ZodSet: zf, ZodFunction: Gm, ZodLazy: Nv, ZodLiteral: Bv, ZodEnum: Qh, ZodNativeEnum: jv, ZodPromise: xg, ZodEffects: Tl, ZodTransformer: Tl, ZodOptional: cc, ZodNullable: Jh, ZodDefault: Vv, ZodCatch: Uv, ZodNaN: Gw, BRAND: x7, ZodBranded: JA, ZodPipeline: l0, ZodReadonly: $v, custom: JN, Schema: Bn, ZodSchema: Bn, late: w7, get ZodFirstPartyTypeKind() { return on; }, coerce: tX, any: P7, array: D7, bigint: S7, boolean: tB, date: E7, discriminatedUnion: z7, effect: PL, enum: q7, function: U7, instanceof: b7, intersection: F7, lazy: $7, literal: G7, map: j7, nan: T7, nativeEnum: H7, never: R7, null: I7, nullable: X7, number: eB, object: eI, oboolean: eX, onumber: J7, optional: Z7, ostring: Q7, pipeline: Y7, preprocess: K7, promise: W7, record: B7, set: V7, strictObject: L7, string: kh, symbol: C7, transformer: PL, tuple: N7, undefined: A7, union: O7, unknown: M7, void: k7, NEVER: rX, ZodIssueCode: er, quotelessJson: KZ, ZodError: ga }), c0 = t => t.type === "checkbox", pf = t => t instanceof Date, wo = t => t == null;
const rB = t => typeof t == "object";
var us = t => !wo(t) && !Array.isArray(t) && rB(t) && !pf(t), nX = t => us(t) && t.target ? c0(t.target) ? t.target.checked : t.target.value : t, iX = t => t.substring(0, t.search(/\.\d+(\.|$)/)) || t, sX = (t, r) => t.has(iX(r)), oX = t => { const r = t.constructor && t.constructor.prototype; return us(r) && r.hasOwnProperty("isPrototypeOf"); }, tI = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function ao(t) { let r; const o = Array.isArray(t), u = typeof FileList < "u" ? t instanceof FileList : !1; if (t instanceof Date)
    r = new Date(t);
else if (t instanceof Set)
    r = new Set(t);
else if (!(tI && (t instanceof Blob || u)) && (o || us(t)))
    if (r = o ? [] : {}, !o && !oX(t))
        r = t;
    else
        for (const g in t)
            t.hasOwnProperty(g) && (r[g] = ao(t[g]));
else
    return t; return r; }
var zb = t => Array.isArray(t) ? t.filter(Boolean) : [], ms = t => t === void 0, zr = (t, r, o) => { if (!r || !us(t))
    return o; const u = zb(r.split(/[,[\].]+?/)).reduce((g, y) => wo(g) ? g : g[y], t); return ms(u) || u === t ? ms(t[r]) ? o : t[r] : u; }, Yl = t => typeof t == "boolean", rI = t => /^\w*$/.test(t), nB = t => zb(t.replace(/["|']|\]/g, "").split(/\.|\[/)), Ai = (t, r, o) => { let u = -1; const g = rI(r) ? [r] : nB(r), y = g.length, E = y - 1; for (; ++u < y;) {
    const s = g[u];
    let k = o;
    if (u !== E) {
        const L = t[s];
        k = us(L) || Array.isArray(L) ? L : isNaN(+g[u + 1]) ? {} : [];
    }
    if (s === "__proto__" || s === "constructor" || s === "prototype")
        return;
    t[s] = k, t = t[s];
} };
const ML = { BLUR: "blur", FOCUS_OUT: "focusout", CHANGE: "change" }, pl = { onBlur: "onBlur", onChange: "onChange", onSubmit: "onSubmit", onTouched: "onTouched", all: "all" }, Wc = { max: "max", min: "min", maxLength: "maxLength", minLength: "minLength", pattern: "pattern", required: "required", validate: "validate" };
bs.createContext(null);
var aX = (t, r, o, u = !0) => { const g = { defaultValues: r._defaultValues }; for (const y in t)
    Object.defineProperty(g, y, { get: () => { const E = y; return r._proxyFormState[E] !== pl.all && (r._proxyFormState[E] = !u || pl.all), t[E]; } }); return g; }, ic = t => typeof t == "string", lX = (t, r, o, u, g) => ic(t) ? (u && r.watch.add(t), zr(o, t, g)) : Array.isArray(t) ? t.map(y => (u && r.watch.add(y), zr(o, y))) : (u && (r.watchAll = !0), o), iB = (t, r, o, u, g) => r ? { ...o[t], types: { ...o[t] && o[t].types ? o[t].types : {}, [u]: g || !0 } } : {}, lv = t => Array.isArray(t) ? t : [t], RL = () => { let t = []; return { get observers() { return t; }, next: g => { for (const y of t)
        y.next && y.next(g); }, subscribe: g => (t.push(g), { unsubscribe: () => { t = t.filter(y => y !== g); } }), unsubscribe: () => { t = []; } }; }, yC = t => wo(t) || !rB(t);
function xh(t, r) { if (yC(t) || yC(r))
    return t === r; if (pf(t) && pf(r))
    return t.getTime() === r.getTime(); const o = Object.keys(t), u = Object.keys(r); if (o.length !== u.length)
    return !1; for (const g of o) {
    const y = t[g];
    if (!u.includes(g))
        return !1;
    if (g !== "ref") {
        const E = r[g];
        if (pf(y) && pf(E) || us(y) && us(E) || Array.isArray(y) && Array.isArray(E) ? !xh(y, E) : y !== E)
            return !1;
    }
} return !0; }
var vo = t => us(t) && !Object.keys(t).length, nI = t => t.type === "file", ml = t => typeof t == "function", qw = t => { if (!tI)
    return !1; const r = t ? t.ownerDocument : 0; return t instanceof (r && r.defaultView ? r.defaultView.HTMLElement : HTMLElement); }, sB = t => t.type === "select-multiple", iI = t => t.type === "radio", cX = t => iI(t) || c0(t), DE = t => qw(t) && t.isConnected;
function uX(t, r) { const o = r.slice(0, -1).length; let u = 0; for (; u < o;)
    t = ms(t) ? u++ : t[r[u++]]; return t; }
function hX(t) { for (const r in t)
    if (t.hasOwnProperty(r) && !ms(t[r]))
        return !1; return !0; }
function ws(t, r) { const o = Array.isArray(r) ? r : rI(r) ? [r] : nB(r), u = o.length === 1 ? t : uX(t, o), g = o.length - 1, y = o[g]; return u && delete u[y], g !== 0 && (us(u) && vo(u) || Array.isArray(u) && hX(u)) && ws(t, o.slice(0, -1)), t; }
var oB = t => { for (const r in t)
    if (ml(t[r]))
        return !0; return !1; };
function Hw(t, r = {}) { const o = Array.isArray(t); if (us(t) || o)
    for (const u in t)
        Array.isArray(t[u]) || us(t[u]) && !oB(t[u]) ? (r[u] = Array.isArray(t[u]) ? [] : {}, Hw(t[u], r[u])) : wo(t[u]) || (r[u] = !0); return r; }
function aB(t, r, o) { const u = Array.isArray(t); if (us(t) || u)
    for (const g in t)
        Array.isArray(t[g]) || us(t[g]) && !oB(t[g]) ? ms(r) || yC(o[g]) ? o[g] = Array.isArray(t[g]) ? Hw(t[g], []) : { ...Hw(t[g]) } : aB(t[g], wo(r) ? {} : r[g], o[g]) : o[g] = !xh(t[g], r[g]); return o; }
var Dy = (t, r) => aB(t, r, Hw(r));
const kL = { value: !1, isValid: !1 }, DL = { value: !0, isValid: !0 };
var lB = t => { if (Array.isArray(t)) {
    if (t.length > 1) {
        const r = t.filter(o => o && o.checked && !o.disabled).map(o => o.value);
        return { value: r, isValid: !!r.length };
    }
    return t[0].checked && !t[0].disabled ? t[0].attributes && !ms(t[0].attributes.value) ? ms(t[0].value) || t[0].value === "" ? DL : { value: t[0].value, isValid: !0 } : DL : kL;
} return kL; }, cB = (t, { valueAsNumber: r, valueAsDate: o, setValueAs: u }) => ms(t) ? t : r ? t === "" ? NaN : t && +t : o && ic(t) ? new Date(t) : u ? u(t) : t;
const LL = { isValid: !1, value: null };
var uB = t => Array.isArray(t) ? t.reduce((r, o) => o && o.checked && !o.disabled ? { isValid: !0, value: o.value } : r, LL) : LL;
function OL(t) { const r = t.ref; return nI(r) ? r.files : iI(r) ? uB(t.refs).value : sB(r) ? [...r.selectedOptions].map(({ value: o }) => o) : c0(r) ? lB(t.refs).value : cB(ms(r.value) ? t.ref.value : r.value, t); }
var dX = (t, r, o, u) => { const g = {}; for (const y of t) {
    const E = zr(r, y);
    E && Ai(g, y, E._f);
} return { criteriaMode: o, names: [...t], fields: g, shouldUseNativeValidation: u }; }, Ww = t => t instanceof RegExp, Ly = t => ms(t) ? t : Ww(t) ? t.source : us(t) ? Ww(t.value) ? t.value.source : t.value : t, zL = t => ({ isOnSubmit: !t || t === pl.onSubmit, isOnBlur: t === pl.onBlur, isOnChange: t === pl.onChange, isOnAll: t === pl.all, isOnTouch: t === pl.onTouched });
const FL = "AsyncFunction";
var fX = t => !!t && !!t.validate && !!(ml(t.validate) && t.validate.constructor.name === FL || us(t.validate) && Object.values(t.validate).find(r => r.constructor.name === FL)), pX = t => t.mount && (t.required || t.min || t.max || t.maxLength || t.minLength || t.pattern || t.validate), NL = (t, r, o) => !o && (r.watchAll || r.watch.has(t) || [...r.watch].some(u => t.startsWith(u) && /^\.\w+/.test(t.slice(u.length))));
const cv = (t, r, o, u) => { for (const g of o || Object.keys(t)) {
    const y = zr(t, g);
    if (y) {
        const { _f: E, ...s } = y;
        if (E) {
            if (E.refs && E.refs[0] && r(E.refs[0], g) && !u)
                return !0;
            if (E.ref && r(E.ref, E.name) && !u)
                return !0;
            if (cv(s, r))
                break;
        }
        else if (us(s) && cv(s, r))
            break;
    }
} };
function BL(t, r, o) { const u = zr(t, o); if (u || rI(o))
    return { error: u, name: o }; const g = o.split("."); for (; g.length;) {
    const y = g.join("."), E = zr(r, y), s = zr(t, y);
    if (E && !Array.isArray(E) && o !== y)
        return { name: o };
    if (s && s.type)
        return { name: y, error: s };
    g.pop();
} return { name: o }; }
var mX = (t, r, o, u) => { o(t); const { name: g, ...y } = t; return vo(y) || Object.keys(y).length >= Object.keys(r).length || Object.keys(y).find(E => r[E] === (!u || pl.all)); }, gX = (t, r, o) => !t || !r || t === r || lv(t).some(u => u && (o ? u === r : u.startsWith(r) || r.startsWith(u))), _X = (t, r, o, u, g) => g.isOnAll ? !1 : !o && g.isOnTouch ? !(r || t) : (o ? u.isOnBlur : g.isOnBlur) ? !t : (o ? u.isOnChange : g.isOnChange) ? t : !0, yX = (t, r) => !zb(zr(t, r)).length && ws(t, r), vX = (t, r, o) => { const u = lv(zr(t, o)); return Ai(u, "root", r[o]), Ai(t, o, u), t; }, rw = t => ic(t);
function jL(t, r, o = "validate") { if (rw(t) || Array.isArray(t) && t.every(rw) || Yl(t) && !t)
    return { type: o, message: rw(t) ? t : "", ref: r }; }
var fm = t => us(t) && !Ww(t) ? t : { value: t, message: "" }, VL = async (t, r, o, u, g, y) => { const { ref: E, refs: s, required: k, maxLength: L, minLength: N, min: V, max: H, pattern: ee, validate: ce, name: J, valueAsNumber: ye, mount: ie } = t._f, Q = zr(o, J); if (!ie || r.has(J))
    return {}; const ue = s ? s[0] : E, be = St => { g && ue.reportValidity && (ue.setCustomValidity(Yl(St) ? "" : St || ""), ue.reportValidity()); }, Ie = {}, Be = iI(E), Ze = c0(E), ot = Be || Ze, At = (ye || nI(E)) && ms(E.value) && ms(Q) || qw(E) && E.value === "" || Q === "" || Array.isArray(Q) && !Q.length, kt = iB.bind(null, J, u, Ie), ct = (St, Kt, bt, ir = Wc.maxLength, tr = Wc.minLength) => { const Or = St ? Kt : bt; Ie[J] = { type: St ? ir : tr, message: Or, ref: E, ...kt(St ? ir : tr, Or) }; }; if (y ? !Array.isArray(Q) || !Q.length : k && (!ot && (At || wo(Q)) || Yl(Q) && !Q || Ze && !lB(s).isValid || Be && !uB(s).isValid)) {
    const { value: St, message: Kt } = rw(k) ? { value: !!k, message: k } : fm(k);
    if (St && (Ie[J] = { type: Wc.required, message: Kt, ref: ue, ...kt(Wc.required, Kt) }, !u))
        return be(Kt), Ie;
} if (!At && (!wo(V) || !wo(H))) {
    let St, Kt;
    const bt = fm(H), ir = fm(V);
    if (!wo(Q) && !isNaN(Q)) {
        const tr = E.valueAsNumber || Q && +Q;
        wo(bt.value) || (St = tr > bt.value), wo(ir.value) || (Kt = tr < ir.value);
    }
    else {
        const tr = E.valueAsDate || new Date(Q), Or = Ft => new Date(new Date().toDateString() + " " + Ft), xt = E.type == "time", Pt = E.type == "week";
        ic(bt.value) && Q && (St = xt ? Or(Q) > Or(bt.value) : Pt ? Q > bt.value : tr > new Date(bt.value)), ic(ir.value) && Q && (Kt = xt ? Or(Q) < Or(ir.value) : Pt ? Q < ir.value : tr < new Date(ir.value));
    }
    if ((St || Kt) && (ct(!!St, bt.message, ir.message, Wc.max, Wc.min), !u))
        return be(Ie[J].message), Ie;
} if ((L || N) && !At && (ic(Q) || y && Array.isArray(Q))) {
    const St = fm(L), Kt = fm(N), bt = !wo(St.value) && Q.length > +St.value, ir = !wo(Kt.value) && Q.length < +Kt.value;
    if ((bt || ir) && (ct(bt, St.message, Kt.message), !u))
        return be(Ie[J].message), Ie;
} if (ee && !At && ic(Q)) {
    const { value: St, message: Kt } = fm(ee);
    if (Ww(St) && !Q.match(St) && (Ie[J] = { type: Wc.pattern, message: Kt, ref: E, ...kt(Wc.pattern, Kt) }, !u))
        return be(Kt), Ie;
} if (ce) {
    if (ml(ce)) {
        const St = await ce(Q, o), Kt = jL(St, ue);
        if (Kt && (Ie[J] = { ...Kt, ...kt(Wc.validate, Kt.message) }, !u))
            return be(Kt.message), Ie;
    }
    else if (us(ce)) {
        let St = {};
        for (const Kt in ce) {
            if (!vo(St) && !u)
                break;
            const bt = jL(await ce[Kt](Q, o), ue, Kt);
            bt && (St = { ...bt, ...kt(Kt, bt.message) }, be(bt.message), u && (Ie[J] = St));
        }
        if (!vo(St) && (Ie[J] = { ref: ue, ...St }, !u))
            return Ie;
    }
} return be(!0), Ie; };
const xX = { mode: pl.onSubmit, reValidateMode: pl.onChange, shouldFocusError: !0 };
function wX(t = {}) { let r = { ...xX, ...t }, o = { submitCount: 0, isDirty: !1, isLoading: ml(r.defaultValues), isValidating: !1, isSubmitted: !1, isSubmitting: !1, isSubmitSuccessful: !1, isValid: !1, touchedFields: {}, dirtyFields: {}, validatingFields: {}, errors: r.errors || {}, disabled: r.disabled || !1 }; const u = {}; let g = us(r.defaultValues) || us(r.values) ? ao(r.values || r.defaultValues) || {} : {}, y = r.shouldUnregister ? {} : ao(g), E = { action: !1, mount: !1, watch: !1 }, s = { mount: new Set, disabled: new Set, unMount: new Set, array: new Set, watch: new Set }, k, L = 0; const N = { isDirty: !1, dirtyFields: !1, validatingFields: !1, touchedFields: !1, isValidating: !1, isValid: !1, errors: !1 }; let V = { ...N }; const H = { array: RL(), state: RL() }, ee = zL(r.mode), ce = zL(r.reValidateMode), J = r.criteriaMode === pl.all, ye = Ue => _t => { clearTimeout(L), L = setTimeout(Ue, _t); }, ie = async (Ue) => { if (!r.disabled && (N.isValid || V.isValid || Ue)) {
    const _t = r.resolver ? vo((await At()).errors) : await ct(u, !0);
    _t !== o.isValid && H.state.next({ isValid: _t });
} }, Q = (Ue, _t) => { !r.disabled && (N.isValidating || N.validatingFields || V.isValidating || V.validatingFields) && ((Ue || Array.from(s.mount)).forEach(Mt => { Mt && (_t ? Ai(o.validatingFields, Mt, _t) : ws(o.validatingFields, Mt)); }), H.state.next({ validatingFields: o.validatingFields, isValidating: !vo(o.validatingFields) })); }, ue = (Ue, _t = [], Mt, cr, ur = !0, Jt = !0) => { if (cr && Mt && !r.disabled) {
    if (E.action = !0, Jt && Array.isArray(zr(u, Ue))) {
        const vr = Mt(zr(u, Ue), cr.argA, cr.argB);
        ur && Ai(u, Ue, vr);
    }
    if (Jt && Array.isArray(zr(o.errors, Ue))) {
        const vr = Mt(zr(o.errors, Ue), cr.argA, cr.argB);
        ur && Ai(o.errors, Ue, vr), yX(o.errors, Ue);
    }
    if ((N.touchedFields || V.touchedFields) && Jt && Array.isArray(zr(o.touchedFields, Ue))) {
        const vr = Mt(zr(o.touchedFields, Ue), cr.argA, cr.argB);
        ur && Ai(o.touchedFields, Ue, vr);
    }
    (N.dirtyFields || V.dirtyFields) && (o.dirtyFields = Dy(g, y)), H.state.next({ name: Ue, isDirty: Kt(Ue, _t), dirtyFields: o.dirtyFields, errors: o.errors, isValid: o.isValid });
}
else
    Ai(y, Ue, _t); }, be = (Ue, _t) => { Ai(o.errors, Ue, _t), H.state.next({ errors: o.errors }); }, Ie = Ue => { o.errors = Ue, H.state.next({ errors: o.errors, isValid: !1 }); }, Be = (Ue, _t, Mt, cr) => { const ur = zr(u, Ue); if (ur) {
    const Jt = zr(y, Ue, ms(Mt) ? zr(g, Ue) : Mt);
    ms(Jt) || cr && cr.defaultChecked || _t ? Ai(y, Ue, _t ? Jt : OL(ur._f)) : tr(Ue, Jt), E.mount && ie();
} }, Ze = (Ue, _t, Mt, cr, ur) => { let Jt = !1, vr = !1; const gn = { name: Ue }; if (!r.disabled) {
    if (!Mt || cr) {
        (N.isDirty || V.isDirty) && (vr = o.isDirty, o.isDirty = gn.isDirty = Kt(), Jt = vr !== gn.isDirty);
        const mi = xh(zr(g, Ue), _t);
        vr = !!zr(o.dirtyFields, Ue), mi ? ws(o.dirtyFields, Ue) : Ai(o.dirtyFields, Ue, !0), gn.dirtyFields = o.dirtyFields, Jt = Jt || (N.dirtyFields || V.dirtyFields) && vr !== !mi;
    }
    if (Mt) {
        const mi = zr(o.touchedFields, Ue);
        mi || (Ai(o.touchedFields, Ue, Mt), gn.touchedFields = o.touchedFields, Jt = Jt || (N.touchedFields || V.touchedFields) && mi !== Mt);
    }
    Jt && ur && H.state.next(gn);
} return Jt ? gn : {}; }, ot = (Ue, _t, Mt, cr) => { const ur = zr(o.errors, Ue), Jt = (N.isValid || V.isValid) && Yl(_t) && o.isValid !== _t; if (r.delayError && Mt ? (k = ye(() => be(Ue, Mt)), k(r.delayError)) : (clearTimeout(L), k = null, Mt ? Ai(o.errors, Ue, Mt) : ws(o.errors, Ue)), (Mt ? !xh(ur, Mt) : ur) || !vo(cr) || Jt) {
    const vr = { ...cr, ...Jt && Yl(_t) ? { isValid: _t } : {}, errors: o.errors, name: Ue };
    o = { ...o, ...vr }, H.state.next(vr);
} }, At = async (Ue) => { Q(Ue, !0); const _t = await r.resolver(y, r.context, dX(Ue || s.mount, u, r.criteriaMode, r.shouldUseNativeValidation)); return Q(Ue), _t; }, kt = async (Ue) => { const { errors: _t } = await At(Ue); if (Ue)
    for (const Mt of Ue) {
        const cr = zr(_t, Mt);
        cr ? Ai(o.errors, Mt, cr) : ws(o.errors, Mt);
    }
else
    o.errors = _t; return _t; }, ct = async (Ue, _t, Mt = { valid: !0 }) => { for (const cr in Ue) {
    const ur = Ue[cr];
    if (ur) {
        const { _f: Jt, ...vr } = ur;
        if (Jt) {
            const gn = s.array.has(Jt.name), mi = ur._f && fX(ur._f);
            mi && N.validatingFields && Q([cr], !0);
            const oi = await VL(ur, s.disabled, y, J, r.shouldUseNativeValidation && !_t, gn);
            if (mi && N.validatingFields && Q([cr]), oi[Jt.name] && (Mt.valid = !1, _t))
                break;
            !_t && (zr(oi, Jt.name) ? gn ? vX(o.errors, oi, Jt.name) : Ai(o.errors, Jt.name, oi[Jt.name]) : ws(o.errors, Jt.name));
        }
        !vo(vr) && await ct(vr, _t, Mt);
    }
} return Mt.valid; }, St = () => { for (const Ue of s.unMount) {
    const _t = zr(u, Ue);
    _t && (_t._f.refs ? _t._f.refs.every(Mt => !DE(Mt)) : !DE(_t._f.ref)) && ln(Ue);
} s.unMount = new Set; }, Kt = (Ue, _t) => !r.disabled && (Ue && _t && Ai(y, Ue, _t), !xh(Jr(), g)), bt = (Ue, _t, Mt) => lX(Ue, s, { ...E.mount ? y : ms(_t) ? g : ic(Ue) ? { [Ue]: _t } : _t }, Mt, _t), ir = Ue => zb(zr(E.mount ? y : g, Ue, r.shouldUnregister ? zr(g, Ue, []) : [])), tr = (Ue, _t, Mt = {}) => { const cr = zr(u, Ue); let ur = _t; if (cr) {
    const Jt = cr._f;
    Jt && (!Jt.disabled && Ai(y, Ue, cB(_t, Jt)), ur = qw(Jt.ref) && wo(_t) ? "" : _t, sB(Jt.ref) ? [...Jt.ref.options].forEach(vr => vr.selected = ur.includes(vr.value)) : Jt.refs ? c0(Jt.ref) ? Jt.refs.length > 1 ? Jt.refs.forEach(vr => (!vr.defaultChecked || !vr.disabled) && (vr.checked = Array.isArray(ur) ? !!ur.find(gn => gn === vr.value) : ur === vr.value)) : Jt.refs[0] && (Jt.refs[0].checked = !!ur) : Jt.refs.forEach(vr => vr.checked = vr.value === ur) : nI(Jt.ref) ? Jt.ref.value = "" : (Jt.ref.value = ur, Jt.ref.type || H.state.next({ name: Ue, values: ao(y) })));
} (Mt.shouldDirty || Mt.shouldTouch) && Ze(Ue, ur, Mt.shouldTouch, Mt.shouldDirty, !0), Mt.shouldValidate && gr(Ue); }, Or = (Ue, _t, Mt) => { for (const cr in _t) {
    const ur = _t[cr], Jt = `${Ue}.${cr}`, vr = zr(u, Jt);
    (s.array.has(Ue) || us(ur) || vr && !vr._f) && !pf(ur) ? Or(Jt, ur, Mt) : tr(Jt, ur, Mt);
} }, xt = (Ue, _t, Mt = {}) => { const cr = zr(u, Ue), ur = s.array.has(Ue), Jt = ao(_t); Ai(y, Ue, Jt), ur ? (H.array.next({ name: Ue, values: ao(y) }), (N.isDirty || N.dirtyFields || V.isDirty || V.dirtyFields) && Mt.shouldDirty && H.state.next({ name: Ue, dirtyFields: Dy(g, y), isDirty: Kt(Ue, Jt) })) : cr && !cr._f && !wo(Jt) ? Or(Ue, Jt, Mt) : tr(Ue, Jt, Mt), NL(Ue, s) && H.state.next({ ...o }), H.state.next({ name: E.mount ? Ue : void 0, values: ao(y) }); }, Pt = async (Ue) => { E.mount = !0; const _t = Ue.target; let Mt = _t.name, cr = !0; const ur = zr(u, Mt), Jt = vr => { cr = Number.isNaN(vr) || pf(vr) && isNaN(vr.getTime()) || xh(vr, zr(y, Mt, vr)); }; if (ur) {
    let vr, gn;
    const mi = _t.type ? OL(ur._f) : nX(Ue), oi = Ue.type === ML.BLUR || Ue.type === ML.FOCUS_OUT, $a = !pX(ur._f) && !r.resolver && !zr(o.errors, Mt) && !ur._f.deps || _X(oi, zr(o.touchedFields, Mt), o.isSubmitted, ce, ee), Mo = NL(Mt, s, oi);
    Ai(y, Mt, mi), oi ? (ur._f.onBlur && ur._f.onBlur(Ue), k && k(0)) : ur._f.onChange && ur._f.onChange(Ue);
    const Ys = Ze(Mt, mi, oi), Ga = !vo(Ys) || Mo;
    if (!oi && H.state.next({ name: Mt, type: Ue.type, values: ao(y) }), $a)
        return (N.isValid || V.isValid) && (r.mode === "onBlur" ? oi && ie() : oi || ie()), Ga && H.state.next({ name: Mt, ...Mo ? {} : Ys });
    if (!oi && Mo && H.state.next({ ...o }), r.resolver) {
        const { errors: wa } = await At([Mt]);
        if (Jt(mi), cr) {
            const gc = BL(o.errors, u, Mt), jn = BL(wa, u, gc.name || Mt);
            vr = jn.error, Mt = jn.name, gn = vo(wa);
        }
    }
    else
        Q([Mt], !0), vr = (await VL(ur, s.disabled, y, J, r.shouldUseNativeValidation))[Mt], Q([Mt]), Jt(mi), cr && (vr ? gn = !1 : (N.isValid || V.isValid) && (gn = await ct(u, !0)));
    cr && (ur._f.deps && gr(ur._f.deps), ot(Mt, gn, vr, Ys));
} }, Ft = (Ue, _t) => { if (zr(o.errors, _t) && Ue.focus)
    return Ue.focus(), 1; }, gr = async (Ue, _t = {}) => { let Mt, cr; const ur = lv(Ue); if (r.resolver) {
    const Jt = await kt(ms(Ue) ? Ue : ur);
    Mt = vo(Jt), cr = Ue ? !ur.some(vr => zr(Jt, vr)) : Mt;
}
else
    Ue ? (cr = (await Promise.all(ur.map(async (Jt) => { const vr = zr(u, Jt); return await ct(vr && vr._f ? { [Jt]: vr } : vr); }))).every(Boolean), !(!cr && !o.isValid) && ie()) : cr = Mt = await ct(u); return H.state.next({ ...!ic(Ue) || (N.isValid || V.isValid) && Mt !== o.isValid ? {} : { name: Ue }, ...r.resolver || !Ue ? { isValid: Mt } : {}, errors: o.errors }), _t.shouldFocus && !cr && cv(u, Ft, Ue ? ur : s.mount), cr; }, Jr = Ue => { const _t = { ...E.mount ? y : g }; return ms(Ue) ? _t : ic(Ue) ? zr(_t, Ue) : Ue.map(Mt => zr(_t, Mt)); }, pi = (Ue, _t) => ({ invalid: !!zr((_t || o).errors, Ue), isDirty: !!zr((_t || o).dirtyFields, Ue), error: zr((_t || o).errors, Ue), isValidating: !!zr(o.validatingFields, Ue), isTouched: !!zr((_t || o).touchedFields, Ue) }), Si = Ue => { Ue && lv(Ue).forEach(_t => ws(o.errors, _t)), H.state.next({ errors: Ue ? o.errors : {} }); }, an = (Ue, _t, Mt) => { const cr = (zr(u, Ue, { _f: {} })._f || {}).ref, ur = zr(o.errors, Ue) || {}, { ref: Jt, message: vr, type: gn, ...mi } = ur; Ai(o.errors, Ue, { ...mi, ..._t, ref: cr }), H.state.next({ name: Ue, errors: o.errors, isValid: !1 }), Mt && Mt.shouldFocus && cr && cr.focus && cr.focus(); }, Kr = (Ue, _t) => ml(Ue) ? H.state.subscribe({ next: Mt => Ue(bt(void 0, _t), Mt) }) : bt(Ue, _t, !0), mn = Ue => H.state.subscribe({ next: _t => { gX(Ue.name, _t.name, Ue.exact) && mX(_t, Ue.formState || N, Gi, Ue.reRenderRoot) && Ue.callback({ values: { ...y }, ...o, ..._t }); } }).unsubscribe, Xs = Ue => (E.mount = !0, V = { ...V, ...Ue.formState }, mn({ ...Ue, formState: V })), ln = (Ue, _t = {}) => { for (const Mt of Ue ? lv(Ue) : s.mount)
    s.mount.delete(Mt), s.array.delete(Mt), _t.keepValue || (ws(u, Mt), ws(y, Mt)), !_t.keepError && ws(o.errors, Mt), !_t.keepDirty && ws(o.dirtyFields, Mt), !_t.keepTouched && ws(o.touchedFields, Mt), !_t.keepIsValidating && ws(o.validatingFields, Mt), !r.shouldUnregister && !_t.keepDefaultValue && ws(g, Mt); H.state.next({ values: ao(y) }), H.state.next({ ...o, ..._t.keepDirty ? { isDirty: Kt() } : {} }), !_t.keepIsValid && ie(); }, Bs = ({ disabled: Ue, name: _t }) => { (Yl(Ue) && E.mount || Ue || s.disabled.has(_t)) && (Ue ? s.disabled.add(_t) : s.disabled.delete(_t)); }, js = (Ue, _t = {}) => { let Mt = zr(u, Ue); const cr = Yl(_t.disabled) || Yl(r.disabled); return Ai(u, Ue, { ...Mt || {}, _f: { ...Mt && Mt._f ? Mt._f : { ref: { name: Ue } }, name: Ue, mount: !0, ..._t } }), s.mount.add(Ue), Mt ? Bs({ disabled: Yl(_t.disabled) ? _t.disabled : r.disabled, name: Ue }) : Be(Ue, !0, _t.value), { ...cr ? { disabled: _t.disabled || r.disabled } : {}, ...r.progressive ? { required: !!_t.required, min: Ly(_t.min), max: Ly(_t.max), minLength: Ly(_t.minLength), maxLength: Ly(_t.maxLength), pattern: Ly(_t.pattern) } : {}, name: Ue, onChange: Pt, onBlur: Pt, ref: ur => { if (ur) {
        js(Ue, _t), Mt = zr(u, Ue);
        const Jt = ms(ur.value) && ur.querySelectorAll && ur.querySelectorAll("input,select,textarea")[0] || ur, vr = cX(Jt), gn = Mt._f.refs || [];
        if (vr ? gn.find(mi => mi === Jt) : Jt === Mt._f.ref)
            return;
        Ai(u, Ue, { _f: { ...Mt._f, ...vr ? { refs: [...gn.filter(DE), Jt, ...Array.isArray(zr(g, Ue)) ? [{}] : []], ref: { type: Jt.type, name: Ue } } : { ref: Jt } } }), Be(Ue, !1, void 0, Jt);
    }
    else
        Mt = zr(u, Ue, {}), Mt._f && (Mt._f.mount = !1), (r.shouldUnregister || _t.shouldUnregister) && !(sX(s.array, Ue) && E.action) && s.unMount.add(Ue); } }; }, ss = () => r.shouldFocusError && cv(u, Ft, s.mount), Gn = Ue => { Yl(Ue) && (H.state.next({ disabled: Ue }), cv(u, (_t, Mt) => { const cr = zr(u, Mt); cr && (_t.disabled = cr._f.disabled || Ue, Array.isArray(cr._f.refs) && cr._f.refs.forEach(ur => { ur.disabled = cr._f.disabled || Ue; })); }, 0, !1)); }, Ua = (Ue, _t) => async (Mt) => { let cr; Mt && (Mt.preventDefault && Mt.preventDefault(), Mt.persist && Mt.persist()); let ur = ao(y); if (H.state.next({ isSubmitting: !0 }), r.resolver) {
    const { errors: Jt, values: vr } = await At();
    o.errors = Jt, ur = vr;
}
else
    await ct(u); if (s.disabled.size)
    for (const Jt of s.disabled)
        Ai(ur, Jt, void 0); if (ws(o.errors, "root"), vo(o.errors)) {
    H.state.next({ errors: {} });
    try {
        await Ue(ur, Mt);
    }
    catch (Jt) {
        cr = Jt;
    }
}
else
    _t && await _t({ ...o.errors }, Mt), ss(), setTimeout(ss); if (H.state.next({ isSubmitted: !0, isSubmitting: !1, isSubmitSuccessful: vo(o.errors) && !cr, submitCount: o.submitCount + 1, errors: o.errors }), cr)
    throw cr; }, Xo = (Ue, _t = {}) => { zr(u, Ue) && (ms(_t.defaultValue) ? xt(Ue, ao(zr(g, Ue))) : (xt(Ue, _t.defaultValue), Ai(g, Ue, ao(_t.defaultValue))), _t.keepTouched || ws(o.touchedFields, Ue), _t.keepDirty || (ws(o.dirtyFields, Ue), o.isDirty = _t.defaultValue ? Kt(Ue, ao(zr(g, Ue))) : Kt()), _t.keepError || (ws(o.errors, Ue), N.isValid && ie()), H.state.next({ ...o })); }, $i = (Ue, _t = {}) => { const Mt = Ue ? ao(Ue) : g, cr = ao(Mt), ur = vo(Ue), Jt = ur ? g : cr; if (_t.keepDefaultValues || (g = Mt), !_t.keepValues) {
    if (_t.keepDirtyValues) {
        const vr = new Set([...s.mount, ...Object.keys(Dy(g, y))]);
        for (const gn of Array.from(vr))
            zr(o.dirtyFields, gn) ? Ai(Jt, gn, zr(y, gn)) : xt(gn, zr(Jt, gn));
    }
    else {
        if (tI && ms(Ue))
            for (const vr of s.mount) {
                const gn = zr(u, vr);
                if (gn && gn._f) {
                    const mi = Array.isArray(gn._f.refs) ? gn._f.refs[0] : gn._f.ref;
                    if (qw(mi)) {
                        const oi = mi.closest("form");
                        if (oi) {
                            oi.reset();
                            break;
                        }
                    }
                }
            }
        for (const vr of s.mount)
            xt(vr, zr(Jt, vr));
    }
    y = ao(Jt), H.array.next({ values: { ...Jt } }), H.state.next({ values: { ...Jt } });
} s = { mount: _t.keepDirtyValues ? s.mount : new Set, unMount: new Set, array: new Set, disabled: new Set, watch: new Set, watchAll: !1, focus: "" }, E.mount = !N.isValid || !!_t.keepIsValid || !!_t.keepDirtyValues, E.watch = !!r.shouldUnregister, H.state.next({ submitCount: _t.keepSubmitCount ? o.submitCount : 0, isDirty: ur ? !1 : _t.keepDirty ? o.isDirty : !!(_t.keepDefaultValues && !xh(Ue, g)), isSubmitted: _t.keepIsSubmitted ? o.isSubmitted : !1, dirtyFields: ur ? {} : _t.keepDirtyValues ? _t.keepDefaultValues && y ? Dy(g, y) : o.dirtyFields : _t.keepDefaultValues && Ue ? Dy(g, Ue) : _t.keepDirty ? o.dirtyFields : {}, touchedFields: _t.keepTouched ? o.touchedFields : {}, errors: _t.keepErrors ? o.errors : {}, isSubmitSuccessful: _t.keepIsSubmitSuccessful ? o.isSubmitSuccessful : !1, isSubmitting: !1 }); }, Ks = (Ue, _t) => $i(ml(Ue) ? Ue(y) : Ue, _t), Io = (Ue, _t = {}) => { const Mt = zr(u, Ue), cr = Mt && Mt._f; if (cr) {
    const ur = cr.refs ? cr.refs[0] : cr.ref;
    ur.focus && (ur.focus(), _t.shouldSelect && ml(ur.select) && ur.select());
} }, Gi = Ue => { o = { ...o, ...Ue }; }, Ko = { control: { register: js, unregister: ln, getFieldState: pi, handleSubmit: Ua, setError: an, _subscribe: mn, _runSchema: At, _getWatch: bt, _getDirty: Kt, _setValid: ie, _setFieldArray: ue, _setDisabledField: Bs, _setErrors: Ie, _getFieldArray: ir, _reset: $i, _resetDefaultValues: () => ml(r.defaultValues) && r.defaultValues().then(Ue => { Ks(Ue, r.resetOptions), H.state.next({ isLoading: !1 }); }), _removeUnmounted: St, _disableForm: Gn, _subjects: H, _proxyFormState: N, get _fields() { return u; }, get _formValues() { return y; }, get _state() { return E; }, set _state(Ue) { E = Ue; }, get _defaultValues() { return g; }, get _names() { return s; }, set _names(Ue) { s = Ue; }, get _formState() { return o; }, get _options() { return r; }, set _options(Ue) { r = { ...r, ...Ue }; } }, subscribe: Xs, trigger: gr, register: js, handleSubmit: Ua, watch: Kr, setValue: xt, getValues: Jr, reset: Ks, resetField: Xo, clearErrors: Si, unregister: ln, setError: an, setFocus: Io, getFieldState: pi }; return { ...Ko, formControl: Ko }; }
function Fb(t = {}) { const r = bs.useRef(void 0), o = bs.useRef(void 0), [u, g] = bs.useState({ isDirty: !1, isValidating: !1, isLoading: ml(t.defaultValues), isSubmitted: !1, isSubmitting: !1, isSubmitSuccessful: !1, isValid: !1, submitCount: 0, dirtyFields: {}, touchedFields: {}, validatingFields: {}, errors: t.errors || {}, disabled: t.disabled || !1, defaultValues: ml(t.defaultValues) ? void 0 : t.defaultValues }); r.current || (r.current = { ...t.formControl ? t.formControl : wX(t), formState: u }, t.formControl && t.defaultValues && !ml(t.defaultValues) && t.formControl.reset(t.defaultValues, t.resetOptions)); const y = r.current.control; return y._options = t, bs.useLayoutEffect(() => y._subscribe({ formState: y._proxyFormState, callback: () => g({ ...y._formState }), reRenderRoot: !0 }), [y]), bs.useEffect(() => y._disableForm(t.disabled), [y, t.disabled]), bs.useEffect(() => { if (y._proxyFormState.isDirty) {
    const E = y._getDirty();
    E !== u.isDirty && y._subjects.state.next({ isDirty: E });
} }, [y, u.isDirty]), bs.useEffect(() => { t.values && !xh(t.values, o.current) ? (y._reset(t.values, y._options.resetOptions), o.current = t.values, g(E => ({ ...E }))) : y._resetDefaultValues(); }, [t.values, y]), bs.useEffect(() => { t.errors && !vo(t.errors) && y._setErrors(t.errors); }, [t.errors, y]), bs.useEffect(() => { y._state.mount || (y._setValid(), y._state.mount = !0), y._state.watch && (y._state.watch = !1, y._subjects.state.next({ ...y._formState })), y._removeUnmounted(); }), bs.useEffect(() => { t.shouldUnregister && y._subjects.state.next({ values: y._getWatch() }); }, [t.shouldUnregister, y]), r.current.formState = aX(u, y), r.current; }
const UL = (t, r, o) => { if (t && "reportValidity" in t) {
    const u = zr(o, r);
    t.setCustomValidity(u && u.message || ""), t.reportValidity();
} }, hB = (t, r) => { for (const o in r.fields) {
    const u = r.fields[o];
    u && u.ref && "reportValidity" in u.ref ? UL(u.ref, o, t) : u.refs && u.refs.forEach(g => UL(g, o, t));
} }, bX = (t, r) => { r.shouldUseNativeValidation && hB(t, r); const o = {}; for (const u in t) {
    const g = zr(r.fields, u), y = Object.assign(t[u] || {}, { ref: g && g.ref });
    if (TX(r.names || Object.keys(t), u)) {
        const E = Object.assign({}, zr(o, u));
        Ai(E, "root", y), Ai(o, u, E);
    }
    else
        Ai(o, u, y);
} return o; }, TX = (t, r) => t.some(o => o.startsWith(r + "."));
var SX = function (t, r) { for (var o = {}; t.length;) {
    var u = t[0], g = u.code, y = u.message, E = u.path.join(".");
    if (!o[E])
        if ("unionErrors" in u) {
            var s = u.unionErrors[0].errors[0];
            o[E] = { message: s.message, type: s.code };
        }
        else
            o[E] = { message: y, type: g };
    if ("unionErrors" in u && u.unionErrors.forEach(function (N) { return N.errors.forEach(function (V) { return t.push(V); }); }), r) {
        var k = o[E].types, L = k && k[u.code];
        o[E] = iB(E, r, o, g, L ? [].concat(L, u.message) : u.message);
    }
    t.shift();
} return o; }, Nb = function (t, r, o) { return o === void 0 && (o = {}), function (u, g, y) { try {
    return Promise.resolve(function (E, s) { try {
        var k = Promise.resolve(t[o.mode === "sync" ? "parse" : "parseAsync"](u, r)).then(function (L) { return y.shouldUseNativeValidation && hB({}, y), { errors: {}, values: o.raw ? u : L }; });
    }
    catch (L) {
        return s(L);
    } return k && k.then ? k.then(void 0, s) : k; }(0, function (E) { if (function (s) { return Array.isArray(s == null ? void 0 : s.errors); }(E))
        return { values: {}, errors: bX(SX(E.errors, !y.shouldUseNativeValidation && y.criteriaMode === "all"), y) }; throw E; }));
}
catch (E) {
    return Promise.reject(E);
} }; };
function Sl(t) { const r = Object.prototype.toString.call(t); return t instanceof Date || typeof t == "object" && r === "[object Date]" ? new t.constructor(+t) : typeof t == "number" || r === "[object Number]" || typeof t == "string" || r === "[object String]" ? new Date(t) : new Date(NaN); }
function Ff(t, r) { return t instanceof Date ? new t.constructor(r) : new Date(r); }
const dB = 6048e5, EX = 864e5;
let CX = {};
function Bb() { return CX; }
function Gv(t, r) { var s, k, L, N; const o = Bb(), u = (r == null ? void 0 : r.weekStartsOn) ?? ((k = (s = r == null ? void 0 : r.locale) == null ? void 0 : s.options) == null ? void 0 : k.weekStartsOn) ?? o.weekStartsOn ?? ((N = (L = o.locale) == null ? void 0 : L.options) == null ? void 0 : N.weekStartsOn) ?? 0, g = Sl(t), y = g.getDay(), E = (y < u ? 7 : 0) + y - u; return g.setDate(g.getDate() - E), g.setHours(0, 0, 0, 0), g; }
function Zw(t) { return Gv(t, { weekStartsOn: 1 }); }
function fB(t) { const r = Sl(t), o = r.getFullYear(), u = Ff(t, 0); u.setFullYear(o + 1, 0, 4), u.setHours(0, 0, 0, 0); const g = Zw(u), y = Ff(t, 0); y.setFullYear(o, 0, 4), y.setHours(0, 0, 0, 0); const E = Zw(y); return r.getTime() >= g.getTime() ? o + 1 : r.getTime() >= E.getTime() ? o : o - 1; }
function $L(t) { const r = Sl(t); return r.setHours(0, 0, 0, 0), r; }
function GL(t) { const r = Sl(t), o = new Date(Date.UTC(r.getFullYear(), r.getMonth(), r.getDate(), r.getHours(), r.getMinutes(), r.getSeconds(), r.getMilliseconds())); return o.setUTCFullYear(r.getFullYear()), +t - +o; }
function AX(t, r) { const o = $L(t), u = $L(r), g = +o - GL(o), y = +u - GL(u); return Math.round((g - y) / EX); }
function IX(t) { const r = fB(t), o = Ff(t, 0); return o.setFullYear(r, 0, 4), o.setHours(0, 0, 0, 0), Zw(o); }
function PX(t) { return t instanceof Date || typeof t == "object" && Object.prototype.toString.call(t) === "[object Date]"; }
function MX(t) { if (!PX(t) && typeof t != "number")
    return !1; const r = Sl(t); return !isNaN(Number(r)); }
function RX(t) { const r = Sl(t), o = Ff(t, 0); return o.setFullYear(r.getFullYear(), 0, 1), o.setHours(0, 0, 0, 0), o; }
const kX = { lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" }, xSeconds: { one: "1 second", other: "{{count}} seconds" }, halfAMinute: "half a minute", lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" }, xMinutes: { one: "1 minute", other: "{{count}} minutes" }, aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" }, xHours: { one: "1 hour", other: "{{count}} hours" }, xDays: { one: "1 day", other: "{{count}} days" }, aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" }, xWeeks: { one: "1 week", other: "{{count}} weeks" }, aboutXMonths: { one: "about 1 month", other: "about {{count}} months" }, xMonths: { one: "1 month", other: "{{count}} months" }, aboutXYears: { one: "about 1 year", other: "about {{count}} years" }, xYears: { one: "1 year", other: "{{count}} years" }, overXYears: { one: "over 1 year", other: "over {{count}} years" }, almostXYears: { one: "almost 1 year", other: "almost {{count}} years" } }, DX = (t, r, o) => { let u; const g = kX[t]; return typeof g == "string" ? u = g : r === 1 ? u = g.one : u = g.other.replace("{{count}}", r.toString()), o != null && o.addSuffix ? o.comparison && o.comparison > 0 ? "in " + u : u + " ago" : u; };
function LE(t) { return (r = {}) => { const o = r.width ? String(r.width) : t.defaultWidth; return t.formats[o] || t.formats[t.defaultWidth]; }; }
const LX = { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, OX = { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, zX = { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, FX = { date: LE({ formats: LX, defaultWidth: "full" }), time: LE({ formats: OX, defaultWidth: "full" }), dateTime: LE({ formats: zX, defaultWidth: "full" }) }, NX = { lastWeek: "'last' eeee 'at' p", yesterday: "'yesterday at' p", today: "'today at' p", tomorrow: "'tomorrow at' p", nextWeek: "eeee 'at' p", other: "P" }, BX = (t, r, o, u) => NX[t];
function Oy(t) { return (r, o) => { const u = o != null && o.context ? String(o.context) : "standalone"; let g; if (u === "formatting" && t.formattingValues) {
    const E = t.defaultFormattingWidth || t.defaultWidth, s = o != null && o.width ? String(o.width) : E;
    g = t.formattingValues[s] || t.formattingValues[E];
}
else {
    const E = t.defaultWidth, s = o != null && o.width ? String(o.width) : t.defaultWidth;
    g = t.values[s] || t.values[E];
} const y = t.argumentCallback ? t.argumentCallback(r) : r; return g[y]; }; }
const jX = { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, VX = { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] }, UX = { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, $X = { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, GX = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" } }, qX = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" } }, HX = (t, r) => { const o = Number(t), u = o % 100; if (u > 20 || u < 10)
    switch (u % 10) {
        case 1: return o + "st";
        case 2: return o + "nd";
        case 3: return o + "rd";
    } return o + "th"; }, WX = { ordinalNumber: HX, era: Oy({ values: jX, defaultWidth: "wide" }), quarter: Oy({ values: VX, defaultWidth: "wide", argumentCallback: t => t - 1 }), month: Oy({ values: UX, defaultWidth: "wide" }), day: Oy({ values: $X, defaultWidth: "wide" }), dayPeriod: Oy({ values: GX, defaultWidth: "wide", formattingValues: qX, defaultFormattingWidth: "wide" }) };
function zy(t) { return (r, o = {}) => { const u = o.width, g = u && t.matchPatterns[u] || t.matchPatterns[t.defaultMatchWidth], y = r.match(g); if (!y)
    return null; const E = y[0], s = u && t.parsePatterns[u] || t.parsePatterns[t.defaultParseWidth], k = Array.isArray(s) ? XX(s, V => V.test(E)) : ZX(s, V => V.test(E)); let L; L = t.valueCallback ? t.valueCallback(k) : k, L = o.valueCallback ? o.valueCallback(L) : L; const N = r.slice(E.length); return { value: L, rest: N }; }; }
function ZX(t, r) { for (const o in t)
    if (Object.prototype.hasOwnProperty.call(t, o) && r(t[o]))
        return o; }
function XX(t, r) { for (let o = 0; o < t.length; o++)
    if (r(t[o]))
        return o; }
function KX(t) { return (r, o = {}) => { const u = r.match(t.matchPattern); if (!u)
    return null; const g = u[0], y = r.match(t.parsePattern); if (!y)
    return null; let E = t.valueCallback ? t.valueCallback(y[0]) : y[0]; E = o.valueCallback ? o.valueCallback(E) : E; const s = r.slice(g.length); return { value: E, rest: s }; }; }
const YX = /^(\d+)(th|st|nd|rd)?/i, QX = /\d+/i, JX = { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i }, eK = { any: [/^b/i, /^(a|c)/i] }, tK = { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i }, rK = { any: [/1/i, /2/i, /3/i, /4/i] }, nK = { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i }, iK = { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] }, sK = { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i }, oK = { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] }, aK = { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i }, lK = { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } }, cK = { ordinalNumber: KX({ matchPattern: YX, parsePattern: QX, valueCallback: t => parseInt(t, 10) }), era: zy({ matchPatterns: JX, defaultMatchWidth: "wide", parsePatterns: eK, defaultParseWidth: "any" }), quarter: zy({ matchPatterns: tK, defaultMatchWidth: "wide", parsePatterns: rK, defaultParseWidth: "any", valueCallback: t => t + 1 }), month: zy({ matchPatterns: nK, defaultMatchWidth: "wide", parsePatterns: iK, defaultParseWidth: "any" }), day: zy({ matchPatterns: sK, defaultMatchWidth: "wide", parsePatterns: oK, defaultParseWidth: "any" }), dayPeriod: zy({ matchPatterns: aK, defaultMatchWidth: "any", parsePatterns: lK, defaultParseWidth: "any" }) }, uK = { code: "en-US", formatDistance: DX, formatLong: FX, formatRelative: BX, localize: WX, match: cK, options: { weekStartsOn: 0, firstWeekContainsDate: 1 } };
function hK(t) { const r = Sl(t); return AX(r, RX(r)) + 1; }
function dK(t) { const r = Sl(t), o = +Zw(r) - +IX(r); return Math.round(o / dB) + 1; }
function pB(t, r) { var N, V, H, ee; const o = Sl(t), u = o.getFullYear(), g = Bb(), y = (r == null ? void 0 : r.firstWeekContainsDate) ?? ((V = (N = r == null ? void 0 : r.locale) == null ? void 0 : N.options) == null ? void 0 : V.firstWeekContainsDate) ?? g.firstWeekContainsDate ?? ((ee = (H = g.locale) == null ? void 0 : H.options) == null ? void 0 : ee.firstWeekContainsDate) ?? 1, E = Ff(t, 0); E.setFullYear(u + 1, 0, y), E.setHours(0, 0, 0, 0); const s = Gv(E, r), k = Ff(t, 0); k.setFullYear(u, 0, y), k.setHours(0, 0, 0, 0); const L = Gv(k, r); return o.getTime() >= s.getTime() ? u + 1 : o.getTime() >= L.getTime() ? u : u - 1; }
function fK(t, r) { var s, k, L, N; const o = Bb(), u = (r == null ? void 0 : r.firstWeekContainsDate) ?? ((k = (s = r == null ? void 0 : r.locale) == null ? void 0 : s.options) == null ? void 0 : k.firstWeekContainsDate) ?? o.firstWeekContainsDate ?? ((N = (L = o.locale) == null ? void 0 : L.options) == null ? void 0 : N.firstWeekContainsDate) ?? 1, g = pB(t, r), y = Ff(t, 0); return y.setFullYear(g, 0, u), y.setHours(0, 0, 0, 0), Gv(y, r); }
function pK(t, r) { const o = Sl(t), u = +Gv(o, r) - +fK(o, r); return Math.round(u / dB) + 1; }
function bi(t, r) { const o = t < 0 ? "-" : "", u = Math.abs(t).toString().padStart(r, "0"); return o + u; }
const ch = { y(t, r) { const o = t.getFullYear(), u = o > 0 ? o : 1 - o; return bi(r === "yy" ? u % 100 : u, r.length); }, M(t, r) { const o = t.getMonth(); return r === "M" ? String(o + 1) : bi(o + 1, 2); }, d(t, r) { return bi(t.getDate(), r.length); }, a(t, r) { const o = t.getHours() / 12 >= 1 ? "pm" : "am"; switch (r) {
        case "a":
        case "aa": return o.toUpperCase();
        case "aaa": return o;
        case "aaaaa": return o[0];
        case "aaaa":
        default: return o === "am" ? "a.m." : "p.m.";
    } }, h(t, r) { return bi(t.getHours() % 12 || 12, r.length); }, H(t, r) { return bi(t.getHours(), r.length); }, m(t, r) { return bi(t.getMinutes(), r.length); }, s(t, r) { return bi(t.getSeconds(), r.length); }, S(t, r) { const o = r.length, u = t.getMilliseconds(), g = Math.trunc(u * Math.pow(10, o - 3)); return bi(g, r.length); } }, pm = { am: "am", pm: "pm", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, qL = { G: function (t, r, o) { const u = t.getFullYear() > 0 ? 1 : 0; switch (r) {
        case "G":
        case "GG":
        case "GGG": return o.era(u, { width: "abbreviated" });
        case "GGGGG": return o.era(u, { width: "narrow" });
        case "GGGG":
        default: return o.era(u, { width: "wide" });
    } }, y: function (t, r, o) { if (r === "yo") {
        const u = t.getFullYear(), g = u > 0 ? u : 1 - u;
        return o.ordinalNumber(g, { unit: "year" });
    } return ch.y(t, r); }, Y: function (t, r, o, u) { const g = pB(t, u), y = g > 0 ? g : 1 - g; if (r === "YY") {
        const E = y % 100;
        return bi(E, 2);
    } return r === "Yo" ? o.ordinalNumber(y, { unit: "year" }) : bi(y, r.length); }, R: function (t, r) { const o = fB(t); return bi(o, r.length); }, u: function (t, r) { const o = t.getFullYear(); return bi(o, r.length); }, Q: function (t, r, o) { const u = Math.ceil((t.getMonth() + 1) / 3); switch (r) {
        case "Q": return String(u);
        case "QQ": return bi(u, 2);
        case "Qo": return o.ordinalNumber(u, { unit: "quarter" });
        case "QQQ": return o.quarter(u, { width: "abbreviated", context: "formatting" });
        case "QQQQQ": return o.quarter(u, { width: "narrow", context: "formatting" });
        case "QQQQ":
        default: return o.quarter(u, { width: "wide", context: "formatting" });
    } }, q: function (t, r, o) { const u = Math.ceil((t.getMonth() + 1) / 3); switch (r) {
        case "q": return String(u);
        case "qq": return bi(u, 2);
        case "qo": return o.ordinalNumber(u, { unit: "quarter" });
        case "qqq": return o.quarter(u, { width: "abbreviated", context: "standalone" });
        case "qqqqq": return o.quarter(u, { width: "narrow", context: "standalone" });
        case "qqqq":
        default: return o.quarter(u, { width: "wide", context: "standalone" });
    } }, M: function (t, r, o) { const u = t.getMonth(); switch (r) {
        case "M":
        case "MM": return ch.M(t, r);
        case "Mo": return o.ordinalNumber(u + 1, { unit: "month" });
        case "MMM": return o.month(u, { width: "abbreviated", context: "formatting" });
        case "MMMMM": return o.month(u, { width: "narrow", context: "formatting" });
        case "MMMM":
        default: return o.month(u, { width: "wide", context: "formatting" });
    } }, L: function (t, r, o) { const u = t.getMonth(); switch (r) {
        case "L": return String(u + 1);
        case "LL": return bi(u + 1, 2);
        case "Lo": return o.ordinalNumber(u + 1, { unit: "month" });
        case "LLL": return o.month(u, { width: "abbreviated", context: "standalone" });
        case "LLLLL": return o.month(u, { width: "narrow", context: "standalone" });
        case "LLLL":
        default: return o.month(u, { width: "wide", context: "standalone" });
    } }, w: function (t, r, o, u) { const g = pK(t, u); return r === "wo" ? o.ordinalNumber(g, { unit: "week" }) : bi(g, r.length); }, I: function (t, r, o) { const u = dK(t); return r === "Io" ? o.ordinalNumber(u, { unit: "week" }) : bi(u, r.length); }, d: function (t, r, o) { return r === "do" ? o.ordinalNumber(t.getDate(), { unit: "date" }) : ch.d(t, r); }, D: function (t, r, o) { const u = hK(t); return r === "Do" ? o.ordinalNumber(u, { unit: "dayOfYear" }) : bi(u, r.length); }, E: function (t, r, o) { const u = t.getDay(); switch (r) {
        case "E":
        case "EE":
        case "EEE": return o.day(u, { width: "abbreviated", context: "formatting" });
        case "EEEEE": return o.day(u, { width: "narrow", context: "formatting" });
        case "EEEEEE": return o.day(u, { width: "short", context: "formatting" });
        case "EEEE":
        default: return o.day(u, { width: "wide", context: "formatting" });
    } }, e: function (t, r, o, u) { const g = t.getDay(), y = (g - u.weekStartsOn + 8) % 7 || 7; switch (r) {
        case "e": return String(y);
        case "ee": return bi(y, 2);
        case "eo": return o.ordinalNumber(y, { unit: "day" });
        case "eee": return o.day(g, { width: "abbreviated", context: "formatting" });
        case "eeeee": return o.day(g, { width: "narrow", context: "formatting" });
        case "eeeeee": return o.day(g, { width: "short", context: "formatting" });
        case "eeee":
        default: return o.day(g, { width: "wide", context: "formatting" });
    } }, c: function (t, r, o, u) { const g = t.getDay(), y = (g - u.weekStartsOn + 8) % 7 || 7; switch (r) {
        case "c": return String(y);
        case "cc": return bi(y, r.length);
        case "co": return o.ordinalNumber(y, { unit: "day" });
        case "ccc": return o.day(g, { width: "abbreviated", context: "standalone" });
        case "ccccc": return o.day(g, { width: "narrow", context: "standalone" });
        case "cccccc": return o.day(g, { width: "short", context: "standalone" });
        case "cccc":
        default: return o.day(g, { width: "wide", context: "standalone" });
    } }, i: function (t, r, o) { const u = t.getDay(), g = u === 0 ? 7 : u; switch (r) {
        case "i": return String(g);
        case "ii": return bi(g, r.length);
        case "io": return o.ordinalNumber(g, { unit: "day" });
        case "iii": return o.day(u, { width: "abbreviated", context: "formatting" });
        case "iiiii": return o.day(u, { width: "narrow", context: "formatting" });
        case "iiiiii": return o.day(u, { width: "short", context: "formatting" });
        case "iiii":
        default: return o.day(u, { width: "wide", context: "formatting" });
    } }, a: function (t, r, o) { const g = t.getHours() / 12 >= 1 ? "pm" : "am"; switch (r) {
        case "a":
        case "aa": return o.dayPeriod(g, { width: "abbreviated", context: "formatting" });
        case "aaa": return o.dayPeriod(g, { width: "abbreviated", context: "formatting" }).toLowerCase();
        case "aaaaa": return o.dayPeriod(g, { width: "narrow", context: "formatting" });
        case "aaaa":
        default: return o.dayPeriod(g, { width: "wide", context: "formatting" });
    } }, b: function (t, r, o) { const u = t.getHours(); let g; switch (u === 12 ? g = pm.noon : u === 0 ? g = pm.midnight : g = u / 12 >= 1 ? "pm" : "am", r) {
        case "b":
        case "bb": return o.dayPeriod(g, { width: "abbreviated", context: "formatting" });
        case "bbb": return o.dayPeriod(g, { width: "abbreviated", context: "formatting" }).toLowerCase();
        case "bbbbb": return o.dayPeriod(g, { width: "narrow", context: "formatting" });
        case "bbbb":
        default: return o.dayPeriod(g, { width: "wide", context: "formatting" });
    } }, B: function (t, r, o) { const u = t.getHours(); let g; switch (u >= 17 ? g = pm.evening : u >= 12 ? g = pm.afternoon : u >= 4 ? g = pm.morning : g = pm.night, r) {
        case "B":
        case "BB":
        case "BBB": return o.dayPeriod(g, { width: "abbreviated", context: "formatting" });
        case "BBBBB": return o.dayPeriod(g, { width: "narrow", context: "formatting" });
        case "BBBB":
        default: return o.dayPeriod(g, { width: "wide", context: "formatting" });
    } }, h: function (t, r, o) { if (r === "ho") {
        let u = t.getHours() % 12;
        return u === 0 && (u = 12), o.ordinalNumber(u, { unit: "hour" });
    } return ch.h(t, r); }, H: function (t, r, o) { return r === "Ho" ? o.ordinalNumber(t.getHours(), { unit: "hour" }) : ch.H(t, r); }, K: function (t, r, o) { const u = t.getHours() % 12; return r === "Ko" ? o.ordinalNumber(u, { unit: "hour" }) : bi(u, r.length); }, k: function (t, r, o) { let u = t.getHours(); return u === 0 && (u = 24), r === "ko" ? o.ordinalNumber(u, { unit: "hour" }) : bi(u, r.length); }, m: function (t, r, o) { return r === "mo" ? o.ordinalNumber(t.getMinutes(), { unit: "minute" }) : ch.m(t, r); }, s: function (t, r, o) { return r === "so" ? o.ordinalNumber(t.getSeconds(), { unit: "second" }) : ch.s(t, r); }, S: function (t, r) { return ch.S(t, r); }, X: function (t, r, o) { const u = t.getTimezoneOffset(); if (u === 0)
        return "Z"; switch (r) {
        case "X": return WL(u);
        case "XXXX":
        case "XX": return cf(u);
        case "XXXXX":
        case "XXX":
        default: return cf(u, ":");
    } }, x: function (t, r, o) { const u = t.getTimezoneOffset(); switch (r) {
        case "x": return WL(u);
        case "xxxx":
        case "xx": return cf(u);
        case "xxxxx":
        case "xxx":
        default: return cf(u, ":");
    } }, O: function (t, r, o) { const u = t.getTimezoneOffset(); switch (r) {
        case "O":
        case "OO":
        case "OOO": return "GMT" + HL(u, ":");
        case "OOOO":
        default: return "GMT" + cf(u, ":");
    } }, z: function (t, r, o) { const u = t.getTimezoneOffset(); switch (r) {
        case "z":
        case "zz":
        case "zzz": return "GMT" + HL(u, ":");
        case "zzzz":
        default: return "GMT" + cf(u, ":");
    } }, t: function (t, r, o) { const u = Math.trunc(t.getTime() / 1e3); return bi(u, r.length); }, T: function (t, r, o) { const u = t.getTime(); return bi(u, r.length); } };
function HL(t, r = "") { const o = t > 0 ? "-" : "+", u = Math.abs(t), g = Math.trunc(u / 60), y = u % 60; return y === 0 ? o + String(g) : o + String(g) + r + bi(y, 2); }
function WL(t, r) { return t % 60 === 0 ? (t > 0 ? "-" : "+") + bi(Math.abs(t) / 60, 2) : cf(t, r); }
function cf(t, r = "") { const o = t > 0 ? "-" : "+", u = Math.abs(t), g = bi(Math.trunc(u / 60), 2), y = bi(u % 60, 2); return o + g + r + y; }
const ZL = (t, r) => { switch (t) {
    case "P": return r.date({ width: "short" });
    case "PP": return r.date({ width: "medium" });
    case "PPP": return r.date({ width: "long" });
    case "PPPP":
    default: return r.date({ width: "full" });
} }, mB = (t, r) => { switch (t) {
    case "p": return r.time({ width: "short" });
    case "pp": return r.time({ width: "medium" });
    case "ppp": return r.time({ width: "long" });
    case "pppp":
    default: return r.time({ width: "full" });
} }, mK = (t, r) => { const o = t.match(/(P+)(p+)?/) || [], u = o[1], g = o[2]; if (!g)
    return ZL(t, r); let y; switch (u) {
    case "P":
        y = r.dateTime({ width: "short" });
        break;
    case "PP":
        y = r.dateTime({ width: "medium" });
        break;
    case "PPP":
        y = r.dateTime({ width: "long" });
        break;
    case "PPPP":
    default:
        y = r.dateTime({ width: "full" });
        break;
} return y.replace("{{date}}", ZL(u, r)).replace("{{time}}", mB(g, r)); }, gK = { p: mB, P: mK }, _K = /^D+$/, yK = /^Y+$/, vK = ["D", "DD", "YY", "YYYY"];
function xK(t) { return _K.test(t); }
function wK(t) { return yK.test(t); }
function bK(t, r, o) { const u = TK(t, r, o); if (console.warn(u), vK.includes(t))
    throw new RangeError(u); }
function TK(t, r, o) { const u = t[0] === "Y" ? "years" : "days of the month"; return `Use \`${t.toLowerCase()}\` instead of \`${t}\` (in \`${r}\`) for formatting ${u} to the input \`${o}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`; }
const SK = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, EK = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, CK = /^'([^]*?)'?$/, AK = /''/g, IK = /[a-zA-Z]/;
function Xw(t, r, o) { var N, V, H, ee; const u = Bb(), g = u.locale ?? uK, y = u.firstWeekContainsDate ?? ((V = (N = u.locale) == null ? void 0 : N.options) == null ? void 0 : V.firstWeekContainsDate) ?? 1, E = u.weekStartsOn ?? ((ee = (H = u.locale) == null ? void 0 : H.options) == null ? void 0 : ee.weekStartsOn) ?? 0, s = Sl(t); if (!MX(s))
    throw new RangeError("Invalid time value"); let k = r.match(EK).map(ce => { const J = ce[0]; if (J === "p" || J === "P") {
    const ye = gK[J];
    return ye(ce, g.formatLong);
} return ce; }).join("").match(SK).map(ce => { if (ce === "''")
    return { isToken: !1, value: "'" }; const J = ce[0]; if (J === "'")
    return { isToken: !1, value: PK(ce) }; if (qL[J])
    return { isToken: !0, value: ce }; if (J.match(IK))
    throw new RangeError("Format string contains an unescaped latin alphabet character `" + J + "`"); return { isToken: !1, value: ce }; }); g.localize.preprocessor && (k = g.localize.preprocessor(s, k)); const L = { firstWeekContainsDate: y, weekStartsOn: E, locale: g }; return k.map(ce => { if (!ce.isToken)
    return ce.value; const J = ce.value; (wK(J) || xK(J)) && bK(J, r, String(t)); const ye = qL[J[0]]; return ye(s, J, g.localize, L); }).join(""); }
function PK(t) { const r = t.match(CK); return r ? r[1].replace(AK, "'") : t; }
var gB = { exports: {} };
(function (t, r) {
    (function (o, u) { t.exports = u(); })(_a, function () {
        var o, u, g;
        function y(s, k) { if (!o)
            o = k;
        else if (!u)
            u = k;
        else {
            var L = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + o + ")(sharedChunk); (" + u + ")(sharedChunk); self.onerror = null;", N = {};
            o(N), g = k(N), typeof window < "u" && window && window.URL && window.URL.createObjectURL && (g.workerUrl = window.URL.createObjectURL(new Blob([L], { type: "text/javascript" })));
        } }
        y(["exports"], function (s) {
            var k = 1e-6, L = typeof Float32Array < "u" ? Float32Array : Array;
            function N(a, e) { var i = e[0], c = e[1], h = e[2], p = e[3], m = i * p - h * c; return m ? (a[0] = p * (m = 1 / m), a[1] = -c * m, a[2] = -h * m, a[3] = i * m, a) : null; }
            function V() { var a = new L(9); return L != Float32Array && (a[1] = 0, a[2] = 0, a[3] = 0, a[5] = 0, a[6] = 0, a[7] = 0), a[0] = 1, a[4] = 1, a[8] = 1, a; }
            function H(a, e) { var i = e[0], c = e[1], h = e[2], p = e[3], m = e[4], x = e[5], b = e[6], S = e[7], A = e[8]; return a[0] = m * A - x * S, a[1] = h * S - c * A, a[2] = c * x - h * m, a[3] = x * b - p * A, a[4] = i * A - h * b, a[5] = h * p - i * x, a[6] = p * S - m * b, a[7] = c * b - i * S, a[8] = i * m - c * p, a; }
            function ee(a, e, i) { var c = e[0], h = e[1], p = e[2], m = e[3], x = e[4], b = e[5], S = e[6], A = e[7], I = e[8], M = i[0], z = i[1], F = i[2], U = i[3], X = i[4], Y = i[5], le = i[6], se = i[7], $ = i[8]; return a[0] = M * c + z * m + F * S, a[1] = M * h + z * x + F * A, a[2] = M * p + z * b + F * I, a[3] = U * c + X * m + Y * S, a[4] = U * h + X * x + Y * A, a[5] = U * p + X * b + Y * I, a[6] = le * c + se * m + $ * S, a[7] = le * h + se * x + $ * A, a[8] = le * p + se * b + $ * I, a; }
            function ce() { var a = new L(16); return L != Float32Array && (a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0), a[0] = 1, a[5] = 1, a[10] = 1, a[15] = 1, a; }
            function J(a) { return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a; }
            function ye(a, e) { var i = e[0], c = e[1], h = e[2], p = e[3], m = e[4], x = e[5], b = e[6], S = e[7], A = e[8], I = e[9], M = e[10], z = e[11], F = e[12], U = e[13], X = e[14], Y = e[15], le = i * x - c * m, se = i * b - h * m, $ = i * S - p * m, te = c * b - h * x, ae = c * S - p * x, fe = h * S - p * b, Te = A * U - I * F, Pe = A * X - M * F, Me = A * Y - z * F, Oe = I * X - M * U, Ye = I * Y - z * U, ut = M * Y - z * X, it = le * ut - se * Ye + $ * Oe + te * Me - ae * Pe + fe * Te; return it ? (a[0] = (x * ut - b * Ye + S * Oe) * (it = 1 / it), a[1] = (h * Ye - c * ut - p * Oe) * it, a[2] = (U * fe - X * ae + Y * te) * it, a[3] = (M * ae - I * fe - z * te) * it, a[4] = (b * Me - m * ut - S * Pe) * it, a[5] = (i * ut - h * Me + p * Pe) * it, a[6] = (X * $ - F * fe - Y * se) * it, a[7] = (A * fe - M * $ + z * se) * it, a[8] = (m * Ye - x * Me + S * Te) * it, a[9] = (c * Me - i * Ye - p * Te) * it, a[10] = (F * ae - U * $ + Y * le) * it, a[11] = (I * $ - A * ae - z * le) * it, a[12] = (x * Pe - m * Oe - b * Te) * it, a[13] = (i * Oe - c * Pe + h * Te) * it, a[14] = (U * se - F * te - X * le) * it, a[15] = (A * te - I * se + M * le) * it, a) : null; }
            function ie(a, e, i) { var c = e[0], h = e[1], p = e[2], m = e[3], x = e[4], b = e[5], S = e[6], A = e[7], I = e[8], M = e[9], z = e[10], F = e[11], U = e[12], X = e[13], Y = e[14], le = e[15], se = i[0], $ = i[1], te = i[2], ae = i[3]; return a[0] = se * c + $ * x + te * I + ae * U, a[1] = se * h + $ * b + te * M + ae * X, a[2] = se * p + $ * S + te * z + ae * Y, a[3] = se * m + $ * A + te * F + ae * le, a[4] = (se = i[4]) * c + ($ = i[5]) * x + (te = i[6]) * I + (ae = i[7]) * U, a[5] = se * h + $ * b + te * M + ae * X, a[6] = se * p + $ * S + te * z + ae * Y, a[7] = se * m + $ * A + te * F + ae * le, a[8] = (se = i[8]) * c + ($ = i[9]) * x + (te = i[10]) * I + (ae = i[11]) * U, a[9] = se * h + $ * b + te * M + ae * X, a[10] = se * p + $ * S + te * z + ae * Y, a[11] = se * m + $ * A + te * F + ae * le, a[12] = (se = i[12]) * c + ($ = i[13]) * x + (te = i[14]) * I + (ae = i[15]) * U, a[13] = se * h + $ * b + te * M + ae * X, a[14] = se * p + $ * S + te * z + ae * Y, a[15] = se * m + $ * A + te * F + ae * le, a; }
            function Q(a, e, i) { var c, h, p, m, x, b, S, A, I, M, z, F, U = i[0], X = i[1], Y = i[2]; return e === a ? (a[12] = e[0] * U + e[4] * X + e[8] * Y + e[12], a[13] = e[1] * U + e[5] * X + e[9] * Y + e[13], a[14] = e[2] * U + e[6] * X + e[10] * Y + e[14], a[15] = e[3] * U + e[7] * X + e[11] * Y + e[15]) : (h = e[1], p = e[2], m = e[3], x = e[4], b = e[5], S = e[6], A = e[7], I = e[8], M = e[9], z = e[10], F = e[11], a[0] = c = e[0], a[1] = h, a[2] = p, a[3] = m, a[4] = x, a[5] = b, a[6] = S, a[7] = A, a[8] = I, a[9] = M, a[10] = z, a[11] = F, a[12] = c * U + x * X + I * Y + e[12], a[13] = h * U + b * X + M * Y + e[13], a[14] = p * U + S * X + z * Y + e[14], a[15] = m * U + A * X + F * Y + e[15]), a; }
            function ue(a, e, i) { var c = i[0], h = i[1], p = i[2]; return a[0] = e[0] * c, a[1] = e[1] * c, a[2] = e[2] * c, a[3] = e[3] * c, a[4] = e[4] * h, a[5] = e[5] * h, a[6] = e[6] * h, a[7] = e[7] * h, a[8] = e[8] * p, a[9] = e[9] * p, a[10] = e[10] * p, a[11] = e[11] * p, a[12] = e[12], a[13] = e[13], a[14] = e[14], a[15] = e[15], a; }
            function be(a, e, i) { var c = Math.sin(i), h = Math.cos(i), p = e[4], m = e[5], x = e[6], b = e[7], S = e[8], A = e[9], I = e[10], M = e[11]; return e !== a && (a[0] = e[0], a[1] = e[1], a[2] = e[2], a[3] = e[3], a[12] = e[12], a[13] = e[13], a[14] = e[14], a[15] = e[15]), a[4] = p * h + S * c, a[5] = m * h + A * c, a[6] = x * h + I * c, a[7] = b * h + M * c, a[8] = S * h - p * c, a[9] = A * h - m * c, a[10] = I * h - x * c, a[11] = M * h - b * c, a; }
            function Ie(a, e, i) { var c = Math.sin(i), h = Math.cos(i), p = e[0], m = e[1], x = e[2], b = e[3], S = e[8], A = e[9], I = e[10], M = e[11]; return e !== a && (a[4] = e[4], a[5] = e[5], a[6] = e[6], a[7] = e[7], a[12] = e[12], a[13] = e[13], a[14] = e[14], a[15] = e[15]), a[0] = p * h - S * c, a[1] = m * h - A * c, a[2] = x * h - I * c, a[3] = b * h - M * c, a[8] = p * c + S * h, a[9] = m * c + A * h, a[10] = x * c + I * h, a[11] = b * c + M * h, a; }
            function Be(a, e, i) { var c = Math.sin(i), h = Math.cos(i), p = e[0], m = e[1], x = e[2], b = e[3], S = e[4], A = e[5], I = e[6], M = e[7]; return e !== a && (a[8] = e[8], a[9] = e[9], a[10] = e[10], a[11] = e[11], a[12] = e[12], a[13] = e[13], a[14] = e[14], a[15] = e[15]), a[0] = p * h + S * c, a[1] = m * h + A * c, a[2] = x * h + I * c, a[3] = b * h + M * c, a[4] = S * h - p * c, a[5] = A * h - m * c, a[6] = I * h - x * c, a[7] = M * h - b * c, a; }
            function Ze(a, e) { return a[0] = e[0], a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = e[1], a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = e[2], a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a; }
            function ot(a, e, i) { var c, h, p, m = i[0], x = i[1], b = i[2], S = Math.hypot(m, x, b); return S < k ? null : (m *= S = 1 / S, x *= S, b *= S, c = Math.sin(e), h = Math.cos(e), a[0] = m * m * (p = 1 - h) + h, a[1] = x * m * p + b * c, a[2] = b * m * p - x * c, a[3] = 0, a[4] = m * x * p - b * c, a[5] = x * x * p + h, a[6] = b * x * p + m * c, a[7] = 0, a[8] = m * b * p + x * c, a[9] = x * b * p - m * c, a[10] = b * b * p + h, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a); }
            function At(a, e) { var i = e[0], c = e[1], h = e[2], p = e[3], m = i + i, x = c + c, b = h + h, S = i * m, A = c * m, I = c * x, M = h * m, z = h * x, F = h * b, U = p * m, X = p * x, Y = p * b; return a[0] = 1 - I - F, a[1] = A + Y, a[2] = M - X, a[3] = 0, a[4] = A - Y, a[5] = 1 - S - F, a[6] = z + U, a[7] = 0, a[8] = M + X, a[9] = z - U, a[10] = 1 - S - I, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a; }
            Math.hypot || (Math.hypot = function () { for (var a = 0, e = arguments.length; e--;)
                a += arguments[e] * arguments[e]; return Math.sqrt(a); });
            var kt = ie;
            function ct() { var a = new L(3); return L != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0), a; }
            function St(a) { var e = new L(3); return e[0] = a[0], e[1] = a[1], e[2] = a[2], e; }
            function Kt(a) { return Math.hypot(a[0], a[1], a[2]); }
            function bt(a, e, i) { var c = new L(3); return c[0] = a, c[1] = e, c[2] = i, c; }
            function ir(a, e, i) { return a[0] = e[0] + i[0], a[1] = e[1] + i[1], a[2] = e[2] + i[2], a; }
            function tr(a, e, i) { return a[0] = e[0] - i[0], a[1] = e[1] - i[1], a[2] = e[2] - i[2], a; }
            function Or(a, e, i) { return a[0] = e[0] * i[0], a[1] = e[1] * i[1], a[2] = e[2] * i[2], a; }
            function xt(a, e, i) { return a[0] = Math.min(e[0], i[0]), a[1] = Math.min(e[1], i[1]), a[2] = Math.min(e[2], i[2]), a; }
            function Pt(a, e, i) { return a[0] = Math.max(e[0], i[0]), a[1] = Math.max(e[1], i[1]), a[2] = Math.max(e[2], i[2]), a; }
            function Ft(a, e, i) { return a[0] = e[0] * i, a[1] = e[1] * i, a[2] = e[2] * i, a; }
            function gr(a, e, i, c) { return a[0] = e[0] + i[0] * c, a[1] = e[1] + i[1] * c, a[2] = e[2] + i[2] * c, a; }
            function Jr(a, e) { var i = e[0] - a[0], c = e[1] - a[1], h = e[2] - a[2]; return i * i + c * c + h * h; }
            function pi(a) { var e = a[0], i = a[1], c = a[2]; return e * e + i * i + c * c; }
            function Si(a, e) { return a[0] = -e[0], a[1] = -e[1], a[2] = -e[2], a; }
            function an(a, e) { var i = e[0], c = e[1], h = e[2], p = i * i + c * c + h * h; return p > 0 && (p = 1 / Math.sqrt(p)), a[0] = e[0] * p, a[1] = e[1] * p, a[2] = e[2] * p, a; }
            function Kr(a, e) { return a[0] * e[0] + a[1] * e[1] + a[2] * e[2]; }
            function mn(a, e, i) { var c = e[0], h = e[1], p = e[2], m = i[0], x = i[1], b = i[2]; return a[0] = h * b - p * x, a[1] = p * m - c * b, a[2] = c * x - h * m, a; }
            function Xs(a, e, i, c) { var h = e[0], p = e[1], m = e[2]; return a[0] = h + c * (i[0] - h), a[1] = p + c * (i[1] - p), a[2] = m + c * (i[2] - m), a; }
            function ln(a, e, i) { var c = e[0], h = e[1], p = e[2], m = i[3] * c + i[7] * h + i[11] * p + i[15]; return a[0] = (i[0] * c + i[4] * h + i[8] * p + i[12]) / (m = m || 1), a[1] = (i[1] * c + i[5] * h + i[9] * p + i[13]) / m, a[2] = (i[2] * c + i[6] * h + i[10] * p + i[14]) / m, a; }
            function Bs(a, e, i) { var c = e[0], h = e[1], p = e[2]; return a[0] = c * i[0] + h * i[3] + p * i[6], a[1] = c * i[1] + h * i[4] + p * i[7], a[2] = c * i[2] + h * i[5] + p * i[8], a; }
            function js(a, e, i) { var c = i[0], h = i[1], p = i[2], m = e[0], x = e[1], b = e[2], S = h * b - p * x, A = p * m - c * b, I = c * x - h * m, M = h * I - p * A, z = p * S - c * I, F = c * A - h * S, U = 2 * i[3]; return A *= U, I *= U, z *= 2, F *= 2, a[0] = m + (S *= U) + (M *= 2), a[1] = x + A + z, a[2] = b + I + F, a; }
            function ss(a, e) { return a[0] === e[0] && a[1] === e[1] && a[2] === e[2]; }
            var Gn = tr, Ua = Or, Xo = Kt;
            function $i() { var a = new L(4); return L != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 0), a; }
            function Ks(a, e, i) { return a[0] = e[0] * i, a[1] = e[1] * i, a[2] = e[2] * i, a[3] = e[3] * i, a; }
            function Io(a, e) { var i = e[0], c = e[1], h = e[2], p = e[3], m = i * i + c * c + h * h + p * p; return m > 0 && (m = 1 / Math.sqrt(m)), a[0] = i * m, a[1] = c * m, a[2] = h * m, a[3] = p * m, a; }
            function Gi(a, e, i) { var c = e[0], h = e[1], p = e[2], m = e[3]; return a[0] = i[0] * c + i[4] * h + i[8] * p + i[12] * m, a[1] = i[1] * c + i[5] * h + i[9] * p + i[13] * m, a[2] = i[2] * c + i[6] * h + i[10] * p + i[14] * m, a[3] = i[3] * c + i[7] * h + i[11] * p + i[15] * m, a; }
            function Po() { var a = new L(4); return L != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0), a[3] = 1, a; }
            function Ko(a) { return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a; }
            function Ue(a, e, i) { i *= .5; var c = e[0], h = e[1], p = e[2], m = e[3], x = Math.sin(i), b = Math.cos(i); return a[0] = c * b + m * x, a[1] = h * b + p * x, a[2] = p * b - h * x, a[3] = m * b - c * x, a; }
            function _t(a, e, i) { i *= .5; var c = e[0], h = e[1], p = e[2], m = e[3], x = Math.sin(i), b = Math.cos(i); return a[0] = c * b - p * x, a[1] = h * b + m * x, a[2] = p * b + c * x, a[3] = m * b - h * x, a; }
            ct(), $i();
            var Mt, cr, ur, Jt, vr, gn = Io, mi = (Mt = ct(), cr = bt(1, 0, 0), ur = bt(0, 1, 0), function (a, e, i) { var c = Kr(e, i); return c < -.999999 ? (mn(Mt, cr, e), Xo(Mt) < 1e-6 && mn(Mt, ur, e), an(Mt, Mt), function (h, p, m) { m *= .5; var x = Math.sin(m); h[0] = x * p[0], h[1] = x * p[1], h[2] = x * p[2], h[3] = Math.cos(m); }(a, Mt, Math.PI), a) : c > .999999 ? (a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a) : (mn(Mt, e, i), a[0] = Mt[0], a[1] = Mt[1], a[2] = Mt[2], a[3] = 1 + c, gn(a, a)); });
            function oi() { var a = new L(2); return L != Float32Array && (a[0] = 0, a[1] = 0), a; }
            function $a(a, e) { var i = new L(2); return i[0] = a, i[1] = e, i; }
            function Mo(a, e, i) { return a[0] = e[0] + i[0], a[1] = e[1] + i[1], a; }
            function Ys(a, e, i) { return a[0] = e[0] - i[0], a[1] = e[1] - i[1], a; }
            function Ga(a, e, i) { return a[0] = e[0] * i, a[1] = e[1] * i, a; }
            function wa(a) { return Math.hypot(a[0], a[1]); }
            function gc(a, e) { var i = e[0], c = e[1], h = i * i + c * c; return h > 0 && (h = 1 / Math.sqrt(h)), a[0] = e[0] * h, a[1] = e[1] * h, a; }
            function jn(a, e) { return a[0] * e[0] + a[1] * e[1]; }
            function ba(a) { return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a; }
            Po(), Po(), V(), oi();
            var pu, Ro, id = function () { if (vr)
                return Jt; function a(e, i, c, h) { this.cx = 3 * e, this.bx = 3 * (c - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * i, this.by = 3 * (h - i) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = i, this.p2x = c, this.p2y = h; } return vr = 1, Jt = a, a.prototype = { sampleCurveX: function (e) { return ((this.ax * e + this.bx) * e + this.cx) * e; }, sampleCurveY: function (e) { return ((this.ay * e + this.by) * e + this.cy) * e; }, sampleCurveDerivativeX: function (e) { return (3 * this.ax * e + 2 * this.bx) * e + this.cx; }, solveCurveX: function (e, i) { if (i === void 0 && (i = 1e-6), e < 0)
                    return 0; if (e > 1)
                    return 1; for (var c = e, h = 0; h < 8; h++) {
                    var p = this.sampleCurveX(c) - e;
                    if (Math.abs(p) < i)
                        return c;
                    var m = this.sampleCurveDerivativeX(c);
                    if (Math.abs(m) < 1e-6)
                        break;
                    c -= p / m;
                } var x = 0, b = 1; for (c = e, h = 0; h < 20 && (p = this.sampleCurveX(c), !(Math.abs(p - e) < i)); h++)
                    e > p ? x = c : b = c, c = .5 * (b - x) + x; return c; }, solve: function (e, i) { return this.sampleCurveY(this.solveCurveX(e, i)); } }, Jt; }(), Gf = ba(id);
            function sd() { if (Ro)
                return pu; function a(e, i) { this.x = e, this.y = i; } return Ro = 1, pu = a, a.prototype = { clone: function () { return new a(this.x, this.y); }, add: function (e) { return this.clone()._add(e); }, sub: function (e) { return this.clone()._sub(e); }, multByPoint: function (e) { return this.clone()._multByPoint(e); }, divByPoint: function (e) { return this.clone()._divByPoint(e); }, mult: function (e) { return this.clone()._mult(e); }, div: function (e) { return this.clone()._div(e); }, rotate: function (e) { return this.clone()._rotate(e); }, rotateAround: function (e, i) { return this.clone()._rotateAround(e, i); }, matMult: function (e) { return this.clone()._matMult(e); }, unit: function () { return this.clone()._unit(); }, perp: function () { return this.clone()._perp(); }, round: function () { return this.clone()._round(); }, mag: function () { return Math.sqrt(this.x * this.x + this.y * this.y); }, equals: function (e) { return this.x === e.x && this.y === e.y; }, dist: function (e) { return Math.sqrt(this.distSqr(e)); }, distSqr: function (e) { var i = e.x - this.x, c = e.y - this.y; return i * i + c * c; }, angle: function () { return Math.atan2(this.y, this.x); }, angleTo: function (e) { return Math.atan2(this.y - e.y, this.x - e.x); }, angleWith: function (e) { return this.angleWithSep(e.x, e.y); }, angleWithSep: function (e, i) { return Math.atan2(this.x * i - this.y * e, this.x * e + this.y * i); }, _matMult: function (e) { var i = e[2] * this.x + e[3] * this.y; return this.x = e[0] * this.x + e[1] * this.y, this.y = i, this; }, _add: function (e) { return this.x += e.x, this.y += e.y, this; }, _sub: function (e) { return this.x -= e.x, this.y -= e.y, this; }, _mult: function (e) { return this.x *= e, this.y *= e, this; }, _div: function (e) { return this.x /= e, this.y /= e, this; }, _multByPoint: function (e) { return this.x *= e.x, this.y *= e.y, this; }, _divByPoint: function (e) { return this.x /= e.x, this.y /= e.y, this; }, _unit: function () { return this._div(this.mag()), this; }, _perp: function () { var e = this.y; return this.y = this.x, this.x = -e, this; }, _rotate: function (e) { var i = Math.cos(e), c = Math.sin(e), h = c * this.x + i * this.y; return this.x = i * this.x - c * this.y, this.y = h, this; }, _rotateAround: function (e, i) { var c = Math.cos(e), h = Math.sin(e), p = i.y + h * (this.x - i.x) + c * (this.y - i.y); return this.x = i.x + c * (this.x - i.x) - h * (this.y - i.y), this.y = p, this; }, _round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this; } }, a.convert = function (e) { return e instanceof a ? e : Array.isArray(e) ? new a(e[0], e[1]) : e; }, pu; }
            var Et = ba(sd());
            function qa(a, e) { if (Array.isArray(a)) {
                if (!Array.isArray(e) || a.length !== e.length)
                    return !1;
                for (let i = 0; i < a.length; i++)
                    if (!qa(a[i], e[i]))
                        return !1;
                return !0;
            } if (typeof a == "object" && a !== null && e !== null) {
                if (typeof e != "object" || Object.keys(a).length !== Object.keys(e).length)
                    return !1;
                for (const i in a)
                    if (!qa(a[i], e[i]))
                        return !1;
                return !0;
            } return a === e; }
            const qf = Math.PI / 180, Qe = 180 / Math.PI;
            function Z(a) { return a * qf; }
            function re(a) { return a * Qe; }
            const _e = [[0, 0], [1, 0], [1, 1], [0, 1]];
            function Ae(a) { if (a <= 0)
                return 0; if (a >= 1)
                return 1; const e = a * a, i = e * a; return 4 * (a < .5 ? i : 3 * (a - e) + i - .75); }
            function Ee(a, e, i, c) { const h = new Gf(a, e, i, c); return function (p) { return h.solve(p); }; }
            const Re = Ee(.25, .1, .25, 1);
            function ke(a, e, i) { return Math.min(i, Math.max(e, a)); }
            function De(a, e, i) { return (i = ke((i - a) / (e - a), 0, 1)) * i * (3 - 2 * i); }
            function qe(a, e, i) { const c = i - e, h = ((a - e) % c + c) % c + e; return h === e ? i : h; }
            function tt(a, e, i) { if (!a.length)
                return i(null, []); let c = a.length; const h = new Array(a.length); let p = null; a.forEach((m, x) => { e(m, (b, S) => { b && (p = b), h[x] = S, --c == 0 && i(p, h); }); }); }
            function $e(a, ...e) { for (const i of e)
                for (const c in i)
                    a[c] = i[c]; return a; }
            let Ct = 1;
            function Ot() { return Ct++; }
            function Wt(a) { return a <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(a) / Math.LN2)); }
            function _r(a, e) { a.forEach(i => { e[i] && (e[i] = e[i].bind(e)); }); }
            function br(a, e, i) { const c = {}; for (const h in a)
                c[h] = e.call(this, a[h], h, a); return c; }
            function Mr(a, e, i) { const c = {}; for (const h in a)
                e.call(this, a[h], h, a) && (c[h] = a[h]); return c; }
            function Fr(a) { return Array.isArray(a) ? a.map(Fr) : typeof a == "object" && a ? br(a, Fr) : a; }
            const ai = {};
            function Br(a) { ai[a] || (typeof console < "u" && console.warn(a), ai[a] = !0); }
            function An(a, e, i) { return (i.y - a.y) * (e.x - a.x) > (e.y - a.y) * (i.x - a.x); }
            function en(a) { let e = 0; for (let i, c, h = 0, p = a.length, m = p - 1; h < p; m = h++)
                i = a[h], c = a[m], e += (c.x - i.x) * (i.y + c.y); return e; }
            function In([a, e, i]) { const c = Z(e + 90), h = Z(i); return { x: a * Math.cos(c) * Math.sin(h), y: a * Math.sin(c) * Math.sin(h), z: a * Math.cos(h), azimuthal: e, polar: i }; }
            function Dn(a) { return (typeof self < "u" || a !== void 0) && typeof WorkerGlobalScope < "u" && (a !== void 0 ? a : self) instanceof WorkerGlobalScope; }
            function vi(a) { const e = {}; if (a.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (i, c, h, p) => { const m = h || p; return e[c] = !m || m.toLowerCase(), ""; }), e["max-age"]) {
                const i = parseInt(e["max-age"], 10);
                isNaN(i) ? delete e["max-age"] : e["max-age"] = i;
            } return e; }
            let Mi = null;
            function qi(a, e) { return [a[4 * e], a[4 * e + 1], a[4 * e + 2], a[4 * e + 3]]; }
            function os(a, e, i, c) { for (; e < i;) {
                const h = e + i >> 1;
                a[h] < c ? e = h + 1 : i = h;
            } return e; }
            function Ha(a, e, i, c) { for (; e < i;) {
                const h = e + i >> 1;
                a[h] <= c ? e = h + 1 : i = h;
            } return e; }
            function _s(a) { return a > 0 ? 1 / (1.001 - a) : 1 + a; }
            function ys(a) { return a > 0 ? 1 - 1 / (1.001 - a) : -a; }
            function Ji(a, e, i) { return (a - e.min) * (i.max - i.min) / (e.max - e.min) + i.min; }
            const hs = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() { return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i; }, get API_TILEJSON_REGEX() { return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i; }, get API_SPRITE_REGEX() { return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i; }, get API_FONTS_REGEX() { return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i; }, get API_STYLE_REGEX() { return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i; }, get API_CDN_URL_REGEX() { return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i; }, get EVENTS_URL() { if (!hs.API_URL)
                    return null; try {
                    const a = new URL(hs.API_URL);
                    return a.hostname === "api.mapbox.cn" ? "https://events.mapbox.cn/events/v2" : a.hostname === "api.mapbox.com" ? "https://events.mapbox.com/events/v2" : null;
                }
                catch {
                    return null;
                } }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", RASTERARRAYS_URL_PREFIX: "rasterarrays/v1", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, DEFAULT_STYLE: "mapbox://styles/mapbox/standard", MAX_PARALLEL_IMAGE_REQUESTS: 16, DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm", MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm", MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm", GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf", TILES3D_URL_PREFIX: "3dtiles/v1" };
            function Ta(a) { return hs.API_URL_REGEX.test(a); }
            function _c(a) { return hs.API_SPRITE_REGEX.test(a); }
            let od, mu, Hf, ad, yc, ld;
            function kg() { return od == null && (od = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && typeof self.createImageBitmap == "function"), od; }
            const Yo = { now: () => ad !== void 0 ? ad : performance.now(), setNow(a) { ad = a; }, restoreNow() { ad = void 0; }, frame(a) { const e = requestAnimationFrame(a); return { cancel: () => cancelAnimationFrame(e) }; }, getImageData(a, e = 0) { const { width: i, height: c } = a; yc || (yc = document.createElement("canvas")); const h = yc.getContext("2d", { willReadFrequently: !0 }); if (!h)
                    throw new Error("failed to create canvas 2d context"); return (i > yc.width || c > yc.height) && (yc.width = i, yc.height = c), h.clearRect(-e, -e, i + 2 * e, c + 2 * e), h.drawImage(a, 0, 0, i, c), h.getImageData(-e, -e, i + 2 * e, c + 2 * e); }, resolveURL: a => (mu || (mu = document.createElement("a")), mu.href = a, mu.href), get devicePixelRatio() { return window.devicePixelRatio; }, get prefersReducedMotion() { return !!window.matchMedia && (Hf == null && (Hf = window.matchMedia("(prefers-reduced-motion: reduce)")), Hf.matches); }, hasCanvasFingerprintNoise() { if (ld !== void 0)
                    return ld; if (!kg())
                    return ld = !1, !1; const a = new OffscreenCanvas(85, 1), e = a.getContext("2d", { willReadFrequently: !0 }); let i = 0; for (let h = 0; h < a.width; ++h)
                    e.fillStyle = `rgba(${i++},${i++},${i++}, 255)`, e.fillRect(h, 0, 1, 1); const c = e.getImageData(0, 0, a.width, a.height); i = 0; for (let h = 0; h < c.data.length; ++h)
                    if (h % 4 != 3 && i++ !== c.data[h])
                        return ld = !0, !0; return ld = !1, !1; } };
            function Dg(a, e) { const i = a.indexOf("?"); if (i < 0)
                return `${a}?${new URLSearchParams(e).toString()}`; const c = new URLSearchParams(a.slice(i)); for (const h in e)
                c.set(h, e[h]); return `${a.slice(0, i)}?${c.toString()}`; }
            function Qs(a, e = { persistentParams: [] }) { const i = a.indexOf("?"); if (i < 0)
                return a; const c = new URLSearchParams, h = new URLSearchParams(a.slice(i)); for (const m of e.persistentParams) {
                const x = h.get(m);
                x && c.set(m, x);
            } const p = c.toString(); return `${a.slice(0, i)}${p.length > 0 ? `?${p}` : ""}`; }
            const Qo = "mapbox-tiles";
            let Wa = 500, Jo = 50;
            const Za = ["language", "worldview", "jobid"];
            let ko, cd;
            function Lg() { try {
                return caches;
            }
            catch { } }
            function Xa() { const a = Lg(); a && ko == null && (ko = a.open(Qo)); }
            let ud = 1 / 0;
            const Og = { supported: !1, testSupport: function (a) { !Wf && As && (Zf ? d0(a) : hd = a); } };
            let hd, As, Wf = !1, Zf = !1;
            const gu = typeof self < "u" ? self : {};
            function d0(a) { const e = a.createTexture(); a.bindTexture(a.TEXTURE_2D, e); try {
                if (a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, As), a.isContextLost())
                    return;
                Og.supported = !0;
            }
            catch { } a.deleteTexture(e), Wf = !0; }
            gu.document && (As = gu.document.createElement("img"), As.onload = function () { hd && d0(hd), hd = null, Zf = !0; }, As.onerror = function () { Wf = !0, hd = null; }, As.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
            const Xf = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Iconset: "Iconset", Image: "Image", Model: "Model" };
            typeof Object.freeze == "function" && Object.freeze(Xf);
            class Kf extends Error {
                constructor(e, i, c) { i === 401 && Ta(c) && (e += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(e), this.status = i, this.url = c; }
                toString() { return `${this.name}: ${this.message} (${this.status}): ${this.url}`; }
            }
            const Yr = Dn() ? () => self.worker.referrer : () => (location.protocol === "blob:" ? parent : self).location.href, _u = function (a, e) { if (!(/^file:/.test(i = a.url) || /^file:/.test(Yr()) && !/^\w+:/.test(i))) {
                if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal"))
                    return function (c, h) { const p = new AbortController, m = new Request(c.url, { method: c.method || "GET", body: c.body, credentials: c.credentials, headers: c.headers, referrer: Yr(), referrerPolicy: c.referrerPolicy, signal: p.signal }); let x = !1, b = !1; const S = (A = m.url).indexOf("sku=") > 0 && Ta(A); var A; c.type === "json" && m.headers.set("Accept", "application/json"); const I = (z, F, U) => { if (b)
                        return; if (z && z.message !== "SecurityError" && Br(z.toString()), F && U)
                        return M(F); const X = Date.now(); fetch(m).then(Y => { if (Y.ok) {
                        const le = S ? Y.clone() : null;
                        return M(Y, le, X);
                    } return h(new Kf(Y.statusText, Y.status, c.url)); }).catch(Y => { Y.name !== "AbortError" && h(new Error(`${Y.message} ${c.url}`)); }); }, M = (z, F, U) => { (c.type === "arrayBuffer" ? z.arrayBuffer() : c.type === "json" ? z.json() : z.text()).then(X => { b || (F && U && function (Y, le, se) { if (Xa(), ko == null)
                        return; const $ = vi(le.headers.get("Cache-Control") || ""); if ($["no-store"])
                        return; const te = { status: le.status, statusText: le.statusText, headers: new Headers }; le.headers.forEach((Te, Pe) => te.headers.set(Pe, Te)), $["max-age"] && te.headers.set("Expires", new Date(se + 1e3 * $["max-age"]).toUTCString()); const ae = te.headers.get("Expires"); if (!ae || new Date(ae).getTime() - se < 42e4)
                        return; let fe = Qs(Y.url, { persistentParams: Za }); if (le.status === 206) {
                        const Te = Y.headers.get("Range");
                        if (!Te)
                            return;
                        te.status = 200, fe = Dg(fe, { range: Te });
                    } (function (Te, Pe) { if (cd === void 0)
                        try {
                            new Response(new ReadableStream), cd = !0;
                        }
                        catch {
                            cd = !1;
                        } cd ? Pe(Te.body) : Te.blob().then(Pe).catch(Me => Br(Me.message)); })(le, Te => { const Pe = new Response((Me = le.status) !== 200 && Me !== 404 && [101, 103, 204, 205, 304].includes(Me) ? null : Te, te); var Me; Xa(), ko != null && ko.then(Oe => Oe.put(fe, Pe)).catch(Oe => Br(Oe.message)); }); }(m, F, U), x = !0, h(null, X, z.headers.get("Cache-Control"), z.headers.get("Expires"))); }).catch(X => { b || h(new Error(X.message)); }); }; return S ? function (z, F) { if (Xa(), ko == null)
                        return F(null); ko.then(U => { let X = Qs(z.url, { persistentParams: Za }); const Y = z.headers.get("Range"); Y && (X = Dg(X, { range: Y })), U.match(X).then(le => { const se = function ($) { if (!$)
                        return !1; const te = new Date($.headers.get("Expires") || 0), ae = vi($.headers.get("Cache-Control") || ""); return Number(te) > Date.now() && !ae["no-cache"]; }(le); U.delete(X).catch(F), se && U.put(X, le.clone()).catch(F), F(null, le, se); }).catch(F); }).catch(F); }(m, I) : I(null, null), { cancel: () => { b = !0, x || p.abort(); } }; }(a, e);
                if (Dn(self) && self.worker.actor)
                    return self.worker.actor.send("getResource", a, e, void 0, !0);
            } var i; return function (c, h) { const p = new XMLHttpRequest; p.open(c.method || "GET", c.url, !0), c.type === "arrayBuffer" && (p.responseType = "arraybuffer"); for (const m in c.headers)
                p.setRequestHeader(m, c.headers[m]); return c.type === "json" && (p.responseType = "text", p.setRequestHeader("Accept", "application/json")), p.withCredentials = c.credentials === "include", p.onerror = () => { h(new Error(p.statusText)); }, p.onload = () => { if ((p.status >= 200 && p.status < 300 || p.status === 0) && p.response !== null) {
                let m = p.response;
                if (c.type === "json")
                    try {
                        m = JSON.parse(p.response);
                    }
                    catch (x) {
                        return h(x);
                    }
                h(null, m, p.getResponseHeader("Cache-Control"), p.getResponseHeader("Expires"));
            }
            else
                h(new Kf(p.statusText, p.status, c.url)); }, p.send(c.body), { cancel: () => p.abort() }; }(a, e); }, yu = function (a, e) { return _u($e(a, { type: "arrayBuffer" }), e); };
            function Hb(a) { const e = document.createElement("a"); return e.href = a, e.protocol === location.protocol && e.host === location.host; }
            const f0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
            let vc, Cl;
            vc = [], Cl = 0;
            const vu = function (a, e) { if (Og.supported && (a.headers || (a.headers = {}), a.headers.accept = "image/webp,*/*"), Cl >= hs.MAX_PARALLEL_IMAGE_REQUESTS) {
                const p = { requestParameters: a, callback: e, cancelled: !1, cancel() { this.cancelled = !0; } };
                return vc.push(p), p;
            } Cl++; let i = !1; const c = () => { if (!i)
                for (i = !0, Cl--; vc.length && Cl < hs.MAX_PARALLEL_IMAGE_REQUESTS;) {
                    const p = vc.shift(), { requestParameters: m, callback: x, cancelled: b } = p;
                    b || (p.cancel = vu(m, x).cancel);
                } }, h = yu(a, (p, m, x, b) => { c(), p ? e(p) : m && (self.createImageBitmap ? function (S, A) { const I = new Blob([new Uint8Array(S)], { type: "image/png" }); createImageBitmap(I).then(M => { A(null, M); }).catch(M => { A(new Error(`Could not load image because of ${M.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)); }); }(m, (S, A) => e(S, A, x, b)) : function (S, A) { const I = new Image; I.onload = () => { A(null, I), URL.revokeObjectURL(I.src), I.onload = null, requestAnimationFrame(() => { I.src = f0; }); }, I.onerror = () => A(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")); const M = new Blob([new Uint8Array(S)], { type: "image/png" }); I.src = S.byteLength ? URL.createObjectURL(M) : f0; }(m, (S, A) => e(S, A, x, b))); }); return { cancel: () => { h.cancel(), c(); } }; };
            var p0, zg, xc, dd = { exports: {} }, xu = { exports: {} }, Yf = { exports: {} }, Fg = function () { if (xc)
                return dd.exports; xc = 1; var a = (p0 || (p0 = 1, xu.exports = function (i, c) { var h, p, m, x, b, S, A, I; for (p = i.length - (h = 3 & i.length), m = c, b = 3432918353, S = 461845907, I = 0; I < p;)
                A = 255 & i.charCodeAt(I) | (255 & i.charCodeAt(++I)) << 8 | (255 & i.charCodeAt(++I)) << 16 | (255 & i.charCodeAt(++I)) << 24, ++I, m = 27492 + (65535 & (x = 5 * (65535 & (m = (m ^= A = (65535 & (A = (A = (65535 & A) * b + (((A >>> 16) * b & 65535) << 16) & 4294967295) << 15 | A >>> 17)) * S + (((A >>> 16) * S & 65535) << 16) & 4294967295) << 13 | m >>> 19)) + ((5 * (m >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (x >>> 16) & 65535) << 16); switch (A = 0, h) {
                case 3: A ^= (255 & i.charCodeAt(I + 2)) << 16;
                case 2: A ^= (255 & i.charCodeAt(I + 1)) << 8;
                case 1: m ^= A = (65535 & (A = (A = (65535 & (A ^= 255 & i.charCodeAt(I))) * b + (((A >>> 16) * b & 65535) << 16) & 4294967295) << 15 | A >>> 17)) * S + (((A >>> 16) * S & 65535) << 16) & 4294967295;
            } return m ^= i.length, m = 2246822507 * (65535 & (m ^= m >>> 16)) + ((2246822507 * (m >>> 16) & 65535) << 16) & 4294967295, m = 3266489909 * (65535 & (m ^= m >>> 13)) + ((3266489909 * (m >>> 16) & 65535) << 16) & 4294967295, (m ^= m >>> 16) >>> 0; }), xu.exports), e = (zg || (zg = 1, Yf.exports = function (i, c) { for (var h, p = i.length, m = c ^ p, x = 0; p >= 4;)
                h = 1540483477 * (65535 & (h = 255 & i.charCodeAt(x) | (255 & i.charCodeAt(++x)) << 8 | (255 & i.charCodeAt(++x)) << 16 | (255 & i.charCodeAt(++x)) << 24)) + ((1540483477 * (h >>> 16) & 65535) << 16), m = 1540483477 * (65535 & m) + ((1540483477 * (m >>> 16) & 65535) << 16) ^ (h = 1540483477 * (65535 & (h ^= h >>> 24)) + ((1540483477 * (h >>> 16) & 65535) << 16)), p -= 4, ++x; switch (p) {
                case 3: m ^= (255 & i.charCodeAt(x + 2)) << 16;
                case 2: m ^= (255 & i.charCodeAt(x + 1)) << 8;
                case 1: m = 1540483477 * (65535 & (m ^= 255 & i.charCodeAt(x))) + ((1540483477 * (m >>> 16) & 65535) << 16);
            } return m = 1540483477 * (65535 & (m ^= m >>> 13)) + ((1540483477 * (m >>> 16) & 65535) << 16), (m ^= m >>> 15) >>> 0; }), Yf.exports); return dd.exports = a, dd.exports.murmur3 = a, dd.exports.murmur2 = e, dd.exports; }(), Js = ba(Fg);
            class Al {
                constructor(e, ...i) { $e(this, i[0] || {}), this.type = e; }
            }
            class Ng extends Al {
                constructor(e, i = {}) { super("error", $e({ error: e }, i)); }
            }
            function Bg(a, e, i) { i[a] && i[a].indexOf(e) !== -1 || (i[a] = i[a] || [], i[a].push(e)); }
            function Qf(a, e, i) { if (i && i[a]) {
                const c = i[a].indexOf(e);
                c !== -1 && i[a].splice(c, 1);
            } }
            class wc {
                on(e, i) { return this._listeners = this._listeners || {}, Bg(e, i, this._listeners), this; }
                off(e, i) { return Qf(e, i, this._listeners), Qf(e, i, this._oneTimeListeners), this; }
                once(e, i) { return i ? (this._oneTimeListeners = this._oneTimeListeners || {}, Bg(e, i, this._oneTimeListeners), this) : new Promise(c => { this.once(e, c); }); }
                fire(e, i) { const c = typeof e == "string" ? new Al(e, i) : e, h = c.type; if (this.listens(h)) {
                    c.target = this;
                    const p = this._listeners && this._listeners[h] ? this._listeners[h].slice() : [];
                    for (const b of p)
                        b.call(this, c);
                    const m = this._oneTimeListeners && this._oneTimeListeners[h] ? this._oneTimeListeners[h].slice() : [];
                    for (const b of m)
                        Qf(h, b, this._oneTimeListeners), b.call(this, c);
                    const x = this._eventedParent;
                    x && ($e(c, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), x.fire(c));
                }
                else
                    c instanceof Ng && console.error(c.error); return this; }
                listens(e) { return !!(this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e)); }
                setEventedParent(e, i) { return this._eventedParent = e, this._eventedParentData = i, this; }
            }
            class eo {
                constructor(e) { typeof e == "string" ? this.name = e : (this.name = e.name, this.iconsetId = e.iconsetId); }
                static from(e) { return new eo(e); }
                static toString(e) { return e.iconsetId ? `${e.name}${e.iconsetId}` : e.name; }
                static parse(e) { const [i, c] = e.split(""); return new eo({ name: i, iconsetId: c }); }
                static isEqual(e, i) { return e.name === i.name && e.iconsetId === i.iconsetId; }
                toString() { return eo.toString(this); }
                serialize() { return { name: this.name, iconsetId: this.iconsetId }; }
            }
            var jg, Jf = {}, fd = function () { if (jg)
                return Jf; jg = 1; var a = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] }; function e(p) { return (p = Math.round(p)) < 0 ? 0 : p > 255 ? 255 : p; } function i(p) { return e(p[p.length - 1] === "%" ? parseFloat(p) / 100 * 255 : parseInt(p)); } function c(p) { return (m = p[p.length - 1] === "%" ? parseFloat(p) / 100 : parseFloat(p)) < 0 ? 0 : m > 1 ? 1 : m; var m; } function h(p, m, x) { return x < 0 ? x += 1 : x > 1 && (x -= 1), 6 * x < 1 ? p + (m - p) * x * 6 : 2 * x < 1 ? m : 3 * x < 2 ? p + (m - p) * (2 / 3 - x) * 6 : p; } try {
                Jf.parseCSSColor = function (p) { var m, x = p.replace(/ /g, "").toLowerCase(); if (x in a)
                    return a[x].slice(); if (x[0] === "#")
                    return x.length === 4 ? (m = parseInt(x.substr(1), 16)) >= 0 && m <= 4095 ? [(3840 & m) >> 4 | (3840 & m) >> 8, 240 & m | (240 & m) >> 4, 15 & m | (15 & m) << 4, 1] : null : x.length === 7 && (m = parseInt(x.substr(1), 16)) >= 0 && m <= 16777215 ? [(16711680 & m) >> 16, (65280 & m) >> 8, 255 & m, 1] : null; var b = x.indexOf("("), S = x.indexOf(")"); if (b !== -1 && S + 1 === x.length) {
                    var A = x.substr(0, b), I = x.substr(b + 1, S - (b + 1)).split(","), M = 1;
                    switch (A) {
                        case "rgba":
                            if (I.length !== 4)
                                return null;
                            M = c(I.pop());
                        case "rgb": return I.length !== 3 ? null : [i(I[0]), i(I[1]), i(I[2]), M];
                        case "hsla":
                            if (I.length !== 4)
                                return null;
                            M = c(I.pop());
                        case "hsl":
                            if (I.length !== 3)
                                return null;
                            var z = (parseFloat(I[0]) % 360 + 360) % 360 / 360, F = c(I[1]), U = c(I[2]), X = U <= .5 ? U * (F + 1) : U + F - U * F, Y = 2 * U - X;
                            return [e(255 * h(Y, X, z + 1 / 3)), e(255 * h(Y, X, z)), e(255 * h(Y, X, z - 1 / 3)), M];
                        default: return null;
                    }
                } return null; };
            }
            catch { } return Jf; }();
            class nn {
                constructor(e, i, c, h = 1) { this.r = e, this.g = i, this.b = c, this.a = h; }
                static parse(e) { if (!e)
                    return; if (e instanceof nn)
                    return e; if (typeof e != "string")
                    return; const i = fd.parseCSSColor(e); return i ? new nn(i[0] / 255 * i[3], i[1] / 255 * i[3], i[2] / 255 * i[3], i[3]) : void 0; }
                toStringPremultipliedAlpha() { const [e, i, c, h] = this.a === 0 ? [0, 0, 0, 0] : [255 * this.r / this.a, 255 * this.g / this.a, 255 * this.b / this.a, this.a]; return `rgba(${Math.round(e)},${Math.round(i)},${Math.round(c)},${h})`; }
                toString() { const [e, i, c, h] = [this.r, this.g, this.b, this.a]; return `rgba(${Math.round(255 * e)},${Math.round(255 * i)},${Math.round(255 * c)},${h})`; }
                toRenderColor(e) { const { r: i, g: c, b: h, a: p } = this; return new m0(e, i, c, h, p); }
                clone() { return new nn(this.r, this.g, this.b, this.a); }
            }
            class m0 {
                constructor(e, i, c, h, p) { if (e) {
                    const m = e.image.height, x = m * m;
                    i = p === 0 ? 0 : i / p * (m - 1), c = p === 0 ? 0 : c / p * (m - 1), h = p === 0 ? 0 : h / p * (m - 1);
                    const b = Math.floor(i), S = Math.floor(c), A = Math.floor(h), I = Math.ceil(i), M = Math.ceil(c), z = Math.ceil(h), F = i - b, U = c - S, X = h - A, Y = e.image.data, le = 4 * (b + S * x + A * m), se = 4 * (b + S * x + z * m), $ = 4 * (b + M * x + A * m), te = 4 * (b + M * x + z * m), ae = 4 * (I + S * x + A * m), fe = 4 * (I + S * x + z * m), Te = 4 * (I + M * x + A * m), Pe = 4 * (I + M * x + z * m);
                    if (le < 0 || Pe >= Y.length)
                        throw new Error("out of range");
                    this.r = nr(nr(nr(Y[le], Y[se], X), nr(Y[$], Y[te], X), U), nr(nr(Y[ae], Y[fe], X), nr(Y[Te], Y[Pe], X), U), F) / 255 * p, this.g = nr(nr(nr(Y[le + 1], Y[se + 1], X), nr(Y[$ + 1], Y[te + 1], X), U), nr(nr(Y[ae + 1], Y[fe + 1], X), nr(Y[Te + 1], Y[Pe + 1], X), U), F) / 255 * p, this.b = nr(nr(nr(Y[le + 2], Y[se + 2], X), nr(Y[$ + 2], Y[te + 2], X), U), nr(nr(Y[ae + 2], Y[fe + 2], X), nr(Y[Te + 2], Y[Pe + 2], X), U), F) / 255 * p, this.a = p;
                }
                else
                    this.r = i, this.g = c, this.b = h, this.a = p; }
                toArray() { const { r: e, g: i, b: c, a: h } = this; return h === 0 ? [0, 0, 0, 0] : [255 * e / h, 255 * i / h, 255 * c / h, h]; }
                toHslaArray() { if (this.a === 0)
                    return [0, 0, 0, 0]; const { r: e, g: i, b: c, a: h } = this, p = Math.min(Math.max(e / h, 0), 1), m = Math.min(Math.max(i / h, 0), 1), x = Math.min(Math.max(c / h, 0), 1), b = Math.min(p, m, x), S = Math.max(p, m, x), A = (b + S) / 2; if (b === S)
                    return [0, 0, 100 * A, h]; const I = S - b, M = A > .5 ? I / (2 - S - b) : I / (S + b); let z = 0; return S === p ? z = (m - x) / I + (m < x ? 6 : 0) : S === m ? z = (x - p) / I + 2 : S === x && (z = (p - m) / I + 4), z *= 60, [Math.min(Math.max(z, 0), 360), Math.min(Math.max(100 * M, 0), 100), Math.min(Math.max(100 * A, 0), 100), h]; }
                toArray01() { const { r: e, g: i, b: c, a: h } = this; return h === 0 ? [0, 0, 0, 0] : [e / h, i / h, c / h, h]; }
                toArray01Scaled(e) { const { r: i, g: c, b: h, a: p } = this; return p === 0 ? [0, 0, 0] : [i / p * e, c / p * e, h / p * e]; }
                toArray01PremultipliedAlpha() { const { r: e, g: i, b: c, a: h } = this; return [e, i, c, h]; }
                toArray01Linear() { const { r: e, g: i, b: c, a: h } = this; return h === 0 ? [0, 0, 0, 0] : [Math.pow(e / h, 2.2), Math.pow(i / h, 2.2), Math.pow(c / h, 2.2), h]; }
            }
            function nr(a, e, i) { return a * (1 - i) + e * i; }
            function g0(a, e, i) { return a.map((c, h) => nr(c, e[h], i)); }
            function ep(a) { return a * a * a * a * a; }
            nn.black = new nn(0, 0, 0, 1), nn.white = new nn(1, 1, 1, 1), nn.transparent = new nn(0, 0, 0, 0), nn.red = new nn(1, 0, 0, 1), nn.blue = new nn(0, 0, 1, 1);
            var tp = Object.freeze({ __proto__: null, array: g0, color: function (a, e, i) { return new nn(nr(a.r, e.r, i), nr(a.g, e.g, i), nr(a.b, e.b, i), nr(a.a, e.a, i)); }, easeIn: ep, number: nr });
            function pd(a, ...e) { for (const i of e)
                for (const c in i)
                    a[c] = i[c]; return a; }
            class Do extends Error {
                constructor(e, i) { super(i), this.message = i, this.key = e; }
            }
            class bc {
                constructor(e, i = []) { this.parent = e, this.bindings = {}; for (const [c, h] of i)
                    this.bindings[c] = h; }
                concat(e) { return new bc(this, e); }
                get(e) { if (this.bindings[e])
                    return this.bindings[e]; if (this.parent)
                    return this.parent.get(e); throw new Error(`${e} not found in scope.`); }
                has(e) { return !!this.bindings[e] || !!this.parent && this.parent.has(e); }
            }
            const Il = { kind: "null" }, Qt = { kind: "number" }, bn = { kind: "string" }, dn = { kind: "boolean" }, Vs = { kind: "color" }, Pl = { kind: "object" }, un = { kind: "value" }, Tc = { kind: "collator" }, md = { kind: "formatted" }, gd = { kind: "resolvedImage" };
            function Is(a, e) { return { kind: "array", itemType: a, N: e }; }
            function Ri(a) { if (a.kind === "array") {
                const e = Ri(a.itemType);
                return typeof a.N == "number" ? `array<${e}, ${a.N}>` : a.itemType.kind === "value" ? "array" : `array<${e}>`;
            } return a.kind; }
            const Wb = [Il, Qt, bn, dn, Vs, md, Pl, Is(un), gd];
            function _d(a, e) { if (e.kind === "error")
                return null; if (a.kind === "array") {
                if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !_d(a.itemType, e.itemType)) && (typeof a.N != "number" || a.N === e.N))
                    return null;
            }
            else {
                if (a.kind === e.kind)
                    return null;
                if (a.kind === "value") {
                    for (const i of Wb)
                        if (!_d(i, e))
                            return null;
                }
            } return `Expected ${Ri(a)} but found ${Ri(e)} instead.`; }
            function Vg(a, e) { return e.some(i => i.kind === a.kind); }
            function wu(a, e) { return e.some(i => i === "null" ? a === null : i === "array" ? Array.isArray(a) : i === "object" ? a && !Array.isArray(a) && typeof a == "object" : i === typeof a); }
            class Ml {
                constructor(e, i, c) { this.sensitivity = e ? i ? "variant" : "case" : i ? "accent" : "base", this.locale = c, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" }); }
                compare(e, i) { return this.collator.compare(e, i); }
                resolvedLocale() { return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale; }
            }
            class rp {
                constructor(e, i, c, h, p) { this.text = e.normalize ? e.normalize() : e, this.image = i, this.scale = c, this.fontStack = h, this.textColor = p; }
            }
            class Ps {
                constructor(e) { this.sections = e; }
                static fromString(e) { return new Ps([new rp(e, null, null, null, null)]); }
                isEmpty() { return this.sections.length === 0 || !this.sections.some(e => e.text.length !== 0 || !!e.image && e.image.hasPrimary()); }
                static factory(e) { return e instanceof Ps ? e : Ps.fromString(e); }
                toString() { return this.sections.length === 0 ? "" : this.sections.map(e => e.text).join(""); }
                serialize() { const e = ["format"]; for (const i of this.sections) {
                    if (i.image) {
                        const h = i.image.getPrimary().id.toString();
                        e.push(["image", h]);
                        continue;
                    }
                    e.push(i.text);
                    const c = {};
                    i.fontStack && (c["text-font"] = ["literal", i.fontStack.split(",")]), i.scale && (c["font-scale"] = i.scale), i.textColor && (c["text-color"] = ["rgba"].concat(i.textColor.toRenderColor(null).toArray())), e.push(c);
                } return e; }
            }
            class ea {
                constructor(e, i = {}) { if (this.id = eo.from(e), this.options = Object.assign({}, i), i.transform) {
                    const { a: c, b: h, c: p, d: m, e: x, f: b } = i.transform;
                    this.options.transform = new DOMMatrix([c, h, p, m, x, b]);
                }
                else
                    this.options.transform = new DOMMatrix([1, 0, 0, 1, 0, 0]); }
                toString() { const { a: e, b: i, c, d: h, e: p, f: m } = this.options.transform; return JSON.stringify({ name: this.id.name, iconsetId: this.id.iconsetId, params: this.options.params, transform: { a: e, b: i, c, d: h, e: p, f: m } }); }
                static parse(e) { let i, c, h, p; try {
                    ({ name: i, iconsetId: c, params: h, transform: p } = JSON.parse(e) || {});
                }
                catch {
                    return null;
                } if (!i)
                    return null; const { a: m, b: x, c: b, d: S, e: A, f: I } = p || {}; return new ea({ name: i, iconsetId: c }, { params: h, transform: new DOMMatrix([m, x, b, S, A, I]) }); }
                scaleSelf(e, i) { return this.options.transform.scaleSelf(e, i), this; }
            }
            class Us {
                constructor(e, i, c, h, p = !1) { this.primaryId = eo.from(e), this.primaryOptions = i, c && (this.secondaryId = eo.from(c)), this.secondaryOptions = h, this.available = p; }
                toString() { return this.primaryId && this.secondaryId ? `[${this.primaryId.name},${this.secondaryId.name}]` : this.primaryId.name; }
                hasPrimary() { return !!this.primaryId; }
                getPrimary() { return new ea(this.primaryId, this.primaryOptions); }
                hasSecondary() { return !!this.secondaryId; }
                getSecondary() { return this.secondaryId ? new ea(this.secondaryId, this.secondaryOptions) : null; }
                static from(e) { return typeof e == "string" ? Us.build({ name: e }) : e; }
                static build(e, i, c, h) { return !e || typeof e == "object" && !("name" in e) ? null : new Us(e, c, i, h); }
            }
            function _0(a, e, i, c) { return typeof a == "number" && a >= 0 && a <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof i == "number" && i >= 0 && i <= 255 ? c === void 0 || typeof c == "number" && c >= 0 && c <= 1 ? null : `Invalid rgba value [${[a, e, i, c].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof c == "number" ? [a, e, i, c] : [a, e, i]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`; }
            function bu(a) { if (a === null || typeof a == "string" || typeof a == "boolean" || typeof a == "number" || a instanceof nn || a instanceof Ml || a instanceof Ps || a instanceof Us)
                return !0; if (Array.isArray(a)) {
                for (const e of a)
                    if (!bu(e))
                        return !1;
                return !0;
            } if (typeof a == "object") {
                for (const e in a)
                    if (!bu(a[e]))
                        return !1;
                return !0;
            } return !1; }
            function ji(a) { if (a === null)
                return Il; if (typeof a == "string")
                return bn; if (typeof a == "boolean")
                return dn; if (typeof a == "number")
                return Qt; if (a instanceof nn)
                return Vs; if (a instanceof Ml)
                return Tc; if (a instanceof Ps)
                return md; if (a instanceof Us)
                return gd; if (Array.isArray(a)) {
                const e = a.length;
                let i;
                for (const c of a) {
                    const h = ji(c);
                    if (i) {
                        if (i === h)
                            continue;
                        i = un;
                        break;
                    }
                    i = h;
                }
                return Is(i || un, e);
            } return Pl; }
            function Ms(a) { const e = typeof a; return a === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(a) : a instanceof nn ? a.toStringPremultipliedAlpha() : a instanceof Ps || a instanceof Us ? a.toString() : JSON.stringify(a); }
            class Rr {
                constructor(e, i) { this.type = e, this.value = i; }
                static parse(e, i) { if (e.length !== 2)
                    return i.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`); if (!bu(e[1]))
                    return i.error("invalid value"); const c = e[1]; let h = ji(c); const p = i.expectedType; return h.kind !== "array" || h.N !== 0 || !p || p.kind !== "array" || typeof p.N == "number" && p.N !== 0 || (h = p), new Rr(h, c); }
                evaluate() { return this.value; }
                eachChild() { }
                outputDefined() { return !0; }
                serialize() { return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof nn ? ["rgba"].concat(this.value.toRenderColor(null).toArray()) : this.value instanceof Ps ? this.value.serialize() : this.value; }
            }
            class Ut {
                constructor(e) { this.name = "ExpressionEvaluationError", this.message = e; }
                toJSON() { return this.message; }
            }
            const yd = { string: bn, number: Qt, boolean: dn, object: Pl };
            class dr {
                constructor(e, i) { this.type = e, this.args = i; }
                static parse(e, i) { if (e.length < 2)
                    return i.error("Expected at least one argument."); let c, h = 1; const p = e[0]; if (p === "array") {
                    let x, b;
                    if (e.length > 2) {
                        const S = e[1];
                        if (typeof S != "string" || !(S in yd) || S === "object")
                            return i.error("The item type argument of \"array\" must be one of string, number, boolean", 1);
                        x = yd[S], h++;
                    }
                    else
                        x = un;
                    if (e.length > 3) {
                        if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2])))
                            return i.error("The length argument to \"array\" must be a positive integer literal", 2);
                        b = e[2], h++;
                    }
                    c = Is(x, b);
                }
                else
                    c = yd[p]; const m = []; for (; h < e.length; h++) {
                    const x = i.parse(e[h], h, un);
                    if (!x)
                        return null;
                    m.push(x);
                } return new dr(c, m); }
                evaluate(e) { for (let i = 0; i < this.args.length; i++) {
                    const c = this.args[i].evaluate(e);
                    if (!_d(this.type, ji(c)))
                        return c;
                    if (i === this.args.length - 1)
                        throw new Ut(`The expression ${JSON.stringify(this.args[i].serialize())} evaluated to ${Ri(ji(c))} but was expected to be of type ${Ri(this.type)}.`);
                } return null; }
                eachChild(e) { this.args.forEach(e); }
                outputDefined() { return this.args.every(e => e.outputDefined()); }
                serialize() { const e = this.type, i = [e.kind]; if (e.kind === "array") {
                    const c = e.itemType;
                    if (c.kind === "string" || c.kind === "number" || c.kind === "boolean") {
                        i.push(c.kind);
                        const h = e.N;
                        (typeof h == "number" || this.args.length > 1) && i.push(h);
                    }
                } return i.concat(this.args.map(c => c.serialize())); }
            }
            class Sc {
                constructor(e) { this.type = md, this.sections = e; }
                static parse(e, i) { if (e.length < 2)
                    return i.error("Expected at least one argument."); const c = e[1]; if (!Array.isArray(c) && typeof c == "object")
                    return i.error("First argument must be an image or text section."); const h = []; let p = !1; for (let m = 1; m <= e.length - 1; ++m) {
                    const x = e[m];
                    if (p && typeof x == "object" && !Array.isArray(x)) {
                        p = !1;
                        let b = null;
                        if (x["font-scale"] && (b = i.parseObjectValue(x["font-scale"], m, "font-scale", Qt), !b))
                            return null;
                        let S = null;
                        if (x["text-font"] && (S = i.parseObjectValue(x["text-font"], m, "text-font", Is(bn)), !S))
                            return null;
                        let A = null;
                        if (x["text-color"] && (A = i.parseObjectValue(x["text-color"], m, "text-color", Vs), !A))
                            return null;
                        const I = h[h.length - 1];
                        I.scale = b, I.font = S, I.textColor = A;
                    }
                    else {
                        const b = i.parse(e[m], m, un);
                        if (!b)
                            return null;
                        const S = b.type.kind;
                        if (S !== "string" && S !== "value" && S !== "null" && S !== "resolvedImage")
                            return i.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                        p = !0, h.push({ content: b, scale: null, font: null, textColor: null });
                    }
                } return new Sc(h); }
                evaluate(e) { return new Ps(this.sections.map(i => { const c = i.content.evaluate(e); return ji(c) === gd ? new rp("", c, null, null, null) : new rp(Ms(c), null, i.scale ? i.scale.evaluate(e) : null, i.font ? i.font.evaluate(e).join(",") : null, i.textColor ? i.textColor.evaluate(e) : null); })); }
                eachChild(e) { for (const i of this.sections)
                    e(i.content), i.scale && e(i.scale), i.font && e(i.font), i.textColor && e(i.textColor); }
                outputDefined() { return !1; }
                serialize() { const e = ["format"]; for (const i of this.sections) {
                    e.push(i.content.serialize());
                    const c = {};
                    i.scale && (c["font-scale"] = i.scale.serialize()), i.font && (c["text-font"] = i.font.serialize()), i.textColor && (c["text-color"] = i.textColor.serialize()), e.push(c);
                } return e; }
            }
            class Tu {
                constructor(e, i, c, h) { this._imageWarnHistory = {}, this.type = gd, this.namePrimary = e, this.nameSecondary = i, c && (this.paramsPrimary = c.params, this.iconsetIdPrimary = c.iconset ? c.iconset.id : void 0), h && (this.paramsSecondary = h.params, this.iconsetIdSecondary = h.iconset ? h.iconset.id : void 0); }
                static parse(e, i) { if (e.length < 2)
                    return i.error("Expected two or more arguments."); let c = 1; const h = []; function p() { if (c < e.length) {
                    const x = i.parse(e[c], c++, bn);
                    return x ? (h.push({ image: x, options: {} }), !0) : (i.error(h.length ? "Secondary image variant is not a string." : "No image name provided."), !1);
                } return !0; } function m() { if (c < e.length) {
                    const b = e[c];
                    if ((x = b) === null || typeof x != "object" || Array.isArray(x))
                        return !0;
                    const S = b.params, A = b.iconset, I = i.concat(c);
                    if (!S && !A)
                        return c++, !0;
                    if (S) {
                        if (typeof S != "object" || S.constructor !== Object)
                            return I.error("Image options \"params\" should be an object"), !1;
                        const M = {}, z = I.concat(void 0, "params");
                        for (const F in S) {
                            if (!F)
                                return z.error("Image parameter name should be non-empty"), !1;
                            const U = z.concat(void 0, F).parse(S[F], void 0, Vs, void 0, { typeAnnotation: "coerce" });
                            if (!U)
                                return !1;
                            M[F] = U;
                        }
                        h[h.length - 1].options.params = M;
                    }
                    if (A) {
                        if (typeof A != "object" || A.constructor !== Object)
                            return I.error("Image options \"iconset\" should be an object"), !1;
                        if (!A.id)
                            return I.error("Image options \"iconset\" should have an \"id\" property"), !1;
                        h[h.length - 1].options.iconset = A;
                    }
                    return c++, !0;
                } var x; return !0; } for (let x = 0; x < 2; x++)
                    if (!p() || !m())
                        return; return new Tu(h[0].image, h[1] ? h[1].image : void 0, h[0].options, h[1] ? h[1].options : void 0); }
                evaluateParams(e, i) { const c = {}; if (i) {
                    for (const h in i)
                        if (i[h])
                            try {
                                c[h] = i[h].evaluate(e);
                            }
                            catch {
                                continue;
                            }
                    if (Object.keys(c).length !== 0)
                        return { params: c };
                } }
                evaluate(e) { const i = { name: this.namePrimary.evaluate(e), iconsetId: this.iconsetIdPrimary }, c = this.nameSecondary ? { name: this.nameSecondary.evaluate(e), iconsetId: this.iconsetIdSecondary } : void 0, h = Us.build(i, c, this.paramsPrimary ? this.evaluateParams(e, this.paramsPrimary) : void 0, this.paramsSecondary ? this.evaluateParams(e, this.paramsSecondary) : void 0); if (h && e.availableImages) {
                    const p = h.getPrimary().id;
                    if (h.available = e.availableImages.some(m => eo.isEqual(m, p)), h.available) {
                        const m = h.getSecondary() ? h.getSecondary().id : null;
                        m && (h.available = e.availableImages.some(x => eo.isEqual(x, m)));
                    }
                } return h; }
                eachChild(e) { if (e(this.namePrimary), this.paramsPrimary)
                    for (const i in this.paramsPrimary)
                        this.paramsPrimary[i] && e(this.paramsPrimary[i]); if (this.nameSecondary && (e(this.nameSecondary), this.paramsSecondary))
                    for (const i in this.paramsSecondary)
                        this.paramsSecondary[i] && e(this.paramsSecondary[i]); }
                outputDefined() { return !1; }
                serializeOptions(e, i) { const c = {}; if (i && (c.iconset = { id: i }), e) {
                    c.params = {};
                    for (const h in e)
                        e[h] && (c.params[h] = e[h].serialize());
                } return Object.keys(c).length > 0 ? c : void 0; }
                serialize() { const e = ["image", this.namePrimary.serialize()]; if (this.paramsPrimary || this.iconsetIdPrimary) {
                    const i = this.serializeOptions(this.paramsPrimary, this.iconsetIdPrimary);
                    i && e.push(i);
                } if (this.nameSecondary && (e.push(this.nameSecondary.serialize()), this.paramsSecondary || this.iconsetIdSecondary)) {
                    const i = this.serializeOptions(this.paramsSecondary, this.iconsetIdSecondary);
                    i && e.push(i);
                } return e; }
            }
            function fr(a) { return a instanceof Number ? "number" : a instanceof String ? "string" : a instanceof Boolean ? "boolean" : Array.isArray(a) ? "array" : a === null ? "null" : typeof a; }
            const y0 = { "to-boolean": dn, "to-color": Vs, "to-number": Qt, "to-string": bn };
            class ta {
                constructor(e, i) { this.type = e, this.args = i; }
                static parse(e, i) { if (e.length < 2)
                    return i.error("Expected at least one argument."); const c = e[0], h = []; let p = Il; if (c === "to-array") {
                    if (!Array.isArray(e[1]))
                        return null;
                    const m = e[1].length;
                    if (i.expectedType) {
                        if (i.expectedType.kind !== "array")
                            return i.error(`Expected ${i.expectedType.kind} but found array.`);
                        p = Is(i.expectedType.itemType, m);
                    }
                    else {
                        if (!(m > 0 && bu(e[1][0])))
                            return null;
                        p = Is(ji(e[1][0]), m);
                    }
                    for (let x = 0; x < m; x++) {
                        const b = e[1][x];
                        let S;
                        if (fr(b) === "array")
                            S = i.parse(b, void 0, p.itemType);
                        else {
                            const A = fr(b);
                            if (A !== p.itemType.kind)
                                return i.error(`Expected ${p.itemType.kind} but found ${A}.`);
                            S = i.registry.literal.parse(["literal", b === void 0 ? null : b], i);
                        }
                        if (!S)
                            return null;
                        h.push(S);
                    }
                }
                else {
                    if ((c === "to-boolean" || c === "to-string") && e.length !== 2)
                        return i.error("Expected one argument.");
                    p = y0[c];
                    for (let m = 1; m < e.length; m++) {
                        const x = i.parse(e[m], m, un);
                        if (!x)
                            return null;
                        h.push(x);
                    }
                } return new ta(p, h); }
                evaluate(e) { if (this.type.kind === "boolean")
                    return !!this.args[0].evaluate(e); if (this.type.kind === "color") {
                    let i, c;
                    for (const h of this.args) {
                        if (i = h.evaluate(e), c = null, i instanceof nn)
                            return i;
                        if (typeof i == "string") {
                            const p = e.parseColor(i);
                            if (p)
                                return p;
                        }
                        else if (Array.isArray(i) && (c = i.length < 3 || i.length > 4 ? `Invalid rbga value ${JSON.stringify(i)}: expected an array containing either three or four numeric values.` : _0(i[0], i[1], i[2], i[3]), !c))
                            return new nn(i[0] / 255, i[1] / 255, i[2] / 255, i[3]);
                    }
                    throw new Ut(c || `Could not parse color from value '${typeof i == "string" ? i : String(JSON.stringify(i))}'`);
                } if (this.type.kind === "number") {
                    let i = null;
                    for (const c of this.args) {
                        if (i = c.evaluate(e), i === null)
                            return 0;
                        const h = Number(i);
                        if (!isNaN(h))
                            return h;
                    }
                    throw new Ut(`Could not convert ${JSON.stringify(i)} to number.`);
                } return this.type.kind === "formatted" ? Ps.fromString(Ms(this.args[0].evaluate(e))) : this.type.kind === "resolvedImage" ? Us.build(Ms(this.args[0].evaluate(e))) : this.type.kind === "array" ? this.args.map(i => i.evaluate(e)) : Ms(this.args[0].evaluate(e)); }
                eachChild(e) { this.args.forEach(e); }
                outputDefined() { return this.args.every(e => e.outputDefined()); }
                serialize() { if (this.type.kind === "formatted")
                    return new Sc([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize(); if (this.type.kind === "resolvedImage")
                    return new Tu(this.args[0]).serialize(); const e = this.type.kind === "array" ? [] : [`to-${this.type.kind}`]; return this.eachChild(i => { e.push(i.serialize()); }), e; }
            }
            const v0 = ["Unknown", "Point", "LineString", "Polygon"];
            class np {
                constructor(e, i) { this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = e, this.options = i; }
                id() { return this.feature && this.feature.id !== void 0 ? this.feature.id : null; }
                geometryType() { return this.feature ? typeof this.feature.type == "number" ? v0[this.feature.type] : this.feature.type : null; }
                geometry() { return this.feature && "geometry" in this.feature ? this.feature.geometry : null; }
                canonicalID() { return this.canonical; }
                properties() { return this.feature && this.feature.properties || {}; }
                measureLight(e) { return this.globals.brightness || 0; }
                distanceFromCenter() { if (this.featureTileCoord && this.featureDistanceData) {
                    const e = this.featureDistanceData.center, i = this.featureDistanceData.scale, { x: c, y: h } = this.featureTileCoord;
                    return this.featureDistanceData.bearing[0] * (c * i - e[0]) + this.featureDistanceData.bearing[1] * (h * i - e[1]);
                } return 0; }
                parseColor(e) { let i = this._parseColorCache[e]; return i || (i = this._parseColorCache[e] = nn.parse(e)), i; }
                getConfig(e) { return this.options ? this.options.get(e) : null; }
            }
            class vs {
                constructor(e, i, c, h, p) { this.name = e, this.type = i, this._evaluate = c, this.args = h, this._overloadIndex = p; }
                evaluate(e) { if (!this._evaluate) {
                    const i = vs.definitions[this.name];
                    this._evaluate = Array.isArray(i) ? i[2] : i.overloads[this._overloadIndex][1];
                } return this._evaluate(e, this.args); }
                eachChild(e) { this.args.forEach(e); }
                outputDefined() { return !1; }
                serialize() { return [this.name].concat(this.args.map(e => e.serialize())); }
                static parse(e, i) { const c = e[0], h = vs.definitions[c]; if (!h)
                    return i.error(`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`, 0); const p = Array.isArray(h) ? h[0] : h.type, m = Array.isArray(h) ? [[h[1], h[2]]] : h.overloads, x = []; let b = null, S = -1; for (const [A, I] of m) {
                    if (Array.isArray(A) && A.length !== e.length - 1)
                        continue;
                    x.push(A), S++, b = new P0(i.registry, i.path, null, i.scope, void 0, i._scope, i.options);
                    const M = [];
                    let z = !1;
                    for (let F = 1; F < e.length; F++) {
                        const U = e[F], X = Array.isArray(A) ? A[F - 1] : A.type, Y = b.parse(U, 1 + M.length, X);
                        if (!Y) {
                            z = !0;
                            break;
                        }
                        M.push(Y);
                    }
                    if (!z)
                        if (Array.isArray(A) && A.length !== M.length)
                            b.error(`Expected ${A.length} arguments, but found ${M.length} instead.`);
                        else {
                            for (let F = 0; F < M.length; F++) {
                                const U = Array.isArray(A) ? A[F] : A.type, X = M[F];
                                b.concat(F + 1).checkSubtype(U, X.type);
                            }
                            if (b.errors.length === 0)
                                return new vs(c, p, I, M, S);
                        }
                } if (x.length === 1)
                    i.errors.push(...b.errors);
                else {
                    const A = (x.length ? x : m.map(([M]) => M)).map(Rs).join(" | "), I = [];
                    for (let M = 1; M < e.length; M++) {
                        const z = i.parse(e[M], 1 + I.length);
                        if (!z)
                            return null;
                        I.push(Ri(z.type));
                    }
                    i.error(`Expected arguments of type ${A}, but found (${I.join(", ")}) instead.`);
                } return null; }
                static register(e, i) { vs.definitions = i; for (const c in i)
                    e[c] = vs; }
            }
            function Rs(a) { return Array.isArray(a) ? `(${a.map(Ri).join(", ")})` : `(${Ri(a.type)}...)`; }
            class Su {
                constructor(e, i, c) { this.type = Tc, this.locale = c, this.caseSensitive = e, this.diacriticSensitive = i; }
                static parse(e, i) { if (e.length !== 2)
                    return i.error("Expected one argument."); const c = e[1]; if (typeof c != "object" || Array.isArray(c))
                    return i.error("Collator options argument must be an object."); const h = c["case-sensitive"] === void 0 ? i.parse(!1, 1, dn) : i.parseObjectValue(c["case-sensitive"], 1, "case-sensitive", dn); if (!h)
                    return null; const p = c["diacritic-sensitive"] === void 0 ? i.parse(!1, 1, dn) : i.parseObjectValue(c["diacritic-sensitive"], 1, "diacritic-sensitive", dn); if (!p)
                    return null; let m = null; return c.locale && (m = i.parseObjectValue(c.locale, 1, "locale", bn), !m) ? null : new Su(h, p, m); }
                evaluate(e) { return new Ml(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null); }
                eachChild(e) { e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale); }
                outputDefined() { return !1; }
                serialize() { const e = {}; return e["case-sensitive"] = this.caseSensitive.serialize(), e["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (e.locale = this.locale.serialize()), ["collator", e]; }
            }
            function Rl(a, e, i = 0, c = a.length - 1, h = Cc) { for (; c > i;) {
                if (c - i > 600) {
                    const b = c - i + 1, S = e - i + 1, A = Math.log(b), I = .5 * Math.exp(2 * A / 3), M = .5 * Math.sqrt(A * I * (b - I) / b) * (S - b / 2 < 0 ? -1 : 1);
                    Rl(a, e, Math.max(i, Math.floor(e - S * I / b + M)), Math.min(c, Math.floor(e + (b - S) * I / b + M)), h);
                }
                const p = a[e];
                let m = i, x = c;
                for (Ec(a, i, e), h(a[c], p) > 0 && Ec(a, i, c); m < x;) {
                    for (Ec(a, m, x), m++, x--; h(a[m], p) < 0;)
                        m++;
                    for (; h(a[x], p) > 0;)
                        x--;
                }
                h(a[i], p) === 0 ? Ec(a, i, x) : (x++, Ec(a, x, c)), x <= e && (i = x + 1), e <= x && (c = x - 1);
            } }
            function Ec(a, e, i) { const c = a[e]; a[e] = a[i], a[i] = c; }
            function Cc(a, e) { return a < e ? -1 : a > e ? 1 : 0; }
            function ks(a) { let e = 0; for (let i, c, h = 0, p = a.length, m = p - 1; h < p; m = h++)
                i = a[h], c = a[m], e += (c.x - i.x) * (i.y + c.y); return e; }
            function vd(a, e) { a[0] = Math.min(a[0], e[0]), a[1] = Math.min(a[1], e[1]), a[2] = Math.max(a[2], e[0]), a[3] = Math.max(a[3], e[1]); }
            function xd(a, e) { return !(a[0] <= e[0] || a[2] >= e[2] || a[1] <= e[1] || a[3] >= e[3]); }
            function Zb(a, e, i) { const c = a[0] - e[0], h = a[1] - e[1], p = a[0] - i[0], m = a[1] - i[1]; return c * m - p * h == 0 && c * p <= 0 && h * m <= 0; }
            function Ka(a, e, i = !1) { let c = !1; for (let x = 0, b = e.length; x < b; x++) {
                const S = e[x];
                for (let A = 0, I = S.length, M = I - 1; A < I; M = A++) {
                    const z = S[M], F = S[A];
                    if (Zb(a, z, F))
                        return i;
                    (p = z)[1] > (h = a)[1] != (m = F)[1] > h[1] && h[0] < (m[0] - p[0]) * (h[1] - p[1]) / (m[1] - p[1]) + p[0] && (c = !c);
                }
            } var h, p, m; return c; }
            function Ug(a, e, i, c) { const h = c[0] - i[0], p = c[1] - i[1], m = (a[0] - i[0]) * p - h * (a[1] - i[1]), x = (e[0] - i[0]) * p - h * (e[1] - i[1]); return m > 0 && x < 0 || m < 0 && x > 0; }
            function Sa(a, e, i, c) { return (h = [c[0] - i[0], c[1] - i[1]])[0] * (p = [e[0] - a[0], e[1] - a[1]])[1] - h[1] * p[0] != 0 && !(!Ug(a, e, i, c) || !Ug(i, c, a, e)); var h, p; }
            function $g(a) { const e = new Et(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), i = new Et(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY); for (const c of a[0])
                e.x > c.x && (e.x = c.x), e.y > c.y && (e.y = c.y), i.x < c.x && (i.x = c.x), i.y < c.y && (i.y = c.y); return { min: e, max: i }; }
            const kl = 8192;
            function Xb(a, e) { const i = (180 + a[0]) / 360, c = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a[1] * Math.PI / 360))) / 360, h = Math.pow(2, e.z); return [Math.round(i * h * kl), Math.round(c * h * kl)]; }
            function Kb(a, e) { for (let i = 0; i < e.length; i++)
                if (Ka(a, e[i]))
                    return !0; return !1; }
            function x0(a, e, i) { for (const c of i)
                for (let h = 0, p = c.length, m = p - 1; h < p; m = h++)
                    if (Sa(a, e, c[m], c[h]))
                        return !0; return !1; }
            function w0(a, e) { for (let i = 0; i < a.length; ++i)
                if (!Ka(a[i], e))
                    return !1; for (let i = 0; i < a.length - 1; ++i)
                if (x0(a[i], a[i + 1], e))
                    return !1; return !0; }
            function Yb(a, e) { for (let i = 0; i < e.length; i++)
                if (w0(a, e[i]))
                    return !0; return !1; }
            function ip(a, e, i) { const c = []; for (let h = 0; h < a.length; h++) {
                const p = [];
                for (let m = 0; m < a[h].length; m++) {
                    const x = Xb(a[h][m], i);
                    vd(e, x), p.push(x);
                }
                c.push(p);
            } return c; }
            function b0(a, e, i) { const c = []; for (let h = 0; h < a.length; h++) {
                const p = ip(a[h], e, i);
                c.push(p);
            } return c; }
            function Dl(a, e, i, c) { if (a[0] < i[0] || a[0] > i[2]) {
                const h = .5 * c;
                let p = a[0] - i[0] > h ? -c : i[0] - a[0] > h ? c : 0;
                p === 0 && (p = a[0] - i[2] > h ? -c : i[2] - a[0] > h ? c : 0), a[0] += p;
            } vd(e, a); }
            function T0(a, e, i, c) { const h = Math.pow(2, c.z) * kl, p = [c.x * kl, c.y * kl], m = []; if (!a)
                return m; for (const x of a)
                for (const b of x) {
                    const S = [b.x + p[0], b.y + p[1]];
                    Dl(S, e, i, h), m.push(S);
                } return m; }
            function S0(a, e, i, c) { const h = Math.pow(2, c.z) * kl, p = [c.x * kl, c.y * kl], m = []; if (!a)
                return m; for (const b of a) {
                const S = [];
                for (const A of b) {
                    const I = [A.x + p[0], A.y + p[1]];
                    vd(e, I), S.push(I);
                }
                m.push(S);
            } if (e[2] - e[0] <= h / 2) {
                (x = e)[0] = x[1] = 1 / 0, x[2] = x[3] = -1 / 0;
                for (const b of m)
                    for (const S of b)
                        Dl(S, e, i, h);
            } var x; return m; }
            class Ya {
                constructor(e, i) { this.type = dn, this.geojson = e, this.geometries = i; }
                static parse(e, i) { if (e.length !== 2)
                    return i.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`); if (bu(e[1])) {
                    const c = e[1];
                    if (c.type === "FeatureCollection")
                        for (let h = 0; h < c.features.length; ++h) {
                            const p = c.features[h].geometry.type;
                            if (p === "Polygon" || p === "MultiPolygon")
                                return new Ya(c, c.features[h].geometry);
                        }
                    else if (c.type === "Feature") {
                        const h = c.geometry.type;
                        if (h === "Polygon" || h === "MultiPolygon")
                            return new Ya(c, c.geometry);
                    }
                    else if (c.type === "Polygon" || c.type === "MultiPolygon")
                        return new Ya(c, c);
                } return i.error("'within' expression requires valid geojson object that contains polygon geometry type."); }
                evaluate(e) { if (e.geometry() != null && e.canonicalID() != null) {
                    if (e.geometryType() === "Point")
                        return function (i, c) { const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], m = i.canonicalID(); if (!m)
                            return !1; if (c.type === "Polygon") {
                            const x = ip(c.coordinates, p, m), b = T0(i.geometry(), h, p, m);
                            if (!xd(h, p))
                                return !1;
                            for (const S of b)
                                if (!Ka(S, x))
                                    return !1;
                        } if (c.type === "MultiPolygon") {
                            const x = b0(c.coordinates, p, m), b = T0(i.geometry(), h, p, m);
                            if (!xd(h, p))
                                return !1;
                            for (const S of b)
                                if (!Kb(S, x))
                                    return !1;
                        } return !0; }(e, this.geometries);
                    if (e.geometryType() === "LineString")
                        return function (i, c) { const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], m = i.canonicalID(); if (!m)
                            return !1; if (c.type === "Polygon") {
                            const x = ip(c.coordinates, p, m), b = S0(i.geometry(), h, p, m);
                            if (!xd(h, p))
                                return !1;
                            for (const S of b)
                                if (!w0(S, x))
                                    return !1;
                        } if (c.type === "MultiPolygon") {
                            const x = b0(c.coordinates, p, m), b = S0(i.geometry(), h, p, m);
                            if (!xd(h, p))
                                return !1;
                            for (const S of b)
                                if (!Yb(S, x))
                                    return !1;
                        } return !0; }(e, this.geometries);
                } return !1; }
                eachChild() { }
                outputDefined() { return !0; }
                serialize() { return ["within", this.geojson]; }
            }
            const wd = { kilometers: 1, miles: 1e3 / 1609.344, nauticalmiles: 1e3 / 1852, meters: 1e3, metres: 1e3, yards: 1e3 / .9144, feet: 1e3 / .3048, inches: 1e3 / .0254 }, Gg = 1 / 298.257223563, Lo = Gg * (2 - Gg), Eu = Math.PI / 180;
            class Cu {
                static fromTile(e, i, c) { const h = Math.PI * (1 - 2 * (e + .5) / Math.pow(2, i)), p = Math.atan(.5 * (Math.exp(h) - Math.exp(-h))) / Eu; return new Cu(p, c); }
                static get units() { return wd; }
                constructor(e, i) { if (e === void 0)
                    throw new Error("No latitude given."); if (i && !wd[i])
                    throw new Error(`Unknown unit ${i}. Use one of: ${Object.keys(wd).join(", ")}`); const c = 6378.137 * Eu * (i ? wd[i] : 1), h = Math.cos(e * Eu), p = 1 / (1 - Lo * (1 - h * h)), m = Math.sqrt(p); this.kx = c * m * h, this.ky = c * m * p * (1 - Lo); }
                distance(e, i) { const c = po(e[0] - i[0]) * this.kx, h = (e[1] - i[1]) * this.ky; return Math.sqrt(c * c + h * h); }
                bearing(e, i) { const c = po(i[0] - e[0]) * this.kx; return Math.atan2(c, (i[1] - e[1]) * this.ky) / Eu; }
                destination(e, i, c) { const h = c * Eu; return this.offset(e, Math.sin(h) * i, Math.cos(h) * i); }
                offset(e, i, c) { return [e[0] + i / this.kx, e[1] + c / this.ky]; }
                lineDistance(e) { let i = 0; for (let c = 0; c < e.length - 1; c++)
                    i += this.distance(e[c], e[c + 1]); return i; }
                area(e) { let i = 0; for (let c = 0; c < e.length; c++) {
                    const h = e[c];
                    for (let p = 0, m = h.length, x = m - 1; p < m; x = p++)
                        i += po(h[p][0] - h[x][0]) * (h[p][1] + h[x][1]) * (c ? -1 : 1);
                } return Math.abs(i) / 2 * this.kx * this.ky; }
                along(e, i) { let c = 0; if (i <= 0)
                    return e[0]; for (let h = 0; h < e.length - 1; h++) {
                    const p = e[h], m = e[h + 1], x = this.distance(p, m);
                    if (c += x, c > i)
                        return sp(p, m, (i - (c - x)) / x);
                } return e[e.length - 1]; }
                pointToSegmentDistance(e, i, c) { let [h, p] = i, m = po(c[0] - h) * this.kx, x = (c[1] - p) * this.ky; if (m !== 0 || x !== 0) {
                    const b = (po(e[0] - h) * this.kx * m + (e[1] - p) * this.ky * x) / (m * m + x * x);
                    b > 1 ? (h = c[0], p = c[1]) : b > 0 && (h += m / this.kx * b, p += x / this.ky * b);
                } return m = po(e[0] - h) * this.kx, x = (e[1] - p) * this.ky, Math.sqrt(m * m + x * x); }
                pointOnLine(e, i) { let c = 1 / 0, h = e[0][0], p = e[0][1], m = 0, x = 0; for (let b = 0; b < e.length - 1; b++) {
                    let S = e[b][0], A = e[b][1], I = po(e[b + 1][0] - S) * this.kx, M = (e[b + 1][1] - A) * this.ky, z = 0;
                    I === 0 && M === 0 || (z = (po(i[0] - S) * this.kx * I + (i[1] - A) * this.ky * M) / (I * I + M * M), z > 1 ? (S = e[b + 1][0], A = e[b + 1][1]) : z > 0 && (S += I / this.kx * z, A += M / this.ky * z)), I = po(i[0] - S) * this.kx, M = (i[1] - A) * this.ky;
                    const F = I * I + M * M;
                    F < c && (c = F, h = S, p = A, m = b, x = z);
                } return { point: [h, p], index: m, t: Math.max(0, Math.min(1, x)) }; }
                lineSlice(e, i, c) { let h = this.pointOnLine(c, e), p = this.pointOnLine(c, i); if (h.index > p.index || h.index === p.index && h.t > p.t) {
                    const S = h;
                    h = p, p = S;
                } const m = [h.point], x = h.index + 1, b = p.index; !qg(c[x], m[0]) && x <= b && m.push(c[x]); for (let S = x + 1; S <= b; S++)
                    m.push(c[S]); return qg(c[b], p.point) || m.push(p.point), m; }
                lineSliceAlong(e, i, c) { let h = 0; const p = []; for (let m = 0; m < c.length - 1; m++) {
                    const x = c[m], b = c[m + 1], S = this.distance(x, b);
                    if (h += S, h > e && p.length === 0 && p.push(sp(x, b, (e - (h - S)) / S)), h >= i)
                        return p.push(sp(x, b, (i - (h - S)) / S)), p;
                    h > e && p.push(b);
                } return p; }
                bufferPoint(e, i) { const c = i / this.ky, h = i / this.kx; return [e[0] - h, e[1] - c, e[0] + h, e[1] + c]; }
                bufferBBox(e, i) { const c = i / this.ky, h = i / this.kx; return [e[0] - h, e[1] - c, e[2] + h, e[3] + c]; }
                insideBBox(e, i) { return po(e[0] - i[0]) >= 0 && po(e[0] - i[2]) <= 0 && e[1] >= i[1] && e[1] <= i[3]; }
            }
            function qg(a, e) { return a[0] === e[0] && a[1] === e[1]; }
            function sp(a, e, i) { const c = po(e[0] - a[0]); return [a[0] + c * i, a[1] + (e[1] - a[1]) * i]; }
            function po(a) { for (; a < -180;)
                a += 360; for (; a > 180;)
                a -= 360; return a; }
            class op {
                constructor(e = [], i = (c, h) => c < h ? -1 : c > h ? 1 : 0) { if (this.data = e, this.length = this.data.length, this.compare = i, this.length > 0)
                    for (let c = (this.length >> 1) - 1; c >= 0; c--)
                        this._down(c); }
                push(e) { this.data.push(e), this._up(this.length++); }
                pop() { if (this.length === 0)
                    return; const e = this.data[0], i = this.data.pop(); return --this.length > 0 && (this.data[0] = i, this._down(0)), e; }
                peek() { return this.data[0]; }
                _up(e) { const { data: i, compare: c } = this, h = i[e]; for (; e > 0;) {
                    const p = e - 1 >> 1, m = i[p];
                    if (c(h, m) >= 0)
                        break;
                    i[e] = m, e = p;
                } i[e] = h; }
                _down(e) { const { data: i, compare: c } = this, h = this.length >> 1, p = i[e]; for (; e < h;) {
                    let m = 1 + (e << 1);
                    const x = m + 1;
                    if (x < this.length && c(i[x], i[m]) < 0 && (m = x), c(i[m], p) >= 0)
                        break;
                    i[e] = i[m], e = m;
                } i[e] = p; }
            }
            var It = 8192;
            function Hg(a, e) { return e.dist - a.dist; }
            const ap = 100, lp = 50;
            function Wg(a) { const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; if (e.length !== a.length)
                return !1; for (let i = 0; i < e.length; i++)
                if (e[i] !== a[i])
                    return !1; return !0; }
            function Ac(a) { return a[1] - a[0] + 1; }
            function Oo(a, e) { const i = a[1] >= a[0] && a[1] < e; return i || console.warn("Distance Expression: Index is out of range"), i; }
            function Au(a, e) { if (a[0] > a[1])
                return [null, null]; const i = Ac(a); if (e) {
                if (i === 2)
                    return [a, null];
                const c = Math.floor(i / 2);
                return [[a[0], a[0] + c], [a[0] + c, a[1]]];
            } {
                if (i === 1)
                    return [a, null];
                const c = Math.floor(i / 2) - 1;
                return [[a[0], a[0] + c], [a[0] + c + 1, a[1]]];
            } }
            function Ll(a, e) { const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; if (!Oo(e, a.length))
                return i; for (let c = e[0]; c <= e[1]; ++c)
                vd(i, a[c]); return i; }
            function bd(a) { const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; for (let i = 0; i < a.length; ++i)
                for (let c = 0; c < a[i].length; ++c)
                    vd(e, a[i][c]); return e; }
            function Ic(a, e, i) { if (Wg(a) || Wg(e))
                return NaN; let c = 0, h = 0; return a[2] < e[0] && (c = e[0] - a[2]), a[0] > e[2] && (c = a[0] - e[2]), a[1] > e[3] && (h = a[1] - e[3]), a[3] < e[1] && (h = e[1] - a[3]), i.distance([0, 0], [c, h]); }
            function Iu(a) { return 360 * a - 180; }
            function Wr(a) { return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90; }
            function Zg(a, e) { const i = Math.pow(2, e.z), c = (a.y / It + e.y) / i; return [Iu((a.x / It + e.x) / i), Wr(c)]; }
            function Qb(a, e) { const i = []; for (let c = 0; c < a.length; ++c)
                i.push(Zg(a[c], e)); return i; }
            function E0(a, e, i) { const c = i.pointOnLine(e, a).point; return i.distance(a, c); }
            function Xg(a, e, i, c, h) { const p = i.slice(c[0], c[1] + 1); let m = 1 / 0; for (let x = e[0]; x <= e[1]; ++x)
                if ((m = Math.min(m, E0(a[x], p, h))) === 0)
                    return 0; return m; }
            function Kg(a, e, i, c, h) { const p = Math.min(h.pointToSegmentDistance(a, i, c), h.pointToSegmentDistance(e, i, c)), m = Math.min(h.pointToSegmentDistance(i, a, e), h.pointToSegmentDistance(c, a, e)); return Math.min(p, m); }
            function li(a, e, i, c, h) { if (!Oo(e, a.length) || !Oo(c, i.length))
                return NaN; let p = 1 / 0; for (let m = e[0]; m < e[1]; ++m)
                for (let x = c[0]; x < c[1]; ++x) {
                    if (Sa(a[m], a[m + 1], i[x], i[x + 1]))
                        return 0;
                    p = Math.min(p, Kg(a[m], a[m + 1], i[x], i[x + 1], h));
                } return p; }
            function Jb(a, e, i, c, h) { if (!Oo(e, a.length) || !Oo(c, i.length))
                return NaN; let p = 1 / 0; for (let m = e[0]; m <= e[1]; ++m)
                for (let x = c[0]; x <= c[1]; ++x)
                    if ((p = Math.min(p, h.distance(a[m], i[x]))) === 0)
                        return p; return p; }
            function eT(a, e, i) { if (Ka(a, e, !0))
                return 0; let c = 1 / 0; for (const h of e) {
                const p = h.length;
                if (p < 2)
                    return console.warn("Distance Expression: Invalid polygon!"), NaN;
                if (h[0] !== h[p - 1] && (c = Math.min(c, i.pointToSegmentDistance(a, h[p - 1], h[0]))) === 0 || (c = Math.min(c, E0(a, h, i))) === 0)
                    return c;
            } return c; }
            function tT(a, e, i, c) { if (!Oo(e, a.length))
                return NaN; for (let p = e[0]; p <= e[1]; ++p)
                if (Ka(a[p], i, !0))
                    return 0; let h = 1 / 0; for (let p = e[0]; p < e[1]; ++p)
                for (const m of i)
                    for (let x = 0, b = m.length, S = b - 1; x < b; S = x++) {
                        if (Sa(a[p], a[p + 1], m[S], m[x]))
                            return 0;
                        h = Math.min(h, Kg(a[p], a[p + 1], m[S], m[x], c));
                    } return h; }
            function C0(a, e) { for (const i of a)
                for (let c = 0; c <= i.length - 1; ++c)
                    if (Ka(i[c], e, !0))
                        return !0; return !1; }
            function rT(a, e, i, c = 1 / 0) { const h = bd(a), p = bd(e); if (c !== 1 / 0 && Ic(h, p, i) >= c)
                return c; if (xd(h, p)) {
                if (C0(a, e))
                    return 0;
            }
            else if (C0(e, a))
                return 0; let m = c; for (const x of a)
                for (let b = 0, S = x.length, A = S - 1; b < S; A = b++)
                    for (const I of e)
                        for (let M = 0, z = I.length, F = z - 1; M < z; F = M++) {
                            if (Sa(x[A], x[b], I[F], I[M]))
                                return 0;
                            m = Math.min(m, Kg(x[A], x[b], I[F], I[M], i));
                        } return m; }
            function cp(a, e, i, c, h, p, m) { if (p === null || m === null)
                return; const x = Ic(Ll(c, p), Ll(h, m), i); x < e && a.push({ dist: x, range1: p, range2: m }); }
            function nT(a, e, i, c, h = 1 / 0) { let p = Math.min(c.distance(a[0], i[0][0]), h); if (p === 0)
                return p; const m = new op([{ dist: 0, range1: [0, a.length - 1], range2: [0, 0] }], Hg), x = e ? lp : ap, b = bd(i); for (; m.length;) {
                const S = m.pop();
                if (S.dist >= p)
                    continue;
                const A = S.range1;
                if (Ac(A) <= x) {
                    if (!Oo(A, a.length))
                        return NaN;
                    if (e) {
                        const I = tT(a, A, i, c);
                        if ((p = Math.min(p, I)) === 0)
                            return p;
                    }
                    else
                        for (let I = A[0]; I <= A[1]; ++I) {
                            const M = eT(a[I], i, c);
                            if ((p = Math.min(p, M)) === 0)
                                return p;
                        }
                }
                else {
                    const I = Au(A, e);
                    if (I[0] !== null) {
                        const M = Ic(Ll(a, I[0]), b, c);
                        M < p && m.push({ dist: M, range1: I[0], range2: [0, 0] });
                    }
                    if (I[1] !== null) {
                        const M = Ic(Ll(a, I[1]), b, c);
                        M < p && m.push({ dist: M, range1: I[1], range2: [0, 0] });
                    }
                }
            } return p; }
            function A0(a, e, i, c, h, p = 1 / 0) { let m = Math.min(p, h.distance(a[0], i[0])); if (m === 0)
                return m; const x = new op([{ dist: 0, range1: [0, a.length - 1], range2: [0, i.length - 1] }], Hg), b = e ? lp : ap, S = c ? lp : ap; for (; x.length;) {
                const A = x.pop();
                if (A.dist >= m)
                    continue;
                const I = A.range1, M = A.range2;
                if (Ac(I) <= b && Ac(M) <= S) {
                    if (!Oo(I, a.length) || !Oo(M, i.length))
                        return NaN;
                    if (e && c ? m = Math.min(m, li(a, I, i, M, h)) : e || c ? e && !c ? m = Math.min(m, Xg(i, M, a, I, h)) : !e && c && (m = Math.min(m, Xg(a, I, i, M, h))) : m = Math.min(m, Jb(a, I, i, M, h)), m === 0)
                        return m;
                }
                else {
                    const z = Au(I, e), F = Au(M, c);
                    cp(x, m, h, a, i, z[0], F[0]), cp(x, m, h, a, i, z[0], F[1]), cp(x, m, h, a, i, z[1], F[0]), cp(x, m, h, a, i, z[1], F[1]);
                }
            } return m; }
            function Yg(a, e, i, c, h = 1 / 0) { let p = h; const m = Ll(a, [0, a.length - 1]); for (const x of i)
                if (!(p !== 1 / 0 && Ic(m, Ll(x, [0, x.length - 1]), c) >= p) && (p = Math.min(p, A0(a, e, x, !0, c, p)), p === 0))
                    return p; return p; }
            function up(a, e, i, c, h = 1 / 0) { let p = h; const m = Ll(a, [0, a.length - 1]); for (const x of i) {
                if (p !== 1 / 0 && Ic(m, bd(x), c) >= p)
                    continue;
                const b = nT(a, e, x, c, p);
                if (isNaN(b))
                    return b;
                if ((p = Math.min(p, b)) === 0)
                    return p;
            } return p; }
            function Qg(a) { return a === "Point" || a === "MultiPoint" || a === "LineString" || a === "MultiLineString" || a === "Polygon" || a === "MultiPolygon"; }
            class Pc {
                constructor(e, i) { this.type = Qt, this.geojson = e, this.geometries = i; }
                static parse(e, i) { if (e.length !== 2)
                    return i.error(`'distance' expression requires either one argument, but found ' ${e.length - 1} instead.`); if (bu(e[1])) {
                    const c = e[1];
                    if (c.type === "FeatureCollection") {
                        for (let h = 0; h < c.features.length; ++h)
                            if (Qg(c.features[h].geometry.type))
                                return new Pc(c, c.features[h].geometry);
                    }
                    else if (c.type === "Feature") {
                        if (Qg(c.geometry.type))
                            return new Pc(c, c.geometry);
                    }
                    else if (Qg(c.type))
                        return new Pc(c, c);
                } return i.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj]."); }
                evaluate(e) { const i = e.geometry(), c = e.canonicalID(); if (i != null && c != null) {
                    if (e.geometryType() === "Point")
                        return function (h, p, m) { const x = []; for (const S of h)
                            for (const A of S)
                                x.push(Zg(A, p)); const b = new Cu(x[0][1], "meters"); return m.type === "Point" || m.type === "MultiPoint" || m.type === "LineString" ? A0(x, !1, m.type === "Point" ? [m.coordinates] : m.coordinates, m.type === "LineString", b) : m.type === "MultiLineString" ? Yg(x, !1, m.coordinates, b) : m.type === "Polygon" || m.type === "MultiPolygon" ? up(x, !1, m.type === "Polygon" ? [m.coordinates] : m.coordinates, b) : null; }(i, c, this.geometries);
                    if (e.geometryType() === "LineString")
                        return function (h, p, m) { const x = []; for (const S of h) {
                            const A = [];
                            for (const I of S)
                                A.push(Zg(I, p));
                            x.push(A);
                        } const b = new Cu(x[0][0][1], "meters"); if (m.type === "Point" || m.type === "MultiPoint" || m.type === "LineString")
                            return Yg(m.type === "Point" ? [m.coordinates] : m.coordinates, m.type === "LineString", x, b); if (m.type === "MultiLineString") {
                            let S = 1 / 0;
                            for (let A = 0; A < m.coordinates.length; A++) {
                                const I = Yg(m.coordinates[A], !0, x, b, S);
                                if (isNaN(I))
                                    return I;
                                if ((S = Math.min(S, I)) === 0)
                                    return S;
                            }
                            return S;
                        } if (m.type === "Polygon" || m.type === "MultiPolygon") {
                            let S = 1 / 0;
                            for (let A = 0; A < x.length; A++) {
                                const I = up(x[A], !0, m.type === "Polygon" ? [m.coordinates] : m.coordinates, b, S);
                                if (isNaN(I))
                                    return I;
                                if ((S = Math.min(S, I)) === 0)
                                    return S;
                            }
                            return S;
                        } return null; }(i, c, this.geometries);
                    if (e.geometryType() === "Polygon")
                        return function (h, p, m) { const x = []; for (const S of function (A, I) { const M = A.length; if (M <= 1)
                            return [A]; const z = []; let F, U; for (let X = 0; X < M; X++) {
                            const Y = ks(A[X]);
                            Y !== 0 && (A[X].area = Math.abs(Y), U === void 0 && (U = Y < 0), U === Y < 0 ? (F && z.push(F), F = [A[X]]) : F.push(A[X]));
                        } return F && z.push(F), z; }(h)) {
                            const A = [];
                            for (let I = 0; I < S.length; ++I)
                                A.push(Qb(S[I], p));
                            x.push(A);
                        } const b = new Cu(x[0][0][0][1], "meters"); if (m.type === "Point" || m.type === "MultiPoint" || m.type === "LineString")
                            return up(m.type === "Point" ? [m.coordinates] : m.coordinates, m.type === "LineString", x, b); if (m.type === "MultiLineString") {
                            let S = 1 / 0;
                            for (let A = 0; A < m.coordinates.length; A++) {
                                const I = up(m.coordinates[A], !0, x, b, S);
                                if (isNaN(I))
                                    return I;
                                if ((S = Math.min(S, I)) === 0)
                                    return S;
                            }
                            return S;
                        } return m.type === "Polygon" || m.type === "MultiPolygon" ? function (S, A, I) { let M = 1 / 0; for (const z of S)
                            for (const F of A) {
                                const U = rT(z, F, I, M);
                                if (isNaN(U))
                                    return U;
                                if ((M = Math.min(M, U)) === 0)
                                    return M;
                            } return M; }(m.type === "Polygon" ? [m.coordinates] : m.coordinates, x, b) : null; }(i, c, this.geometries);
                    console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
                }
                else
                    console.warn("Distance Expression: requirs valid feature and canonical information."); return null; }
                eachChild() { }
                outputDefined() { return !0; }
                serialize() { return ["distance", this.geojson]; }
            }
            function Jg(a, e) { switch (a) {
                case "string": return Ms(e);
                case "number": return +e;
                case "boolean": return !!e;
                case "color": return nn.parse(e);
                case "formatted": return Ps.fromString(Ms(e));
                case "resolvedImage": return Us.build(Ms(e));
            } return e; }
            function I0(a, e, i, c) { return c !== void 0 && (a = c * Math.round(a / c)), e !== void 0 && a < e && (a = e), i !== void 0 && a > i && (a = i), a; }
            class Pu {
                constructor(e, i, c) { this.type = e, this.key = i, this.scope = c; }
                static parse(e, i) { let c = i.expectedType; if (c == null && (c = un), e.length < 2 || e.length > 3)
                    return i.error("Invalid number of arguments for 'config' expression."); const h = i.parse(e[1], 1); if (!(h instanceof Rr))
                    return i.error("Key name of 'config' expression must be a string literal."); if (e.length >= 3) {
                    const p = i.parse(e[2], 2);
                    return p instanceof Rr ? new Pu(c, Ms(h.value), Ms(p.value)) : i.error("Scope of 'config' expression must be a string literal.");
                } return new Pu(c, Ms(h.value)); }
                evaluate(e) { const i = [this.key, this.scope, e.scope].filter(Boolean).join(""), c = e.getConfig(i); if (!c)
                    return null; const { type: h, value: p, values: m, minValue: x, maxValue: b, stepValue: S } = c, A = c.default.evaluate(e); let I = A; if (p) {
                    const M = e.scope;
                    e.scope = (M || "").split("").slice(1).join(""), I = p.evaluate(e), e.scope = M;
                } return h && (I = Jg(h, I)), I === void 0 || x === void 0 && b === void 0 && S === void 0 || (typeof I == "number" ? I = I0(I, x, b, S) : Array.isArray(I) && (I = I.map(M => typeof M == "number" ? I0(M, x, b, S) : M))), p !== void 0 && I !== void 0 && m && !m.includes(I) && (I = A, h && (I = Jg(h, I))), (h && h !== this.type || I !== void 0 && ji(I) !== this.type) && (I = Jg(this.type.kind, I)), I; }
                eachChild() { }
                outputDefined() { return !1; }
                serialize() { const e = ["config", this.key]; return this.scope && e.concat(this.key), e; }
            }
            function Td(a) { if (a instanceof vs && (a.name === "get" && a.args.length === 1 || a.name === "feature-state" || a.name === "has" && a.args.length === 1 || a.name === "properties" || a.name === "geometry-type" || a.name === "id" || /^filter-/.test(a.name)) || a instanceof Ya || a instanceof Pc)
                return !1; let e = !0; return a.eachChild(i => { e && !Td(i) && (e = !1); }), e; }
            function hp(a) { if (a instanceof vs && a.name === "feature-state")
                return !1; let e = !0; return a.eachChild(i => { e && !hp(i) && (e = !1); }), e; }
            function dp(a) { if (a instanceof Pu)
                return new Set([a.key]); let e = new Set; return a.eachChild(i => { e = new Set([...e, ...dp(i)]); }), e; }
            function Mu(a, e) { if (a instanceof vs && e.indexOf(a.name) >= 0)
                return !1; let i = !0; return a.eachChild(c => { i && !Mu(c, e) && (i = !1); }), i; }
            class fp {
                constructor(e, i) { this.type = i.type, this.name = e, this.boundExpression = i; }
                static parse(e, i) { if (e.length !== 2 || typeof e[1] != "string")
                    return i.error("'var' expression requires exactly one string literal argument."); const c = e[1]; return i.scope.has(c) ? new fp(c, i.scope.get(c)) : i.error(`Unknown variable "${c}". Make sure "${c}" has been bound in an enclosing "let" expression before using it.`, 1); }
                evaluate(e) { return this.boundExpression.evaluate(e); }
                eachChild() { }
                outputDefined() { return !1; }
                serialize() { return ["var", this.name]; }
            }
            class e_ {
                constructor(e, i = [], c, h = new bc, p = [], m, x) { this.registry = e, this.path = i, this.key = i.map(b => typeof b == "string" ? `['${b}']` : `[${b}]`).join(""), this.scope = h, this.errors = p, this.expectedType = c, this._scope = m, this.options = x; }
                parse(e, i, c, h, p = {}) { return i || c ? this.concat(i, null, c, h)._parse(e, p) : this._parse(e, p); }
                parseObjectValue(e, i, c, h, p, m = {}) { return this.concat(i, c, h, p)._parse(e, m); }
                _parse(e, i) { function c(h, p, m) { return m === "assert" ? new dr(p, [h]) : m === "coerce" ? new ta(p, [h]) : h; } if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) {
                    if (e.length === 0)
                        return this.error("Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].");
                    const h = typeof e[0] == "string" ? this.registry[e[0]] : void 0;
                    if (h) {
                        let p = h.parse(e, this);
                        if (!p)
                            return null;
                        if (this.expectedType) {
                            const m = this.expectedType, x = p.type;
                            if (m.kind !== "string" && m.kind !== "number" && m.kind !== "boolean" && m.kind !== "object" && m.kind !== "array" || x.kind !== "value")
                                if (m.kind !== "color" && m.kind !== "formatted" && m.kind !== "resolvedImage" || x.kind !== "value" && x.kind !== "string") {
                                    if (this.checkSubtype(m, x))
                                        return null;
                                }
                                else
                                    p = c(p, m, i.typeAnnotation || "coerce");
                            else
                                p = c(p, m, i.typeAnnotation || "assert");
                        }
                        if (!(p instanceof Rr) && p.type.kind !== "resolvedImage" && t_(p)) {
                            const m = new np(this._scope, this.options);
                            try {
                                p = new Rr(p.type, p.evaluate(m));
                            }
                            catch (x) {
                                return this.error(x.message), null;
                            }
                        }
                        return p;
                    }
                    return ta.parse(["to-array", e], this);
                } return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? "Bare objects invalid. Use [\"literal\", {...}] instead." : `Expected an array, but found ${typeof e} instead.`); }
                concat(e, i, c, h) { let p = typeof e == "number" ? this.path.concat(e) : this.path; p = typeof i == "string" ? p.concat(i) : p; const m = h ? this.scope.concat(h) : this.scope; return new e_(this.registry, p, c || null, m, this.errors, this._scope, this.options); }
                error(e, ...i) { const c = `${this.key}${i.map(h => `[${h}]`).join("")}`; this.errors.push(new Do(c, e)); }
                checkSubtype(e, i) { const c = _d(e, i); return c && this.error(c), c; }
            }
            var P0 = e_;
            function t_(a) { if (a instanceof fp)
                return t_(a.boundExpression); if (a instanceof vs && a.name === "error" || a instanceof Su || a instanceof Ya || a instanceof Pc || a instanceof Pu)
                return !1; const e = a instanceof ta || a instanceof dr; let i = !0; return a.eachChild(c => { i = e ? i && t_(c) : i && c instanceof Rr; }), !!i && Td(a) && Mu(a, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]); }
            function pp(a, e) { const i = a.length - 1; let c, h, p = 0, m = i, x = 0; for (; p <= m;)
                if (x = Math.floor((p + m) / 2), c = a[x], h = a[x + 1], c <= e) {
                    if (x === i || e < h)
                        return x;
                    p = x + 1;
                }
                else {
                    if (!(c > e))
                        throw new Ut("Input is not a number.");
                    m = x - 1;
                } return 0; }
            class Sd {
                constructor(e, i, c) { this.type = e, this.input = i, this.labels = [], this.outputs = []; for (const [h, p] of c)
                    this.labels.push(h), this.outputs.push(p); }
                static parse(e, i) { if (e.length - 1 < 4)
                    return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`); if ((e.length - 1) % 2 != 0)
                    return i.error("Expected an even number of arguments."); const c = i.parse(e[1], 1, Qt); if (!c)
                    return null; const h = []; let p = null; i.expectedType && i.expectedType.kind !== "value" && (p = i.expectedType); for (let m = 1; m < e.length; m += 2) {
                    const x = m === 1 ? -1 / 0 : e[m], b = e[m + 1], S = m, A = m + 1;
                    if (typeof x != "number")
                        return i.error("Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", S);
                    if (h.length && h[h.length - 1][0] >= x)
                        return i.error("Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.", S);
                    const I = i.parse(b, A, p);
                    if (!I)
                        return null;
                    p = p || I.type, h.push([x, I]);
                } return new Sd(p, c, h); }
                evaluate(e) { const i = this.labels, c = this.outputs; if (i.length === 1)
                    return c[0].evaluate(e); const h = this.input.evaluate(e); if (h <= i[0])
                    return c[0].evaluate(e); const p = i.length; return h >= i[p - 1] ? c[p - 1].evaluate(e) : c[pp(i, h)].evaluate(e); }
                eachChild(e) { e(this.input); for (const i of this.outputs)
                    e(i); }
                outputDefined() { return this.outputs.every(e => e.outputDefined()); }
                serialize() { const e = ["step", this.input.serialize()]; for (let i = 0; i < this.labels.length; i++)
                    i > 0 && e.push(this.labels[i]), e.push(this.outputs[i].serialize()); return e; }
            }
            const M0 = .95047, R0 = 1.08883, k0 = 4 / 29, Ru = 6 / 29, D0 = 3 * Ru * Ru, iT = Ru * Ru * Ru, r_ = Math.PI / 180, sT = 180 / Math.PI;
            function mp(a) { return a > iT ? Math.pow(a, 1 / 3) : a / D0 + k0; }
            function n_(a) { return a > Ru ? a * a * a : D0 * (a - k0); }
            function i_(a) { return 255 * (a <= .0031308 ? 12.92 * a : 1.055 * Math.pow(a, 1 / 2.4) - .055); }
            function s_(a) { return (a /= 255) <= .04045 ? a / 12.92 : Math.pow((a + .055) / 1.055, 2.4); }
            function o_(a) { const e = s_(a.r), i = s_(a.g), c = s_(a.b), h = mp((.4124564 * e + .3575761 * i + .1804375 * c) / M0), p = mp((.2126729 * e + .7151522 * i + .072175 * c) / 1); return { l: 116 * p - 16, a: 500 * (h - p), b: 200 * (p - mp((.0193339 * e + .119192 * i + .9503041 * c) / R0)), alpha: a.a }; }
            function a_(a) { let e = (a.l + 16) / 116, i = isNaN(a.a) ? e : e + a.a / 500, c = isNaN(a.b) ? e : e - a.b / 200; return e = 1 * n_(e), i = M0 * n_(i), c = R0 * n_(c), new nn(i_(3.2404542 * i - 1.5371385 * e - .4985314 * c), i_(-.969266 * i + 1.8760108 * e + .041556 * c), i_(.0556434 * i - .2040259 * e + 1.0572252 * c), a.alpha); }
            function ku(a, e, i) { const c = e - a; return a + i * (c > 180 || c < -180 ? c - 360 * Math.round(c / 360) : c); }
            const Du = { forward: o_, reverse: a_, interpolate: function (a, e, i) { return { l: nr(a.l, e.l, i), a: nr(a.a, e.a, i), b: nr(a.b, e.b, i), alpha: nr(a.alpha, e.alpha, i) }; } }, Lu = { forward: function (a) { const { l: e, a: i, b: c } = o_(a), h = Math.atan2(c, i) * sT; return { h: h < 0 ? h + 360 : h, c: Math.sqrt(i * i + c * c), l: e, alpha: a.a }; }, reverse: function (a) { const e = a.h * r_, i = a.c; return a_({ l: a.l, a: Math.cos(e) * i, b: Math.sin(e) * i, alpha: a.alpha }); }, interpolate: function (a, e, i) { return { h: ku(a.h, e.h, i), c: nr(a.c, e.c, i), l: nr(a.l, e.l, i), alpha: nr(a.alpha, e.alpha, i) }; } };
            var L0 = Object.freeze({ __proto__: null, hcl: Lu, lab: Du });
            class $s {
                constructor(e, i, c, h, p) { this.type = e, this.operator = i, this.interpolation = c, this.input = h, this.labels = [], this.outputs = []; for (const [m, x] of p)
                    this.labels.push(m), this.outputs.push(x); }
                static interpolationFactor(e, i, c, h) { let p = 0; if (e.name === "exponential")
                    p = Ed(i, e.base, c, h);
                else if (e.name === "linear")
                    p = Ed(i, 1, c, h);
                else if (e.name === "cubic-bezier") {
                    const m = e.controlPoints;
                    p = new Gf(m[0], m[1], m[2], m[3]).solve(Ed(i, 1, c, h));
                } return p; }
                static parse(e, i) { let [c, h, p, ...m] = e; if (!Array.isArray(h) || h.length === 0)
                    return i.error("Expected an interpolation type expression.", 1); if (h[0] === "linear")
                    h = { name: "linear" };
                else if (h[0] === "exponential") {
                    const S = h[1];
                    if (typeof S != "number")
                        return i.error("Exponential interpolation requires a numeric base.", 1, 1);
                    h = { name: "exponential", base: S };
                }
                else {
                    if (h[0] !== "cubic-bezier")
                        return i.error(`Unknown interpolation type ${String(h[0])}`, 1, 0);
                    {
                        const S = h.slice(1);
                        if (S.length !== 4 || S.some(A => typeof A != "number" || A < 0 || A > 1))
                            return i.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                        h = { name: "cubic-bezier", controlPoints: S };
                    }
                } if (e.length - 1 < 4)
                    return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`); if (e.length - 1 > 3 && (e.length - 1) % 2 != 0)
                    return i.error("Expected an even number of arguments."); if (p = i.parse(p, 2, Qt), !p)
                    return null; const x = []; let b = null; c === "interpolate-hcl" || c === "interpolate-lab" ? b = Vs : i.expectedType && i.expectedType.kind !== "value" && (b = i.expectedType); for (let S = 0; S < m.length; S += 2) {
                    const A = m[S], I = m[S + 1], M = S + 3, z = S + 4;
                    if (typeof A != "number")
                        return i.error("Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", M);
                    if (x.length && x[x.length - 1][0] >= A)
                        return i.error("Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.", M);
                    const F = i.parse(I, z, b);
                    if (!F)
                        return null;
                    b = b || F.type, x.push([A, F]);
                } return b.kind === "number" || b.kind === "color" || b.kind === "array" && b.itemType.kind === "number" && typeof b.N == "number" ? new $s(b, c, h, p, x) : i.error(`Type ${Ri(b)} is not interpolatable.`); }
                evaluate(e) { const i = this.labels, c = this.outputs; if (i.length === 1)
                    return c[0].evaluate(e); const h = this.input.evaluate(e); if (h <= i[0])
                    return c[0].evaluate(e); const p = i.length; if (h >= i[p - 1])
                    return c[p - 1].evaluate(e); const m = pp(i, h), x = $s.interpolationFactor(this.interpolation, h, i[m], i[m + 1]), b = c[m].evaluate(e), S = c[m + 1].evaluate(e); return this.operator === "interpolate" ? tp[this.type.kind.toLowerCase()](b, S, x) : this.operator === "interpolate-hcl" ? Lu.reverse(Lu.interpolate(Lu.forward(b), Lu.forward(S), x)) : Du.reverse(Du.interpolate(Du.forward(b), Du.forward(S), x)); }
                eachChild(e) { e(this.input); for (const i of this.outputs)
                    e(i); }
                outputDefined() { return this.outputs.every(e => e.outputDefined()); }
                serialize() { let e; e = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier", ...this.interpolation.controlPoints]; const i = [this.operator, e, this.input.serialize()]; for (let c = 0; c < this.labels.length; c++)
                    i.push(this.labels[c], this.outputs[c].serialize()); return i; }
            }
            function Ed(a, e, i, c) { const h = c - i, p = a - i; return h === 0 ? 0 : e === 1 ? p / h : (Math.pow(e, p) - 1) / (Math.pow(e, h) - 1); }
            class gp {
                constructor(e, i) { this.type = e, this.args = i; }
                static parse(e, i) { if (e.length < 2)
                    return i.error("Expectected at least one argument."); let c = null; const h = i.expectedType; h && h.kind !== "value" && (c = h); const p = []; for (const x of e.slice(1)) {
                    const b = i.parse(x, 1 + p.length, c, void 0, { typeAnnotation: "omit" });
                    if (!b)
                        return null;
                    c = c || b.type, p.push(b);
                } const m = h && p.some(x => _d(h, x.type)); return new gp(m ? un : c, p); }
                evaluate(e) { let i, c = null, h = 0; for (const p of this.args) {
                    if (h++, c = p.evaluate(e), c && c instanceof Us && !c.available && (i || (i = c), c = null, h === this.args.length))
                        return i;
                    if (c !== null)
                        break;
                } return c; }
                eachChild(e) { this.args.forEach(e); }
                outputDefined() { return this.args.every(e => e.outputDefined()); }
                serialize() { const e = ["coalesce"]; return this.eachChild(i => { e.push(i.serialize()); }), e; }
            }
            class _p {
                constructor(e, i) { this.type = i.type, this.bindings = [].concat(e), this.result = i; }
                evaluate(e) { return this.result.evaluate(e); }
                eachChild(e) { for (const i of this.bindings)
                    e(i[1]); e(this.result); }
                static parse(e, i) { if (e.length < 4)
                    return i.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`); const c = []; for (let p = 1; p < e.length - 1; p += 2) {
                    const m = e[p];
                    if (typeof m != "string")
                        return i.error(`Expected string, but found ${typeof m} instead.`, p);
                    if (/[^a-zA-Z0-9_]/.test(m))
                        return i.error("Variable names must contain only alphanumeric characters or '_'.", p);
                    const x = i.parse(e[p + 1], p + 1);
                    if (!x)
                        return null;
                    c.push([m, x]);
                } const h = i.parse(e[e.length - 1], e.length - 1, i.expectedType, c); return h ? new _p(c, h) : null; }
                outputDefined() { return this.result.outputDefined(); }
                serialize() { const e = ["let"]; for (const [i, c] of this.bindings)
                    e.push(i, c.serialize()); return e.push(this.result.serialize()), e; }
            }
            class yp {
                constructor(e, i, c) { this.type = e, this.index = i, this.input = c; }
                static parse(e, i) { if (e.length !== 3)
                    return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`); const c = i.parse(e[1], 1, Qt), h = i.parse(e[2], 2, Is(i.expectedType || un)); return c && h ? new yp(h.type.itemType, c, h) : null; }
                evaluate(e) { const i = this.index.evaluate(e), c = this.input.evaluate(e); if (i < 0)
                    throw new Ut(`Array index out of bounds: ${i} < 0.`); if (i >= c.length)
                    throw new Ut(`Array index out of bounds: ${i} > ${c.length - 1}.`); if (i !== Math.floor(i))
                    throw new Ut(`Array index must be an integer, but found ${i} instead. Use at-interpolated to retrieve interpolated result with a fractional index.`); return c[i]; }
                eachChild(e) { e(this.index), e(this.input); }
                outputDefined() { return !1; }
                serialize() { return ["at", this.index.serialize(), this.input.serialize()]; }
            }
            class vp {
                constructor(e, i, c) { this.type = e, this.index = i, this.input = c; }
                static parse(e, i) { if (e.length !== 3)
                    return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`); const c = i.parse(e[1], 1, Qt), h = i.parse(e[2], 2, Is(i.expectedType || un)); return c && h ? new vp(h.type.itemType, c, h) : null; }
                evaluate(e) { const i = this.index.evaluate(e), c = this.input.evaluate(e); if (i < 0)
                    throw new Ut(`Array index out of bounds: ${i} < 0.`); if (i > c.length - 1)
                    throw new Ut(`Array index out of bounds: ${i} > ${c.length - 1}.`); if (i === Math.floor(i))
                    return c[i]; const h = Math.floor(i), p = Math.ceil(i), m = c[h], x = c[p]; if (typeof m != "number" || typeof x != "number")
                    throw new Ut(`Cannot interpolate between non-number values at index ${i}.`); const b = i - h; return m * (1 - b) + x * b; }
                eachChild(e) { e(this.index), e(this.input); }
                outputDefined() { return !1; }
                serialize() { return ["at-interpolated", this.index.serialize(), this.input.serialize()]; }
            }
            class l_ {
                constructor(e, i) { this.type = dn, this.needle = e, this.haystack = i; }
                static parse(e, i) { if (e.length !== 3)
                    return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`); const c = i.parse(e[1], 1, un), h = i.parse(e[2], 2, un); return c && h ? Vg(c.type, [dn, bn, Qt, Il, un]) ? new l_(c, h) : i.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ri(c.type)} instead`) : null; }
                evaluate(e) { const i = this.needle.evaluate(e), c = this.haystack.evaluate(e); if (c == null)
                    return !1; if (!wu(i, ["boolean", "string", "number", "null"]))
                    throw new Ut(`Expected first argument to be of type boolean, string, number or null, but found ${Ri(ji(i))} instead.`); if (!wu(c, ["string", "array"]))
                    throw new Ut(`Expected second argument to be of type array or string, but found ${Ri(ji(c))} instead.`); return c.indexOf(i) >= 0; }
                eachChild(e) { e(this.needle), e(this.haystack); }
                outputDefined() { return !0; }
                serialize() { return ["in", this.needle.serialize(), this.haystack.serialize()]; }
            }
            class xp {
                constructor(e, i, c) { this.type = Qt, this.needle = e, this.haystack = i, this.fromIndex = c; }
                static parse(e, i) { if (e.length <= 2 || e.length >= 5)
                    return i.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`); const c = i.parse(e[1], 1, un), h = i.parse(e[2], 2, un); if (!c || !h)
                    return null; if (!Vg(c.type, [dn, bn, Qt, Il, un]))
                    return i.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ri(c.type)} instead`); if (e.length === 4) {
                    const p = i.parse(e[3], 3, Qt);
                    return p ? new xp(c, h, p) : null;
                } return new xp(c, h); }
                evaluate(e) { const i = this.needle.evaluate(e), c = this.haystack.evaluate(e); if (!wu(i, ["boolean", "string", "number", "null"]))
                    throw new Ut(`Expected first argument to be of type boolean, string, number or null, but found ${Ri(ji(i))} instead.`); if (!wu(c, ["string", "array"]))
                    throw new Ut(`Expected second argument to be of type array or string, but found ${Ri(ji(c))} instead.`); if (this.fromIndex) {
                    const h = this.fromIndex.evaluate(e);
                    return c.indexOf(i, h);
                } return c.indexOf(i); }
                eachChild(e) { e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex); }
                outputDefined() { return !1; }
                serialize() { if (this.fromIndex != null && this.fromIndex !== void 0) {
                    const e = this.fromIndex.serialize();
                    return ["index-of", this.needle.serialize(), this.haystack.serialize(), e];
                } return ["index-of", this.needle.serialize(), this.haystack.serialize()]; }
            }
            class c_ {
                constructor(e, i, c, h, p, m) { this.inputType = e, this.type = i, this.input = c, this.cases = h, this.outputs = p, this.otherwise = m; }
                static parse(e, i) { if (e.length < 5)
                    return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`); if (e.length % 2 != 1)
                    return i.error("Expected an even number of arguments."); let c, h; i.expectedType && i.expectedType.kind !== "value" && (h = i.expectedType); const p = {}, m = []; for (let S = 2; S < e.length - 1; S += 2) {
                    let A = e[S];
                    const I = e[S + 1];
                    Array.isArray(A) || (A = [A]);
                    const M = i.concat(S);
                    if (A.length === 0)
                        return M.error("Expected at least one branch label.");
                    for (const F of A) {
                        if (typeof F != "number" && typeof F != "string")
                            return M.error("Branch labels must be numbers or strings.");
                        if (typeof F == "number" && Math.abs(F) > Number.MAX_SAFE_INTEGER)
                            return M.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                        if (typeof F == "number" && Math.floor(F) !== F)
                            return M.error("Numeric branch labels must be integer values.");
                        if (c) {
                            if (M.checkSubtype(c, ji(F)))
                                return null;
                        }
                        else
                            c = ji(F);
                        if (p[String(F)] !== void 0)
                            return M.error("Branch labels must be unique.");
                        p[String(F)] = m.length;
                    }
                    const z = i.parse(I, S, h);
                    if (!z)
                        return null;
                    h = h || z.type, m.push(z);
                } const x = i.parse(e[1], 1, un); if (!x)
                    return null; const b = i.parse(e[e.length - 1], e.length - 1, h); return b ? x.type.kind !== "value" && i.concat(1).checkSubtype(c, x.type) ? null : new c_(c, h, x, p, m, b) : null; }
                evaluate(e) { const i = this.input.evaluate(e); return (ji(i) === this.inputType && this.outputs[this.cases[i]] || this.otherwise).evaluate(e); }
                eachChild(e) { e(this.input), this.outputs.forEach(e), e(this.otherwise); }
                outputDefined() { return this.outputs.every(e => e.outputDefined()) && this.otherwise.outputDefined(); }
                serialize() { const e = ["match", this.input.serialize()], i = Object.keys(this.cases).sort(), c = [], h = {}; for (const m of i) {
                    const x = h[this.cases[m]];
                    x === void 0 ? (h[this.cases[m]] = c.length, c.push([this.cases[m], [m]])) : c[x][1].push(m);
                } const p = m => this.inputType.kind === "number" ? Number(m) : m; for (const [m, x] of c)
                    e.push(x.length === 1 ? p(x[0]) : x.map(p)), e.push(this.outputs[m].serialize()); return e.push(this.otherwise.serialize()), e; }
            }
            class wp {
                constructor(e, i, c) { this.type = e, this.branches = i, this.otherwise = c; }
                static parse(e, i) { if (e.length < 4)
                    return i.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`); if (e.length % 2 != 0)
                    return i.error("Expected an odd number of arguments."); let c; i.expectedType && i.expectedType.kind !== "value" && (c = i.expectedType); const h = []; for (let m = 1; m < e.length - 1; m += 2) {
                    const x = i.parse(e[m], m, dn);
                    if (!x)
                        return null;
                    const b = i.parse(e[m + 1], m + 1, c);
                    if (!b)
                        return null;
                    h.push([x, b]), c = c || b.type;
                } const p = i.parse(e[e.length - 1], e.length - 1, c); return p ? new wp(c, h, p) : null; }
                evaluate(e) { for (const [i, c] of this.branches)
                    if (i.evaluate(e))
                        return c.evaluate(e); return this.otherwise.evaluate(e); }
                eachChild(e) { for (const [i, c] of this.branches)
                    e(i), e(c); e(this.otherwise); }
                outputDefined() { return this.branches.every(([e, i]) => i.outputDefined()) && this.otherwise.outputDefined(); }
                serialize() { const e = ["case"]; return this.eachChild(i => { e.push(i.serialize()); }), e; }
            }
            class Cd {
                constructor(e, i, c, h) { this.type = e, this.input = i, this.beginIndex = c, this.endIndex = h; }
                static parse(e, i) { if (e.length <= 2 || e.length >= 5)
                    return i.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`); const c = i.parse(e[1], 1, un), h = i.parse(e[2], 2, Qt); if (!c || !h)
                    return null; if (!Vg(c.type, [Is(un), bn, un]))
                    return i.error(`Expected first argument to be of type array or string, but found ${Ri(c.type)} instead`); if (e.length === 4) {
                    const p = i.parse(e[3], 3, Qt);
                    return p ? new Cd(c.type, c, h, p) : null;
                } return new Cd(c.type, c, h); }
                evaluate(e) { const i = this.input.evaluate(e), c = this.beginIndex.evaluate(e); if (!wu(i, ["string", "array"]))
                    throw new Ut(`Expected first argument to be of type array or string, but found ${Ri(ji(i))} instead.`); if (this.endIndex) {
                    const h = this.endIndex.evaluate(e);
                    return i.slice(c, h);
                } return i.slice(c); }
                eachChild(e) { e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex); }
                outputDefined() { return !1; }
                serialize() { if (this.endIndex != null && this.endIndex !== void 0) {
                    const e = this.endIndex.serialize();
                    return ["slice", this.input.serialize(), this.beginIndex.serialize(), e];
                } return ["slice", this.input.serialize(), this.beginIndex.serialize()]; }
            }
            function Ad(a, e) { return a === "==" || a === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value"; }
            function O0(a, e, i, c) { return c.compare(e, i) === 0; }
            function Mc(a, e, i) { const c = a !== "==" && a !== "!="; return class _B {
                constructor(p, m, x) { this.type = dn, this.lhs = p, this.rhs = m, this.collator = x, this.hasUntypedArgument = p.type.kind === "value" || m.type.kind === "value"; }
                static parse(p, m) { if (p.length !== 3 && p.length !== 4)
                    return m.error("Expected two or three arguments."); const x = p[0]; let b = m.parse(p[1], 1, un); if (!b)
                    return null; if (!Ad(x, b.type))
                    return m.concat(1).error(`"${x}" comparisons are not supported for type '${Ri(b.type)}'.`); let S = m.parse(p[2], 2, un); if (!S)
                    return null; if (!Ad(x, S.type))
                    return m.concat(2).error(`"${x}" comparisons are not supported for type '${Ri(S.type)}'.`); if (b.type.kind !== S.type.kind && b.type.kind !== "value" && S.type.kind !== "value")
                    return m.error(`Cannot compare types '${Ri(b.type)}' and '${Ri(S.type)}'.`); c && (b.type.kind === "value" && S.type.kind !== "value" ? b = new dr(S.type, [b]) : b.type.kind !== "value" && S.type.kind === "value" && (S = new dr(b.type, [S]))); let A = null; if (p.length === 4) {
                    if (b.type.kind !== "string" && S.type.kind !== "string" && b.type.kind !== "value" && S.type.kind !== "value")
                        return m.error("Cannot use collator to compare non-string types.");
                    if (A = m.parse(p[3], 3, Tc), !A)
                        return null;
                } return new _B(b, S, A); }
                evaluate(p) { const m = this.lhs.evaluate(p), x = this.rhs.evaluate(p); if (c && this.hasUntypedArgument) {
                    const b = ji(m), S = ji(x);
                    if (b.kind !== S.kind || b.kind !== "string" && b.kind !== "number")
                        throw new Ut(`Expected arguments for "${a}" to be (string, string) or (number, number), but found (${b.kind}, ${S.kind}) instead.`);
                } if (this.collator && !c && this.hasUntypedArgument) {
                    const b = ji(m), S = ji(x);
                    if (b.kind !== "string" || S.kind !== "string")
                        return e(p, m, x);
                } return this.collator ? i(p, m, x, this.collator.evaluate(p)) : e(p, m, x); }
                eachChild(p) { p(this.lhs), p(this.rhs), this.collator && p(this.collator); }
                outputDefined() { return !0; }
                serialize() { const p = [a]; return this.eachChild(m => { p.push(m.serialize()); }), p; }
            }; }
            const oT = Mc("==", function (a, e, i) { return e === i; }, O0), aT = Mc("!=", function (a, e, i) { return e !== i; }, function (a, e, i, c) { return !O0(0, e, i, c); }), z0 = Mc("<", function (a, e, i) { return e < i; }, function (a, e, i, c) { return c.compare(e, i) < 0; }), F0 = Mc(">", function (a, e, i) { return e > i; }, function (a, e, i, c) { return c.compare(e, i) > 0; }), lT = Mc("<=", function (a, e, i) { return e <= i; }, function (a, e, i, c) { return c.compare(e, i) <= 0; }), cT = Mc(">=", function (a, e, i) { return e >= i; }, function (a, e, i, c) { return c.compare(e, i) >= 0; });
            class u_ {
                constructor(e, i, c, h, p, m) { this.type = bn, this.number = e, this.locale = i, this.currency = c, this.unit = h, this.minFractionDigits = p, this.maxFractionDigits = m; }
                static parse(e, i) { if (e.length !== 3)
                    return i.error("Expected two arguments."); const c = i.parse(e[1], 1, Qt); if (!c)
                    return null; const h = e[2]; if (typeof h != "object" || Array.isArray(h))
                    return i.error("NumberFormat options argument must be an object."); let p = null; if (h.locale && (p = i.parseObjectValue(h.locale, 2, "locale", bn), !p))
                    return null; let m = null; if (h.currency && (m = i.parseObjectValue(h.currency, 2, "currency", bn), !m))
                    return null; let x = null; if (h.unit && (x = i.parseObjectValue(h.unit, 2, "unit", bn), !x))
                    return null; let b = null; if (h["min-fraction-digits"] && (b = i.parseObjectValue(h["min-fraction-digits"], 2, "min-fraction-digits", Qt), !b))
                    return null; let S = null; return h["max-fraction-digits"] && (S = i.parseObjectValue(h["max-fraction-digits"], 2, "max-fraction-digits", Qt), !S) ? null : new u_(c, p, m, x, b, S); }
                evaluate(e) { return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, unit: this.unit ? this.unit.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e)); }
                eachChild(e) { e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.unit && e(this.unit), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits); }
                outputDefined() { return !1; }
                serialize() { const e = {}; return this.locale && (e.locale = this.locale.serialize()), this.currency && (e.currency = this.currency.serialize()), this.unit && (e.unit = this.unit.serialize()), this.minFractionDigits && (e["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (e["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), e]; }
            }
            class Id {
                constructor(e) { this.type = Qt, this.input = e; }
                static parse(e, i) { if (e.length !== 2)
                    return i.error(`Expected 1 argument, but found ${e.length - 1} instead.`); const c = i.parse(e[1], 1); return c ? c.type.kind !== "array" && c.type.kind !== "string" && c.type.kind !== "value" ? i.error(`Expected argument of type string or array, but found ${Ri(c.type)} instead.`) : new Id(c) : null; }
                evaluate(e) { const i = this.input.evaluate(e); if (typeof i == "string" || Array.isArray(i))
                    return i.length; throw new Ut(`Expected value to be of type string or array, but found ${Ri(ji(i))} instead.`); }
                eachChild(e) { e(this.input); }
                outputDefined() { return !1; }
                serialize() { const e = ["length"]; return this.eachChild(i => { e.push(i.serialize()); }), e; }
            }
            function N0(a) { return function () { a = 1831565813 + (a |= 0) | 0; let e = Math.imul(a ^ a >>> 15, 1 | a); return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296; }; }
            const Rc = { "==": oT, "!=": aT, ">": F0, "<": z0, ">=": cT, "<=": lT, array: dr, at: yp, "at-interpolated": vp, boolean: dr, case: wp, coalesce: gp, collator: Su, format: Sc, image: Tu, in: l_, "index-of": xp, interpolate: $s, "interpolate-hcl": $s, "interpolate-lab": $s, length: Id, let: _p, literal: Rr, match: c_, number: dr, "number-format": u_, object: dr, slice: Cd, step: Sd, string: dr, "to-boolean": ta, "to-color": ta, "to-number": ta, "to-string": ta, var: fp, within: Ya, distance: Pc, config: Pu };
            function B0(a, [e, i, c, h]) { e = e.evaluate(a), i = i.evaluate(a), c = c.evaluate(a); const p = h ? h.evaluate(a) : 1, m = _0(e, i, c, p); if (m)
                throw new Ut(m); return new nn(e / 255 * p, i / 255 * p, c / 255 * p, p); }
            function j0(a, [e, i, c, h]) { e = e.evaluate(a), i = i.evaluate(a), c = c.evaluate(a); const p = h ? h.evaluate(a) : 1, m = function (S, A, I, M) { return typeof S == "number" && S >= 0 && S <= 360 ? typeof A == "number" && A >= 0 && A <= 100 && typeof I == "number" && I >= 0 && I <= 100 ? M === void 0 || typeof M == "number" && M >= 0 && M <= 1 ? null : `Invalid hsla value [${[S, A, I, M].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${(typeof M == "number" ? [S, A, I, M] : [S, A, I]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${(typeof M == "number" ? [S, A, I, M] : [S, A, I]).join(", ")}]: 'h' must be between 0 and 360.`; }(e, i, c, p); if (m)
                throw new Ut(m); const x = `hsla(${e}, ${i}%, ${c}%, ${p})`, b = nn.parse(x); if (!b)
                throw new Ut(`Failed to parse HSLA color: ${x}`); return b; }
            function h_(a, e) { return a in e; }
            function bp(a, e) { const i = e[a]; return i === void 0 ? null : i; }
            function Ol(a) { return { type: a }; }
            function V0(a) { return { result: "success", value: a }; }
            function mo(a) { return { result: "error", value: a }; }
            function d_(a, e) { return !!a && !!a.parameters && a.parameters.indexOf(e) > -1; }
            function Tp(a) { return a["property-type"] === "data-driven"; }
            function U0(a) { return d_(a.expression, "measure-light"); }
            function f_(a) { return d_(a.expression, "zoom"); }
            function Sp(a) { return !!a.expression && a.expression.interpolated; }
            function Ep(a) { return typeof a == "object" && a !== null && !Array.isArray(a); }
            function $0(a) { return a; }
            function Cp(a, e) { const i = e.type === "color", c = a.stops && typeof a.stops[0][0] == "object", h = c || !(c || a.property !== void 0), p = a.type || (Sp(e) ? "exponential" : "interval"); if (i && ((a = pd({}, a)).stops && (a.stops = a.stops.map(S => [S[0], nn.parse(S[1])])), a.default = nn.parse(a.default ? a.default : e.default)), a.colorSpace && a.colorSpace !== "rgb" && !L0[a.colorSpace])
                throw new Error(`Unknown color space: ${a.colorSpace}`); let m, x, b; if (p === "exponential")
                m = Qa;
            else if (p === "interval")
                m = uT;
            else if (p === "categorical") {
                m = G0, x = Object.create(null);
                for (const S of a.stops)
                    x[S[0]] = S[1];
                b = typeof a.stops[0][0];
            }
            else {
                if (p !== "identity")
                    throw new Error(`Unknown function type "${p}"`);
                m = hT;
            } if (c) {
                const S = {}, A = [];
                for (let z = 0; z < a.stops.length; z++) {
                    const F = a.stops[z], U = F[0].zoom;
                    S[U] === void 0 && (S[U] = { zoom: U, type: a.type, property: a.property, default: a.default, stops: [] }, A.push(U)), S[U].stops.push([F[0].value, F[1]]);
                }
                const I = [];
                for (const z of A)
                    I.push([S[z].zoom, Cp(S[z], e)]);
                const M = { name: "linear" };
                return { kind: "composite", interpolationType: M, interpolationFactor: $s.interpolationFactor.bind(void 0, M), zoomStops: I.map(z => z[0]), evaluate: ({ zoom: z }, F) => Qa({ stops: I, base: a.base }, e, z).evaluate(z, F) };
            } if (h) {
                const S = p === "exponential" ? { name: "exponential", base: a.base !== void 0 ? a.base : 1 } : null;
                return { kind: "camera", interpolationType: S, interpolationFactor: $s.interpolationFactor.bind(void 0, S), zoomStops: a.stops.map(A => A[0]), evaluate: ({ zoom: A }) => m(a, e, A, x, b) };
            } return { kind: "source", evaluate(S, A) { const I = A && A.properties ? A.properties[a.property] : void 0; return I === void 0 ? kc(a.default, e.default) : m(a, e, I, x, b); } }; }
            function kc(a, e, i) { return a !== void 0 ? a : e !== void 0 ? e : i !== void 0 ? i : void 0; }
            function G0(a, e, i, c, h) { return kc(typeof i === h ? c[i] : void 0, a.default, e.default); }
            function uT(a, e, i) { if (fr(i) !== "number")
                return kc(a.default, e.default); const c = a.stops.length; if (c === 1 || i <= a.stops[0][0])
                return a.stops[0][1]; if (i >= a.stops[c - 1][0])
                return a.stops[c - 1][1]; const h = pp(a.stops.map(p => p[0]), i); return a.stops[h][1]; }
            function Qa(a, e, i) { const c = a.base !== void 0 ? a.base : 1; if (fr(i) !== "number")
                return kc(a.default, e.default); const h = a.stops.length; if (h === 1 || i <= a.stops[0][0])
                return a.stops[0][1]; if (i >= a.stops[h - 1][0])
                return a.stops[h - 1][1]; const p = pp(a.stops.map(A => A[0]), i), m = function (A, I, M, z) { const F = z - M, U = A - M; return F === 0 ? 0 : I === 1 ? U / F : (Math.pow(I, U) - 1) / (Math.pow(I, F) - 1); }(i, c, a.stops[p][0], a.stops[p + 1][0]), x = a.stops[p][1], b = a.stops[p + 1][1]; let S = tp[e.type] || $0; if (a.colorSpace && a.colorSpace !== "rgb") {
                const A = L0[a.colorSpace];
                S = (I, M) => A.reverse(A.interpolate(A.forward(I), A.forward(M), m));
            } return typeof x.evaluate == "function" ? { evaluate(...A) { const I = x.evaluate.apply(void 0, A), M = b.evaluate.apply(void 0, A); if (I !== void 0 && M !== void 0)
                    return S(I, M, m); } } : S(x, b, m); }
            function hT(a, e, i) { return e.type === "color" ? i = nn.parse(i) : e.type === "formatted" ? i = Ps.fromString(i.toString()) : e.type === "resolvedImage" ? i = Us.build(i.toString()) : fr(i) === e.type || e.type === "enum" && e.values[i] || (i = void 0), kc(i, a.default, e.default); }
            vs.register(Rc, { error: [{ kind: "error" }, [bn], (a, [e]) => { throw new Ut(e.evaluate(a)); }], typeof: [bn, [un], (a, [e]) => Ri(ji(e.evaluate(a)))], "to-rgba": [Is(Qt, 4), [Vs], (a, [e]) => e.evaluate(a).toRenderColor(null).toArray()], "to-hsla": [Is(Qt, 4), [Vs], (a, [e]) => e.evaluate(a).toRenderColor(null).toHslaArray()], rgb: [Vs, [Qt, Qt, Qt], B0], rgba: [Vs, [Qt, Qt, Qt, Qt], B0], hsl: [Vs, [Qt, Qt, Qt], j0], hsla: [Vs, [Qt, Qt, Qt, Qt], j0], has: { type: dn, overloads: [[[bn], (a, [e]) => h_(e.evaluate(a), a.properties())], [[bn, Pl], (a, [e, i]) => h_(e.evaluate(a), i.evaluate(a))]] }, get: { type: un, overloads: [[[bn], (a, [e]) => bp(e.evaluate(a), a.properties())], [[bn, Pl], (a, [e, i]) => bp(e.evaluate(a), i.evaluate(a))]] }, "feature-state": [un, [bn], (a, [e]) => bp(e.evaluate(a), a.featureState || {})], properties: [Pl, [], a => a.properties()], "geometry-type": [bn, [], a => a.geometryType()], id: [un, [], a => a.id()], zoom: [Qt, [], a => a.globals.zoom], pitch: [Qt, [], a => a.globals.pitch || 0], "distance-from-center": [Qt, [], a => a.distanceFromCenter()], "measure-light": [Qt, [bn], (a, [e]) => a.measureLight(e.evaluate(a))], "heatmap-density": [Qt, [], a => a.globals.heatmapDensity || 0], "line-progress": [Qt, [], a => a.globals.lineProgress || 0], "raster-value": [Qt, [], a => a.globals.rasterValue || 0], "raster-particle-speed": [Qt, [], a => a.globals.rasterParticleSpeed || 0], "sky-radial-progress": [Qt, [], a => a.globals.skyRadialProgress || 0], accumulated: [un, [], a => a.globals.accumulated === void 0 ? null : a.globals.accumulated], "+": [Qt, Ol(Qt), (a, e) => { let i = 0; for (const c of e)
                        i += c.evaluate(a); return i; }], "*": [Qt, Ol(Qt), (a, e) => { let i = 1; for (const c of e)
                        i *= c.evaluate(a); return i; }], "-": { type: Qt, overloads: [[[Qt, Qt], (a, [e, i]) => e.evaluate(a) - i.evaluate(a)], [[Qt], (a, [e]) => -e.evaluate(a)]] }, "/": [Qt, [Qt, Qt], (a, [e, i]) => e.evaluate(a) / i.evaluate(a)], "%": [Qt, [Qt, Qt], (a, [e, i]) => e.evaluate(a) % i.evaluate(a)], ln2: [Qt, [], () => Math.LN2], pi: [Qt, [], () => Math.PI], e: [Qt, [], () => Math.E], "^": [Qt, [Qt, Qt], (a, [e, i]) => Math.pow(e.evaluate(a), i.evaluate(a))], sqrt: [Qt, [Qt], (a, [e]) => Math.sqrt(e.evaluate(a))], log10: [Qt, [Qt], (a, [e]) => Math.log(e.evaluate(a)) / Math.LN10], ln: [Qt, [Qt], (a, [e]) => Math.log(e.evaluate(a))], log2: [Qt, [Qt], (a, [e]) => Math.log(e.evaluate(a)) / Math.LN2], sin: [Qt, [Qt], (a, [e]) => Math.sin(e.evaluate(a))], cos: [Qt, [Qt], (a, [e]) => Math.cos(e.evaluate(a))], tan: [Qt, [Qt], (a, [e]) => Math.tan(e.evaluate(a))], asin: [Qt, [Qt], (a, [e]) => Math.asin(e.evaluate(a))], acos: [Qt, [Qt], (a, [e]) => Math.acos(e.evaluate(a))], atan: [Qt, [Qt], (a, [e]) => Math.atan(e.evaluate(a))], min: [Qt, Ol(Qt), (a, e) => Math.min(...e.map(i => i.evaluate(a)))], max: [Qt, Ol(Qt), (a, e) => Math.max(...e.map(i => i.evaluate(a)))], abs: [Qt, [Qt], (a, [e]) => Math.abs(e.evaluate(a))], round: [Qt, [Qt], (a, [e]) => { const i = e.evaluate(a); return i < 0 ? -Math.round(-i) : Math.round(i); }], floor: [Qt, [Qt], (a, [e]) => Math.floor(e.evaluate(a))], ceil: [Qt, [Qt], (a, [e]) => Math.ceil(e.evaluate(a))], "filter-==": [dn, [bn, un], (a, [e, i]) => a.properties()[e.value] === i.value], "filter-id-==": [dn, [un], (a, [e]) => a.id() === e.value], "filter-type-==": [dn, [bn], (a, [e]) => a.geometryType() === e.value], "filter-<": [dn, [bn, un], (a, [e, i]) => { const c = a.properties()[e.value], h = i.value; return typeof c == typeof h && c < h; }], "filter-id-<": [dn, [un], (a, [e]) => { const i = a.id(), c = e.value; return typeof i == typeof c && i < c; }], "filter->": [dn, [bn, un], (a, [e, i]) => { const c = a.properties()[e.value], h = i.value; return typeof c == typeof h && c > h; }], "filter-id->": [dn, [un], (a, [e]) => { const i = a.id(), c = e.value; return typeof i == typeof c && i > c; }], "filter-<=": [dn, [bn, un], (a, [e, i]) => { const c = a.properties()[e.value], h = i.value; return typeof c == typeof h && c <= h; }], "filter-id-<=": [dn, [un], (a, [e]) => { const i = a.id(), c = e.value; return typeof i == typeof c && i <= c; }], "filter->=": [dn, [bn, un], (a, [e, i]) => { const c = a.properties()[e.value], h = i.value; return typeof c == typeof h && c >= h; }], "filter-id->=": [dn, [un], (a, [e]) => { const i = a.id(), c = e.value; return typeof i == typeof c && i >= c; }], "filter-has": [dn, [un], (a, [e]) => e.value in a.properties()], "filter-has-id": [dn, [], a => a.id() !== null && a.id() !== void 0], "filter-type-in": [dn, [Is(bn)], (a, [e]) => e.value.indexOf(a.geometryType()) >= 0], "filter-id-in": [dn, [Is(un)], (a, [e]) => e.value.indexOf(a.id()) >= 0], "filter-in-small": [dn, [bn, Is(un)], (a, [e, i]) => i.value.indexOf(a.properties()[e.value]) >= 0], "filter-in-large": [dn, [bn, Is(un)], (a, [e, i]) => function (c, h, p, m) { for (; p <= m;) {
                        const x = p + m >> 1;
                        if (h[x] === c)
                            return !0;
                        h[x] > c ? m = x - 1 : p = x + 1;
                    } return !1; }(a.properties()[e.value], i.value, 0, i.value.length - 1)], all: { type: dn, overloads: [[[dn, dn], (a, [e, i]) => e.evaluate(a) && i.evaluate(a)], [Ol(dn), (a, e) => { for (const i of e)
                                if (!i.evaluate(a))
                                    return !1; return !0; }]] }, any: { type: dn, overloads: [[[dn, dn], (a, [e, i]) => e.evaluate(a) || i.evaluate(a)], [Ol(dn), (a, e) => { for (const i of e)
                                if (i.evaluate(a))
                                    return !0; return !1; }]] }, "!": [dn, [dn], (a, [e]) => !e.evaluate(a)], "is-supported-script": [dn, [bn], (a, [e]) => { const i = a.globals && a.globals.isSupportedScript; return !i || i(e.evaluate(a)); }], upcase: [bn, [bn], (a, [e]) => e.evaluate(a).toUpperCase()], downcase: [bn, [bn], (a, [e]) => e.evaluate(a).toLowerCase()], concat: [bn, Ol(un), (a, e) => e.map(i => Ms(i.evaluate(a))).join("")], "resolved-locale": [bn, [Tc], (a, [e]) => e.evaluate(a).resolvedLocale()], random: [Qt, [Qt, Qt, un], (a, e) => { const [i, c, h] = e.map(m => m.evaluate(a)); if (i > c || i === c)
                        return i; let p; if (typeof h == "string")
                        p = function (m) { let x = 0; if (m.length === 0)
                            return x; for (let b = 0; b < m.length; b++)
                            x = (x << 5) - x + m.charCodeAt(b), x |= 0; return x; }(h);
                    else {
                        if (typeof h != "number")
                            throw new Ut(`Invalid seed input: ${h}`);
                        p = h;
                    } return i + N0(p)() * (c - i); }] });
            class p_ {
                constructor(e, i, c, h) { this.expression = e, this._warningHistory = {}, this._evaluator = new np(c, h), this._defaultValue = i ? function (p) { return p.type === "color" && (Ep(p.default) || Array.isArray(p.default)) ? new nn(0, 0, 0, 0) : p.type === "color" ? nn.parse(p.default) || null : p.default === void 0 ? null : p.default; }(i) : null, this._enumValues = i && i.type === "enum" ? i.values : null, this.configDependencies = dp(e); }
                evaluateWithoutErrorHandling(e, i, c, h, p, m, x, b) { return this._evaluator.globals = e, this._evaluator.feature = i, this._evaluator.featureState = c, this._evaluator.canonical = h || null, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = m, this._evaluator.featureTileCoord = x || null, this._evaluator.featureDistanceData = b || null, this.expression.evaluate(this._evaluator); }
                evaluate(e, i, c, h, p, m, x, b) { this._evaluator.globals = e, this._evaluator.feature = i || null, this._evaluator.featureState = c || null, this._evaluator.canonical = h || null, this._evaluator.availableImages = p || null, this._evaluator.formattedSection = m || null, this._evaluator.featureTileCoord = x || null, this._evaluator.featureDistanceData = b || null; try {
                    const S = this.expression.evaluate(this._evaluator);
                    if (S == null || typeof S == "number" && S != S)
                        return this._defaultValue;
                    if (this._enumValues && !(S in this._enumValues))
                        throw new Ut(`Expected value to be one of ${Object.keys(this._enumValues).map(A => JSON.stringify(A)).join(", ")}, but found ${JSON.stringify(S)} instead.`);
                    return S;
                }
                catch (S) {
                    return this._warningHistory[S.message] || (this._warningHistory[S.message] = !0, typeof console < "u" && console.warn(`Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${S.message}`)), this._defaultValue;
                } }
            }
            function Ap(a) { return Array.isArray(a) && a.length > 0 && typeof a[0] == "string" && a[0] in Rc; }
            function Ou(a, e, i, c) { const h = new P0(Rc, [], e ? function (m) { const x = { color: Vs, string: bn, number: Qt, enum: bn, boolean: dn, formatted: md, resolvedImage: gd }; return m.type === "array" ? Is(x[m.value] || un, m.length) : x[m.type]; }(e) : void 0, void 0, void 0, i, c), p = h.parse(a, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0); return p ? V0(new p_(p, e, i, c)) : mo(h.errors); }
            class Dc {
                constructor(e, i, c, h) { this.kind = e, this._styleExpression = i, this.isLightConstant = c, this.isLineProgressConstant = h, this.isStateDependent = e !== "constant" && !hp(i.expression), this.configDependencies = dp(i.expression); }
                evaluateWithoutErrorHandling(e, i, c, h, p, m) { return this._styleExpression.evaluateWithoutErrorHandling(e, i, c, h, p, m); }
                evaluate(e, i, c, h, p, m) { return this._styleExpression.evaluate(e, i, c, h, p, m); }
            }
            class zu {
                constructor(e, i, c, h, p, m) { this.kind = e, this.zoomStops = c, this._styleExpression = i, this.isStateDependent = e !== "camera" && !hp(i.expression), this.isLightConstant = p, this.isLineProgressConstant = m, this.configDependencies = dp(i.expression), this.interpolationType = h; }
                evaluateWithoutErrorHandling(e, i, c, h, p, m) { return this._styleExpression.evaluateWithoutErrorHandling(e, i, c, h, p, m); }
                evaluate(e, i, c, h, p, m) { return this._styleExpression.evaluate(e, i, c, h, p, m); }
                interpolationFactor(e, i, c) { return this.interpolationType ? $s.interpolationFactor(this.interpolationType, e, i, c) : 0; }
            }
            function Pd(a, e, i, c) { if ((a = Ou(a, e, i, c)).result === "error")
                return a; const h = a.value.expression, p = Td(h); if (!p && !Tp(e))
                return mo([new Do("", "data expressions not supported")]); const m = Mu(h, ["zoom", "pitch", "distance-from-center"]); if (!m && !f_(e))
                return mo([new Do("", "zoom expressions not supported")]); const x = Mu(h, ["measure-light"]); if (!x && !U0(e))
                return mo([new Do("", "measure-light expression not supported")]); const b = Mu(h, ["line-progress"]); if (!b && !function (I) { return d_(I.expression, "line-progress"); }(e))
                return mo([new Do("", "line-progress expression not supported")]); const S = e.expression && e.expression.relaxZoomRestriction, A = Ip(h); return A || m || S ? A instanceof Do ? mo([A]) : A instanceof $s && !Sp(e) ? mo([new Do("", "\"interpolate\" expressions cannot be used with this property")]) : V0(A ? new zu(p && b ? "camera" : "composite", a.value, A.labels, A instanceof $s ? A.interpolation : void 0, x, b) : new Dc(p && b ? "constant" : "source", a.value, x, b)) : mo([new Do("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression, or in the properties of atmosphere.")]); }
            class Md {
                constructor(e, i) { this._parameters = e, this._specification = i, pd(this, Cp(this._parameters, this._specification)); }
                static deserialize(e) { return new Md(e._parameters, e._specification); }
                static serialize(e) { return { _parameters: e._parameters, _specification: e._specification }; }
            }
            function Ip(a) { let e = null; if (a instanceof _p)
                e = Ip(a.result);
            else if (a instanceof gp) {
                for (const i of a.args)
                    if (e = Ip(i), e)
                        break;
            }
            else
                (a instanceof Sd || a instanceof $s) && a.input instanceof vs && a.input.name === "zoom" && (e = a); return e instanceof Do || a.eachChild(i => { const c = Ip(i); c instanceof Do ? e = c : e && c && e !== c && (e = new Do("", "Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.")); }), e; }
            var m_, Pp, g_ = function () { if (Pp)
                return m_; Pp = 1, m_ = e; var a = 3; function e(i, c, h) { var p = this.cells = []; if (i instanceof ArrayBuffer) {
                this.arrayBuffer = i;
                var m = new Int32Array(this.arrayBuffer);
                i = m[0], this.d = (c = m[1]) + 2 * (h = m[2]);
                for (var x = 0; x < this.d * this.d; x++) {
                    var b = m[a + x], S = m[a + x + 1];
                    p.push(b === S ? null : m.subarray(b, S));
                }
                var A = m[a + p.length + 1];
                this.keys = m.subarray(m[a + p.length], A), this.bboxes = m.subarray(A), this.insert = this._insertReadonly;
            }
            else {
                this.d = c + 2 * h;
                for (var I = 0; I < this.d * this.d; I++)
                    p.push([]);
                this.keys = [], this.bboxes = [];
            } this.n = c, this.extent = i, this.padding = h, this.scale = c / i, this.uid = 0; var M = h / c * i; this.min = -M, this.max = i + M; } return e.prototype.insert = function (i, c, h, p, m) { this._forEachCell(c, h, p, m, this._insertCell, this.uid++), this.keys.push(i), this.bboxes.push(c), this.bboxes.push(h), this.bboxes.push(p), this.bboxes.push(m); }, e.prototype._insertReadonly = function () { throw "Cannot insert into a GridIndex created from an ArrayBuffer."; }, e.prototype._insertCell = function (i, c, h, p, m, x) { this.cells[m].push(x); }, e.prototype.query = function (i, c, h, p, m) { var x = this.min, b = this.max; if (i <= x && c <= x && b <= h && b <= p && !m)
                return Array.prototype.slice.call(this.keys); var S = []; return this._forEachCell(i, c, h, p, this._queryCell, S, {}, m), S; }, e.prototype._queryCell = function (i, c, h, p, m, x, b, S) { var A = this.cells[m]; if (A !== null)
                for (var I = this.keys, M = this.bboxes, z = 0; z < A.length; z++) {
                    var F = A[z];
                    if (b[F] === void 0) {
                        var U = 4 * F;
                        (S ? S(M[U + 0], M[U + 1], M[U + 2], M[U + 3]) : i <= M[U + 2] && c <= M[U + 3] && h >= M[U + 0] && p >= M[U + 1]) ? (b[F] = !0, x.push(I[F])) : b[F] = !1;
                    }
                } }, e.prototype._forEachCell = function (i, c, h, p, m, x, b, S) { for (var A = this._convertToCellCoord(i), I = this._convertToCellCoord(c), M = this._convertToCellCoord(h), z = this._convertToCellCoord(p), F = A; F <= M; F++)
                for (var U = I; U <= z; U++) {
                    var X = this.d * U + F;
                    if ((!S || S(this._convertFromCellCoord(F), this._convertFromCellCoord(U), this._convertFromCellCoord(F + 1), this._convertFromCellCoord(U + 1))) && m.call(this, i, c, h, p, X, x, b, S))
                        return;
                } }, e.prototype._convertFromCellCoord = function (i) { return (i - this.padding) / this.scale; }, e.prototype._convertToCellCoord = function (i) { return Math.max(0, Math.min(this.d - 1, Math.floor(i * this.scale) + this.padding)); }, e.prototype.toArrayBuffer = function () { if (this.arrayBuffer)
                return this.arrayBuffer; for (var i = this.cells, c = a + this.cells.length + 1 + 1, h = 0, p = 0; p < this.cells.length; p++)
                h += this.cells[p].length; var m = new Int32Array(c + h + this.keys.length + this.bboxes.length); m[0] = this.extent, m[1] = this.n, m[2] = this.padding; for (var x = c, b = 0; b < i.length; b++) {
                var S = i[b];
                m[a + b] = x, m.set(S, x), x += S.length;
            } return m[a + i.length] = x, m.set(this.keys, x), m[a + i.length + 1] = x += this.keys.length, m.set(this.bboxes, x), x += this.bboxes.length, m.buffer; }, m_; }(), Fu = ba(g_);
            const Rd = {};
            function Nt(a, e, i = {}) { Object.defineProperty(a, "_classRegistryKey", { value: e, writable: !1 }), Rd[e] = { klass: a, omit: i.omit || [] }; }
            Nt(Object, "Object"), Fu.serialize = function (a, e) { const i = a.toArrayBuffer(); return e && e.add(i), { buffer: i }; }, Fu.deserialize = function (a) { return new Fu(a.buffer); }, Object.defineProperty(Fu, "name", { value: "Grid" }), Nt(Fu, "Grid"), typeof DOMMatrix < "u" && Nt(DOMMatrix, "DOMMatrix"), Nt(nn, "Color"), Nt(Error, "Error"), Nt(Ps, "Formatted"), Nt(rp, "FormattedSection"), Nt(Kf, "AJAXError"), Nt(Us, "ResolvedImage"), Nt(Md, "StylePropertyFunction"), Nt(p_, "StyleExpression", { omit: ["_evaluator"] }), Nt(eo, "ImageId"), Nt(ea, "ImageVariant"), Nt(zu, "ZoomDependentExpression"), Nt(Dc, "ZoomConstantExpression"), Nt(vs, "CompoundExpression", { omit: ["_evaluate"] });
            for (const a in Rc)
                Rd[Rc[a]._classRegistryKey] || Nt(Rc[a], `Expression${a}`);
            function kd(a) { return a && typeof ArrayBuffer < "u" && (a instanceof ArrayBuffer || a.constructor && a.constructor.name === "ArrayBuffer"); }
            function Lc(a) { return self.ImageBitmap && a instanceof ImageBitmap; }
            function zl(a, e) { if (a == null || typeof a == "boolean" || typeof a == "number" || typeof a == "string" || a instanceof Boolean || a instanceof Number || a instanceof String || a instanceof Date || a instanceof RegExp)
                return a; if (kd(a) || Lc(a))
                return e && e.add(a), a; if (ArrayBuffer.isView(a))
                return e && e.add(a.buffer), a; if (a instanceof ImageData)
                return e && e.add(a.data.buffer), a; if (Array.isArray(a)) {
                const i = [];
                for (const c of a)
                    i.push(zl(c, e));
                return i;
            } if (a instanceof Map) {
                const i = { $name: "Map", entries: [] };
                for (const [c, h] of a.entries())
                    i.entries.push(zl(c), zl(h, e));
                return i;
            } if (a instanceof Set) {
                const i = { $name: "Set" };
                let c = 0;
                for (const h of a.values())
                    i[++c] = zl(h);
                return i;
            } if (a instanceof DOMMatrix) {
                const i = { $name: "DOMMatrix" }, c = ["is2D", "m11", "m12", "m13", "m14", "m21", "m22", "m23", "m24", "m31", "m32", "m33", "m34", "m41", "m42", "m43", "m44", "a", "b", "c", "d", "e", "f"];
                for (const h of c)
                    i[h] = a[h];
                return i;
            } if (typeof a == "bigint")
                return { $name: "BigInt", value: a.toString() }; if (typeof a == "object") {
                const i = a.constructor, c = i._classRegistryKey;
                if (!c)
                    throw new Error(`Can't serialize object of unregistered class "${i.name}".`);
                const h = i.serialize ? i.serialize(a, e) : {};
                if (!i.serialize) {
                    for (const p in a)
                        a.hasOwnProperty(p) && (Rd[c].omit.indexOf(p) >= 0 || (h[p] = zl(a[p], e)));
                    a instanceof Error && (h.message = a.message);
                }
                if (h.$name)
                    throw new Error("$name property is reserved for worker serialization logic.");
                return c !== "Object" && (h.$name = c), h;
            } throw new Error("can't serialize object of type " + typeof a); }
            function Fl(a) { if (a == null || typeof a == "boolean" || typeof a == "number" || typeof a == "string" || a instanceof Boolean || a instanceof Number || a instanceof String || a instanceof Date || a instanceof RegExp || kd(a) || Lc(a) || ArrayBuffer.isView(a) || a instanceof ImageData)
                return a; if (Array.isArray(a))
                return a.map(Fl); if (typeof a == "object") {
                const e = a.$name || "Object";
                if (e === "Map") {
                    const h = a.entries || [], p = new Map;
                    for (let m = 0; m < h.length; m += 2)
                        p.set(Fl(h[m]), Fl(h[m + 1]));
                    return p;
                }
                if (e === "Set") {
                    const h = new Set;
                    for (const p of Object.keys(a))
                        p !== "$name" && h.add(Fl(a[p]));
                    return h;
                }
                if (e === "DOMMatrix") {
                    let h;
                    return h = a.is2D ? [a.a, a.b, a.c, a.d, a.e, a.f] : [a.m11, a.m12, a.m13, a.m14, a.m21, a.m22, a.m23, a.m24, a.m31, a.m32, a.m33, a.m34, a.m41, a.m42, a.m43, a.m44], new DOMMatrix(h);
                }
                if (e === "BigInt")
                    return BigInt(a.value);
                const { klass: i } = Rd[e];
                if (!i)
                    throw new Error(`Can't deserialize unregistered class "${e}".`);
                if (i.deserialize)
                    return i.deserialize(a);
                const c = Object.create(i.prototype);
                for (const h of Object.keys(a))
                    h !== "$name" && (c[h] = Fl(a[h]));
                return c;
            } throw new Error("can't deserialize object of type " + typeof a); }
            const sr = { "Latin-1 Supplement": a => a >= 128 && a <= 255, Arabic: a => a >= 1536 && a <= 1791, "Arabic Supplement": a => a >= 1872 && a <= 1919, "Arabic Extended-A": a => a >= 2208 && a <= 2303, "Hangul Jamo": a => a >= 4352 && a <= 4607, "Unified Canadian Aboriginal Syllabics": a => a >= 5120 && a <= 5759, Khmer: a => a >= 6016 && a <= 6143, "Unified Canadian Aboriginal Syllabics Extended": a => a >= 6320 && a <= 6399, "General Punctuation": a => a >= 8192 && a <= 8303, "Letterlike Symbols": a => a >= 8448 && a <= 8527, "Number Forms": a => a >= 8528 && a <= 8591, "Miscellaneous Technical": a => a >= 8960 && a <= 9215, "Control Pictures": a => a >= 9216 && a <= 9279, "Optical Character Recognition": a => a >= 9280 && a <= 9311, "Enclosed Alphanumerics": a => a >= 9312 && a <= 9471, "Geometric Shapes": a => a >= 9632 && a <= 9727, "Miscellaneous Symbols": a => a >= 9728 && a <= 9983, "Miscellaneous Symbols and Arrows": a => a >= 11008 && a <= 11263, "CJK Radicals Supplement": a => a >= 11904 && a <= 12031, "Kangxi Radicals": a => a >= 12032 && a <= 12255, "Ideographic Description Characters": a => a >= 12272 && a <= 12287, "CJK Symbols and Punctuation": a => a >= 12288 && a <= 12351, Hiragana: a => a >= 12352 && a <= 12447, Katakana: a => a >= 12448 && a <= 12543, Bopomofo: a => a >= 12544 && a <= 12591, "Hangul Compatibility Jamo": a => a >= 12592 && a <= 12687, Kanbun: a => a >= 12688 && a <= 12703, "Bopomofo Extended": a => a >= 12704 && a <= 12735, "CJK Strokes": a => a >= 12736 && a <= 12783, "Katakana Phonetic Extensions": a => a >= 12784 && a <= 12799, "Enclosed CJK Letters and Months": a => a >= 12800 && a <= 13055, "CJK Compatibility": a => a >= 13056 && a <= 13311, "CJK Unified Ideographs Extension A": a => a >= 13312 && a <= 19903, "Yijing Hexagram Symbols": a => a >= 19904 && a <= 19967, "CJK Unified Ideographs": a => a >= 19968 && a <= 40959, "Yi Syllables": a => a >= 40960 && a <= 42127, "Yi Radicals": a => a >= 42128 && a <= 42191, "Hangul Jamo Extended-A": a => a >= 43360 && a <= 43391, "Hangul Syllables": a => a >= 44032 && a <= 55215, "Hangul Jamo Extended-B": a => a >= 55216 && a <= 55295, "Private Use Area": a => a >= 57344 && a <= 63743, "CJK Compatibility Ideographs": a => a >= 63744 && a <= 64255, "Arabic Presentation Forms-A": a => a >= 64336 && a <= 65023, "Vertical Forms": a => a >= 65040 && a <= 65055, "CJK Compatibility Forms": a => a >= 65072 && a <= 65103, "Small Form Variants": a => a >= 65104 && a <= 65135, "Arabic Presentation Forms-B": a => a >= 65136 && a <= 65279, "Halfwidth and Fullwidth Forms": a => a >= 65280 && a <= 65519, Osage: a => a >= 66736 && a <= 66815, "CJK Unified Ideographs Extension B": a => a >= 131072 && a <= 173791 };
            function __(a) { for (const e of a)
                if (Dd(e.charCodeAt(0)))
                    return !0; return !1; }
            function dT(a) { for (const e of a)
                if (!q0(e.charCodeAt(0)))
                    return !1; return !0; }
            function q0(a) { return !(sr.Arabic(a) || sr["Arabic Supplement"](a) || sr["Arabic Extended-A"](a) || sr["Arabic Presentation Forms-A"](a) || sr["Arabic Presentation Forms-B"](a)); }
            function Dd(a) { return !(a !== 746 && a !== 747 && (a < 4352 || !(sr["Bopomofo Extended"](a) || sr.Bopomofo(a) || sr["CJK Compatibility Forms"](a) && !(a >= 65097 && a <= 65103) || sr["CJK Compatibility Ideographs"](a) || sr["CJK Compatibility"](a) || sr["CJK Radicals Supplement"](a) || sr["CJK Strokes"](a) || !(!sr["CJK Symbols and Punctuation"](a) || a >= 12296 && a <= 12305 || a >= 12308 && a <= 12319 || a === 12336) || sr["CJK Unified Ideographs Extension A"](a) || sr["CJK Unified Ideographs"](a) || sr["Enclosed CJK Letters and Months"](a) || sr["Hangul Compatibility Jamo"](a) || sr["Hangul Jamo Extended-A"](a) || sr["Hangul Jamo Extended-B"](a) || sr["Hangul Jamo"](a) || sr["Hangul Syllables"](a) || sr.Hiragana(a) || sr["Ideographic Description Characters"](a) || sr.Kanbun(a) || sr["Kangxi Radicals"](a) || sr["Katakana Phonetic Extensions"](a) || sr.Katakana(a) && a !== 12540 || !(!sr["Halfwidth and Fullwidth Forms"](a) || a === 65288 || a === 65289 || a === 65293 || a >= 65306 && a <= 65310 || a === 65339 || a === 65341 || a === 65343 || a >= 65371 && a <= 65503 || a === 65507 || a >= 65512 && a <= 65519) || !(!sr["Small Form Variants"](a) || a >= 65112 && a <= 65118 || a >= 65123 && a <= 65126) || sr["Unified Canadian Aboriginal Syllabics"](a) || sr["Unified Canadian Aboriginal Syllabics Extended"](a) || sr["Vertical Forms"](a) || sr["Yijing Hexagram Symbols"](a) || sr["Yi Syllables"](a) || sr["Yi Radicals"](a)))); }
            function H0(a) { return !(Dd(a) || function (e) { return !!(sr["Latin-1 Supplement"](e) && (e === 167 || e === 169 || e === 174 || e === 177 || e === 188 || e === 189 || e === 190 || e === 215 || e === 247) || sr["General Punctuation"](e) && (e === 8214 || e === 8224 || e === 8225 || e === 8240 || e === 8241 || e === 8251 || e === 8252 || e === 8258 || e === 8263 || e === 8264 || e === 8265 || e === 8273) || sr["Letterlike Symbols"](e) || sr["Number Forms"](e) || sr["Miscellaneous Technical"](e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || e === 9003 || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || e === 9167 || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || sr["Control Pictures"](e) && e !== 9251 || sr["Optical Character Recognition"](e) || sr["Enclosed Alphanumerics"](e) || sr["Geometric Shapes"](e) || sr["Miscellaneous Symbols"](e) && !(e >= 9754 && e <= 9759) || sr["Miscellaneous Symbols and Arrows"](e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || sr["CJK Symbols and Punctuation"](e) || sr.Katakana(e) || sr["Private Use Area"](e) || sr["CJK Compatibility Forms"](e) || sr["Small Form Variants"](e) || sr["Halfwidth and Fullwidth Forms"](e) || e === 8734 || e === 8756 || e === 8757 || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || e === 65532 || e === 65533); }(a)); }
            function fT(a) { return sr.Arabic(a) || sr["Arabic Supplement"](a) || sr["Arabic Extended-A"](a) || sr["Arabic Presentation Forms-A"](a) || sr["Arabic Presentation Forms-B"](a); }
            function W0(a) { return a >= 1424 && a <= 2303 || sr["Arabic Presentation Forms-A"](a) || sr["Arabic Presentation Forms-B"](a); }
            function pT(a, e) { return !(!e && W0(a) || a >= 2304 && a <= 3583 || a >= 3840 && a <= 4255 || sr.Khmer(a)); }
            function mT(a) { for (const e of a)
                if (W0(e.charCodeAt(0)))
                    return !0; return !1; }
            const y_ = "deferred", v_ = "loading", x_ = "loaded";
            let w_ = null, to = "unavailable", Nl = null;
            const Oc = function (a) { a && typeof a == "string" && a.indexOf("NetworkError") > -1 && (to = "error"), w_ && w_(a); };
            function Mp() { Rp.fire(new Al("pluginStateChange", { pluginStatus: to, pluginURL: Nl })); }
            const Rp = new wc, Nu = function () { return to; }, Z0 = function () { if (to !== y_ || !Nl)
                throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified"); to = v_, Mp(), Nl && yu({ url: Nl }, a => { a ? Oc(a) : (to = x_, Mp()); }); }, zo = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => to === x_ || zo.applyArabicShaping != null, isLoading: () => to === v_, setState(a) { to = a.pluginStatus, Nl = a.pluginURL; }, isParsed: () => zo.applyArabicShaping != null && zo.processBidirectionalText != null && zo.processStyledBidirectionalText != null, getPluginURL: () => Nl };
            class yn {
                constructor(e, i) { this.zoom = e, i ? (this.now = i.now, this.fadeDuration = i.fadeDuration, this.transition = i.transition, this.pitch = i.pitch, this.brightness = i.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0); }
                isSupportedScript(e) { return function (i, c) { for (const h of i)
                    if (!pT(h.charCodeAt(0), c))
                        return !1; return !0; }(e, zo.isLoaded()); }
            }
            class Ld {
                constructor(e, i, c, h) { this.property = e, this.value = i, this.expression = function (p, m, x, b) { if (Ep(p))
                    return new Md(p, m); if (Ap(p) || Array.isArray(p) && p.length > 0) {
                    const S = Pd(p, m, x, b);
                    if (S.result === "error")
                        throw new Error(S.value.map(A => `${A.key}: ${A.message}`).join(", "));
                    return S.value;
                } {
                    let S = p;
                    return typeof p == "string" && m.type === "color" && (S = nn.parse(p)), { kind: "constant", configDependencies: new Set, evaluate: () => S };
                } }(i === void 0 ? e.specification.default : i, e.specification, c, h); }
                isDataDriven() { return this.expression.kind === "source" || this.expression.kind === "composite"; }
                possiblyEvaluate(e, i, c) { return this.property.possiblyEvaluate(this, e, i, c); }
            }
            class Bl {
                constructor(e, i, c) { this.property = e, this.value = new Ld(e, void 0, i, c); }
                transitioned(e, i) { return new K0(this.property, this.value, i, $e({}, e.transition, this.transition), e.now); }
                untransitioned() { return new K0(this.property, this.value, null, {}, 0); }
            }
            class X0 {
                constructor(e, i, c) { this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues), this._scope = i, this._options = c, this.configDependencies = new Set; }
                getValue(e) { return Fr(this._values[e].value.value); }
                setValue(e, i) { this._values.hasOwnProperty(e) || (this._values[e] = new Bl(this._values[e].property, this._scope, this._options)), this._values[e].value = new Ld(this._values[e].property, i === null ? void 0 : Fr(i), this._scope, this._options), this._values[e].value.expression.configDependencies && (this.configDependencies = new Set([...this.configDependencies, ...this._values[e].value.expression.configDependencies])); }
                setTransitionOrValue(e, i) { i && (this._options = i); const c = this._properties.properties; if (e)
                    for (const h in e) {
                        const p = e[h];
                        if (h.endsWith("-transition")) {
                            const m = h.slice(0, -11);
                            c[m] && this.setTransition(m, p);
                        }
                        else
                            c.hasOwnProperty(h) && this.setValue(h, p);
                    } }
                getTransition(e) { return Fr(this._values[e].transition); }
                setTransition(e, i) { this._values.hasOwnProperty(e) || (this._values[e] = new Bl(this._values[e].property)), this._values[e].transition = Fr(i) || void 0; }
                serialize() { const e = {}; for (const i of Object.keys(this._values)) {
                    const c = this.getValue(i);
                    c !== void 0 && (e[i] = c);
                    const h = this.getTransition(i);
                    h !== void 0 && (e[`${i}-transition`] = h);
                } return e; }
                transitioned(e, i) { const c = new Y0(this._properties); for (const h of Object.keys(this._values))
                    c._values[h] = this._values[h].transitioned(e, i._values[h]); return c; }
                untransitioned() { const e = new Y0(this._properties); for (const i of Object.keys(this._values))
                    e._values[i] = this._values[i].untransitioned(); return e; }
            }
            class K0 {
                constructor(e, i, c, h, p) { const m = h.delay || 0, x = h.duration || 0; p = p || 0, this.property = e, this.value = i, this.begin = p + m, this.end = this.begin + x, e.specification.transition && (h.delay || h.duration) && (this.prior = c); }
                possiblyEvaluate(e, i, c) { const h = e.now || 0, p = this.value.possiblyEvaluate(e, i, c), m = this.prior; if (m) {
                    if (h > this.end)
                        return this.prior = null, p;
                    if (this.value.isDataDriven())
                        return this.prior = null, p;
                    if (h < this.begin)
                        return m.possiblyEvaluate(e, i, c);
                    {
                        const x = (h - this.begin) / (this.end - this.begin);
                        return this.property.interpolate(m.possiblyEvaluate(e, i, c), p, Ae(x));
                    }
                } return p; }
            }
            class Y0 {
                constructor(e) { this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues); }
                possiblyEvaluate(e, i, c) { const h = new zc(this._properties); for (const p of Object.keys(this._values))
                    h._values[p] = this._values[p].possiblyEvaluate(e, i, c); return h; }
                hasTransition() { for (const e of Object.keys(this._values))
                    if (this._values[e].prior)
                        return !0; return !1; }
            }
            class gT {
                constructor(e, i, c) { this._properties = e, this._values = Object.create(e.defaultPropertyValues), this._scope = i, this._options = c, this.configDependencies = new Set; }
                getValue(e) { return Fr(this._values[e].value); }
                setValue(e, i) { this._values[e] = new Ld(this._values[e].property, i === null ? void 0 : Fr(i), this._scope, this._options), this._values[e].expression.configDependencies && (this.configDependencies = new Set([...this.configDependencies, ...this._values[e].expression.configDependencies])); }
                serialize() { const e = {}; for (const i of Object.keys(this._values)) {
                    const c = this.getValue(i);
                    c !== void 0 && (e[i] = c);
                } return e; }
                possiblyEvaluate(e, i, c) { const h = new zc(this._properties); for (const p of Object.keys(this._values))
                    h._values[p] = this._values[p].possiblyEvaluate(e, i, c); return h; }
            }
            class Bu {
                constructor(e, i, c) { this.property = e, this.value = i, this.parameters = c; }
                isConstant() { return this.value.kind === "constant"; }
                constantOr(e) { return this.value.kind === "constant" ? this.value.value : e; }
                evaluate(e, i, c, h) { return this.property.evaluate(this.value, this.parameters, e, i, c, h); }
            }
            class zc {
                constructor(e) { this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues); }
                get(e) { return this._values[e]; }
            }
            class wt {
                constructor(e) { this.specification = e; }
                possiblyEvaluate(e, i) { return e.expression.evaluate(i); }
                interpolate(e, i, c) { const h = tp[this.specification.type]; return h ? h(e, i, c) : e; }
            }
            class zt {
                constructor(e, i) { this.specification = e, this.overrides = i; }
                possiblyEvaluate(e, i, c, h) { return new Bu(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? { kind: "constant", value: e.expression.evaluate(i, null, {}, c, h) } : e.expression, i); }
                interpolate(e, i, c) { if (e.value.kind !== "constant" || i.value.kind !== "constant")
                    return e; if (e.value.value === void 0 || i.value.value === void 0)
                    return new Bu(this, { kind: "constant", value: void 0 }, e.parameters); const h = tp[this.specification.type]; return h ? new Bu(this, { kind: "constant", value: h(e.value.value, i.value.value, c) }, e.parameters) : e; }
                evaluate(e, i, c, h, p, m) { return e.kind === "constant" ? e.value : e.evaluate(i, c, h, p, m); }
            }
            class Fc {
                constructor(e) { this.specification = e; }
                possiblyEvaluate(e, i, c, h) { return !!e.expression.evaluate(i, null, {}, c, h); }
                interpolate() { return !1; }
            }
            class gi {
                constructor(e) { this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = []; const i = new yn(0, {}); for (const c in e) {
                    const h = e[c];
                    h.specification.overridable && this.overridableProperties.push(c);
                    const p = this.defaultPropertyValues[c] = new Ld(h, void 0), m = this.defaultTransitionablePropertyValues[c] = new Bl(h);
                    this.defaultTransitioningPropertyValues[c] = m.untransitioned(), this.defaultPossiblyEvaluatedValues[c] = p.possiblyEvaluate(i);
                } }
            }
            Nt(zt, "DataDrivenProperty"), Nt(wt, "DataConstantProperty"), Nt(Fc, "ColorRampProperty");
            var Ne = JSON.parse("{\"$version\":8,\"$root\":{\"version\":{\"type\":\"enum\",\"values\":[8]},\"fragment\":{\"type\":\"boolean\"},\"name\":{\"type\":\"string\"},\"metadata\":{\"type\":\"*\"},\"center\":{\"type\":\"array\",\"value\":\"number\"},\"zoom\":{\"type\":\"number\"},\"bearing\":{\"type\":\"number\",\"default\":0,\"period\":360},\"pitch\":{\"type\":\"number\",\"default\":0},\"light\":{\"type\":\"light\"},\"lights\":{\"type\":\"array\",\"value\":\"light-3d\"},\"terrain\":{\"type\":\"terrain\",\"optional\":true},\"fog\":{\"type\":\"fog\"},\"snow\":{\"type\":\"snow\"},\"rain\":{\"type\":\"rain\"},\"camera\":{\"type\":\"camera\"},\"color-theme\":{\"type\":\"colorTheme\"},\"indoor\":{\"type\":\"indoor\"},\"imports\":{\"type\":\"array\",\"value\":\"import\"},\"iconsets\":{\"type\":\"iconsets\"},\"schema\":{\"type\":\"schema\"},\"sources\":{\"type\":\"sources\"},\"sprite\":{\"type\":\"string\"},\"glyphs\":{\"type\":\"string\",\"default\":\"mapbox://fonts/mapbox/{fontstack}/{range}.pbf\"},\"transition\":{\"type\":\"transition\"},\"projection\":{\"type\":\"projection\"},\"layers\":{\"type\":\"array\",\"value\":\"layer\"},\"models\":{\"type\":\"models\"},\"featuresets\":{\"type\":\"featuresets\"}},\"featuresets\":{\"*\":{\"type\":\"featureset\"}},\"featureset\":{\"metadata\":{\"type\":\"*\"},\"selectors\":{\"type\":\"array\",\"value\":\"selector\"}},\"selector\":{\"layer\":{\"type\":\"string\"},\"properties\":{\"type\":\"selectorProperty\"},\"featureNamespace\":{\"type\":\"string\"},\"_uniqueFeatureID\":{\"type\":\"boolean\"}},\"selectorProperty\":{\"*\":{\"type\":\"*\"}},\"model\":{\"type\":\"string\"},\"import\":{\"id\":{\"type\":\"string\"},\"url\":{\"type\":\"string\"},\"config\":{\"type\":\"config\"},\"data\":{\"type\":\"$root\"},\"color-theme\":{\"type\":\"colorTheme\",\"optional\":true}},\"config\":{\"*\":{\"type\":\"*\"}},\"schema\":{\"*\":{\"type\":\"option\"}},\"option\":{\"default\":{\"type\":\"*\",\"expression\":{}},\"type\":{\"type\":\"enum\",\"values\":{\"string\":1,\"number\":1,\"boolean\":1,\"color\":1}},\"array\":{\"type\":\"boolean\"},\"minValue\":{\"type\":\"number\"},\"maxValue\":{\"type\":\"number\"},\"stepValue\":{\"type\":\"number\"},\"values\":{\"type\":\"array\",\"value\":\"*\"},\"metadata\":{\"type\":\"*\"}},\"models\":{\"*\":{\"type\":\"model\"}},\"light-3d\":{\"id\":{\"type\":\"string\"},\"properties\":{\"type\":\"properties\"},\"type\":{\"type\":\"enum\",\"values\":{\"ambient\":{},\"directional\":{},\"flat\":{}}}},\"properties\":[\"properties_light_directional\",\"properties_light_ambient\",\"properties_light_flat\"],\"properties_light_directional\":{\"direction\":{\"type\":\"array\",\"default\":[210,30],\"minimum\":[0,0],\"maximum\":[360,90],\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"cast-shadows\":{\"type\":\"boolean\",\"default\":false},\"shadow-quality\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"parameters\":[\"zoom\"]}},\"shadow-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"properties_light_ambient\":{\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"properties_light_flat\":{\"anchor\":{\"type\":\"enum\",\"default\":\"viewport\",\"values\":{\"map\":1,\"viewport\":1},\"expression\":{\"parameters\":[\"zoom\"]}},\"position\":{\"type\":\"array\",\"default\":[1.15,210,30],\"length\":3,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"iconsets\":{\"*\":{\"type\":\"iconset\"}},\"iconset\":[\"iconset_sprite\",\"iconset_source\"],\"iconset_sprite\":{\"type\":{\"type\":\"enum\",\"values\":{\"sprite\":1}},\"url\":{\"type\":\"string\"}},\"iconset_source\":{\"type\":{\"type\":\"enum\",\"values\":{\"source\":1}},\"source\":{\"type\":\"string\"}},\"sources\":{\"*\":{\"type\":\"source\"}},\"source\":[\"source_vector\",\"source_raster\",\"source_raster_dem\",\"source_raster_array\",\"source_geojson\",\"source_video\",\"source_image\",\"source_model\"],\"source_vector\":{\"type\":{\"type\":\"enum\",\"values\":{\"vector\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"extra_bounds\":{\"type\":\"array\",\"value\":{\"type\":\"array\",\"value\":\"number\",\"length\":4}},\"scheme\":{\"type\":\"enum\",\"values\":{\"xyz\":1,\"tms\":1},\"default\":\"xyz\"},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"attribution\":{\"type\":\"string\"},\"promoteId\":{\"type\":\"promoteId\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster\":{\"type\":{\"type\":\"enum\",\"values\":{\"raster\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"extra_bounds\":{\"type\":\"array\",\"value\":{\"type\":\"array\",\"value\":\"number\",\"length\":4}},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"scheme\":{\"type\":\"enum\",\"values\":{\"xyz\":1,\"tms\":1},\"default\":\"xyz\"},\"attribution\":{\"type\":\"string\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster_dem\":{\"type\":{\"type\":\"enum\",\"values\":{\"raster-dem\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"extra_bounds\":{\"type\":\"array\",\"value\":{\"type\":\"array\",\"value\":\"number\",\"length\":4}},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"attribution\":{\"type\":\"string\"},\"encoding\":{\"type\":\"enum\",\"values\":{\"terrarium\":1,\"mapbox\":1},\"default\":\"mapbox\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster_array\":{\"type\":{\"type\":\"enum\",\"values\":{\"raster-array\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"extra_bounds\":{\"type\":\"array\",\"value\":{\"type\":\"array\",\"value\":\"number\",\"length\":4}},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"attribution\":{\"type\":\"string\"},\"rasterLayers\":{\"type\":\"*\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_geojson\":{\"type\":{\"type\":\"enum\",\"values\":{\"geojson\":1}},\"data\":{\"type\":\"*\"},\"maxzoom\":{\"type\":\"number\",\"default\":18},\"minzoom\":{\"type\":\"number\",\"default\":0},\"attribution\":{\"type\":\"string\"},\"buffer\":{\"type\":\"number\",\"default\":128,\"maximum\":512,\"minimum\":0},\"filter\":{\"type\":\"*\"},\"tolerance\":{\"type\":\"number\",\"default\":0.375},\"cluster\":{\"type\":\"boolean\",\"default\":false},\"clusterRadius\":{\"type\":\"number\",\"default\":50,\"minimum\":0},\"clusterMaxZoom\":{\"type\":\"number\"},\"clusterMinPoints\":{\"type\":\"number\"},\"clusterProperties\":{\"type\":\"*\"},\"lineMetrics\":{\"type\":\"boolean\",\"default\":false},\"generateId\":{\"type\":\"boolean\",\"default\":false},\"promoteId\":{\"type\":\"promoteId\"},\"dynamic\":{\"type\":\"boolean\",\"default\":false}},\"source_video\":{\"type\":{\"type\":\"enum\",\"values\":{\"video\":1}},\"urls\":{\"type\":\"array\",\"value\":\"string\"},\"coordinates\":{\"type\":\"array\",\"length\":4,\"value\":{\"type\":\"array\",\"length\":2,\"value\":\"number\"}}},\"source_image\":{\"type\":{\"type\":\"enum\",\"values\":{\"image\":1}},\"url\":{\"type\":\"string\"},\"coordinates\":{\"type\":\"array\",\"length\":4,\"value\":{\"type\":\"array\",\"length\":2,\"value\":\"number\"}}},\"source_model\":{\"type\":{\"type\":\"enum\",\"values\":{\"model\":1,\"batched-model\":1}},\"maxzoom\":{\"type\":\"number\",\"default\":18},\"minzoom\":{\"type\":\"number\",\"default\":0},\"tiles\":{\"type\":\"array\",\"value\":\"string\"}},\"layer\":{\"id\":{\"type\":\"string\"},\"type\":{\"type\":\"enum\",\"values\":{\"fill\":{},\"line\":{},\"symbol\":{},\"circle\":{},\"heatmap\":{},\"fill-extrusion\":{},\"building\":{},\"raster\":{},\"raster-particle\":{},\"hillshade\":{},\"model\":{},\"background\":{},\"sky\":{},\"slot\":{},\"clip\":{}}},\"metadata\":{\"type\":\"*\"},\"source\":{\"type\":\"string\"},\"source-layer\":{\"type\":\"string\"},\"slot\":{\"type\":\"string\"},\"minzoom\":{\"type\":\"number\",\"minimum\":0,\"maximum\":24},\"maxzoom\":{\"type\":\"number\",\"minimum\":0,\"maximum\":24},\"filter\":{\"type\":\"filter\"},\"layout\":{\"type\":\"layout\"},\"paint\":{\"type\":\"paint\"}},\"layout\":[\"layout_clip\",\"layout_fill\",\"layout_line\",\"layout_circle\",\"layout_heatmap\",\"layout_fill-extrusion\",\"layout_building\",\"layout_symbol\",\"layout_raster\",\"layout_raster-particle\",\"layout_hillshade\",\"layout_background\",\"layout_sky\",\"layout_model\"],\"layout_background\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_sky\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_model\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"model-id\":{\"type\":\"string\",\"default\":\"\",\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}}},\"layout_clip\":{\"clip-layer-types\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"model\":1,\"symbol\":1},\"default\":[],\"expression\":{}},\"clip-layer-scope\":{\"type\":\"array\",\"value\":\"string\",\"default\":[],\"expression\":{}}},\"layout_fill\":{\"fill-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"fill-elevation-reference\":{\"type\":\"enum\",\"values\":{\"none\":1,\"hd-road-base\":1,\"hd-road-markup\":1},\"default\":\"none\",\"expression\":{}},\"fill-construct-bridge-guard-rail\":{\"type\":\"boolean\",\"default\":\"true\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"}},\"layout_circle\":{\"circle-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"circle-elevation-reference\":{\"type\":\"enum\",\"values\":{\"none\":1,\"hd-road-markup\":1},\"default\":\"none\",\"expression\":{}},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_heatmap\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_fill-extrusion\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"fill-extrusion-edge-radius\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{}}},\"layout_building\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"building-roof-shape\":{\"type\":\"enum\",\"values\":{\"flat\":1,\"hipped\":1,\"gabled\":1,\"parapet\":1,\"mansard\":1,\"skillion\":1,\"pyramidal\":1},\"default\":\"flat\",\"expression\":{\"parameters\":[\"feature\"]},\"property-type\":\"data-driven\"},\"building-height\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{},\"property-type\":\"data-driven\"},\"building-base\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{},\"property-type\":\"data-driven\"}},\"layout_line\":{\"line-cap\":{\"type\":\"enum\",\"values\":{\"butt\":1,\"round\":1,\"square\":1},\"default\":\"butt\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-join\":{\"type\":\"enum\",\"values\":{\"bevel\":1,\"round\":1,\"miter\":1,\"none\":1},\"default\":\"miter\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-miter-limit\":{\"type\":\"number\",\"default\":2,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"line-round-limit\":{\"type\":\"number\",\"default\":1.05,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"line-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-z-offset\":{\"type\":\"number\",\"default\":0,\"expression\":{\"parameters\":[\"zoom\",\"feature\",\"line-progress\"]},\"property-type\":\"data-driven\"},\"line-elevation-reference\":{\"type\":\"enum\",\"values\":{\"none\":1,\"sea\":1,\"ground\":1,\"hd-road-markup\":1},\"default\":\"none\",\"expression\":{}},\"line-cross-slope\":{\"type\":\"number\",\"expression\":{}},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"line-width-unit\":{\"type\":\"enum\",\"values\":{\"pixels\":1,\"meters\":1},\"default\":\"pixels\",\"expression\":{\"parameters\":[\"zoom\"]}}},\"layout_symbol\":{\"symbol-placement\":{\"type\":\"enum\",\"values\":{\"point\":1,\"line\":1,\"line-center\":1},\"default\":\"point\",\"expression\":{\"parameters\":[\"zoom\"]}},\"symbol-spacing\":{\"type\":\"number\",\"default\":250,\"minimum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"symbol-avoid-edges\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"symbol-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"symbol-z-order\":{\"type\":\"enum\",\"values\":{\"auto\":1,\"viewport-y\":1,\"source\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"symbol-z-elevate\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"symbol-elevation-reference\":{\"type\":\"enum\",\"values\":{\"sea\":1,\"ground\":1,\"hd-road-markup\":1},\"default\":\"ground\",\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-allow-overlap\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-ignore-placement\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-optional\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-rotation-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-size\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-size-scale-range\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0.8,2],\"minimum\":0.1,\"maximum\":10,\"expression\":{}},\"icon-text-fit\":{\"type\":\"enum\",\"values\":{\"none\":1,\"width\":1,\"height\":1,\"both\":1},\"default\":\"none\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-text-fit-padding\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[0,0,0,0],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-image\":{\"type\":\"resolvedImage\",\"tokens\":true,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-padding\":{\"type\":\"number\",\"default\":2,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"icon-keep-upright\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-anchor\":{\"type\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"text-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"text-rotation-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"text-field\":{\"type\":\"formatted\",\"default\":\"\",\"tokens\":true,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-font\":{\"type\":\"array\",\"value\":\"string\",\"default\":[\"Open Sans Regular\",\"Arial Unicode MS Regular\"],\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-size\":{\"type\":\"number\",\"default\":16,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-size-scale-range\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0.8,2],\"minimum\":0.1,\"maximum\":10,\"expression\":{}},\"text-max-width\":{\"type\":\"number\",\"default\":10,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-line-height\":{\"type\":\"number\",\"default\":1.2,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-letter-spacing\":{\"type\":\"number\",\"default\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-justify\":{\"type\":\"enum\",\"values\":{\"auto\":1,\"left\":1,\"center\":1,\"right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-radial-offset\":{\"type\":\"number\",\"default\":0,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]}},\"text-variable-anchor\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"expression\":{\"parameters\":[\"zoom\"]}},\"text-anchor\":{\"type\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-max-angle\":{\"type\":\"number\",\"default\":45,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"text-writing-mode\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"horizontal\":1,\"vertical\":1},\"expression\":{\"parameters\":[\"zoom\"]}},\"text-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-padding\":{\"type\":\"number\",\"default\":2,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"text-keep-upright\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]}},\"text-transform\":{\"type\":\"enum\",\"values\":{\"none\":1,\"uppercase\":1,\"lowercase\":1},\"default\":\"none\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-allow-overlap\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"text-ignore-placement\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"text-optional\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_raster\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_raster-particle\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_hillshade\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"filter\":{\"type\":\"array\",\"value\":\"*\"},\"filter_symbol\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\",\"pitch\",\"distance-from-center\"]}},\"filter_fill\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_hillshade\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_raster\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_raster-particle\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_clip\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_model\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_line\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_circle\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_fill-extrusion\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_building\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_heatmap\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_operator\":{\"type\":\"enum\",\"values\":{\"==\":1,\"!=\":1,\">\":1,\">=\":1,\"<\":1,\"<=\":1,\"in\":1,\"!in\":1,\"all\":1,\"any\":1,\"none\":1,\"has\":1,\"!has\":1}},\"geometry_type\":{\"type\":\"enum\",\"values\":{\"Point\":1,\"LineString\":1,\"Polygon\":1}},\"function\":{\"expression\":{\"type\":\"expression\"},\"stops\":{\"type\":\"array\",\"value\":\"function_stop\"},\"base\":{\"type\":\"number\",\"default\":1,\"minimum\":0},\"property\":{\"type\":\"string\",\"default\":\"$zoom\"},\"type\":{\"type\":\"enum\",\"values\":{\"identity\":1,\"exponential\":1,\"interval\":1,\"categorical\":1},\"default\":\"exponential\"},\"colorSpace\":{\"type\":\"enum\",\"values\":{\"rgb\":1,\"lab\":1,\"hcl\":1},\"default\":\"rgb\"},\"default\":{\"type\":\"*\"}},\"function_stop\":{\"type\":\"array\",\"minimum\":0,\"maximum\":24,\"value\":[\"number\",\"color\"],\"length\":2},\"expression\":{\"type\":\"array\",\"value\":\"*\",\"minimum\":1},\"fog\":{\"range\":{\"type\":\"array\",\"default\":[0.5,10],\"minimum\":-20,\"maximum\":20,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"high-color\":{\"type\":\"color\",\"default\":\"#245cdf\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"space-color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],4,\"#010b19\",7,\"#367ab9\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"horizon-blend\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],4,0.2,7,0.1],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"star-intensity\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],5,0.35,6,0],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vertical-range\":{\"type\":\"array\",\"default\":[0,0],\"minimum\":0,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}}},\"snow\":{\"density\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,0.85],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,0.3],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette-color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"center-thinning\":{\"type\":\"number\",\"default\":0.4,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"direction\":{\"type\":\"array\",\"default\":[0,50],\"minimum\":0,\"maximum\":360,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"flake-size\":{\"type\":\"number\",\"default\":0.71,\"minimum\":0,\"maximum\":5,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true}},\"rain\":{\"density\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,0.5],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"measure-light\",\"brightness\"],0,\"#03113d\",0.3,\"#a8adbc\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"opacity\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"measure-light\",\"brightness\"],0,0.88,1,0.7],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,1],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette-color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"measure-light\",\"brightness\"],0,\"#001736\",0.3,\"#464646\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"center-thinning\":{\"type\":\"number\",\"default\":0.57,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"direction\":{\"type\":\"array\",\"default\":[0,80],\"minimum\":0,\"maximum\":360,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"droplet-size\":{\"type\":\"array\",\"default\":[2.6,18.2],\"minimum\":0,\"maximum\":50,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"distortion-strength\":{\"type\":\"number\",\"default\":0.7,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true}},\"camera\":{\"camera-projection\":{\"type\":\"enum\",\"values\":{\"perspective\":1,\"orthographic\":1},\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"default\":\"perspective\"}},\"colorTheme\":{\"data\":{\"type\":\"string\",\"expression\":{}}},\"indoor\":{\"floorplanFeaturesetId\":{\"type\":\"string\",\"expression\":{}},\"buildingFeaturesetId\":{\"type\":\"string\",\"expression\":{}}},\"light\":{\"anchor\":{\"type\":\"enum\",\"default\":\"viewport\",\"values\":{\"map\":1,\"viewport\":1},\"expression\":{\"parameters\":[\"zoom\"]}},\"position\":{\"type\":\"array\",\"default\":[1.15,210,30],\"length\":3,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"projection\":{\"name\":{\"type\":\"enum\",\"values\":{\"albers\":1,\"equalEarth\":1,\"equirectangular\":1,\"lambertConformalConic\":1,\"mercator\":1,\"naturalEarth\":1,\"winkelTripel\":1,\"globe\":1},\"default\":\"mercator\"},\"center\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"minimum\":[-180,-90],\"maximum\":[180,90]},\"parallels\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"minimum\":[-90,-90],\"maximum\":[90,90]}},\"terrain\":{\"source\":{\"type\":\"string\"},\"exaggeration\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1000,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"paint\":[\"paint_fill\",\"paint_line\",\"paint_circle\",\"paint_heatmap\",\"paint_fill-extrusion\",\"paint_building\",\"paint_symbol\",\"paint_raster\",\"paint_raster-particle\",\"paint_hillshade\",\"paint_background\",\"paint_sky\",\"paint_model\"],\"paint_fill\":{\"fill-antialias\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-outline-color\":{\"type\":\"color\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-pattern-cross-fade\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"transition\":true},\"fill-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-z-offset\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-bridge-guard-rail-color\":{\"type\":\"color\",\"default\":\"rgba(241, 236, 225, 255)\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-tunnel-structure-color\":{\"type\":\"color\",\"default\":\"rgba(241, 236, 225, 255)\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature\"]},\"property-type\":\"data-driven\"}},\"paint_fill-extrusion\":{\"fill-extrusion-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-extrusion-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-pattern-cross-fade\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"transition\":true},\"fill-extrusion-height\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-base\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-height-alignment\":{\"type\":\"enum\",\"values\":{\"terrain\":1,\"flat\":1},\"default\":\"flat\"},\"fill-extrusion-base-alignment\":{\"type\":\"enum\",\"values\":{\"terrain\":1,\"flat\":1},\"default\":\"terrain\"},\"fill-extrusion-vertical-gradient\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-extrusion-ambient-occlusion-intensity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-radius\":{\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-wall-radius\":{\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-ground-radius\":{\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-ground-attenuation\":{\"type\":\"number\",\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-flood-light-color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-extrusion-flood-light-intensity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-extrusion-flood-light-wall-radius\":{\"property-type\":\"data-driven\",\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}},\"fill-extrusion-flood-light-ground-radius\":{\"property-type\":\"data-driven\",\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}},\"fill-extrusion-flood-light-ground-attenuation\":{\"type\":\"number\",\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-vertical-scale\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-rounded-roof\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-extrusion-cutoff-fade-range\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{}},\"fill-extrusion-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-line-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-cast-shadows\":{\"type\":\"boolean\",\"default\":true}},\"paint_building\":{\"building-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"building-ambient-occlusion-wall-intensity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"building-ambient-occlusion-ground-intensity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"building-ambient-occlusion-ground-radius\":{\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"building-ambient-occlusion-ground-attenuation\":{\"type\":\"number\",\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"building-vertical-scale\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"building-cast-shadows\":{\"type\":\"boolean\",\"default\":true},\"building-color\":{\"type\":\"color\",\"default\":\"rgba(193, 154, 127, 1)\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"building-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"}},\"paint_line\":{\"line-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"line-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"line-width\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\",\"line-progress\"]},\"property-type\":\"data-driven\"},\"line-gap-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-offset\":{\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-dasharray\":{\"type\":\"array\",\"value\":\"number\",\"minimum\":0,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-pattern-cross-fade\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"transition\":true},\"line-gradient\":{\"type\":\"color\",\"expression\":{\"interpolated\":true,\"parameters\":[\"line-progress\"]}},\"line-trim-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"minimum\":[0,0],\"maximum\":[1,1]},\"line-trim-fade-range\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"minimum\":[0,0],\"maximum\":[1,1],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"line-trim-color\":{\"type\":\"color\",\"default\":\"transparent\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"line-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"line-border-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-border-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-occlusion-opacity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"paint_circle\":{\"circle-radius\":{\"type\":\"number\",\"default\":5,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-blur\":{\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"circle-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"circle-pitch-scale\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"circle-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"viewport\",\"expression\":{\"parameters\":[\"zoom\"]}},\"circle-stroke-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-stroke-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-stroke-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}}},\"paint_heatmap\":{\"heatmap-radius\":{\"type\":\"number\",\"default\":30,\"minimum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"heatmap-weight\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"heatmap-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"heatmap-color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"heatmap-density\"],0,\"rgba(0, 0, 255, 0)\",0.1,\"royalblue\",0.3,\"cyan\",0.5,\"lime\",0.7,\"yellow\",1,\"red\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"heatmap-density\"]}},\"heatmap-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}}},\"paint_symbol\":{\"icon-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-occlusion-opacity\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1,\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-emissive-strength\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"text-emissive-strength\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"icon-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"icon-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-image-cross-fade\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"transition\":true},\"text-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-occlusion-opacity\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1,\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"overridable\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"text-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-color-saturation\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"expression\":{}},\"icon-color-contrast\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"expression\":{}},\"icon-color-brightness-min\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{}},\"icon-color-brightness-max\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{}},\"symbol-z-offset\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"}},\"paint_raster\":{\"raster-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-color\":{\"type\":\"color\",\"expression\":{\"interpolated\":true,\"parameters\":[\"raster-value\"]}},\"raster-color-mix\":{\"type\":\"array\",\"default\":[0.2126,0.7152,0.0722,0],\"length\":4,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-color-range\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-hue-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-brightness-min\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-brightness-max\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-saturation\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-contrast\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-resampling\":{\"type\":\"enum\",\"values\":{\"linear\":1,\"nearest\":1},\"default\":\"linear\",\"expression\":{\"parameters\":[\"zoom\"]}},\"raster-fade-duration\":{\"type\":\"number\",\"default\":300,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"raster-array-band\":{\"type\":\"string\"},\"raster-elevation\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}}},\"paint_raster-particle\":{\"raster-particle-array-band\":{\"type\":\"string\"},\"raster-particle-count\":{\"type\":\"number\",\"default\":512,\"minimum\":1},\"raster-particle-color\":{\"type\":\"color\",\"expression\":{\"interpolated\":true,\"parameters\":[\"raster-particle-speed\"]}},\"raster-particle-max-speed\":{\"type\":\"number\",\"default\":1,\"minimum\":1},\"raster-particle-speed-factor\":{\"type\":\"number\",\"default\":0.2,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-particle-fade-opacity-factor\":{\"type\":\"number\",\"default\":0.98,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-particle-reset-rate-factor\":{\"type\":\"number\",\"default\":0.8,\"minimum\":0,\"maximum\":1},\"raster-particle-elevation\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}}},\"paint_hillshade\":{\"hillshade-illumination-direction\":{\"type\":\"number\",\"default\":335,\"minimum\":0,\"maximum\":359,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"hillshade-illumination-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"viewport\",\"expression\":{\"parameters\":[\"zoom\"]}},\"hillshade-exaggeration\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"hillshade-shadow-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"hillshade-highlight-color\":{\"type\":\"color\",\"default\":\"#FFFFFF\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"hillshade-accent-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"hillshade-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}}},\"paint_background\":{\"background-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[]}},\"background-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"background-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\"]}},\"background-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"background-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}}},\"paint_sky\":{\"sky-type\":{\"type\":\"enum\",\"values\":{\"gradient\":1,\"atmosphere\":1},\"default\":\"atmosphere\",\"expression\":{\"parameters\":[\"zoom\"]}},\"sky-atmosphere-sun\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"minimum\":[0,0],\"maximum\":[360,180],\"expression\":{\"parameters\":[\"zoom\"]}},\"sky-atmosphere-sun-intensity\":{\"type\":\"number\",\"default\":10,\"minimum\":0,\"maximum\":100},\"sky-gradient-center\":{\"type\":\"array\",\"value\":\"number\",\"default\":[0,0],\"length\":2,\"minimum\":[0,0],\"maximum\":[360,180],\"expression\":{\"parameters\":[\"zoom\"]}},\"sky-gradient-radius\":{\"type\":\"number\",\"default\":90,\"minimum\":0,\"maximum\":180,\"expression\":{\"parameters\":[\"zoom\"]}},\"sky-gradient\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"sky-radial-progress\"],0.8,\"#87ceeb\",1,\"white\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"sky-radial-progress\"]}},\"sky-atmosphere-halo-color\":{\"type\":\"color\",\"default\":\"white\"},\"sky-atmosphere-color\":{\"type\":\"color\",\"default\":\"white\"},\"sky-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}}},\"paint_model\":{\"model-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"property-type\":\"data-driven\"},\"model-rotation\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[0,0,0],\"period\":360,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-scale\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[1,1,1],\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-translation\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[0,0,0],\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\",\"zoom\"]},\"transition\":true},\"model-color-mix-intensity\":{\"type\":\"number\",\"property-type\":\"data-driven\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-type\":{\"type\":\"enum\",\"values\":{\"common-3d\":1,\"location-indicator\":1},\"default\":\"common-3d\"},\"model-cast-shadows\":{\"type\":\"boolean\",\"default\":true},\"model-receive-shadows\":{\"type\":\"boolean\",\"default\":true},\"model-ambient-occlusion-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"model-emissive-strength\":{\"type\":\"number\",\"property-type\":\"data-driven\",\"default\":0,\"minimum\":0,\"maximum\":5,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-roughness\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]},\"transition\":true},\"model-height-based-emissive-strength-multiplier\":{\"type\":\"array\",\"default\":[1,1,1,1,0],\"length\":5,\"value\":\"number\",\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-cutoff-fade-range\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{}},\"model-front-cutoff\":{\"type\":\"array\",\"value\":\"number\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"length\":3,\"default\":[0,0,1],\"minimum\":[0,0,0],\"maximum\":[1,1,1]}},\"transition\":{\"duration\":{\"type\":\"number\",\"default\":300,\"minimum\":0},\"delay\":{\"type\":\"number\",\"default\":0,\"minimum\":0}},\"promoteId\":{\"*\":{\"type\":\"*\"}}}");
            function ra(a) { return a instanceof Number || a instanceof String || a instanceof Boolean ? a.valueOf() : a; }
            function kp(a) { if (Array.isArray(a))
                return a.map(kp); if (a instanceof Object && !(a instanceof Number || a instanceof String || a instanceof Boolean)) {
                const e = {};
                for (const i in a)
                    e[i] = kp(a[i]);
                return e;
            } return ra(a); }
            function Dp(a) { if (a === !0 || a === !1)
                return !0; if (!Array.isArray(a) || a.length === 0)
                return !1; switch (a[0]) {
                case "has": return a.length >= 2 && a[1] !== "$id" && a[1] !== "$type";
                case "in": return a.length >= 3 && (typeof a[1] != "string" || Array.isArray(a[2]));
                case "!in":
                case "!has":
                case "none": return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=": return a.length !== 3 || Array.isArray(a[1]) || Array.isArray(a[2]);
                case "any":
                case "all":
                    for (const e of a.slice(1))
                        if (!Dp(e) && typeof e != "boolean")
                            return !1;
                    return !0;
                default: return !0;
            } }
            function b_(a, e = "", i = null, c = "fill") {
                if (a == null)
                    return { filter: () => !0, needGeometry: !1, needFeature: !1 };
                Dp(a) || (a = Lp(a));
                const h = a;
                let p = !0;
                try {
                    p = function (A) { if (!ju(A))
                        return A; let I = kp(A); return J0(I), I = Q0(I), I; }(h);
                }
                catch {
                    console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(h, null, 2)}
        `);
                }
                let m = null, x = null;
                if (c !== "background" && c !== "sky" && c !== "slot") {
                    x = Ne[`filter_${c}`];
                    const A = Ou(p, x, e, i);
                    if (A.result === "error")
                        throw new Error(A.value.map(I => `${I.key}: ${I.message}`).join(", "));
                    m = (I, M, z) => A.value.evaluate(I, M, {}, z);
                }
                let b = null, S = null;
                if (p !== h) {
                    const A = Ou(h, x, e, i);
                    if (A.result === "error")
                        throw new Error(A.value.map(I => `${I.key}: ${I.message}`).join(", "));
                    b = (I, M, z, F, U) => A.value.evaluate(I, M, {}, z, void 0, void 0, F, U), S = !Td(A.value.expression);
                }
                return { filter: m, dynamicFilter: b || void 0, needGeometry: ex(p), needFeature: !!S };
            }
            function Q0(a) { if (!Array.isArray(a))
                return a; const e = function (i) { if (_T.has(i[0])) {
                for (let c = 1; c < i.length; c++)
                    if (ju(i[c]))
                        return !0;
            } return i; }(a); return e === !0 ? e : e.map(i => Q0(i)); }
            function J0(a) { let e = !1; const i = []; if (a[0] === "case") {
                for (let c = 1; c < a.length - 1; c += 2)
                    e = e || ju(a[c]), i.push(a[c + 1]);
                i.push(a[a.length - 1]);
            }
            else if (a[0] === "match") {
                e = e || ju(a[1]);
                for (let c = 2; c < a.length - 1; c += 2)
                    i.push(a[c + 1]);
                i.push(a[a.length - 1]);
            }
            else if (a[0] === "step") {
                e = e || ju(a[1]);
                for (let c = 1; c < a.length - 1; c += 2)
                    i.push(a[c + 1]);
            } e && (a.length = 0, a.push("any", ...i)); for (let c = 1; c < a.length; c++)
                J0(a[c]); }
            function ju(a) { if (!Array.isArray(a))
                return !1; if ((e = a[0]) === "pitch" || e === "distance-from-center")
                return !0; var e; for (let i = 1; i < a.length; i++)
                if (ju(a[i]))
                    return !0; return !1; }
            const _T = new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
            function yT(a, e) { return a < e ? -1 : a > e ? 1 : 0; }
            function ex(a) { if (!Array.isArray(a))
                return !1; if (a[0] === "within" || a[0] === "distance")
                return !0; for (let e = 1; e < a.length; e++)
                if (ex(a[e]))
                    return !0; return !1; }
            function Lp(a) { if (!a)
                return !0; const e = a[0]; return a.length <= 1 ? e !== "any" : e === "==" ? T_(a[1], a[2], "==") : e === "!=" ? Op(T_(a[1], a[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? T_(a[1], a[2], e) : e === "any" ? (i = a.slice(1), ["any"].concat(i.map(Lp))) : e === "all" ? ["all"].concat(a.slice(1).map(Lp)) : e === "none" ? ["all"].concat(a.slice(1).map(Lp).map(Op)) : e === "in" ? S_(a[1], a.slice(2)) : e === "!in" ? Op(S_(a[1], a.slice(2))) : e === "has" ? tx(a[1]) : e !== "!has" || Op(tx(a[1])); var i; }
            function T_(a, e, i) { switch (a) {
                case "$type": return [`filter-type-${i}`, e];
                case "$id": return [`filter-id-${i}`, e];
                default: return [`filter-${i}`, a, e];
            } }
            function S_(a, e) { if (e.length === 0)
                return !1; switch (a) {
                case "$type": return ["filter-type-in", ["literal", e]];
                case "$id": return ["filter-id-in", ["literal", e]];
                default: return e.length > 200 && !e.some(i => typeof i != typeof e[0]) ? ["filter-in-large", a, ["literal", e.sort(yT)]] : ["filter-in-small", a, ["literal", e]];
            } }
            function tx(a) { switch (a) {
                case "$type": return !0;
                case "$id": return ["filter-has-id"];
                default: return ["filter-has", a];
            } }
            function Op(a) { return ["!", a]; }
            const Od = "";
            function Nc(a, e) { return e ? `${a}${Od}${e}` : a; }
            const E_ = "-transition", jl = new Set(["fill", "line", "background", "hillshade", "raster"]);
            class Ds extends wc {
                constructor(e, i, c, h, p) { if (super(), this.id = e.id, this.fqid = Nc(this.id, c), this.type = e.type, this.scope = c, this.lut = h, this.options = p, this._featureFilter = { filter: () => !0, needGeometry: !1, needFeature: !1 }, this._filterCompiled = !1, this.configDependencies = new Set, e.type !== "custom") {
                    if (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type && e.type !== "background" && e.type !== "sky" && e.type !== "slot") {
                        this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter;
                        const m = Ou(this.filter, Ne[`filter_${e.type}`]);
                        m.result !== "error" && (this.configDependencies = new Set([...this.configDependencies, ...m.value.configDependencies]));
                    }
                    if (e.slot && (this.slot = e.slot), i.layout && (this._unevaluatedLayout = new gT(i.layout, this.scope, p), this.configDependencies = new Set([...this.configDependencies, ...this._unevaluatedLayout.configDependencies])), i.paint) {
                        this._transitionablePaint = new X0(i.paint, this.scope, p);
                        for (const m in e.paint)
                            this.setPaintProperty(m, e.paint[m]);
                        for (const m in e.layout)
                            this.setLayoutProperty(m, e.layout[m]);
                        this.configDependencies = new Set([...this.configDependencies, ...this._transitionablePaint.configDependencies]), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new zc(i.paint);
                    }
                } }
                onAdd(e) { }
                onRemove(e) { }
                isDraped(e) { return !this.is3D(!0) && jl.has(this.type); }
                getLayoutProperty(e) { return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e); }
                setLayoutProperty(e, i) { if (this.type === "custom" && e === "visibility")
                    return void (this.visibility = i); const c = this._unevaluatedLayout; c._properties.properties[e] && (c.setValue(e, i), this.configDependencies = new Set([...this.configDependencies, ...c.configDependencies]), e === "visibility" && this.possiblyEvaluateVisibility()); }
                possiblyEvaluateVisibility() { this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 })); }
                getPaintProperty(e) { return e.endsWith(E_) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e); }
                setPaintProperty(e, i) { const c = this._transitionablePaint, h = c._properties.properties; if (e.endsWith(E_)) {
                    const I = e.slice(0, -11);
                    return h[I] && c.setTransition(I, i || void 0), !1;
                } if (!h[e])
                    return !1; const p = c._values[e], m = p.value.isDataDriven(), x = p.value; c.setValue(e, i), this.configDependencies = new Set([...this.configDependencies, ...c.configDependencies]), this._handleSpecialPaintPropertyUpdate(e); const b = c._values[e].value, S = b.isDataDriven(), A = e.endsWith("pattern") || e === "line-dasharray"; return S || m || A || this._handleOverridablePaintPropertyUpdate(e, x, b); }
                _handleSpecialPaintPropertyUpdate(e) { }
                getProgramIds() { return null; }
                getDefaultProgramParams(e, i, c) { return null; }
                _handleOverridablePaintPropertyUpdate(e, i, c) { return !1; }
                isHidden(e) { return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || this.visibility === "none"; }
                updateTransitions(e) { this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint); }
                hasTransition() { return this._transitioningPaint.hasTransition(); }
                recalculate(e, i) { this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, i)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, i); }
                serialize() { return Mr({ id: this.id, type: this.type, slot: this.slot, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }, (e, i) => !(e === void 0 || i === "layout" && !Object.keys(e).length || i === "paint" && !Object.keys(e).length)); }
                is3D(e) { return !1; }
                hasElevation() { return !1; }
                isSky() { return !1; }
                isTileClipped() { return !1; }
                hasOffscreenPass() { return !1; }
                hasShadowPass() { return !1; }
                canCastShadows() { return !1; }
                hasLightBeamPass() { return !1; }
                cutoffRange() { return 0; }
                tileCoverLift() { return 0; }
                resize() { }
                isStateDependent() { for (const e in this.paint._values) {
                    const i = this.paint.get(e);
                    if (i instanceof Bu && Tp(i.property.specification) && (i.value.kind === "source" || i.value.kind === "composite") && i.value.isStateDependent)
                        return !0;
                } return !1; }
                compileFilter(e) { this._filterCompiled || (this._featureFilter = b_(this.filter, this.scope, e), this._filterCompiled = !0); }
                invalidateCompiledFilter() { this._filterCompiled = !1; }
                dynamicFilter() { return this._featureFilter.dynamicFilter; }
                dynamicFilterNeedsFeature() { return this._featureFilter.needFeature; }
                getLayerRenderingStats() { return this._stats; }
                resetLayerRenderingStats(e) { this._stats && (e.renderPass === "shadow" ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0); }
                queryRadius(e) { }
                queryIntersectsFeature(e, i, c, h, p, m, x, b, S) { }
            }
            const vT = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
            class zd {
                constructor(e, i) { this._structArray = e, this._pos1 = i * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8; }
            }
            class Xn {
                constructor() { this.isTransferred = !1, this.capacity = -1, this.resize(0); }
                static serialize(e, i) { return e._trim(), i && (e.isTransferred = !0, i.add(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer }; }
                static deserialize(e) { const i = Object.create(this.prototype); return i.arrayBuffer = e.arrayBuffer, i.length = e.length, i.capacity = e.arrayBuffer.byteLength / i.bytesPerElement, i._refreshViews(), i; }
                _trim() { this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews()); }
                clear() { this.length = 0; }
                resize(e) { this.reserve(e), this.length = e; }
                reserve(e) { if (e > this.capacity) {
                    this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                    const i = this.uint8;
                    this._refreshViews(), i && this.uint8.set(i);
                } }
                _refreshViews() { throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout"); }
                emplace(...e) { throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout"); }
                emplaceBack(...e) { throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout"); }
                destroy() { this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null; }
            }
            function tn(a, e = 1) { let i = 0, c = 0; return { members: a.map(h => { const p = vT[h.type].BYTES_PER_ELEMENT, m = i = C_(i, Math.max(e, p)), x = h.components || 1; return c = Math.max(c, p), i += p * x, { name: h.name, type: h.type, components: x, offset: m }; }), size: C_(i, Math.max(c, e)), alignment: e }; }
            function C_(a, e) { return Math.ceil(a / e) * e; }
            class Ja extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }
                emplaceBack(e, i) { const c = this.length; return this.resize(c + 1), this.emplace(c, e, i); }
                emplace(e, i, c) { const h = 2 * e; return this.int16[h + 0] = i, this.int16[h + 1] = c, e; }
            }
            Ja.prototype.bytesPerElement = 4, Nt(Ja, "StructArrayLayout2i4");
            class zp extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }
                emplaceBack(e, i, c) { const h = this.length; return this.resize(h + 1), this.emplace(h, e, i, c); }
                emplace(e, i, c, h) { const p = 3 * e; return this.int16[p + 0] = i, this.int16[p + 1] = c, this.int16[p + 2] = h, e; }
            }
            zp.prototype.bytesPerElement = 6, Nt(zp, "StructArrayLayout3i6");
            class Bc extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h) { const p = this.length; return this.resize(p + 1), this.emplace(p, e, i, c, h); }
                emplace(e, i, c, h, p) { const m = 4 * e; return this.int16[m + 0] = i, this.int16[m + 1] = c, this.int16[m + 2] = h, this.int16[m + 3] = p, e; }
            }
            Bc.prototype.bytesPerElement = 8, Nt(Bc, "StructArrayLayout4i8");
            class Vu extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e) { const i = this.length; return this.resize(i + 1), this.emplace(i, e); }
                emplace(e, i) { return this.float32[1 * e + 0] = i, e; }
            }
            Vu.prototype.bytesPerElement = 4, Nt(Vu, "StructArrayLayout1f4");
            class Fp extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e, i, c) { const h = this.length; return this.resize(h + 1), this.emplace(h, e, i, c); }
                emplace(e, i, c, h) { const p = 4 * e, m = 2 * e; return this.int16[p + 0] = i, this.int16[p + 1] = c, this.float32[m + 1] = h, e; }
            }
            Fp.prototype.bytesPerElement = 8, Nt(Fp, "StructArrayLayout2i1f8");
            class Uu extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }
                emplaceBack(e, i, c) { const h = this.length; return this.resize(h + 1), this.emplace(h, e, i, c); }
                emplace(e, i, c, h) { const p = 4 * e; return this.int16[p + 0] = i, this.int16[p + 1] = c, this.int16[p + 2] = h, e; }
            }
            Uu.prototype.bytesPerElement = 8, Nt(Uu, "StructArrayLayout3i8");
            class A_ extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p) { const m = this.length; return this.resize(m + 1), this.emplace(m, e, i, c, h, p); }
                emplace(e, i, c, h, p, m) { const x = 5 * e; return this.int16[x + 0] = i, this.int16[x + 1] = c, this.int16[x + 2] = h, this.int16[x + 3] = p, this.int16[x + 4] = m, e; }
            }
            A_.prototype.bytesPerElement = 10, Nt(A_, "StructArrayLayout5i10");
            class I_ extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p, m, x) { const b = this.length; return this.resize(b + 1), this.emplace(b, e, i, c, h, p, m, x); }
                emplace(e, i, c, h, p, m, x, b) { const S = 6 * e, A = 12 * e, I = 3 * e; return this.int16[S + 0] = i, this.int16[S + 1] = c, this.uint8[A + 4] = h, this.uint8[A + 5] = p, this.uint8[A + 6] = m, this.uint8[A + 7] = x, this.float32[I + 2] = b, e; }
            }
            I_.prototype.bytesPerElement = 12, Nt(I_, "StructArrayLayout2i4ub1f12");
            class Ea extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e, i, c) { const h = this.length; return this.resize(h + 1), this.emplace(h, e, i, c); }
                emplace(e, i, c, h) { const p = 3 * e; return this.float32[p + 0] = i, this.float32[p + 1] = c, this.float32[p + 2] = h, e; }
            }
            Ea.prototype.bytesPerElement = 12, Nt(Ea, "StructArrayLayout3f12");
            class el extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p) { const m = this.length; return this.resize(m + 1), this.emplace(m, e, i, c, h, p); }
                emplace(e, i, c, h, p, m) { const x = 6 * e, b = 3 * e; return this.uint16[x + 0] = i, this.uint16[x + 1] = c, this.uint16[x + 2] = h, this.uint16[x + 3] = p, this.float32[b + 2] = m, e; }
            }
            el.prototype.bytesPerElement = 12, Nt(el, "StructArrayLayout4ui1f12");
            class Np extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h) { const p = this.length; return this.resize(p + 1), this.emplace(p, e, i, c, h); }
                emplace(e, i, c, h, p) { const m = 4 * e; return this.uint16[m + 0] = i, this.uint16[m + 1] = c, this.uint16[m + 2] = h, this.uint16[m + 3] = p, e; }
            }
            Np.prototype.bytesPerElement = 8, Nt(Np, "StructArrayLayout4ui8");
            class jc extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p, m) { const x = this.length; return this.resize(x + 1), this.emplace(x, e, i, c, h, p, m); }
                emplace(e, i, c, h, p, m, x) { const b = 6 * e; return this.int16[b + 0] = i, this.int16[b + 1] = c, this.int16[b + 2] = h, this.int16[b + 3] = p, this.int16[b + 4] = m, this.int16[b + 5] = x, e; }
            }
            jc.prototype.bytesPerElement = 12, Nt(jc, "StructArrayLayout6i12");
            class $u extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p, m, x, b, S, A, I, M) { const z = this.length; return this.resize(z + 1), this.emplace(z, e, i, c, h, p, m, x, b, S, A, I, M); }
                emplace(e, i, c, h, p, m, x, b, S, A, I, M, z) { const F = 12 * e; return this.int16[F + 0] = i, this.int16[F + 1] = c, this.int16[F + 2] = h, this.int16[F + 3] = p, this.uint16[F + 4] = m, this.uint16[F + 5] = x, this.uint16[F + 6] = b, this.uint16[F + 7] = S, this.int16[F + 8] = A, this.int16[F + 9] = I, this.int16[F + 10] = M, this.int16[F + 11] = z, e; }
            }
            $u.prototype.bytesPerElement = 24, Nt($u, "StructArrayLayout4i4ui4i24");
            class Gs extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p, m) { const x = this.length; return this.resize(x + 1), this.emplace(x, e, i, c, h, p, m); }
                emplace(e, i, c, h, p, m, x) { const b = 10 * e, S = 5 * e; return this.int16[b + 0] = i, this.int16[b + 1] = c, this.int16[b + 2] = h, this.float32[S + 2] = p, this.float32[S + 3] = m, this.float32[S + 4] = x, e; }
            }
            Gs.prototype.bytesPerElement = 20, Nt(Gs, "StructArrayLayout3i3f20");
            class Ca extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h) { const p = this.length; return this.resize(p + 1), this.emplace(p, e, i, c, h); }
                emplace(e, i, c, h, p) { const m = 4 * e; return this.float32[m + 0] = i, this.float32[m + 1] = c, this.float32[m + 2] = h, this.float32[m + 3] = p, e; }
            }
            Ca.prototype.bytesPerElement = 16, Nt(Ca, "StructArrayLayout4f16");
            class P_ extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer); }
                emplaceBack(e) { const i = this.length; return this.resize(i + 1), this.emplace(i, e); }
                emplace(e, i) { return this.uint32[1 * e + 0] = i, e; }
            }
            P_.prototype.bytesPerElement = 4, Nt(P_, "StructArrayLayout1ul4");
            class Vl extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); }
                emplaceBack(e, i) { const c = this.length; return this.resize(c + 1), this.emplace(c, e, i); }
                emplace(e, i, c) { const h = 2 * e; return this.uint16[h + 0] = i, this.uint16[h + 1] = c, e; }
            }
            Vl.prototype.bytesPerElement = 4, Nt(Vl, "StructArrayLayout2ui4");
            class M_ extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p, m, x, b, S, A, I, M, z) { const F = this.length; return this.resize(F + 1), this.emplace(F, e, i, c, h, p, m, x, b, S, A, I, M, z); }
                emplace(e, i, c, h, p, m, x, b, S, A, I, M, z, F) { const U = 20 * e, X = 10 * e; return this.int16[U + 0] = i, this.int16[U + 1] = c, this.int16[U + 2] = h, this.int16[U + 3] = p, this.int16[U + 4] = m, this.float32[X + 3] = x, this.float32[X + 4] = b, this.float32[X + 5] = S, this.float32[X + 6] = A, this.int16[U + 14] = I, this.uint32[X + 8] = M, this.uint16[U + 18] = z, this.uint16[U + 19] = F, e; }
            }
            M_.prototype.bytesPerElement = 40, Nt(M_, "StructArrayLayout5i4f1i1ul2ui40");
            class Bp extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p, m, x) { const b = this.length; return this.resize(b + 1), this.emplace(b, e, i, c, h, p, m, x); }
                emplace(e, i, c, h, p, m, x, b) { const S = 8 * e; return this.int16[S + 0] = i, this.int16[S + 1] = c, this.int16[S + 2] = h, this.int16[S + 4] = p, this.int16[S + 5] = m, this.int16[S + 6] = x, this.int16[S + 7] = b, e; }
            }
            Bp.prototype.bytesPerElement = 16, Nt(Bp, "StructArrayLayout3i2i2i16");
            class Fd extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p) { const m = this.length; return this.resize(m + 1), this.emplace(m, e, i, c, h, p); }
                emplace(e, i, c, h, p, m) { const x = 4 * e, b = 8 * e; return this.float32[x + 0] = i, this.float32[x + 1] = c, this.float32[x + 2] = h, this.int16[b + 6] = p, this.int16[b + 7] = m, e; }
            }
            Fd.prototype.bytesPerElement = 16, Nt(Fd, "StructArrayLayout2f1f2i16");
            class R_ extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p, m) { const x = this.length; return this.resize(x + 1), this.emplace(x, e, i, c, h, p, m); }
                emplace(e, i, c, h, p, m, x) { const b = 20 * e, S = 5 * e; return this.uint8[b + 0] = i, this.uint8[b + 1] = c, this.float32[S + 1] = h, this.float32[S + 2] = p, this.float32[S + 3] = m, this.float32[S + 4] = x, e; }
            }
            R_.prototype.bytesPerElement = 20, Nt(R_, "StructArrayLayout2ub4f20");
            class Hi extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); }
                emplaceBack(e, i, c) { const h = this.length; return this.resize(h + 1), this.emplace(h, e, i, c); }
                emplace(e, i, c, h) { const p = 3 * e; return this.uint16[p + 0] = i, this.uint16[p + 1] = c, this.uint16[p + 2] = h, e; }
            }
            Hi.prototype.bytesPerElement = 6, Nt(Hi, "StructArrayLayout3ui6");
            class k_ extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p, m, x, b, S, A, I, M, z, F, U, X, Y, le, se, $, te) { const ae = this.length; return this.resize(ae + 1), this.emplace(ae, e, i, c, h, p, m, x, b, S, A, I, M, z, F, U, X, Y, le, se, $, te); }
                emplace(e, i, c, h, p, m, x, b, S, A, I, M, z, F, U, X, Y, le, se, $, te, ae) { const fe = 30 * e, Te = 15 * e, Pe = 60 * e; return this.int16[fe + 0] = i, this.int16[fe + 1] = c, this.int16[fe + 2] = h, this.float32[Te + 2] = p, this.float32[Te + 3] = m, this.uint16[fe + 8] = x, this.uint16[fe + 9] = b, this.uint32[Te + 5] = S, this.uint32[Te + 6] = A, this.uint32[Te + 7] = I, this.uint16[fe + 16] = M, this.uint16[fe + 17] = z, this.uint16[fe + 18] = F, this.float32[Te + 10] = U, this.float32[Te + 11] = X, this.uint8[Pe + 48] = Y, this.uint8[Pe + 49] = le, this.uint8[Pe + 50] = se, this.uint32[Te + 13] = $, this.int16[fe + 28] = te, this.uint8[Pe + 58] = ae, e; }
            }
            k_.prototype.bytesPerElement = 60, Nt(k_, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
            class D_ extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p, m, x, b, S, A, I, M, z, F, U, X, Y, le, se, $, te, ae, fe, Te, Pe, Me, Oe, Ye, ut, it, lt, pt, We) { const at = this.length; return this.resize(at + 1), this.emplace(at, e, i, c, h, p, m, x, b, S, A, I, M, z, F, U, X, Y, le, se, $, te, ae, fe, Te, Pe, Me, Oe, Ye, ut, it, lt, pt, We); }
                emplace(e, i, c, h, p, m, x, b, S, A, I, M, z, F, U, X, Y, le, se, $, te, ae, fe, Te, Pe, Me, Oe, Ye, ut, it, lt, pt, We, at) { const Ge = 20 * e, Xe = 40 * e, gt = 80 * e; return this.float32[Ge + 0] = i, this.float32[Ge + 1] = c, this.int16[Xe + 4] = h, this.int16[Xe + 5] = p, this.int16[Xe + 6] = m, this.int16[Xe + 7] = x, this.int16[Xe + 8] = b, this.int16[Xe + 9] = S, this.int16[Xe + 10] = A, this.int16[Xe + 11] = I, this.int16[Xe + 12] = M, this.uint16[Xe + 13] = z, this.uint16[Xe + 14] = F, this.uint16[Xe + 15] = U, this.uint16[Xe + 16] = X, this.uint16[Xe + 17] = Y, this.uint16[Xe + 18] = le, this.uint16[Xe + 19] = se, this.uint16[Xe + 20] = $, this.uint16[Xe + 21] = te, this.uint16[Xe + 22] = ae, this.uint16[Xe + 23] = fe, this.uint16[Xe + 24] = Te, this.uint16[Xe + 25] = Pe, this.uint16[Xe + 26] = Me, this.uint16[Xe + 27] = Oe, this.uint32[Ge + 14] = Ye, this.float32[Ge + 15] = ut, this.float32[Ge + 16] = it, this.float32[Ge + 17] = lt, this.float32[Ge + 18] = pt, this.uint8[gt + 76] = We, this.uint16[Xe + 39] = at, e; }
            }
            D_.prototype.bytesPerElement = 80, Nt(D_, "StructArrayLayout2f9i15ui1ul4f1ub1ui80");
            class Ul extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p) { const m = this.length; return this.resize(m + 1), this.emplace(m, e, i, c, h, p); }
                emplace(e, i, c, h, p, m) { const x = 5 * e; return this.float32[x + 0] = i, this.float32[x + 1] = c, this.float32[x + 2] = h, this.float32[x + 3] = p, this.float32[x + 4] = m, e; }
            }
            Ul.prototype.bytesPerElement = 20, Nt(Ul, "StructArrayLayout5f20");
            class Nd extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p, m, x) { const b = this.length; return this.resize(b + 1), this.emplace(b, e, i, c, h, p, m, x); }
                emplace(e, i, c, h, p, m, x, b) { const S = 7 * e; return this.float32[S + 0] = i, this.float32[S + 1] = c, this.float32[S + 2] = h, this.float32[S + 3] = p, this.float32[S + 4] = m, this.float32[S + 5] = x, this.float32[S + 6] = b, e; }
            }
            Nd.prototype.bytesPerElement = 28, Nt(Nd, "StructArrayLayout7f28");
            class L_ extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p, m, x, b, S, A, I) { const M = this.length; return this.resize(M + 1), this.emplace(M, e, i, c, h, p, m, x, b, S, A, I); }
                emplace(e, i, c, h, p, m, x, b, S, A, I, M) { const z = 11 * e; return this.float32[z + 0] = i, this.float32[z + 1] = c, this.float32[z + 2] = h, this.float32[z + 3] = p, this.float32[z + 4] = m, this.float32[z + 5] = x, this.float32[z + 6] = b, this.float32[z + 7] = S, this.float32[z + 8] = A, this.float32[z + 9] = I, this.float32[z + 10] = M, e; }
            }
            L_.prototype.bytesPerElement = 44, Nt(L_, "StructArrayLayout11f44");
            class jp extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p, m, x, b, S) { const A = this.length; return this.resize(A + 1), this.emplace(A, e, i, c, h, p, m, x, b, S); }
                emplace(e, i, c, h, p, m, x, b, S, A) { const I = 9 * e; return this.float32[I + 0] = i, this.float32[I + 1] = c, this.float32[I + 2] = h, this.float32[I + 3] = p, this.float32[I + 4] = m, this.float32[I + 5] = x, this.float32[I + 6] = b, this.float32[I + 7] = S, this.float32[I + 8] = A, e; }
            }
            jp.prototype.bytesPerElement = 36, Nt(jp, "StructArrayLayout9f36");
            class Vc extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e, i) { const c = this.length; return this.resize(c + 1), this.emplace(c, e, i); }
                emplace(e, i, c) { const h = 2 * e; return this.float32[h + 0] = i, this.float32[h + 1] = c, e; }
            }
            Vc.prototype.bytesPerElement = 8, Nt(Vc, "StructArrayLayout2f8");
            class O_ extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h) { const p = this.length; return this.resize(p + 1), this.emplace(p, e, i, c, h); }
                emplace(e, i, c, h, p) { const m = 6 * e; return this.uint32[3 * e + 0] = i, this.uint16[m + 2] = c, this.uint16[m + 3] = h, this.uint16[m + 4] = p, e; }
            }
            O_.prototype.bytesPerElement = 12, Nt(O_, "StructArrayLayout1ul3ui12");
            class Bd extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); }
                emplaceBack(e) { const i = this.length; return this.resize(i + 1), this.emplace(i, e); }
                emplace(e, i) { return this.uint16[1 * e + 0] = i, e; }
            }
            Bd.prototype.bytesPerElement = 2, Nt(Bd, "StructArrayLayout1ui2");
            class Gu extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p, m, x, b, S, A, I, M, z, F, U, X) { const Y = this.length; return this.resize(Y + 1), this.emplace(Y, e, i, c, h, p, m, x, b, S, A, I, M, z, F, U, X); }
                emplace(e, i, c, h, p, m, x, b, S, A, I, M, z, F, U, X, Y) { const le = 16 * e; return this.float32[le + 0] = i, this.float32[le + 1] = c, this.float32[le + 2] = h, this.float32[le + 3] = p, this.float32[le + 4] = m, this.float32[le + 5] = x, this.float32[le + 6] = b, this.float32[le + 7] = S, this.float32[le + 8] = A, this.float32[le + 9] = I, this.float32[le + 10] = M, this.float32[le + 11] = z, this.float32[le + 12] = F, this.float32[le + 13] = U, this.float32[le + 14] = X, this.float32[le + 15] = Y, e; }
            }
            Gu.prototype.bytesPerElement = 64, Nt(Gu, "StructArrayLayout16f64");
            class jd extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); }
                emplaceBack(e, i, c, h, p, m, x) { const b = this.length; return this.resize(b + 1), this.emplace(b, e, i, c, h, p, m, x); }
                emplace(e, i, c, h, p, m, x, b) { const S = 10 * e, A = 5 * e; return this.uint16[S + 0] = i, this.uint16[S + 1] = c, this.uint16[S + 2] = h, this.uint16[S + 3] = p, this.float32[A + 2] = m, this.float32[A + 3] = x, this.float32[A + 4] = b, e; }
            }
            jd.prototype.bytesPerElement = 20, Nt(jd, "StructArrayLayout4ui3f20");
            class z_ extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); }
                emplaceBack(e) { const i = this.length; return this.resize(i + 1), this.emplace(i, e); }
                emplace(e, i) { return this.int16[1 * e + 0] = i, e; }
            }
            z_.prototype.bytesPerElement = 2, Nt(z_, "StructArrayLayout1i2");
            class Vp extends Xn {
                _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer); }
                emplaceBack(e) { const i = this.length; return this.resize(i + 1), this.emplace(i, e); }
                emplace(e, i) { return this.uint8[1 * e + 0] = i, e; }
            }
            Vp.prototype.bytesPerElement = 1, Nt(Vp, "StructArrayLayout1ub1");
            class rx extends zd {
                get projectedAnchorX() { return this._structArray.int16[this._pos2 + 0]; }
                get projectedAnchorY() { return this._structArray.int16[this._pos2 + 1]; }
                get projectedAnchorZ() { return this._structArray.int16[this._pos2 + 2]; }
                get tileAnchorX() { return this._structArray.int16[this._pos2 + 3]; }
                get tileAnchorY() { return this._structArray.int16[this._pos2 + 4]; }
                get x1() { return this._structArray.float32[this._pos4 + 3]; }
                get y1() { return this._structArray.float32[this._pos4 + 4]; }
                get x2() { return this._structArray.float32[this._pos4 + 5]; }
                get y2() { return this._structArray.float32[this._pos4 + 6]; }
                get padding() { return this._structArray.int16[this._pos2 + 14]; }
                get featureIndex() { return this._structArray.uint32[this._pos4 + 8]; }
                get sourceLayerIndex() { return this._structArray.uint16[this._pos2 + 18]; }
                get bucketIndex() { return this._structArray.uint16[this._pos2 + 19]; }
            }
            rx.prototype.size = 40;
            class Up extends M_ {
                get(e) { return new rx(this, e); }
            }
            Nt(Up, "CollisionBoxArray");
            class nx extends zd {
                get projectedAnchorX() { return this._structArray.int16[this._pos2 + 0]; }
                get projectedAnchorY() { return this._structArray.int16[this._pos2 + 1]; }
                get projectedAnchorZ() { return this._structArray.int16[this._pos2 + 2]; }
                get tileAnchorX() { return this._structArray.float32[this._pos4 + 2]; }
                get tileAnchorY() { return this._structArray.float32[this._pos4 + 3]; }
                get glyphStartIndex() { return this._structArray.uint16[this._pos2 + 8]; }
                get numGlyphs() { return this._structArray.uint16[this._pos2 + 9]; }
                get vertexStartIndex() { return this._structArray.uint32[this._pos4 + 5]; }
                get lineStartIndex() { return this._structArray.uint32[this._pos4 + 6]; }
                get lineLength() { return this._structArray.uint32[this._pos4 + 7]; }
                get segment() { return this._structArray.uint16[this._pos2 + 16]; }
                get lowerSize() { return this._structArray.uint16[this._pos2 + 17]; }
                get upperSize() { return this._structArray.uint16[this._pos2 + 18]; }
                get lineOffsetX() { return this._structArray.float32[this._pos4 + 10]; }
                get lineOffsetY() { return this._structArray.float32[this._pos4 + 11]; }
                get writingMode() { return this._structArray.uint8[this._pos1 + 48]; }
                get placedOrientation() { return this._structArray.uint8[this._pos1 + 49]; }
                set placedOrientation(e) { this._structArray.uint8[this._pos1 + 49] = e; }
                get hidden() { return this._structArray.uint8[this._pos1 + 50]; }
                set hidden(e) { this._structArray.uint8[this._pos1 + 50] = e; }
                get crossTileID() { return this._structArray.uint32[this._pos4 + 13]; }
                set crossTileID(e) { this._structArray.uint32[this._pos4 + 13] = e; }
                get associatedIconIndex() { return this._structArray.int16[this._pos2 + 28]; }
                get flipState() { return this._structArray.uint8[this._pos1 + 58]; }
                set flipState(e) { this._structArray.uint8[this._pos1 + 58] = e; }
            }
            nx.prototype.size = 60;
            class ix extends k_ {
                get(e) { return new nx(this, e); }
            }
            Nt(ix, "PlacedSymbolArray");
            class sx extends zd {
                get tileAnchorX() { return this._structArray.float32[this._pos4 + 0]; }
                get tileAnchorY() { return this._structArray.float32[this._pos4 + 1]; }
                get projectedAnchorX() { return this._structArray.int16[this._pos2 + 4]; }
                get projectedAnchorY() { return this._structArray.int16[this._pos2 + 5]; }
                get projectedAnchorZ() { return this._structArray.int16[this._pos2 + 6]; }
                get rightJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 7]; }
                get centerJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 8]; }
                get leftJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 9]; }
                get verticalPlacedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 10]; }
                get placedIconSymbolIndex() { return this._structArray.int16[this._pos2 + 11]; }
                get verticalPlacedIconSymbolIndex() { return this._structArray.int16[this._pos2 + 12]; }
                get key() { return this._structArray.uint16[this._pos2 + 13]; }
                get textBoxStartIndex() { return this._structArray.uint16[this._pos2 + 14]; }
                get textBoxEndIndex() { return this._structArray.uint16[this._pos2 + 15]; }
                get verticalTextBoxStartIndex() { return this._structArray.uint16[this._pos2 + 16]; }
                get verticalTextBoxEndIndex() { return this._structArray.uint16[this._pos2 + 17]; }
                get iconBoxStartIndex() { return this._structArray.uint16[this._pos2 + 18]; }
                get iconBoxEndIndex() { return this._structArray.uint16[this._pos2 + 19]; }
                get verticalIconBoxStartIndex() { return this._structArray.uint16[this._pos2 + 20]; }
                get verticalIconBoxEndIndex() { return this._structArray.uint16[this._pos2 + 21]; }
                get featureIndex() { return this._structArray.uint16[this._pos2 + 22]; }
                get numHorizontalGlyphVertices() { return this._structArray.uint16[this._pos2 + 23]; }
                get numVerticalGlyphVertices() { return this._structArray.uint16[this._pos2 + 24]; }
                get numIconVertices() { return this._structArray.uint16[this._pos2 + 25]; }
                get numVerticalIconVertices() { return this._structArray.uint16[this._pos2 + 26]; }
                get useRuntimeCollisionCircles() { return this._structArray.uint16[this._pos2 + 27]; }
                get crossTileID() { return this._structArray.uint32[this._pos4 + 14]; }
                set crossTileID(e) { this._structArray.uint32[this._pos4 + 14] = e; }
                get textOffset0() { return this._structArray.float32[this._pos4 + 15]; }
                get textOffset1() { return this._structArray.float32[this._pos4 + 16]; }
                get collisionCircleDiameter() { return this._structArray.float32[this._pos4 + 17]; }
                get zOffset() { return this._structArray.float32[this._pos4 + 18]; }
                set zOffset(e) { this._structArray.float32[this._pos4 + 18] = e; }
                get hasIconTextFit() { return this._structArray.uint8[this._pos1 + 76]; }
                get elevationFeatureIndex() { return this._structArray.uint16[this._pos2 + 39]; }
            }
            sx.prototype.size = 80;
            class ox extends D_ {
                get(e) { return new sx(this, e); }
            }
            Nt(ox, "SymbolInstanceArray");
            class F_ extends Vu {
                getoffsetX(e) { return this.float32[1 * e + 0]; }
            }
            Nt(F_, "GlyphOffsetArray");
            class ax extends Ja {
                getx(e) { return this.int16[2 * e + 0]; }
                gety(e) { return this.int16[2 * e + 1]; }
            }
            Nt(ax, "SymbolLineVertexArray");
            class lx extends zd {
                get featureIndex() { return this._structArray.uint32[this._pos4 + 0]; }
                get sourceLayerIndex() { return this._structArray.uint16[this._pos2 + 2]; }
                get bucketIndex() { return this._structArray.uint16[this._pos2 + 3]; }
                get layoutVertexArrayOffset() { return this._structArray.uint16[this._pos2 + 4]; }
            }
            lx.prototype.size = 12;
            class cx extends O_ {
                get(e) { return new lx(this, e); }
            }
            Nt(cx, "FeatureIndexArray");
            class ux extends Vl {
                geta_centroid_pos0(e) { return this.uint16[2 * e + 0]; }
                geta_centroid_pos1(e) { return this.uint16[2 * e + 1]; }
            }
            Nt(ux, "FillExtrusionCentroidArray");
            class hx extends zd {
                get a_join_normal_inside0() { return this._structArray.int16[this._pos2 + 0]; }
                get a_join_normal_inside1() { return this._structArray.int16[this._pos2 + 1]; }
                get a_join_normal_inside2() { return this._structArray.int16[this._pos2 + 2]; }
            }
            hx.prototype.size = 6;
            class dx extends zp {
                get(e) { return new hx(this, e); }
            }
            Nt(dx, "FillExtrusionWallArray");
            const xT = tn([{ name: "a_pos", components: 2, type: "Int16" }], 4), wT = tn([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
            class ti {
                constructor(e = []) { this.segments = e; }
                _prepareSegment(e, i, c, h) { let p = this.segments[this.segments.length - 1]; return e > ti.MAX_VERTEX_ARRAY_LENGTH && Br(`Max vertices per segment is ${ti.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`), (!p || p.vertexLength + e > ti.MAX_VERTEX_ARRAY_LENGTH || p.sortKey !== h) && (p = { vertexOffset: i, primitiveOffset: c, vertexLength: 0, primitiveLength: 0 }, h !== void 0 && (p.sortKey = h), this.segments.push(p)), p; }
                prepareSegment(e, i, c, h) { return this._prepareSegment(e, i.length, c.length, h); }
                get() { return this.segments; }
                destroy() { for (const e of this.segments)
                    for (const i in e.vaos)
                        e.vaos[i].destroy(); }
                static simpleSegment(e, i, c, h) { return new ti([{ vertexOffset: e, primitiveOffset: i, vertexLength: c, primitiveLength: h, vaos: {}, sortKey: 0 }]); }
            }
            function fx(a, e) { return 256 * (a = ke(Math.floor(a), 0, 255)) + ke(Math.floor(e), 0, 255); }
            ti.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Nt(ti, "SegmentVector");
            const bT = tn([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), qu = tn([{ name: "a_pattern_b", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), TT = tn([{ name: "a_dash", components: 4, type: "Uint16" }]);
            class Hu {
                constructor() { this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = !1; }
                add(e, i, c, h) { this.ids.push(px(e)), this.positions.push(i, c, h); }
                eachPosition(e, i) { const c = px(e); let h = 0, p = this.ids.length - 1; for (; h < p;) {
                    const m = h + p >> 1;
                    this.ids[m] >= c ? p = m : h = m + 1;
                } for (; this.ids[h] === c;)
                    i(this.positions[3 * h], this.positions[3 * h + 1], this.positions[3 * h + 2]), h++; }
                static serialize(e, i) { const c = new Float64Array(e.ids), h = new Uint32Array(e.positions); return $p(c, h, 0, c.length - 1), i && (i.add(c.buffer), i.add(h.buffer)), { ids: c, positions: h }; }
                static deserialize(e) { const i = new Hu; let c; i.ids = e.ids, i.positions = e.positions; for (const h of i.ids)
                    h !== c && i.uniqueIds.push(h), c = h; return i.indexed = !0, i; }
            }
            function px(a) { const e = +a; return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : Js(String(a)); }
            function $p(a, e, i, c) { for (; i < c;) {
                const h = a[i + c >> 1];
                let p = i - 1, m = c + 1;
                for (;;) {
                    do
                        p++;
                    while (a[p] < h);
                    do
                        m--;
                    while (a[m] > h);
                    if (p >= m)
                        break;
                    Vd(a, p, m), Vd(e, 3 * p, 3 * m), Vd(e, 3 * p + 1, 3 * m + 1), Vd(e, 3 * p + 2, 3 * m + 2);
                }
                m - i < c - m ? ($p(a, e, i, m), i = m + 1) : ($p(a, e, m + 1, c), c = m);
            } }
            function Vd(a, e, i) { const c = a[e]; a[e] = a[i], a[i] = c; }
            Nt(Hu, "FeaturePositionMap");
            class Aa {
                constructor(e) { this.gl = e.gl, this.initialized = !1; }
                fetchUniformLocation(e, i) { return this.location || this.initialized || (this.location = this.gl.getUniformLocation(e, i), this.initialized = !0), !!this.location; }
                set(e, i, c) { throw new Error("Uniform#set() must be implemented by each concrete Uniform"); }
            }
            class Gp extends Aa {
                constructor(e) { super(e), this.current = 0; }
                set(e, i, c) { this.fetchUniformLocation(e, i) && this.current !== c && (this.current = c, this.gl.uniform1i(this.location, c)); }
            }
            class Ei extends Aa {
                constructor(e) { super(e), this.current = 0; }
                set(e, i, c) { this.fetchUniformLocation(e, i) && this.current !== c && (this.current = c, this.gl.uniform1f(this.location, c)); }
            }
            class na extends Aa {
                constructor(e) { super(e), this.current = [0, 0]; }
                set(e, i, c) { this.fetchUniformLocation(e, i) && (c[0] === this.current[0] && c[1] === this.current[1] || (this.current = c, this.gl.uniform2f(this.location, c[0], c[1]))); }
            }
            class Ud extends Aa {
                constructor(e) { super(e), this.current = [0, 0, 0]; }
                set(e, i, c) { this.fetchUniformLocation(e, i) && (c[0] === this.current[0] && c[1] === this.current[1] && c[2] === this.current[2] || (this.current = c, this.gl.uniform3f(this.location, c[0], c[1], c[2]))); }
            }
            class qp extends Aa {
                constructor(e) { super(e), this.current = [0, 0, 0, 0]; }
                set(e, i, c) { this.fetchUniformLocation(e, i) && (c[0] === this.current[0] && c[1] === this.current[1] && c[2] === this.current[2] && c[3] === this.current[3] || (this.current = c, this.gl.uniform4f(this.location, c[0], c[1], c[2], c[3]))); }
            }
            class mx extends Aa {
                constructor(e) { super(e), this.current = nn.transparent.toRenderColor(null); }
                set(e, i, c) { this.fetchUniformLocation(e, i) && (c.r === this.current.r && c.g === this.current.g && c.b === this.current.b && c.a === this.current.a || (this.current = c, this.gl.uniform4f(this.location, c.r, c.g, c.b, c.a))); }
            }
            const ST = new Float32Array(16);
            class $d extends Aa {
                constructor(e) { super(e), this.current = ST; }
                set(e, i, c) { if (this.fetchUniformLocation(e, i)) {
                    if (c[12] !== this.current[12] || c[0] !== this.current[0])
                        return this.current = c, void this.gl.uniformMatrix4fv(this.location, !1, c);
                    for (let h = 1; h < 16; h++)
                        if (c[h] !== this.current[h]) {
                            this.current = c, this.gl.uniformMatrix4fv(this.location, !1, c);
                            break;
                        }
                } }
            }
            const gx = new Float32Array(9), N_ = new Float32Array(4);
            class Fo extends Aa {
                constructor(e) { super(e), this.current = N_; }
                set(e, i, c) { if (this.fetchUniformLocation(e, i)) {
                    for (let h = 0; h < 4; h++)
                        if (c[h] !== this.current[h]) {
                            this.current = c, this.gl.uniformMatrix2fv(this.location, !1, c);
                            break;
                        }
                } }
            }
            function Gd(a) { return [fx(255 * a.r, 255 * a.g), fx(255 * a.b, 255 * a.a)]; }
            class qd {
                constructor(e, i, c, h) { this.value = e, this.uniformNames = i.map(p => `u_${p}`), this.type = c, this.context = h; }
                setUniform(e, i, c, h, p) { const m = h.constantOr(this.value); i.set(e, p, m instanceof nn ? m.toRenderColor(this.lutExpression && this.lutExpression.value === "none" ? null : this.context.lut) : m); }
                getBinding(e, i) { return this.type === "color" ? new mx(e) : new Ei(e); }
            }
            class Wu {
                constructor(e, i) { this.uniformNames = i.map(c => `u_${c}`), this.pattern = null, this.patternTransition = null, this.pixelRatio = 1; }
                setConstantPatternPositions(e, i) { this.pixelRatio = e.pixelRatio || 1, this.pattern = e.tl.concat(e.br), this.patternTransition = i ? i.tl.concat(i.br) : this.pattern; }
                setUniform(e, i, c, h, p) { let m = null; p !== "u_pattern" && p !== "u_dash" || (m = this.pattern), p === "u_pattern_b" && (m = this.patternTransition), p === "u_pixel_ratio" && (m = this.pixelRatio), m && i.set(e, p, m); }
                getBinding(e, i) { return i === "u_pattern" || i === "u_pattern_b" || i === "u_dash" ? new qp(e) : new Ei(e); }
            }
            class tl {
                constructor(e, i, c, h) { this.expression = e, this.type = c, this.maxValue = 0, this.paintVertexAttributes = i.map(p => ({ name: `a_${p}`, type: "Float32", components: c === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new h; }
                populatePaintArray(e, i, c, h, p, m, x) { const b = this.paintVertexArray.length, S = this.expression.kind === "composite" || this.expression.kind === "source" ? this.expression.evaluate(new yn(0, { brightness: m }), i, {}, p, h, x) : this.expression.kind === "constant" && this.expression.value, A = !!this.lutExpression && (this.lutExpression.kind === "composite" || this.lutExpression.kind === "source" ? this.lutExpression.evaluate(new yn(0, { brightness: m }), i, {}, p, h, x) : this.lutExpression.value) === "none"; this.paintVertexArray.resize(e), this._setPaintValue(b, e, S, A ? null : this.context.lut); }
                updatePaintArray(e, i, c, h, p, m, x) { const b = this.expression.kind === "composite" || this.expression.kind === "source" ? this.expression.evaluate({ zoom: 0, brightness: x }, c, h, void 0, p) : this.expression.kind === "constant" && this.expression.value, S = !!this.lutExpression && (this.lutExpression.kind === "composite" || this.lutExpression.kind === "source" ? this.lutExpression.evaluate(new yn(0, { brightness: x }), c, h, void 0, p) : this.lutExpression.value) === "none"; this._setPaintValue(e, i, b, S ? null : this.context.lut); }
                _setPaintValue(e, i, c, h) { if (this.type === "color") {
                    const p = Gd(c.toRenderColor(h));
                    for (let m = e; m < i; m++)
                        this.paintVertexArray.emplace(m, p[0], p[1]);
                }
                else {
                    for (let p = e; p < i; p++)
                        this.paintVertexArray.emplace(p, c);
                    this.maxValue = Math.max(this.maxValue, Math.abs(c));
                } }
                upload(e) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.lutExpression && this.lutExpression.kind !== "constant" && (this.lutExpression.isStateDependent || !this.lutExpression.isLightConstant) || this.expression.kind !== "constant" && (this.expression.isStateDependent || !this.expression.isLightConstant))); }
                destroy() { this.paintVertexBuffer && this.paintVertexBuffer.destroy(); }
            }
            class ia {
                constructor(e, i, c, h, p, m) { this.expression = e, this.uniformNames = i.map(x => `u_${x}_t`), this.type = c, this.useIntegerZoom = h, this.context = p, this.maxValue = 0, this.paintVertexAttributes = i.map(x => ({ name: `a_${x}`, type: "Float32", components: c === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new m; }
                populatePaintArray(e, i, c, h, p, m, x) { const b = this.expression.evaluate(new yn(this.context.zoom, { brightness: m }), i, {}, p, h, x), S = this.expression.evaluate(new yn(this.context.zoom + 1, { brightness: m }), i, {}, p, h, x), A = !!this.lutExpression && (this.lutExpression.kind === "composite" || this.lutExpression.kind === "source" ? this.lutExpression.evaluate(new yn(0, { brightness: m }), i, {}, p, h, x) : this.lutExpression.value) === "none", I = this.paintVertexArray.length; this.paintVertexArray.resize(e), this._setPaintValue(I, e, b, S, A ? null : this.context.lut); }
                updatePaintArray(e, i, c, h, p, m, x) { const b = this.expression.evaluate({ zoom: this.context.zoom, brightness: x }, c, h, void 0, p), S = this.expression.evaluate({ zoom: this.context.zoom + 1, brightness: x }, c, h, void 0, p), A = !!this.lutExpression && (this.lutExpression.kind === "composite" || this.lutExpression.kind === "source" ? this.lutExpression.evaluate(new yn(0, { brightness: x }), c, h, void 0, p) : this.lutExpression.value) === "none"; this._setPaintValue(e, i, b, S, A ? null : this.context.lut); }
                _setPaintValue(e, i, c, h, p) { if (this.type === "color") {
                    const m = Gd(c.toRenderColor(p)), x = Gd(c.toRenderColor(p));
                    for (let b = e; b < i; b++)
                        this.paintVertexArray.emplace(b, m[0], m[1], x[0], x[1]);
                }
                else {
                    for (let m = e; m < i; m++)
                        this.paintVertexArray.emplace(m, c, h);
                    this.maxValue = Math.max(this.maxValue, Math.abs(c), Math.abs(h));
                } }
                upload(e) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant)); }
                destroy() { this.paintVertexBuffer && this.paintVertexBuffer.destroy(); }
                setUniform(e, i, c, h, p) { const m = this.useIntegerZoom ? Math.floor(c.zoom) : c.zoom, x = ke(this.expression.interpolationFactor(m, this.context.zoom, this.context.zoom + 1), 0, 1); i.set(e, p, x); }
                getBinding(e, i) { return new Ei(e); }
            }
            class sa {
                constructor(e, i, c, h, p) { this.expression = e, this.layerId = p, this.paintVertexAttributes = (c === "array" ? TT : bT).members; for (let m = 0; m < i.length; ++m)
                    ; this.paintVertexArray = new h, this.paintTransitionVertexArray = new el; }
                populatePaintArray(e, i, c, h) { const p = this.paintVertexArray.length; this.paintVertexArray.resize(e), this._setPaintValues(p, e, i.patterns && i.patterns[this.layerId], c); }
                updatePaintArray(e, i, c, h, p, m, x) { this._setPaintValues(e, i, c.patterns && c.patterns[this.layerId], m); }
                _setPaintValues(e, i, c, h) { if (!h || !c)
                    return; const p = h[c[0]], m = h[c[1]]; if (p) {
                    if (p) {
                        const { tl: x, br: b, pixelRatio: S } = p;
                        for (let A = e; A < i; A++)
                            this.paintVertexArray.emplace(A, x[0], x[1], b[0], b[1], S);
                    }
                    if (m) {
                        this.paintTransitionVertexArray.resize(this.paintVertexArray.length);
                        const { tl: x, br: b, pixelRatio: S } = m;
                        for (let A = e; A < i; A++)
                            this.paintTransitionVertexArray.emplace(A, x[0], x[1], b[0], b[1], S);
                    }
                } }
                upload(e) { const i = this.expression.isStateDependent || !this.expression.isLightConstant; this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, i)), this.paintTransitionVertexArray && this.paintTransitionVertexArray.length && (this.paintTransitionVertexBuffer = e.createVertexBuffer(this.paintTransitionVertexArray, qu.members, i)); }
                destroy() { this.paintVertexBuffer && this.paintVertexBuffer.destroy(), this.paintTransitionVertexBuffer && this.paintTransitionVertexBuffer.destroy(); }
            }
            class $l {
                constructor(e, i, c = () => !0) { this.binders = {}, this._buffers = [], this.context = i; const h = []; for (const p in e.paint._values) {
                    const m = e.paint.get(p);
                    if (p.endsWith("-use-theme") || !c(p) || !(m instanceof Bu && Tp(m.property.specification)))
                        continue;
                    const x = n(p, e.type), b = m.value, S = m.property.specification.type, A = !!m.property.useIntegerZoom, I = p === "line-dasharray" || p.endsWith("pattern"), M = e.paint.get(`${p}-use-theme`), z = p === "line-dasharray" && e.layout.get("line-cap").value.kind !== "constant" || M && M.value.kind !== "constant";
                    if (b.kind !== "constant" || z)
                        if (b.kind === "source" || z || I) {
                            const F = _(p, S, "source");
                            this.binders[p] = I ? new sa(b, x, S, F, e.id) : new tl(b, x, S, F), h.push(`/a_${p}`);
                        }
                        else {
                            const F = _(p, S, "composite");
                            this.binders[p] = new ia(b, x, S, A, i, F), h.push(`/z_${p}`);
                        }
                    else
                        this.binders[p] = I ? new Wu(b.value, x) : new qd(b.value, x, S, i), h.push(`/u_${p}`);
                    M && (this.binders[p].lutExpression = M.value);
                } this.cacheKey = h.sort().join(""); }
                getMaxValue(e) { const i = this.binders[e]; return i instanceof tl || i instanceof ia ? i.maxValue : 0; }
                populatePaintArrays(e, i, c, h, p, m, x) { for (const b in this.binders) {
                    const S = this.binders[b];
                    S.context = this.context, (S instanceof tl || S instanceof ia || S instanceof sa) && S.populatePaintArray(e, i, c, h, p, m, x);
                } }
                setConstantPatternPositions(e, i) { for (const c in this.binders) {
                    const h = this.binders[c];
                    h instanceof Wu && h.setConstantPatternPositions(e, i);
                } }
                getPatternTransitionVertexBuffer(e) { const i = this.binders[e]; return i instanceof sa ? i.paintTransitionVertexBuffer : null; }
                updatePaintArrays(e, i, c, h, p, m, x, b, S) { let A = !1; const I = Object.keys(e), M = I.length !== 0 && !b, z = M ? I : i.uniqueIds; this.context.lut = p.lut; for (const F in this.binders) {
                    const U = this.binders[F];
                    if (U.context = this.context, (U instanceof tl || U instanceof ia || U instanceof sa) && U.expression && U.expression.kind && U.expression.kind !== "constant" && (U.expression.isStateDependent === !0 || U.expression.isLightConstant === !1)) {
                        const X = p.paint.get(F);
                        U.expression = X.value;
                        for (const Y of z) {
                            const le = e[Y.toString()];
                            i.eachPosition(Y, (se, $, te) => { const ae = h.feature(se); U.updatePaintArray($, te, ae, le, m, x, S); });
                        }
                        if (!M)
                            for (const Y of c.uniqueIds) {
                                const le = e[Y.toString()];
                                c.eachPosition(Y, (se, $, te) => { const ae = h.feature(se); U.updatePaintArray($, te, ae, le, m, x, S); });
                            }
                        A = !0;
                    }
                } return A; }
                defines() { const e = []; for (const i in this.binders) {
                    const c = this.binders[i];
                    (c instanceof qd || c instanceof Wu) && e.push(...c.uniformNames.map(h => `#define HAS_UNIFORM_${h}`));
                } return e; }
                getBinderAttributes() { const e = []; for (const i in this.binders) {
                    const c = this.binders[i];
                    if (c instanceof tl || c instanceof ia || c instanceof sa)
                        for (let h = 0; h < c.paintVertexAttributes.length; h++)
                            e.push(c.paintVertexAttributes[h].name);
                    if (c instanceof sa)
                        for (let h = 0; h < qu.members.length; h++)
                            e.push(qu.members[h].name);
                } return e; }
                getBinderUniforms() { const e = []; for (const i in this.binders) {
                    const c = this.binders[i];
                    if (c instanceof qd || c instanceof Wu || c instanceof ia)
                        for (const h of c.uniformNames)
                            e.push(h);
                } return e; }
                getPaintVertexBuffers() { return this._buffers; }
                getUniforms(e) { const i = []; for (const c in this.binders) {
                    const h = this.binders[c];
                    if (h instanceof qd || h instanceof Wu || h instanceof ia)
                        for (const p of h.uniformNames)
                            i.push({ name: p, property: c, binding: h.getBinding(e, p) });
                } return i; }
                setUniforms(e, i, c, h, p) { for (const { name: m, property: x, binding: b } of c)
                    this.binders[x].setUniform(e, b, p, h.get(x), m); }
                updatePaintBuffers() { this._buffers = []; for (const e in this.binders) {
                    const i = this.binders[e];
                    (i instanceof tl || i instanceof ia || i instanceof sa) && i.paintVertexBuffer && this._buffers.push(i.paintVertexBuffer), i instanceof sa && i.paintTransitionVertexBuffer && this._buffers.push(i.paintTransitionVertexBuffer);
                } }
                upload(e) { for (const i in this.binders) {
                    const c = this.binders[i];
                    (c instanceof tl || c instanceof ia || c instanceof sa) && c.upload(e);
                } this.updatePaintBuffers(); }
                destroy() { for (const e in this.binders) {
                    const i = this.binders[e];
                    (i instanceof tl || i instanceof ia || i instanceof sa) && i.destroy();
                } }
            }
            class Uc {
                constructor(e, i, c = () => !0) { this.programConfigurations = {}; for (const h of e)
                    this.programConfigurations[h.id] = new $l(h, i, c); this.needsUpload = !1, this._featureMap = new Hu, this._featureMapWithoutIds = new Hu, this._bufferOffset = 0, this._idlessCounter = 0; }
                populatePaintArrays(e, i, c, h, p, m, x, b) { for (const S in this.programConfigurations)
                    this.programConfigurations[S].populatePaintArrays(e, i, h, p, m, x, b); i.id !== void 0 ? this._featureMap.add(i.id, c, this._bufferOffset, e) : (this._featureMapWithoutIds.add(this._idlessCounter, c, this._bufferOffset, e), this._idlessCounter += 1), this._bufferOffset = e, this.needsUpload = !0; }
                updatePaintArrays(e, i, c, h, p, m, x) { for (const b of c)
                    this.needsUpload = this.programConfigurations[b.id].updatePaintArrays(e, this._featureMap, this._featureMapWithoutIds, i, b, h, p, m, x || 0) || this.needsUpload; }
                get(e) { return this.programConfigurations[e]; }
                upload(e) { if (this.needsUpload) {
                    for (const i in this.programConfigurations)
                        this.programConfigurations[i].upload(e);
                    this.needsUpload = !1;
                } }
                destroy() { for (const e in this.programConfigurations)
                    this.programConfigurations[e].destroy(); }
            }
            const d = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-occlusion-opacity": ["occlusion_opacity"], "icon-occlusion-opacity": ["occlusion_opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-emissive-strength": ["emissive_strength"], "icon-emissive-strength": ["emissive_strength"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "symbol-z-offset": ["z_offset"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio", "pattern_b"], "fill-pattern": ["pattern", "pixel_ratio", "pattern_b"], "fill-extrusion-pattern": ["pattern", "pixel_ratio", "pattern_b"], "line-dasharray": ["dash"] };
            function n(a, e) { return d[a] || [a.replace(`${e}-`, "").replace(/-/g, "_")]; }
            const l = { "line-pattern": { source: el, composite: el }, "fill-pattern": { source: el, composite: el }, "fill-extrusion-pattern": { source: el, composite: el }, "line-dasharray": { source: Np, composite: Np } }, f = { color: { source: Vc, composite: Ca }, number: { source: Vu, composite: Vc } };
            function _(a, e, i) { const c = l[a]; return c && c[i] || f[e][i]; }
            Nt(qd, "ConstantBinder"), Nt(Wu, "PatternConstantBinder"), Nt(tl, "SourceExpressionBinder"), Nt(sa, "PatternCompositeBinder"), Nt(ia, "CompositeExpressionBinder"), Nt($l, "ProgramConfiguration", { omit: ["_buffers"] }), Nt(Uc, "ProgramConfigurationSet");
            const v = It / Math.PI / 2, w = 5, T = 6, C = 16383, P = 64, R = [P, 32, 16], O = -v, D = v;
            function B(a, e, i, c = v) { return i = Z(i), [a * Math.sin(i) * c, -e * c, a * Math.cos(i) * c]; }
            function q(a, e, i) { return B(Math.cos(Z(a)), Math.sin(Z(a)), e, i); }
            const G = 63710088e-1, K = 2 * Math.PI * G;
            class W {
                constructor(e, i) { if (isNaN(e) || isNaN(i))
                    throw new Error(`Invalid LngLat object: (${e}, ${i})`); if (this.lng = +e, this.lat = +i, this.lat > 90 || this.lat < -90)
                    throw new Error("Invalid LngLat latitude value: must be between -90 and 90"); }
                wrap() { return new W(qe(this.lng, -180, 180), this.lat); }
                toArray() { return [this.lng, this.lat]; }
                toString() { return `LngLat(${this.lng}, ${this.lat})`; }
                distanceTo(e) { const i = Math.PI / 180, c = this.lat * i, h = e.lat * i, p = Math.sin(c) * Math.sin(h) + Math.cos(c) * Math.cos(h) * Math.cos((e.lng - this.lng) * i); return G * Math.acos(Math.min(p, 1)); }
                toBounds(e = 0) { const i = 360 * e / 40075017, c = i / Math.cos(Math.PI / 180 * this.lat); return new oe({ lng: this.lng - c, lat: this.lat - i }, { lng: this.lng + c, lat: this.lat + i }); }
                toEcef(e) { return q(this.lat, this.lng, v + e * v / G); }
                static convert(e) { if (e instanceof W)
                    return e; if (Array.isArray(e) && (e.length === 2 || e.length === 3))
                    return new W(Number(e[0]), Number(e[1])); if (!Array.isArray(e) && typeof e == "object" && e !== null)
                    return new W(Number("lng" in e ? e.lng : e.lon), Number(e.lat)); throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]"); }
            }
            class oe {
                constructor(e, i) { if (e)
                    if (i)
                        this.setSouthWest(e).setNorthEast(i);
                    else if (e.length === 4) {
                        const c = e;
                        this.setSouthWest([c[0], c[1]]).setNorthEast([c[2], c[3]]);
                    }
                    else {
                        const c = e;
                        this.setSouthWest(c[0]).setNorthEast(c[1]);
                    } }
                setNorthEast(e) { return this._ne = e instanceof W ? new W(e.lng, e.lat) : W.convert(e), this; }
                setSouthWest(e) { return this._sw = e instanceof W ? new W(e.lng, e.lat) : W.convert(e), this; }
                extend(e) { const i = this._sw, c = this._ne; let h, p; if (e instanceof W)
                    h = e, p = e;
                else {
                    if (!(e instanceof oe))
                        return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(oe.convert(e)) : this.extend(W.convert(e)) : typeof e == "object" && e !== null && e.hasOwnProperty("lat") && (e.hasOwnProperty("lon") || e.hasOwnProperty("lng")) ? this.extend(W.convert(e)) : this;
                    if (h = e._sw, p = e._ne, !h || !p)
                        return this;
                } return i || c ? (i.lng = Math.min(h.lng, i.lng), i.lat = Math.min(h.lat, i.lat), c.lng = Math.max(p.lng, c.lng), c.lat = Math.max(p.lat, c.lat)) : (this._sw = new W(h.lng, h.lat), this._ne = new W(p.lng, p.lat)), this; }
                getCenter() { return new W((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2); }
                getSouthWest() { return this._sw; }
                getNorthEast() { return this._ne; }
                getNorthWest() { return new W(this.getWest(), this.getNorth()); }
                getSouthEast() { return new W(this.getEast(), this.getSouth()); }
                getWest() { return this._sw.lng; }
                getSouth() { return this._sw.lat; }
                getEast() { return this._ne.lng; }
                getNorth() { return this._ne.lat; }
                toArray() { return [this._sw.toArray(), this._ne.toArray()]; }
                toString() { return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`; }
                isEmpty() { return !(this._sw && this._ne); }
                contains(e) { const { lng: i, lat: c } = W.convert(e); let h = this._sw.lng <= i && i <= this._ne.lng; return this._sw.lng > this._ne.lng && (h = this._sw.lng >= i && i >= this._ne.lng), this._sw.lat <= c && c <= this._ne.lat && h; }
                static convert(e) { if (e)
                    return e instanceof oe ? e : new oe(e); }
            }
            const de = 0, me = 25.5;
            function we(a) { return K * Math.cos(a * Math.PI / 180); }
            function ve(a) { return (180 + a) / 360; }
            function xe(a) { return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a * Math.PI / 360))) / 360; }
            function ge(a, e) { return a / we(e); }
            function Se(a) { return 360 * a - 180; }
            function Ce(a) { return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90; }
            function je(a, e) { return a * we(Ce(e)); }
            const ze = 85.051129;
            function rt(a) { return Math.cos(Z(ke(a, -ze, ze))); }
            function et(a, e) { const i = ke(e, de, me), c = Math.pow(2, i); return rt(a) * K / (512 * c); }
            function vt(a) { return 1 / Math.cos(a * Math.PI / 180); }
            function Fe(a, e = 0) { const i = Math.exp(Math.PI * (1 - (a.y + e / It) / (1 << a.z) * 2)); return 80150034 * i / (i * i + 1) / It / (1 << a.z); }
            class Ve {
                constructor(e, i, c = 0) { this.x = +e, this.y = +i, this.z = +c; }
                static fromLngLat(e, i = 0) { const c = W.convert(e); return new Ve(ve(c.lng), xe(c.lat), ge(i, c.lat)); }
                toLngLat() { return new W(Se(this.x), Ce(this.y)); }
                toAltitude() { return je(this.z, this.y); }
                meterInMercatorCoordinateUnits() { return 1 / K * vt(Ce(this.y)); }
            }
            function Le(a, e, i, c, h, p, m, x, b) { const S = (e + c) / 2, A = (i + h) / 2, I = new Et(S, A); x(I), function (M, z, F, U, X, Y) { const le = F - X, se = U - Y; return Math.abs((U - z) * le - (F - M) * se) / Math.hypot(le, se); }(I.x, I.y, p.x, p.y, m.x, m.y) >= b ? (Le(a, e, i, S, A, p, I, x, b), Le(a, S, A, c, h, I, m, x, b)) : a.push(m); }
            function st(a, e, i) { let c = a[0], h = c.x, p = c.y; e(c); const m = [c]; for (let x = 1; x < a.length; x++) {
                const b = a[x], { x: S, y: A } = b;
                e(b), Le(m, h, p, S, A, c, b, e, i), h = S, p = A, c = b;
            } return m; }
            function He(a, e, i, c) { if (c(e, i)) {
                const h = e.add(i)._mult(.5);
                He(a, e, h, c), He(a, h, i, c);
            }
            else
                a.push(i); }
            function ht(a, e) { let i = a[0]; const c = [i]; for (let h = 1; h < a.length; h++) {
                const p = a[h];
                He(c, i, p, e), i = p;
            } return c; }
            const nt = Math.pow(2, 14) - 1, dt = -nt - 1;
            function ft(a, e) { const i = Math.round(a.x * e), c = Math.round(a.y * e); return a.x = ke(i, dt, nt), a.y = ke(c, dt, nt), (i < a.x || i > a.x + 1 || c < a.y || c > a.y + 1) && Br("Geometry exceeds allowed extent, reduce your vector tile buffer size"), a; }
            function Vt(a, e, i) { const c = a.loadGeometry(), h = a.extent, p = It / h; if (e && i && i.projection.isReprojectedInTileSpace) {
                const m = 1 << e.z, { scale: x, x: b, y: S, projection: A } = i, I = M => { const z = Se((e.x + M.x / h) / m), F = Ce((e.y + M.y / h) / m), U = A.project(z, F); M.x = (U.x * x - b) * h, M.y = (U.y * x - S) * h; };
                for (let M = 0; M < c.length; M++)
                    if (a.type !== 1)
                        c[M] = st(c[M], I, 1);
                    else {
                        const z = [];
                        for (const F of c[M])
                            F.x < 0 || F.x >= h || F.y < 0 || F.y >= h || (I(F), z.push(F));
                        c[M] = z;
                    }
            } for (const m of c)
                for (const x of m)
                    ft(x, p); return c; }
            function Xt(a, e) { return { type: a.type, id: a.id, properties: a.properties, geometry: e ? Vt(a) : [] }; }
            function Bt(a, e, i, c, h) { a.emplaceBack(2 * e + (c + 1) / 2, 2 * i + (h + 1) / 2); }
            function Yt(a, e, i) { a.emplaceBack(e.x, e.y, e.z, i[0] * 16384, i[1] * 16384, i[2] * 16384); }
            class $t {
                constructor(e) { this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(i => i.fqid), this.index = e.index, this.hasPattern = !1, this.projection = e.projection, this.layoutVertexArray = new Ja, this.indexArray = new Hi, this.segments = new ti, this.programConfigurations = new Uc(e.layers, { zoom: e.zoom, lut: e.lut }), this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id); }
                updateFootprints(e, i) { }
                populate(e, i, c, h) { const p = this.layers[0], m = []; let x = null; p.type === "circle" && (x = p.layout.get("circle-sort-key")); for (const { feature: S, id: A, index: I, sourceLayerIndex: M } of e) {
                    const z = this.layers[0]._featureFilter.needGeometry, F = Xt(S, z);
                    if (!this.layers[0]._featureFilter.filter(new yn(this.zoom), F, c))
                        continue;
                    const U = x ? x.evaluate(F, {}, c) : void 0, X = { id: A, properties: S.properties, type: S.type, sourceLayerIndex: M, index: I, geometry: z ? F.geometry : Vt(S, c, h), patterns: {}, sortKey: U };
                    m.push(X);
                } x && m.sort((S, A) => S.sortKey - A.sortKey); let b = null; h.projection.name === "globe" && (this.globeExtVertexArray = new jc, b = h.projection); for (const S of m) {
                    const { geometry: A, index: I, sourceLayerIndex: M } = S, z = e[I].feature;
                    this.addFeature(S, A, I, i.availableImages, c, b, i.brightness), i.featureIndex.insert(z, A, I, M, this.index);
                } }
                update(e, i, c, h, p, m, x) { this.programConfigurations.updatePaintArrays(e, i, p, c, h, m, x); }
                isEmpty() { return this.layoutVertexArray.length === 0; }
                uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload; }
                upload(e) { this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, xT.members), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, wT.members))), this.programConfigurations.upload(e), this.uploaded = !0; }
                destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy()); }
                addFeature(e, i, c, h, p, m, x) { for (const b of i)
                    for (const S of b) {
                        const A = S.x, I = S.y;
                        if (A < 0 || A >= It || I < 0 || I >= It)
                            continue;
                        if (m) {
                            const F = m.projectTilePoint(A, I, p), U = m.upVector(p, A, I), X = this.globeExtVertexArray;
                            Yt(X, F, U), Yt(X, F, U), Yt(X, F, U), Yt(X, F, U);
                        }
                        const M = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey), z = M.vertexLength;
                        Bt(this.layoutVertexArray, A, I, -1, -1), Bt(this.layoutVertexArray, A, I, 1, -1), Bt(this.layoutVertexArray, A, I, 1, 1), Bt(this.layoutVertexArray, A, I, -1, 1), this.indexArray.emplaceBack(z, z + 1, z + 2), this.indexArray.emplaceBack(z, z + 2, z + 3), M.vertexLength += 4, M.primitiveLength += 2;
                    } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, c, {}, h, p, x); }
            }
            function or(a, e) { for (let i = 0; i < a.length; i++)
                if (xn(e, a[i]))
                    return !0; for (let i = 0; i < e.length; i++)
                if (xn(a, e[i]))
                    return !0; return !!fn(a, e); }
            function mr(a, e, i) { return !!xn(a, e) || !!xr(e, a, i); }
            function Nr(a, e) { if (a.length === 1)
                return Qr(e, a[0]); for (let i = 0; i < e.length; i++) {
                const c = e[i];
                for (let h = 0; h < c.length; h++)
                    if (xn(a, c[h]))
                        return !0;
            } for (let i = 0; i < a.length; i++)
                if (Qr(e, a[i]))
                    return !0; for (let i = 0; i < e.length; i++)
                if (fn(a, e[i]))
                    return !0; return !1; }
            function vn(a, e, i) { if (a.length > 1) {
                if (fn(a, e))
                    return !0;
                for (let c = 0; c < e.length; c++)
                    if (xr(e[c], a, i))
                        return !0;
            } for (let c = 0; c < a.length; c++)
                if (xr(a[c], e, i))
                    return !0; return !1; }
            function fn(a, e) { if (a.length === 0 || e.length === 0)
                return !1; for (let i = 0; i < a.length - 1; i++) {
                const c = a[i], h = a[i + 1];
                for (let p = 0; p < e.length - 1; p++)
                    if (jr(c, h, e[p], e[p + 1]))
                        return !0;
            } return !1; }
            function jr(a, e, i, c) { return An(a, i, c) !== An(e, i, c) && An(a, e, i) !== An(a, e, c); }
            function hi(a, e, i) { return (a.x - i.x) * (e.y - i.y) - (a.y - i.y) * (e.x - i.x); }
            function Jn(a, e, i, c) { const h = hi(a, e, c), p = hi(a, e, i); if (Math.sign(h) === Math.sign(p))
                return; const m = hi(i, c, a), x = m + p - h; return Math.sign(m) !== Math.sign(x) ? [m / (m - x), p / (p - h)] : void 0; }
            function xr(a, e, i) { const c = i * i; if (e.length === 1)
                return a.distSqr(e[0]) < c; for (let h = 1; h < e.length; h++)
                if (Hr(a, e[h - 1], e[h]) < c)
                    return !0; return !1; }
            function Hr(a, e, i) { const c = e.distSqr(i); if (c === 0)
                return a.distSqr(e); const h = ((a.x - e.x) * (i.x - e.x) + (a.y - e.y) * (i.y - e.y)) / c; return a.distSqr(h < 0 ? e : h > 1 ? i : i.sub(e)._mult(h)._add(e)); }
            function Qr(a, e) { let i, c, h, p = !1; for (let m = 0; m < a.length; m++) {
                i = a[m];
                for (let x = 0, b = i.length - 1; x < i.length; b = x++)
                    c = i[x], h = i[b], c.y > e.y != h.y > e.y && e.x < (h.x - c.x) * (e.y - c.y) / (h.y - c.y) + c.x && (p = !p);
            } return p; }
            function xn(a, e) { let i = !1; for (let c = 0, h = a.length - 1; c < a.length; h = c++) {
                const p = a[c], m = a[h];
                p.y > e.y != m.y > e.y && e.x < (m.x - p.x) * (e.y - p.y) / (m.y - p.y) + p.x && (i = !i);
            } return i; }
            function Ii(a, e, i, c, h) { for (const m of a)
                if (e <= m.x && i <= m.y && c >= m.x && h >= m.y)
                    return !0; const p = [new Et(e, i), new Et(e, h), new Et(c, h), new Et(c, i)]; if (a.length > 2) {
                for (const m of p)
                    if (xn(a, m))
                        return !0;
            } for (let m = 0; m < a.length - 1; m++)
                if (_i(a[m], a[m + 1], p))
                    return !0; return !1; }
            function _i(a, e, i) { const c = i[0], h = i[2]; if (a.x < c.x && e.x < c.x || a.x > h.x && e.x > h.x || a.y < c.y && e.y < c.y || a.y > h.y && e.y > h.y)
                return !1; const p = An(a, e, i[0]); return p !== An(a, e, i[1]) || p !== An(a, e, i[2]) || p !== An(a, e, i[3]); }
            function Ci(a, e, i, c, h, p) { let m = e.y - a.y, x = a.x - e.x; if (p = p || 0) {
                const b = m * m + x * x;
                if (b === 0)
                    return !0;
                const S = Math.sqrt(b);
                m /= S, x /= S;
            } return !((i.x - a.x) * m + (i.y - a.y) * x - p < 0 || (c.x - a.x) * m + (c.y - a.y) * x - p < 0 || (h.x - a.x) * m + (h.y - a.y) * x - p < 0); }
            function Kn(a, e, i, c, h, p, m) { return !(Ci(a, e, c, h, p, m) || Ci(e, i, c, h, p, m) || Ci(i, a, c, h, p, m) || Ci(c, h, a, e, i, m) || Ci(h, p, a, e, i, m) || Ci(p, c, a, e, i, m)); }
            function Cr(a, e, i) { const c = e.paint.get(a).value; return c.kind === "constant" ? c.value : i.programConfigurations.get(e.id).getMaxValue(a); }
            function qn(a) { return Math.sqrt(a[0] * a[0] + a[1] * a[1]); }
            function Xr(a, e, i, c, h) { if (!e[0] && !e[1])
                return a; const p = Et.convert(e)._mult(h); i === "viewport" && p._rotate(-c); const m = []; for (let x = 0; x < a.length; x++)
                m.push(a[x].sub(p)); return m; }
            function Hn(a, e, i, c) { const h = Et.convert(a)._mult(c); return e === "viewport" && h._rotate(-i), h; }
            let sn, Yn;
            function Wi(a, e, i) { var c = 2 * Math.PI * 6378137 / 256 / Math.pow(2, i); return [a * c - 2 * Math.PI * 6378137 / 2, e * c - 2 * Math.PI * 6378137 / 2]; }
            Nt($t, "CircleBucket", { omit: ["layers"] });
            class Ln {
                constructor(e, i, c) { this.z = e, this.x = i, this.y = c, this.key = as(0, e, e, i, c); }
                equals(e) { return this.z === e.z && this.x === e.x && this.y === e.y; }
                url(e, i) { const c = function (p, m, x) { var b = Wi(256 * p, 256 * (m = Math.pow(2, x) - m - 1), x), S = Wi(256 * (p + 1), 256 * (m + 1), x); return b[0] + "," + b[1] + "," + S[0] + "," + S[1]; }(this.x, this.y, this.z), h = function (p, m, x) { let b, S = ""; for (let A = p; A > 0; A--)
                    b = 1 << A - 1, S += (m & b ? 1 : 0) + (x & b ? 2 : 0); return S; }(this.z, this.x, this.y); return e[(this.x + this.y) % e.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(i === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", h).replace("{bbox-epsg-3857}", c); }
                toString() { return `${this.z}/${this.x}/${this.y}`; }
            }
            class es {
                constructor(e, i) { this.wrap = e, this.canonical = i, this.key = as(e, i.z, i.z, i.x, i.y); }
            }
            class wi {
                constructor(e, i, c, h, p) { this.overscaledZ = e, this.wrap = i, this.canonical = new Ln(c, +h, +p), this.key = i === 0 && e === c ? this.canonical.key : as(i, e, c, h, p); }
                equals(e) { return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical); }
                scaledTo(e) { const i = this.canonical.z - e; return e > this.canonical.z ? new wi(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new wi(e, this.wrap, e, this.canonical.x >> i, this.canonical.y >> i); }
                calculateScaledKey(e, i = !0) { if (this.overscaledZ === e && i)
                    return this.key; if (e > this.canonical.z)
                    return as(this.wrap * +i, e, this.canonical.z, this.canonical.x, this.canonical.y); {
                    const c = this.canonical.z - e;
                    return as(this.wrap * +i, e, e, this.canonical.x >> c, this.canonical.y >> c);
                } }
                isChildOf(e) { if (e.wrap !== this.wrap)
                    return !1; const i = this.canonical.z - e.canonical.z; return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.z < this.canonical.z && e.canonical.x === this.canonical.x >> i && e.canonical.y === this.canonical.y >> i; }
                children(e) { if (this.overscaledZ >= e)
                    return [new wi(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)]; const i = this.canonical.z + 1, c = 2 * this.canonical.x, h = 2 * this.canonical.y; return [new wi(i, this.wrap, i, c, h), new wi(i, this.wrap, i, c + 1, h), new wi(i, this.wrap, i, c, h + 1), new wi(i, this.wrap, i, c + 1, h + 1)]; }
                isLessThan(e) { return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y)); }
                wrapped() { return new wi(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y); }
                unwrapTo(e) { return new wi(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y); }
                overscaleFactor() { return Math.pow(2, this.overscaledZ - this.canonical.z); }
                toUnwrapped() { return new es(this.wrap, this.canonical); }
                toString() { return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`; }
            }
            function as(a, e, i, c, h) { const p = 1 << Math.min(i, 22); let m = p * (h % p) + c % p; return a && i < 22 && (m += p * p * ((a < 0 ? -2 * a - 1 : 2 * a) % (1 << 2 * (22 - i)))), 16 * (32 * m + i) + (e - i); }
            const oa = [a => { let e = a.canonical.x - 1, i = a.wrap; return e < 0 && (e = (1 << a.canonical.z) - 1, i--), new wi(a.overscaledZ, i, a.canonical.z, e, a.canonical.y); }, a => { let e = a.canonical.x + 1, i = a.wrap; return e === 1 << a.canonical.z && (e = 0, i++), new wi(a.overscaledZ, i, a.canonical.z, e, a.canonical.y); }, a => new wi(a.overscaledZ, a.wrap, a.canonical.z, a.canonical.x, (a.canonical.y === 0 ? 1 << a.canonical.z : a.canonical.y) - 1), a => new wi(a.overscaledZ, a.wrap, a.canonical.z, a.canonical.x, a.canonical.y === (1 << a.canonical.z) - 1 ? 0 : a.canonical.y + 1)];
            Nt(Ln, "CanonicalTileID"), Nt(wi, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
            const rl = tn([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: ro } = rl, No = tn([{ name: "a_pos_3", components: 3, type: "Int16" }]);
            var Ia = tn([{ name: "a_pos", type: "Int16", components: 2 }]);
            class Pa {
                constructor(e, i) { this.pos = e, this.dir = i; }
                intersectsPlane(e, i, c) { const h = jn(i, this.dir); if (Math.abs(h) < 1e-6)
                    return !1; const p = ((e[0] - this.pos[0]) * i[0] + (e[1] - this.pos[1]) * i[1]) / h; return c[0] = this.pos[0] + this.dir[0] * p, c[1] = this.pos[1] + this.dir[1] * p, !0; }
            }
            class aa {
                constructor(e, i) { this.pos = e, this.dir = i; }
                intersectsPlane(e, i, c) { const h = Kr(i, this.dir); if (Math.abs(h) < 1e-6)
                    return !1; const p = ((e[0] - this.pos[0]) * i[0] + (e[1] - this.pos[1]) * i[1] + (e[2] - this.pos[2]) * i[2]) / h; return c[0] = this.pos[0] + this.dir[0] * p, c[1] = this.pos[1] + this.dir[1] * p, c[2] = this.pos[2] + this.dir[2] * p, !0; }
                closestPointOnSphere(e, i, c) { if (function (z, F) { var U = z[0], X = z[1], Y = z[2], le = F[0], se = F[1], $ = F[2]; return Math.abs(U - le) <= k * Math.max(1, Math.abs(U), Math.abs(le)) && Math.abs(X - se) <= k * Math.max(1, Math.abs(X), Math.abs(se)) && Math.abs(Y - $) <= k * Math.max(1, Math.abs(Y), Math.abs($)); }(this.pos, e) || i === 0)
                    return c[0] = c[1] = c[2] = 0, !1; const [h, p, m] = this.dir, x = this.pos[0] - e[0], b = this.pos[1] - e[1], S = this.pos[2] - e[2], A = h * h + p * p + m * m, I = 2 * (x * h + b * p + S * m), M = I * I - 4 * A * (x * x + b * b + S * S - i * i); if (M < 0) {
                    const z = Math.max(-I / 2, 0), F = x + h * z, U = b + p * z, X = S + m * z, Y = Math.hypot(F, U, X);
                    return c[0] = F * i / Y, c[1] = U * i / Y, c[2] = X * i / Y, !1;
                } {
                    const z = (-I - Math.sqrt(M)) / (2 * A);
                    if (z < 0) {
                        const F = Math.hypot(x, b, S);
                        return c[0] = x * i / F, c[1] = b * i / F, c[2] = S * i / F, !1;
                    }
                    return c[0] = x + h * z, c[1] = b + p * z, c[2] = S + m * z, !0;
                } }
            }
            class Zu {
                constructor(e, i, c, h, p) { this.TL = e, this.TR = i, this.BR = c, this.BL = h, this.horizon = p; }
                static fromInvProjectionMatrix(e, i, c) { const h = [-1, 1, 1], p = [1, 1, 1], m = [1, -1, 1], x = [-1, -1, 1], b = ln(h, h, e), S = ln(p, p, e), A = ln(m, m, e), I = ln(x, x, e); return new Zu(b, S, A, I, i / c); }
            }
            function $c(a, e, i) { let c = 1 / 0, h = -1 / 0; const p = []; for (const m of a) {
                Gn(p, m, e);
                const x = Kr(p, i);
                c = Math.min(c, x), h = Math.max(h, x);
            } return [c, h]; }
            function Hp(a, e) { let i = !0; for (let c = 0; c < a.planes.length; c++) {
                const h = a.planes[c];
                let p = 0;
                for (let m = 0; m < e.length; m++)
                    p += Kr(h, e[m]) + h[3] >= 0;
                if (p === 0)
                    return 0;
                p !== e.length && (i = !1);
            } return i ? 2 : 1; }
            function Wp(a, e) { for (const i of a.projections) {
                const c = $c(e, a.points[0], i.axis);
                if (i.projection[1] < c[0] || i.projection[0] > c[1])
                    return 0;
            } return 1; }
            function Zp(a, e) { let i = 0; const c = [0, 0, 0, 0]; for (let m = 0; m < a.length; m++)
                c[0] = a[m][0], c[1] = a[m][1], c[2] = a[m][2], c[3] = 1, (h = c)[0] * (p = e)[0] + h[1] * p[1] + h[2] * p[2] + h[3] * p[3] >= 0 && i++; var h, p; return i; }
            class Hd {
                constructor(e, i) { this.points = e || new Array(8).fill([0, 0, 0]), this.planes = i || new Array(6).fill([0, 0, 0, 0]), this.bounds = Wn.fromPoints(this.points), this.projections = [], this.frustumEdges = [Gn([], this.points[2], this.points[3]), Gn([], this.points[0], this.points[3]), Gn([], this.points[4], this.points[0]), Gn([], this.points[5], this.points[1]), Gn([], this.points[6], this.points[2]), Gn([], this.points[7], this.points[3])]; for (const c of this.frustumEdges) {
                    const h = [0, -c[2], c[1]], p = [c[2], 0, -c[0]];
                    this.projections.push({ axis: h, projection: $c(this.points, this.points[0], h) }), this.projections.push({ axis: p, projection: $c(this.points, this.points[0], p) });
                } }
                static fromInvProjectionMatrix(e, i, c, h) { const p = Math.pow(2, c), m = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(S => { const A = Gi([], S, e), I = 1 / A[3] / i * p; return (M = A)[0] = (z = A)[0] * (F = [I, I, h ? 1 / A[3] : I, I])[0], M[1] = z[1] * F[1], M[2] = z[2] * F[2], M[3] = z[3] * F[3], M; var M, z, F; }), x = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(S => { const A = an([], mn([], Gn([], m[S[0]], m[S[1]]), Gn([], m[S[2]], m[S[1]]))), I = -Kr(A, m[S[1]]); return A.concat(I); }), b = []; for (let S = 0; S < m.length; S++)
                    b.push([m[S][0], m[S][1], m[S][2]]); return new Hd(b, x); }
                intersectsPrecise(e, i, c) { for (let h = 0; h < i.length; h++)
                    if (!Zp(e, i[h]))
                        return 0; for (let h = 0; h < this.planes.length; h++)
                    if (!Zp(e, this.planes[h]))
                        return 0; for (const h of c)
                    for (const p of this.frustumEdges) {
                        const m = mn([], h, p), x = Kt(m);
                        if (x === 0)
                            continue;
                        Ft(m, m, 1 / x);
                        const b = $c(this.points, this.points[0], m), S = $c(e, this.points[0], m);
                        if (b[0] > S[1] || S[0] > b[1])
                            return 0;
                    } return 1; }
                containsPoint(e) { for (const i of this.planes) {
                    const c = i[3];
                    if (Kr([i[0], i[1], i[2]], e) + c < 0)
                        return !1;
                } return !0; }
            }
            class Wn {
                static fromPoints(e) { const i = [1 / 0, 1 / 0, 1 / 0], c = [-1 / 0, -1 / 0, -1 / 0]; for (const h of e)
                    xt(i, i, h), Pt(c, c, h); return new Wn(i, c); }
                static fromTileIdAndHeight(e, i, c) { const h = 1 << e.canonical.z, p = e.canonical.x, m = e.canonical.y; return new Wn([p / h, m / h, i], [(p + 1) / h, (m + 1) / h, c]); }
                static applyTransform(e, i) { const c = e.getCorners(); for (let h = 0; h < c.length; ++h)
                    ln(c[h], c[h], i); return Wn.fromPoints(c); }
                static applyTransformFast(e, i) { const c = [i[12], i[13], i[14]], h = [...c]; for (let p = 0; p < 3; p++)
                    for (let m = 0; m < 3; m++) {
                        const x = i[4 * m + p], b = x * e.min[m], S = x * e.max[m];
                        c[p] += Math.min(b, S), h[p] += Math.max(b, S);
                    } return new Wn(c, h); }
                static projectAabbCorners(e, i) { const c = e.getCorners(); for (let h = 0; h < c.length; ++h)
                    ln(c[h], c[h], i); return c; }
                constructor(e, i) { this.min = e, this.max = i, this.center = Ft([], ir([], this.min, this.max), .5); }
                quadrant(e) { const i = [e % 2 == 0, e < 2], c = St(this.min), h = St(this.max); for (let p = 0; p < i.length; p++)
                    c[p] = i[p] ? this.min[p] : this.center[p], h[p] = i[p] ? this.center[p] : this.max[p]; return h[2] = this.max[2], new Wn(c, h); }
                distanceX(e) { return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]; }
                distanceY(e) { return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]; }
                distanceZ(e) { return Math.max(Math.min(this.max[2], e[2]), this.min[2]) - e[2]; }
                getCorners() { const e = this.min, i = this.max; return [[e[0], e[1], e[2]], [i[0], e[1], e[2]], [i[0], i[1], e[2]], [e[0], i[1], e[2]], [e[0], e[1], i[2]], [i[0], e[1], i[2]], [i[0], i[1], i[2]], [e[0], i[1], i[2]]]; }
                intersects(e) { return this.intersectsAabb(e.bounds) ? Hp(e, this.getCorners()) : 0; }
                intersectsFlat(e) { return this.intersectsAabb(e.bounds) ? Hp(e, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0; }
                intersectsPrecise(e, i) { return i || this.intersects(e) ? Wp(e, this.getCorners()) : 0; }
                intersectsPreciseFlat(e, i) { return i || this.intersectsFlat(e) ? Wp(e, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0; }
                intersectsAabb(e) { for (let i = 0; i < 3; ++i)
                    if (this.min[i] > e.max[i] || e.min[i] > this.max[i])
                        return !1; return !0; }
                intersectsAabbXY(e) { return !(this.min[0] > e.max[0] || e.min[0] > this.max[0] || this.min[1] > e.max[1] || e.min[1] > this.max[1]); }
                encapsulate(e) { for (let i = 0; i < 3; i++)
                    this.min[i] = Math.min(this.min[i], e.min[i]), this.max[i] = Math.max(this.max[i], e.max[i]); }
                encapsulatePoint(e) { for (let i = 0; i < 3; i++)
                    this.min[i] = Math.min(this.min[i], e[i]), this.max[i] = Math.max(this.max[i], e[i]); }
                closestPoint(e) { return [Math.max(Math.min(this.max[0], e[0]), this.min[0]), Math.max(Math.min(this.max[1], e[1]), this.min[1]), Math.max(Math.min(this.max[2], e[2]), this.min[2])]; }
            }
            function Xu(a) { return a * v / G; }
            Nt(Wn, "Aabb");
            const B_ = [new Wn([O, O, O], [D, D, D]), new Wn([O, O, O], [0, 0, D]), new Wn([0, O, O], [D, 0, D]), new Wn([O, 0, O], [0, D, D]), new Wn([0, 0, O], [D, D, D])];
            function RI(a, e, i, c = !0) { const h = Ft([], a._camera.position, a.worldSize), p = [e, i, 1, 1]; Gi(p, p, a.pixelMatrixInverse), Ks(p, p, 1 / p[3]); const m = an([], Gn([], p, h)), x = a.globeMatrix, b = [x[12], x[13], x[14]], S = Gn([], b, h), A = Kt(S), I = an([], S), M = a.worldSize / (2 * Math.PI), z = Kr(I, m), F = Math.asin(M / A); if (F < Math.acos(z)) {
                if (!c)
                    return null;
                const Me = [], Oe = [];
                Ft(Me, m, A / z), an(Oe, Gn(Oe, Me, S)), an(m, ir(m, S, Ft(m, Oe, Math.tan(F) * A)));
            } const U = []; new aa(h, m).closestPointOnSphere(b, M, U); const X = an([], qi(x, 0)), Y = an([], qi(x, 1)), le = an([], qi(x, 2)), se = Kr(X, U), $ = Kr(Y, U), te = Kr(le, U), ae = re(Math.asin(-$ / M)); let fe = re(Math.atan2(se, te)); fe = a.center.lng + function (Me, Oe) { const Ye = (Oe - Me + 180) % 360 - 180; return Ye < -180 ? Ye + 360 : Ye; }(a.center.lng, fe); const Te = ve(fe), Pe = ke(xe(ae), 0, 1); return new Ve(Te, Pe); }
            class b4 {
                constructor(e, i, c) { this.a = Gn([], e, c), this.b = Gn([], i, c), this.center = c; const h = an([], this.a), p = an([], this.b); this.angle = Math.acos(Kr(h, p)); }
            }
            function ET(a, e) { if (a.angle === 0)
                return null; let i; return i = a.a[e] === 0 ? 1 / a.angle * .5 * Math.PI : 1 / a.angle * Math.atan(a.b[e] / a.a[e] / Math.sin(a.angle) - 1 / Math.tan(a.angle)), i < 0 || i > 1 ? null : function (c, h, p, m) { const x = Math.sin(p); return c * (Math.sin((1 - m) * p) / x) + h * (Math.sin(m * p) / x); }(a.a[e], a.b[e], a.angle, ke(i, 0, 1)) + a.center[e]; }
            function Gl(a) { if (a.z <= 1)
                return B_[a.z + 2 * a.y + a.x]; const e = CT(_x(a)); return Wn.fromPoints(e); }
            function Gc(a, e, i) { return Ft(a, a, 1 - i), gr(a, a, e, i); }
            function kI(a, e, i) { for (const c of a)
                ln(c, c, e), Ft(c, c, i); }
            function DI(a, e, i, c) { const h = e / a.worldSize, p = a.globeMatrix; if (i.z <= 1) {
                const Pe = Gl(i).getCorners();
                return kI(Pe, p, h), Wn.fromPoints(Pe);
            } const m = _x(i, c), x = CT(m, v + Xu(a._tileCoverLift)); kI(x, p, h); const b = Number.MAX_VALUE, S = [-b, -b, -b], A = [b, b, b]; if (m.contains(a.center)) {
                for (const Oe of x)
                    xt(A, A, Oe), Pt(S, S, Oe);
                S[2] = 0;
                const Pe = a.point, Me = [Pe.x * h, Pe.y * h, 0];
                return xt(A, A, Me), Pt(S, S, Me), new Wn(A, S);
            } if (a._tileCoverLift > 0) {
                for (const Pe of x)
                    xt(A, A, Pe), Pt(S, S, Pe);
                return new Wn(A, S);
            } const I = [p[12] * h, p[13] * h, p[14] * h], M = m.getCenter(), z = ke(a.center.lat, -ze, ze), F = ke(M.lat, -ze, ze), U = ve(a.center.lng), X = xe(z); let Y = U - ve(M.lng); const le = X - xe(F); Y > .5 ? Y -= 1 : Y < -.5 && (Y += 1); let se = 0; Math.abs(Y) > Math.abs(le) ? se = Y >= 0 ? 1 : 3 : (se = le >= 0 ? 0 : 2, gr(I, I, [p[4] * h, p[5] * h, p[6] * h], -Math.sin(Z(le >= 0 ? m.getSouth() : m.getNorth())) * v)); const $ = x[se], te = x[(se + 1) % 4], ae = new b4($, te, I), fe = [ET(ae, 0) || $[0], ET(ae, 1) || $[1], ET(ae, 2) || $[2]], Te = Ku(a.zoom); if (Te > 0) {
                const Pe = function ({ x: Oe, y: Ye, z: ut }, it, lt, pt, We) { const at = 1 / (1 << ut); let Ge = Oe * at, Xe = Ge + at, gt = Ye * at, yt = gt + at, Zt = 0; const jt = (Ge + Xe) / 2 - pt; return jt > .5 ? Zt = -1 : jt < -.5 && (Zt = 1), Ge = ((Ge + Zt) * it - (pt *= it)) * lt + pt, Xe = ((Xe + Zt) * it - pt) * lt + pt, gt = (gt * it - (We *= it)) * lt + We, yt = (yt * it - We) * lt + We, [[Ge, yt, 0], [Xe, yt, 0], [Xe, gt, 0], [Ge, gt, 0]]; }(i, e, a._pixelsPerMercatorPixel, U, X);
                for (let Oe = 0; Oe < x.length; Oe++)
                    Gc(x[Oe], Pe[Oe], Te);
                const Me = ir([], Pe[se], Pe[(se + 1) % 4]);
                Ft(Me, Me, .5), Gc(fe, Me, Te);
            } for (const Pe of x)
                xt(A, A, Pe), Pt(S, S, Pe); return A[2] = Math.min($[2], te[2]), xt(A, A, fe), Pt(S, S, fe), new Wn(A, S); }
            function _x({ x: a, y: e, z: i }, c = !1) { const h = 1 / (1 << i), p = new W(Se(a * h), e === (1 << i) - 1 && c ? -90 : Ce((e + 1) * h)), m = new W(Se((a + 1) * h), e === 0 && c ? 90 : Ce(e * h)); return new oe(p, m); }
            function CT(a, e = v) { const i = Z(a.getNorth()), c = Z(a.getSouth()), h = Math.cos(i), p = Math.cos(c), m = Math.sin(i), x = Math.sin(c), b = a.getWest(), S = a.getEast(); return [B(p, x, b, e), B(p, x, S, e), B(h, m, S, e), B(h, m, b, e)]; }
            function j_(a, e, i, c) { const h = 1 << i.z, p = (a / It + i.x) / h; return q(Ce((e / It + i.y) / h), Se(p), c); }
            function yx({ min: a, max: e }) { return C / Math.max(e[0] - a[0], e[1] - a[1], e[2] - a[2]); }
            const LI = new Float64Array(16);
            function vx(a) { const e = yx(a), i = Ze(LI, [e, e, e]); return Q(i, i, Si([], a.min)); }
            function AT(a) { const e = (c = a.min, (i = LI)[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = c[0], i[13] = c[1], i[14] = c[2], i[15] = 1, i); var i, c; const h = 1 / yx(a); return ue(e, e, [h, h, h]); }
            function IT(a) { const e = It / (2 * Math.PI); return a / (2 * Math.PI) / e; }
            function OI(a, e) { return It / (512 * Math.pow(2, a)) * yx(Gl(e)); }
            function zI(a, e, i, c, h) { const p = IT(i), m = [a, e, -i / (2 * Math.PI)], x = J(new Float64Array(16)); return Q(x, x, m), ue(x, x, [p, p, p]), be(x, x, Z(-h)), Ie(x, x, Z(-c)), x; }
            function Ku(a) { return De(w, T, a); }
            function FI(a, e) { const i = q(e.lat, e.lng), c = function (F) { const U = q(F._center.lat, F._center.lng); let X = mn([], bt(0, 1, 0), U); const Y = ot([], -F.angle, U); X = ln(X, X, Y), ot(Y, -F._pitch, X); const le = an([], U); return Ft(le, le, Xu(F.cameraToCenterDistance / F.pixelsPerMeter)), ln(le, le, Y), ir([], U, le); }(a); return m = (h = tr([], c, i))[0], x = h[1], b = h[2], S = (p = i)[0], A = p[1], I = p[2], z = (M = Math.sqrt(m * m + x * x + b * b) * Math.sqrt(S * S + A * A + I * I)) && Kr(h, p) / M, Math.acos(Math.min(Math.max(z, -1), 1)); var h, p, m, x, b, S, A, I, M, z; }
            function PT(a, e) { return FI(a, e) > Math.PI / 2 * 1.01; }
            const NI = Z(85), T4 = Math.cos(NI), S4 = Math.sin(NI), E4 = ce(), BI = a => { const e = []; return a.paint.get("circle-pitch-alignment") === "map" && e.push("PITCH_WITH_MAP"), a.paint.get("circle-pitch-scale") === "map" && e.push("SCALE_WITH_MAP"), e; };
            function jI(a, e, i, c, h, p, m, x, b) { if (p && a.queryGeometry.isAboveHorizon)
                return !1; p && (b *= a.pixelToTileUnitsFactor); const S = a.tileID.canonical, A = i.projection.upVectorScale(S, i.center.lat, i.worldSize).metersToTile; for (const I of e)
                for (const M of I) {
                    const z = M.add(x), F = h && i.elevation ? i.elevation.exaggeration() * h.getElevationAt(z.x, z.y, !0) : 0, U = i.projection.projectTilePoint(z.x, z.y, S);
                    if (F > 0) {
                        const se = i.projection.upVector(S, z.x, z.y);
                        U.x += se[0] * A * F, U.y += se[1] * A * F, U.z += se[2] * A * F;
                    }
                    const X = p ? z : C4(U.x, U.y, U.z, c), Y = p ? a.tilespaceRays.map(se => I4(se, F)) : a.queryGeometry.screenGeometry, le = Gi([], [U.x, U.y, U.z, 1], c);
                    if (!m && p ? b *= le[3] / i.cameraToCenterDistance : m && !p && (b *= i.cameraToCenterDistance / le[3]), p) {
                        const se = Ce((M.y / It + S.y) / (1 << S.z));
                        b /= i.projection.pixelsPerMeter(se, 1) / ge(1, se);
                    }
                    if (mr(Y, X, b))
                        return !0;
                } return !1; }
            function C4(a, e, i, c) { const h = Gi([], [a, e, i, 1], c); return new Et(h[0] / h[3], h[1] / h[3]); }
            const VI = bt(0, 0, 0), A4 = bt(0, 0, 1);
            function I4(a, e) { const i = ct(); return VI[2] = e, a.intersectsPlane(VI, A4, i), new Et(i[0], i[1]); }
            class UI extends $t {
            }
            let $I, GI, qI, HI;
            function WI(a, { width: e, height: i }, c, h) { if (h) {
                if (h instanceof Uint8ClampedArray)
                    h = new Uint8Array(h.buffer);
                else if (h.length !== e * i * c)
                    throw new RangeError("mismatched image size");
            }
            else
                h = new Uint8Array(e * i * c); return a.width = e, a.height = i, a.data = h, a; }
            function ZI(a, e, i) { const { width: c, height: h } = e; c === a.width && h === a.height || (MT(a, e, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(a.width, c), height: Math.min(a.height, h) }, i, null), a.width = c, a.height = h, a.data = e.data); }
            function MT(a, e, i, c, h, p, m, x) { if (h.width === 0 || h.height === 0)
                return e; if (h.width > a.width || h.height > a.height || i.x > a.width - h.width || i.y > a.height - h.height)
                throw new RangeError("out of range source coordinates for image copy"); if (h.width > e.width || h.height > e.height || c.x > e.width - h.width || c.y > e.height - h.height)
                throw new RangeError("out of range destination coordinates for image copy"); const b = a.data, S = e.data, A = p === 4 && x; for (let I = 0; I < h.height; I++) {
                const M = ((i.y + I) * a.width + i.x) * p, z = ((c.y + I) * e.width + c.x) * p;
                if (A)
                    for (let F = 0; F < h.width; F++) {
                        const U = M + F * p + 3, X = z + F * p;
                        S[X + 0] = 255, S[X + 1] = 255, S[X + 2] = 255, S[X + 3] = b[U];
                    }
                else if (m)
                    for (let F = 0; F < h.width; F++) {
                        const U = M + F * p, X = z + F * p, Y = b[U + 3], le = new nn(b[U + 0] / 255 * Y, b[U + 1] / 255 * Y, b[U + 2] / 255 * Y, Y).toRenderColor(m).toArray();
                        S[X + 0] = le[0], S[X + 1] = le[1], S[X + 2] = le[2], S[X + 3] = le[3];
                    }
                else
                    for (let F = 0; F < h.width * p; F++)
                        S[z + F] = b[M + F];
            } return e; }
            Nt(UI, "HeatmapBucket", { omit: ["layers"] });
            class Yu {
                constructor(e, i) { WI(this, e, 1, i); }
                resize(e) { ZI(this, new Yu(e), 1); }
                clone() { return new Yu({ width: this.width, height: this.height }, new Uint8Array(this.data)); }
                static copy(e, i, c, h, p) { MT(e, i, c, h, p, 1, null); }
            }
            class ds {
                constructor(e, i) { WI(this, e, 4, i); }
                resize(e) { ZI(this, new ds(e), 4); }
                replace(e, i) { i ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e; }
                clone() { return new ds({ width: this.width, height: this.height }, new Uint8Array(this.data)); }
                static copy(e, i, c, h, p, m, x) { MT(e, i, c, h, p, 4, m, x); }
            }
            class XI {
                constructor(e, i) { this.width = e.width, this.height = e.height, this.data = i instanceof Uint8Array ? new Float32Array(i.buffer) : i; }
            }
            function V_(a) { const e = {}, i = a.resolution || 256, c = a.clips ? a.clips.length : 1, h = a.image || new ds({ width: i, height: c }), p = (m, x, b) => { e[a.evaluationKey] = b; const S = a.expression.evaluate(e); S && (h.data[m + x + 0] = Math.floor(255 * S.r / S.a), h.data[m + x + 1] = Math.floor(255 * S.g / S.a), h.data[m + x + 2] = Math.floor(255 * S.b / S.a), h.data[m + x + 3] = Math.floor(255 * S.a)); }; if (a.clips)
                for (let m = 0, x = 0; m < c; ++m, x += 4 * i)
                    for (let b = 0, S = 0; b < i; b++, S += 4) {
                        const A = b / (i - 1), { start: I, end: M } = a.clips[m];
                        p(x, S, I * (1 - A) + M * A);
                    }
            else
                for (let m = 0, x = 0; m < i; m++, x += 4)
                    p(0, x, m / (i - 1)); return h; }
            Nt(Yu, "AlphaImage"), Nt(ds, "RGBAImage");
            const P4 = tn([{ name: "a_pos", components: 2, type: "Int16" }], 4), M4 = tn([{ name: "a_road_z_offset", components: 1, type: "Float32" }], 4), R4 = tn([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_height", components: 1, type: "Float32" }], 4), k4 = tn([{ name: "a_pos_normal_3", components: 3, type: "Int16" }], 4);
            function U_(a, e, i = 2) { const c = e && e.length, h = c ? e[0] * i : a.length; let p = KI(a, 0, h, i, !0); const m = []; if (!p || p.next === p.prev)
                return m; let x, b, S; if (c && (p = function (A, I, M, z) { const F = []; for (let U = 0, X = I.length; U < X; U++) {
                const Y = KI(A, I[U] * z, U < X - 1 ? I[U + 1] * z : A.length, z, !1);
                Y === Y.next && (Y.steiner = !0), F.push(j4(Y));
            } F.sort(F4); for (let U = 0; U < F.length; U++)
                M = N4(F[U], M); return M; }(a, e, p, i)), a.length > 80 * i) {
                x = 1 / 0, b = 1 / 0;
                let A = -1 / 0, I = -1 / 0;
                for (let M = i; M < h; M += i) {
                    const z = a[M], F = a[M + 1];
                    z < x && (x = z), F < b && (b = F), z > A && (A = z), F > I && (I = F);
                }
                S = Math.max(A - x, I - b), S = S !== 0 ? 32767 / S : 0;
            } return $_(p, m, i, x, b, S, 0), m; }
            function KI(a, e, i, c, h) { let p; if (h === function (m, x, b, S) { let A = 0; for (let I = x, M = b - S; I < b; I += S)
                A += (m[M] - m[I]) * (m[I + 1] + m[M + 1]), M = I; return A; }(a, e, i, c) > 0)
                for (let m = e; m < i; m += c)
                    p = eP(m / c | 0, a[m], a[m + 1], p);
            else
                for (let m = i - c; m >= e; m -= c)
                    p = eP(m / c | 0, a[m], a[m + 1], p); return p && Xp(p, p.next) && (H_(p), p = p.next), p; }
            function Wd(a, e) { if (!a)
                return a; e || (e = a); let i, c = a; do
                if (i = !1, c.steiner || !Xp(c, c.next) && Zi(c.prev, c, c.next) !== 0)
                    c = c.next;
                else {
                    if (H_(c), c = e = c.prev, c === c.next)
                        break;
                    i = !0;
                }
            while (i || c !== e); return e; }
            function $_(a, e, i, c, h, p, m) { if (!a)
                return; !m && p && function (b, S, A, I) { let M = b; do
                M.z === 0 && (M.z = RT(M.x, M.y, S, A, I)), M.prevZ = M.prev, M.nextZ = M.next, M = M.next;
            while (M !== b); M.prevZ.nextZ = null, M.prevZ = null, function (z) { let F, U = 1; do {
                let X, Y = z;
                z = null;
                let le = null;
                for (F = 0; Y;) {
                    F++;
                    let se = Y, $ = 0;
                    for (let ae = 0; ae < U && ($++, se = se.nextZ, se); ae++)
                        ;
                    let te = U;
                    for (; $ > 0 || te > 0 && se;)
                        $ !== 0 && (te === 0 || !se || Y.z <= se.z) ? (X = Y, Y = Y.nextZ, $--) : (X = se, se = se.nextZ, te--), le ? le.nextZ = X : z = X, X.prevZ = le, le = X;
                    Y = se;
                }
                le.nextZ = null, U *= 2;
            } while (F > 1); }(M); }(a, c, h, p); let x = a; for (; a.prev !== a.next;) {
                const b = a.prev, S = a.next;
                if (p ? L4(a, c, h, p) : D4(a))
                    e.push(b.i, a.i, S.i), H_(a), a = S.next, x = S.next;
                else if ((a = S) === x) {
                    m ? m === 1 ? $_(a = O4(Wd(a), e), e, i, c, h, p, 2) : m === 2 && z4(a, e, i, c, h, p) : $_(Wd(a), e, i, c, h, p, 1);
                    break;
                }
            } }
            function D4(a) { const e = a.prev, i = a, c = a.next; if (Zi(e, i, c) >= 0)
                return !1; const h = e.x, p = i.x, m = c.x, x = e.y, b = i.y, S = c.y, A = Math.min(h, p, m), I = Math.min(x, b, S), M = Math.max(h, p, m), z = Math.max(x, b, S); let F = c.next; for (; F !== e;) {
                if (F.x >= A && F.x <= M && F.y >= I && F.y <= z && G_(h, x, p, b, m, S, F.x, F.y) && Zi(F.prev, F, F.next) >= 0)
                    return !1;
                F = F.next;
            } return !0; }
            function L4(a, e, i, c) { const h = a.prev, p = a, m = a.next; if (Zi(h, p, m) >= 0)
                return !1; const x = h.x, b = p.x, S = m.x, A = h.y, I = p.y, M = m.y, z = Math.min(x, b, S), F = Math.min(A, I, M), U = Math.max(x, b, S), X = Math.max(A, I, M), Y = RT(z, F, e, i, c), le = RT(U, X, e, i, c); let se = a.prevZ, $ = a.nextZ; for (; se && se.z >= Y && $ && $.z <= le;) {
                if (se.x >= z && se.x <= U && se.y >= F && se.y <= X && se !== h && se !== m && G_(x, A, b, I, S, M, se.x, se.y) && Zi(se.prev, se, se.next) >= 0 || (se = se.prevZ, $.x >= z && $.x <= U && $.y >= F && $.y <= X && $ !== h && $ !== m && G_(x, A, b, I, S, M, $.x, $.y) && Zi($.prev, $, $.next) >= 0))
                    return !1;
                $ = $.nextZ;
            } for (; se && se.z >= Y;) {
                if (se.x >= z && se.x <= U && se.y >= F && se.y <= X && se !== h && se !== m && G_(x, A, b, I, S, M, se.x, se.y) && Zi(se.prev, se, se.next) >= 0)
                    return !1;
                se = se.prevZ;
            } for (; $ && $.z <= le;) {
                if ($.x >= z && $.x <= U && $.y >= F && $.y <= X && $ !== h && $ !== m && G_(x, A, b, I, S, M, $.x, $.y) && Zi($.prev, $, $.next) >= 0)
                    return !1;
                $ = $.nextZ;
            } return !0; }
            function O4(a, e) { let i = a; do {
                const c = i.prev, h = i.next.next;
                !Xp(c, h) && QI(c, i, i.next, h) && q_(c, h) && q_(h, c) && (e.push(c.i, i.i, h.i), H_(i), H_(i.next), i = a = h), i = i.next;
            } while (i !== a); return Wd(i); }
            function z4(a, e, i, c, h, p) { let m = a; do {
                let x = m.next.next;
                for (; x !== m.prev;) {
                    if (m.i !== x.i && V4(m, x)) {
                        let b = JI(m, x);
                        return m = Wd(m, m.next), b = Wd(b, b.next), $_(m, e, i, c, h, p, 0), void $_(b, e, i, c, h, p, 0);
                    }
                    x = x.next;
                }
                m = m.next;
            } while (m !== a); }
            function F4(a, e) { let i = a.x - e.x; return i === 0 && (i = a.y - e.y, i === 0) && (i = (a.next.y - a.y) / (a.next.x - a.x) - (e.next.y - e.y) / (e.next.x - e.x)), i; }
            function N4(a, e) { const i = function (h, p) { let m = p; const x = h.x, b = h.y; let S, A = -1 / 0; if (Xp(h, m))
                return m; do {
                if (Xp(h, m.next))
                    return m.next;
                if (b <= m.y && b >= m.next.y && m.next.y !== m.y) {
                    const U = m.x + (b - m.y) * (m.next.x - m.x) / (m.next.y - m.y);
                    if (U <= x && U > A && (A = U, S = m.x < m.next.x ? m : m.next, U === x))
                        return S;
                }
                m = m.next;
            } while (m !== p); if (!S)
                return null; const I = S, M = S.x, z = S.y; let F = 1 / 0; m = S; do {
                if (x >= m.x && m.x >= M && x !== m.x && YI(b < z ? x : A, b, M, z, b < z ? A : x, b, m.x, m.y)) {
                    const U = Math.abs(b - m.y) / (x - m.x);
                    q_(m, h) && (U < F || U === F && (m.x > S.x || m.x === S.x && B4(S, m))) && (S = m, F = U);
                }
                m = m.next;
            } while (m !== I); return S; }(a, e); if (!i)
                return e; const c = JI(i, a); return Wd(c, c.next), Wd(i, i.next); }
            function B4(a, e) { return Zi(a.prev, a, e.prev) < 0 && Zi(e.next, a, a.next) < 0; }
            function RT(a, e, i, c, h) { return (a = 1431655765 & ((a = 858993459 & ((a = 252645135 & ((a = 16711935 & ((a = (a - i) * h | 0) | a << 8)) | a << 4)) | a << 2)) | a << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - c) * h | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1; }
            function j4(a) { let e = a, i = a; do
                (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next;
            while (e !== a); return i; }
            function YI(a, e, i, c, h, p, m, x) { return (h - m) * (e - x) >= (a - m) * (p - x) && (a - m) * (c - x) >= (i - m) * (e - x) && (i - m) * (p - x) >= (h - m) * (c - x); }
            function G_(a, e, i, c, h, p, m, x) { return !(a === m && e === x) && YI(a, e, i, c, h, p, m, x); }
            function V4(a, e) { return a.next.i !== e.i && a.prev.i !== e.i && !function (i, c) { let h = i; do {
                if (h.i !== i.i && h.next.i !== i.i && h.i !== c.i && h.next.i !== c.i && QI(h, h.next, i, c))
                    return !0;
                h = h.next;
            } while (h !== i); return !1; }(a, e) && (q_(a, e) && q_(e, a) && function (i, c) { let h = i, p = !1; const m = (i.x + c.x) / 2, x = (i.y + c.y) / 2; do
                h.y > x != h.next.y > x && h.next.y !== h.y && m < (h.next.x - h.x) * (x - h.y) / (h.next.y - h.y) + h.x && (p = !p), h = h.next;
            while (h !== i); return p; }(a, e) && (Zi(a.prev, a, e.prev) || Zi(a, e.prev, e)) || Xp(a, e) && Zi(a.prev, a, a.next) > 0 && Zi(e.prev, e, e.next) > 0); }
            function Zi(a, e, i) { return (e.y - a.y) * (i.x - e.x) - (e.x - a.x) * (i.y - e.y); }
            function Xp(a, e) { return a.x === e.x && a.y === e.y; }
            function QI(a, e, i, c) { const h = wx(Zi(a, e, i)), p = wx(Zi(a, e, c)), m = wx(Zi(i, c, a)), x = wx(Zi(i, c, e)); return h !== p && m !== x || !(h !== 0 || !xx(a, i, e)) || !(p !== 0 || !xx(a, c, e)) || !(m !== 0 || !xx(i, a, c)) || !(x !== 0 || !xx(i, e, c)); }
            function xx(a, e, i) { return e.x <= Math.max(a.x, i.x) && e.x >= Math.min(a.x, i.x) && e.y <= Math.max(a.y, i.y) && e.y >= Math.min(a.y, i.y); }
            function wx(a) { return a > 0 ? 1 : a < 0 ? -1 : 0; }
            function q_(a, e) { return Zi(a.prev, a, a.next) < 0 ? Zi(a, e, a.next) >= 0 && Zi(a, a.prev, e) >= 0 : Zi(a, e, a.prev) < 0 || Zi(a, a.next, e) < 0; }
            function JI(a, e) { const i = kT(a.i, a.x, a.y), c = kT(e.i, e.x, e.y), h = a.next, p = e.prev; return a.next = e, e.prev = a, i.next = h, h.prev = i, c.next = i, i.prev = c, p.next = c, c.prev = p, c; }
            function eP(a, e, i, c) { const h = kT(a, e, i); return c ? (h.next = c.next, h.prev = c, c.next.prev = h, c.next = h) : (h.prev = h, h.next = h), h; }
            function H_(a) { a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ); }
            function kT(a, e, i) { return { i: a, x: e, y: i, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 }; }
            function bx(a, e) { const i = a.length; if (i <= 1)
                return [a]; const c = []; let h, p; for (let m = 0; m < i; m++) {
                const x = en(a[m]);
                x !== 0 && (a[m].area = Math.abs(x), p === void 0 && (p = x < 0), p === x < 0 ? (h && c.push(h), h = [a[m]]) : h.push(a[m]));
            } if (h && c.push(h), e > 1)
                for (let m = 0; m < c.length; m++)
                    c[m].length <= e || (Rl(c[m], e, 1, c[m].length - 1, U4), c[m] = c[m].slice(0, e)); return c; }
            function U4(a, e) { return e.area - a.area; }
            function tP(a, e, i = 1) { if (!a)
                return null; const c = typeof a == "string" ? Us.from(a).getPrimary() : a.getPrimary(), h = typeof a == "string" ? null : a.getSecondary(); for (const p of [c, h]) {
                if (!p)
                    continue;
                const m = p.id.toString();
                e.has(m) || e.set(m, []), p.scaleSelf(i), e.get(m).push(p);
            } return { primary: c.toString(), secondary: h ? h.toString() : null }; }
            function DT(a, e, i, c) { const h = c.patternDependencies; let p = !1; for (const m of e) {
                const x = m.paint.get(`${a}-pattern`);
                x.isConstant() || (p = !0), tP(x.constantOr(null), h, i) && (p = !0);
            } return p; }
            function LT(a, e, i, c, h, p) { const m = p.patternDependencies; for (const x of e) {
                const b = x.paint.get(`${a}-pattern`).value;
                if (b.kind !== "constant") {
                    let S = b.evaluate({ zoom: c }, i, {}, p.availableImages);
                    S = S && S.name ? S.name : S;
                    const A = tP(S, m, h);
                    if (!A)
                        continue;
                    const { primary: I, secondary: M } = A;
                    I && (i.patterns[x.id] = [I, M].filter(Boolean));
                }
            } return i; }
            var OT, rP, zT, nP, FT, iP, sP, Tx = {};
            function oP() { if (rP)
                return OT; rP = 1; var a = sd(); function e(h, p, m, x, b) { this.properties = {}, this.extent = m, this.type = 0, this._pbf = h, this._geometry = -1, this._keys = x, this._values = b, h.readFields(i, this, p); } function i(h, p, m) { h == 1 ? p.id = m.readVarint() : h == 2 ? function (x, b) { for (var S = x.readVarint() + x.pos; x.pos < S;) {
                var A = b._keys[x.readVarint()], I = b._values[x.readVarint()];
                b.properties[A] = I;
            } }(m, p) : h == 3 ? p.type = m.readVarint() : h == 4 && (p._geometry = m.pos); } function c(h) { for (var p, m, x = 0, b = 0, S = h.length, A = S - 1; b < S; A = b++)
                x += ((m = h[A]).x - (p = h[b]).x) * (p.y + m.y); return x; } return OT = e, e.types = ["Unknown", "Point", "LineString", "Polygon"], e.prototype.loadGeometry = function () { var h = this._pbf; h.pos = this._geometry; for (var p, m = h.readVarint() + h.pos, x = 1, b = 0, S = 0, A = 0, I = []; h.pos < m;) {
                if (b <= 0) {
                    var M = h.readVarint();
                    x = 7 & M, b = M >> 3;
                }
                if (b--, x === 1 || x === 2)
                    S += h.readSVarint(), A += h.readSVarint(), x === 1 && (p && I.push(p), p = []), p.push(new a(S, A));
                else {
                    if (x !== 7)
                        throw new Error("unknown command " + x);
                    p && p.push(p[0].clone());
                }
            } return p && I.push(p), I; }, e.prototype.bbox = function () { var h = this._pbf; h.pos = this._geometry; for (var p = h.readVarint() + h.pos, m = 1, x = 0, b = 0, S = 0, A = 1 / 0, I = -1 / 0, M = 1 / 0, z = -1 / 0; h.pos < p;) {
                if (x <= 0) {
                    var F = h.readVarint();
                    m = 7 & F, x = F >> 3;
                }
                if (x--, m === 1 || m === 2)
                    (b += h.readSVarint()) < A && (A = b), b > I && (I = b), (S += h.readSVarint()) < M && (M = S), S > z && (z = S);
                else if (m !== 7)
                    throw new Error("unknown command " + m);
            } return [A, M, I, z]; }, e.prototype.toGeoJSON = function (h, p, m) { var x, b, S = this.extent * Math.pow(2, m), A = this.extent * h, I = this.extent * p, M = this.loadGeometry(), z = e.types[this.type]; function F(Y) { for (var le = 0; le < Y.length; le++) {
                var se = Y[le];
                Y[le] = [360 * (se.x + A) / S - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (se.y + I) / S) * Math.PI / 180)) - 90];
            } } switch (this.type) {
                case 1:
                    var U = [];
                    for (x = 0; x < M.length; x++)
                        U[x] = M[x][0];
                    F(M = U);
                    break;
                case 2:
                    for (x = 0; x < M.length; x++)
                        F(M[x]);
                    break;
                case 3: for (M = function (Y) { var le = Y.length; if (le <= 1)
                    return [Y]; for (var se, $, te = [], ae = 0; ae < le; ae++) {
                    var fe = c(Y[ae]);
                    fe !== 0 && ($ === void 0 && ($ = fe < 0), $ === fe < 0 ? (se && te.push(se), se = [Y[ae]]) : se.push(Y[ae]));
                } return se && te.push(se), te; }(M), x = 0; x < M.length; x++)
                    for (b = 0; b < M[x].length; b++)
                        F(M[x][b]);
            } M.length === 1 ? M = M[0] : z = "Multi" + z; var X = { type: "Feature", geometry: { type: z, coordinates: M }, properties: this.properties }; return "id" in this && (X.id = this.id), X; }, OT; }
            function aP() { if (nP)
                return zT; nP = 1; var a = oP(); function e(c, h) { this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = c, this._keys = [], this._values = [], this._features = [], c.readFields(i, this, h), this.length = this._features.length; } function i(c, h, p) { c === 15 ? h.version = p.readVarint() : c === 1 ? h.name = p.readString() : c === 5 ? h.extent = p.readVarint() : c === 2 ? h._features.push(p.pos) : c === 3 ? h._keys.push(p.readString()) : c === 4 && h._values.push(function (m) { for (var x = null, b = m.readVarint() + m.pos; m.pos < b;) {
                var S = m.readVarint() >> 3;
                x = S === 1 ? m.readString() : S === 2 ? m.readFloat() : S === 3 ? m.readDouble() : S === 4 ? m.readVarint64() : S === 5 ? m.readVarint() : S === 6 ? m.readSVarint() : S === 7 ? m.readBoolean() : null;
            } return x; }(p)); } return zT = e, e.prototype.feature = function (c) { if (c < 0 || c >= this._features.length)
                throw new Error("feature index out of bounds"); this._pbf.pos = this._features[c]; var h = this._pbf.readVarint() + this._pbf.pos; return new a(this._pbf, h, this.extent, this._keys, this._values); }, zT; }
            function lP() { return sP || (sP = 1, Tx.VectorTile = function () { if (iP)
                return FT; iP = 1; var a = aP(); function e(i, c, h) { if (i === 3) {
                var p = new a(h, h.readVarint() + h.pos);
                p.length && (c[p.name] = p);
            } } return FT = function (i, c) { this.layers = i.readFields(e, {}, c); }, FT; }(), Tx.VectorTileFeature = oP(), Tx.VectorTileLayer = aP()), Tx; }
            var Qu = lP();
            const Zd = "3d_elevation_id", cP = "level";
            class $4 {
                constructor() { this._valid = !1; }
                reset(e) { return this.feature = e, this._valid = !0, this._geometry = e.loadGeometry(), this._geometry.length !== 0 && this._geometry[0].length !== 0 || (this._valid = !1), this; }
                geometry(e, i) { return this._valid && e(i(this._geometry)), this; }
                require(e, i, c) { return this.get(e, !0, i, c); }
                optional(e, i, c) { return this.get(e, !1, i, c); }
                success() { return this._valid; }
                get(e, i, c, h) { const p = this.feature.properties.hasOwnProperty(e) ? +this.feature.properties[e] : void 0; return this._valid && p !== void 0 && !Number.isNaN(p) ? c(h ? h(p) : p) : i && (this._valid = !1), this; }
            }
            class uP {
                constructor(e, i) { this.featureFunc = e, this.vertexFunc = i; }
                parseFeature(e, i, c) { return this.featureFunc(e, i, c); }
                parseVertex(e, i, c) { return this.vertexFunc(e, i, c); }
            }
            const G4 = new uP((a, e, i) => a.reset(e).require(Zd, c => { i.id = c; }).optional("fixed_height_relative", c => { i.constantHeight = c; }, Xd.decodeRelativeHeight).geometry(c => { i.bounds = c; }, $g).success(), (a, e, i) => a.reset(e).require(Zd, c => { i.id = c; }).require("elevation_idx", c => { i.idx = c; }).require("extent", c => { i.extent = c; }).require("height_relative", c => { i.height = c; }, Xd.decodeRelativeHeight).geometry(c => { i.position = c; }, Xd.getPoint).success()), q4 = new uP((a, e, i) => a.reset(e).require(Zd, c => { i.id = c; }).optional("fixed_height", c => { i.constantHeight = c; }, Xd.decodeMetricHeight).geometry(c => { i.bounds = c; }, $g).success(), (a, e, i) => a.reset(e).require(Zd, c => { i.id = c; }).require("elevation_idx", c => { i.idx = c; }).require("extent", c => { i.extent = c; }).require("height", c => { i.height = c; }, Xd.decodeMetricHeight).geometry(c => { i.position = c; }, Xd.getPoint).success());
            class Xd {
                static getPoint(e) { return $a(e[0][0].x, e[0][0].y); }
                static decodeRelativeHeight(e) { return 1e-4 * e * 5; }
                static decodeMetricHeight(e) { return 1e-4 * e; }
                static parse(e) { const i = [], c = [], h = e.length, p = new $4; for (let x = 0; x < h; x++) {
                    const b = e.feature(x), S = b.properties.hasOwnProperty("version") ? String(b.properties.version) : void 0, A = (m = S) ? m === "1.0.1" ? q4 : void 0 : G4;
                    if (A === void 0) {
                        Br(`Unknown elevation feature version number ${S || "(unknown)"}`);
                        continue;
                    }
                    const I = b.properties.hasOwnProperty("type") ? b.properties.type : void 0;
                    if (I) {
                        if (Qu.VectorTileFeature.types[b.type] === "Point" && I === "curve_point") {
                            const M = {};
                            A.parseVertex(p, b, M) && i.push(M);
                        }
                        else if (Qu.VectorTileFeature.types[b.type] === "Polygon" && I === "curve_meta") {
                            const M = {};
                            A.parseFeature(p, b, M) && c.push(M);
                        }
                    }
                } var m; return { vertices: i, features: c }; }
            }
            class hP {
                constructor(e, i) { this.feature = e, this.metersToTile = i, this.index = 0; }
                get() { const e = this.feature.vertices[this.index], i = this.feature.vertexProps[this.index].dir, c = i[1], h = -i[0], p = (e.extent + 1) * this.metersToTile; return [new Et(Math.trunc(e.position[0] + c * p), Math.trunc(e.position[1] + h * p)), new Et(Math.trunc(e.position[0] - c * p), Math.trunc(e.position[1] - h * p))]; }
                next() { this.index++; }
                valid() { return this.index < this.feature.vertices.length; }
            }
            class NT {
                constructor(e, i, c, h, p, m) { if (this.vertices = [], this.vertexProps = [], this.edges = [], this.edgeProps = [], this.id = e, this.heightRange = { min: c, max: c }, this.safeArea = i, this.constantHeight = c, this.constantHeight == null && (this.constantHeight != null || h.length !== 0)) {
                    this.vertices = h, this.edges = p, this.edges = this.edges.filter(x => { return x.a < this.vertices.length && x.b < this.vertices.length && !((b = this.vertices[x.a].position)[0] === (S = this.vertices[x.b].position)[0] && b[1] === S[1]); var b, S; }), this.heightRange = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
                    for (const x of this.vertices)
                        this.vertexProps.push({ dir: $a(0, 0) }), this.heightRange.min = Math.min(this.heightRange.min, x.height), this.heightRange.max = Math.max(this.heightRange.max, x.height);
                    for (const x of this.edges) {
                        const b = this.vertices[x.a].position, S = this.vertices[x.b].position, A = Ys(oi(), S, b), I = wa(A), M = Ga(oi(), A, 1 / I);
                        this.edgeProps.push({ vec: A, dir: M, len: I });
                        const z = this.vertexProps[x.a].dir, F = this.vertexProps[x.b].dir;
                        Mo(z, z, M), Mo(F, F, M);
                    }
                    for (const x of this.vertexProps)
                        x.dir[0] === 0 && x.dir[1] === 0 || gc(x.dir, x.dir);
                    this.tessellate(m);
                } }
                pointElevation(e) { if (this.constantHeight != null)
                    return this.constantHeight; const i = this.getClosestEdge(e); if (i == null)
                    return 0; const [c, h] = i; return ((p, m, x) => (1 - x) * p + x * m)(this.vertices[this.edges[c].a].height, this.vertices[this.edges[c].b].height, h); }
                getSafeArea() { return this.safeArea; }
                isTunnel() { return this.heightRange.max <= -5; }
                getClosestEdge(e) { if (this.edges.length === 0)
                    return; let i = 0, c = Number.POSITIVE_INFINITY, h = 0; const p = $a(e.x, e.y); for (let m = 0; m < this.edges.length; m++) {
                    const x = this.edges[m], b = this.edgeProps[m].dir, S = new Pa(p, this.edgeProps[m].dir), A = this.vertices[x.a].position, I = this.vertices[x.b].position, M = oi(), z = oi(), F = S.intersectsPlane(A, this.vertexProps[x.a].dir, M), U = S.intersectsPlane(I, this.vertexProps[x.b].dir, z);
                    if (!F || !U)
                        continue;
                    const X = Ys(oi(), z, M), Y = Ys(oi(), p, M), le = jn(X, X), se = le > 0 ? jn(Y, X) / le : 0, $ = ke(se, 0, 1), te = Math.abs((se - $) * this.edgeProps[m].len), ae = Ys(oi(), p, A), fe = te + Math.abs(jn(ae, $a(b[1], -b[0])));
                    fe < c && (i = m, c = fe, h = $);
                } return [i, h]; }
                tessellate(e) { for (let i = this.edges.length - 1; i >= 0; --i) {
                    const c = this.edges[i].a, h = this.edges[i].b, { position: p, height: m, extent: x } = this.vertices[c], { position: b, height: S, extent: A } = this.vertices[h], I = this.vertexProps[c].dir, M = this.vertexProps[h].dir, z = bt(p[0] / e, p[1] / e, m), F = bt(b[0] / e, b[1] / e, S), U = bt(I[1], -I[0], 0);
                    Ft(U, U, x);
                    const X = bt(M[1], -M[0], 0);
                    if (Ft(X, X, A), this.distSqLines(bt(z[0] + .5 * U[0], z[1] + .5 * U[1], z[2] + .5 * U[2]), bt(F[0] - .5 * X[0], F[1] - .5 * X[1], F[2] - .5 * X[2]), bt(z[0] - .5 * U[0], z[1] - .5 * U[1], z[2] - .5 * U[2]), bt(F[0] + .5 * X[0], F[1] + .5 * X[1], F[2] + .5 * X[2])) <= .0025000000000000005)
                        continue;
                    const Y = this.vertices.length, le = Mo(oi(), p, b);
                    this.vertices.push({ position: Ga(le, le, .5), height: .5 * (m + S), extent: .5 * (x + A) });
                    const se = Mo(oi(), I, M);
                    this.vertexProps.push({ dir: gc(se, se) }), this.edges.splice(i, 1), this.edgeProps.splice(i, 1), this.edges.push({ a: c, b: Y }), this.edges.push({ a: Y, b: h });
                    const $ = Ys(oi(), this.vertices[Y].position, p), te = wa($), ae = { vec: $, dir: Ga(oi(), $, 1 / te), len: te };
                    this.edgeProps.push(ae), this.edgeProps.push(ae);
                } }
                distSqLines(e, i, c, h) { const p = tr(ct(), i, e), m = tr(ct(), h, c), x = tr(ct(), e, c), b = Kr(p, p), S = Kr(p, m), A = Kr(p, x), I = Kr(m, m), M = Kr(m, x), z = b * I - S * S; if (z === 0) {
                    const X = Kr(x, m) / Kr(m, m);
                    return Jr(Xs(ct(), c, h, X), e);
                } const F = (S * M - A * I) / z, U = (b * M - S * A) / z; return Jr(Xs(ct(), e, i, F), Xs(ct(), c, h, U)); }
            }
            class BT {
                static parseFrom(e, i) { const c = Xd.parse(e); if (!c)
                    return []; let { vertices: h, features: p } = c; const m = 1 / Fe(i); p.sort((A, I) => A.id - I.id), h.sort((A, I) => A.id - I.id || A.idx - I.idx), h = h.filter((A, I, M) => I === M.findIndex(z => z.id === A.id && z.idx === A.idx)); const x = []; let b = 0; const S = h.length; for (const A of p) {
                    if (A.constantHeight) {
                        x.push(new NT(A.id, A.bounds, A.constantHeight));
                        continue;
                    }
                    for (; b !== S && h[b].id < A.id;)
                        b++;
                    if (b === S || h[b].id !== A.id)
                        continue;
                    const I = [], M = [], z = b;
                    for (; b !== S && h[b].id === A.id;) {
                        const F = h[b];
                        if (I.push({ position: F.position, height: F.height, extent: F.extent }), b !== z && h[b - 1].idx === F.idx - 1) {
                            const U = b - z;
                            M.push({ a: U - 1, b: U });
                        }
                        b++;
                    }
                    x.push(new NT(A.id, A.bounds, void 0, I, M, m));
                } return x; }
                static getElevationFeature(e, i) { if (!i)
                    return; const c = +e.properties[Zd]; return Number.isNaN(c) ? void 0 : i.find(h => h.id === c); }
            }
            class dP {
                constructor(e, i) { this.zScale = 1, this.xOffset = 0, this.yOffset = 0, e.equals(i) || (this.zScale = Math.pow(2, i.z - e.z), this.xOffset = (e.x * this.zScale - i.x) * It, this.yOffset = (e.y * this.zScale - i.y) * It); }
                constantElevation(e, i) { if (e.constantHeight != null)
                    return this.computeBiasedHeight(e.constantHeight, i); }
                pointElevation(e, i, c) { const h = this.constantElevation(i, c); return h ?? (e.x = e.x * this.zScale + this.xOffset, e.y = e.y * this.zScale + this.yOffset, this.computeBiasedHeight(i.pointElevation(e), c)); }
                computeBiasedHeight(e, i) { return i <= 0 ? e : e + i * De(0, i, e >= 0 ? e : Math.abs(.5 * e)); }
            }
            Nt(NT, "ElevationFeature");
            class fP {
                constructor() { this.polygons = new Map; }
                add(e, ...i) { this.polygons.has(e) ? this.polygons.get(e).push(...i) : this.polygons.set(e, i); }
                merge(e) { for (const [i, c] of e.polygons)
                    this.add(i, ...c); }
            }
            class Kd {
                constructor() { this.portals = []; }
                static evaluate(e) { if (e.length === 0)
                    return new Kd; let i = []; for (const S of e)
                    i.push(...S.portals); if (i.length === 0)
                    return new Kd; const c = (S, A) => S <= 0 && A <= 0 || S >= It && A >= It; for (const S of i) {
                    const A = S.va, I = S.vb;
                    (c(A.x, I.x) || c(A.y, I.y)) && (S.type = "border");
                } const h = i.filter(S => S.type !== "unevaluated"), p = i.filter(S => S.type === "unevaluated"); if (p.length === 0)
                    return new Kd; p.sort((S, A) => S.hash === A.hash ? S.isTunnel === A.isTunnel ? 0 : S.isTunnel ? -1 : 1 : S.hash < A.hash ? 1 : -1), i = h.concat(p); let m = h.length, x = m, b = m; do
                    if (x++, x === i.length || i[m].hash !== i[x].hash) {
                        if (x - m == 2) {
                            b < m && (i[b] = i[m], i[m] = null);
                            const S = i[b], A = i[x - 1];
                            S.type = S.isTunnel !== A.isTunnel ? "tunnel" : "polygon", S.connection = { a: S.connection.a, b: A.connection.a }, b++;
                        }
                        m = x;
                    }
                while (m !== i.length); return i.splice(b), i.sort((S, A) => S.hash < A.hash ? 1 : -1), { portals: i }; }
            }
            Nt(Kd, "ElevationPortalGraph"), Nt(fP, "ElevationPolygons");
            class H4 {
                constructor(e, i, c) { this.outPositions = e, this.outNormals = i, this.outIndices = c, this.vertexLookup = new Map, this.buffer = new ArrayBuffer(4), this.view = new DataView(this.buffer); }
                addVertex(e, i, c) { let h = e[2]; c != null && (h *= c); const p = this.getVec3Bits(e) << 96n | this.getVec3Bits(i), m = this.vertexLookup.get(p); if (m != null)
                    return m; const x = this.outPositions.length; this.vertexLookup.set(p, x); const b = Math.trunc(16384 * i[0]), S = Math.trunc(16384 * i[1]), A = Math.trunc(16384 * i[2]); return this.outPositions.emplaceBack(e[0], e[1], h), this.outNormals.emplaceBack(b, S, A), x; }
                addVertices(e, i, ...c) { const h = []; for (const p of c) {
                    const m = this.addVertex(p, e, i);
                    h.push(m);
                } return h; }
                addTriangles(e, i, c) { if (i && c) {
                    const h = c.length === 1, p = bt(0, 0, 0);
                    for (let m = 0; m < e.length; m += 3) {
                        const x = i[e[m + 0]], b = i[e[m + 1]], S = i[e[m + 2]], A = h ? c[0] : c[e[m + 1]], I = h ? c[0] : c[e[m + 2]], M = this.addVertex(bt(x.x, x.y, h ? c[0] : c[e[m + 0]]), p), z = this.addVertex(bt(b.x, b.y, A), p), F = this.addVertex(bt(S.x, S.y, I), p);
                        this.outIndices.emplaceBack(M, z, F);
                    }
                }
                else
                    for (let h = 0; h < e.length; h += 3)
                        this.outIndices.emplaceBack(e[h + 0], e[h + 1], e[h + 2]); }
                addQuad(e, i) { const c = this.addVertices(i, void 0, ...e.map(b => bt(b.coord.x, b.coord.y, b.height))), [h, p, m, x] = c; this.addTriangles([h, p, m, m, x, h]); }
                getBits(e) { return this.view.setFloat32(0, e), BigInt(this.view.getUint32(0)); }
                getVec3Bits(e) { return this.getBits(e[0]) << 64n | this.getBits(e[1]) << 32n | this.getBits(e[2]); }
            }
            class Bo {
                constructor(e) { this.unevaluatedPortals = new Kd, this.portalPolygons = new fP, this.vertexHashLookup = new Map, this.unevalVertices = [], this.unevalHeights = [], this.unevalTriangles = [], this.unevalTunnelTriangles = [], this.unevalEdges = [], this.vertexPositions = new Fp, this.vertexNormals = new Uu, this.indexArray = new Hi, this.tileToMeters = Fe(e); }
                addVertices(e, i) { const c = this.unevalVertices.length; for (let h = 0; h < e.length; h++)
                    this.unevalVertices.push(e[h]), this.unevalHeights.push(i[h]); return c; }
                addTriangles(e, i, c) { const h = c ? this.unevalTunnelTriangles : this.unevalTriangles; for (const p of e)
                    h.push(p + i); }
                addRenderableRing(e, i, c, h, p) { const m = [new Et(p.min.x, p.min.y), new Et(p.max.x, p.min.y), new Et(p.max.x, p.max.y), new Et(p.min.x, p.max.y)]; for (let x = 0; x < c - 1; x++) {
                    const b = i + x, S = b + 1, A = this.unevalVertices[b], I = this.unevalVertices[S];
                    if (!(A.x >= p.min.x && A.x <= p.max.x && A.y >= p.min.y && A.y <= p.max.y || I.x >= p.min.x && I.x <= p.max.x && I.y >= p.min.y && I.y <= p.max.y || _i(A, I, m)) || this.isOnBorder(A.x, I.x) || this.isOnBorder(A.y, I.y))
                        continue;
                    const M = Bo.computeEdgeHash(this.unevalVertices[b], this.unevalVertices[S]);
                    let z, F = this.vertexHashLookup.get(Bo.computePosHash(A));
                    F != null ? z = F.next : (F = this.vertexHashLookup.get(Bo.computePosHash(I)), z = F != null ? F.prev : M), this.unevalEdges.push({ polygonIdx: e, a: b, b: S, hash: M, portalHash: z, isTunnel: h, type: "unevaluated" });
                } }
                addPortalCandidates(e, i, c, h, p) { if (i.length === 0)
                    return; this.portalPolygons.add(e, { geometry: i, zLevel: p }); const m = i[0]; this.vertexHashLookup.clear(); let x = Bo.computeEdgeHash(m[m.length - 2], m[m.length - 1]); for (let b = 0; b < m.length - 1; b++) {
                    const S = m[b + 0], A = m[b + 1], I = $a(A.x - S.x, A.y - S.y), M = wa(I);
                    if (M === 0)
                        continue;
                    let z = "unevaluated";
                    const F = h.pointElevation(S), U = h.pointElevation(A);
                    Math.abs(F) < .01 && Math.abs(U) < .01 ? z = "entrance" : (this.isOnBorder(S.x, A.x) || this.isOnBorder(S.y, A.y)) && (z = "border");
                    const X = Bo.computeEdgeHash(S, A);
                    this.unevaluatedPortals.portals.push({ connection: { a: e, b: void 0 }, va: S, vb: A, vab: I, length: M, hash: X, isTunnel: c, type: z });
                    const Y = Bo.computePosHash(S);
                    this.vertexHashLookup.set(Y, { prev: x, next: X }), x = X;
                } }
                construct(e) { if (this.unevalVertices.length === 0)
                    return; const i = () => ({ vertexOffset: 0, primitiveOffset: this.indexArray.length }), c = I => { I.primitiveLength = this.indexArray.length - I.primitiveOffset; }, h = new H4(this.vertexPositions, this.vertexNormals, this.indexArray); this.prepareEdges(e.portals, this.unevalEdges); const p = i(), m = i(), x = i(), b = (I, M) => { I.sort((F, U) => F.type === M && U.type !== M ? -1 : F.type !== M && U.type === M ? 1 : 0); const z = I.findIndex(F => F.type !== M); return z >= 0 ? z : I.length; }; let S = 0; this.unevalEdges.length > 0 && (S = b(this.unevalEdges, "none"), this.constructBridgeStructures(h, this.unevalVertices, this.unevalHeights, this.unevalEdges, { min: 0, max: S }, this.tileToMeters)); const A = i(); if (this.unevalEdges.length > 0) {
                    const I = this.unevalEdges.splice(S), M = b(I, "tunnel") + S;
                    this.unevalEdges.push(...I), this.constructTunnelStructures(h, this.unevalVertices, this.unevalHeights, this.unevalEdges, { min: 0, max: S }, { min: S, max: M });
                } c(x), h.addTriangles(this.unevalTriangles, this.unevalVertices, this.unevalHeights), c(A), h.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, this.unevalHeights), c(m), h.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, [-.1]), c(p), this.maskSegments = ti.simpleSegment(0, A.primitiveOffset, 0, A.primitiveLength), this.depthSegments = ti.simpleSegment(0, m.primitiveOffset, 0, m.primitiveLength), this.renderableSegments = ti.simpleSegment(0, x.primitiveOffset, 0, x.primitiveLength), this.shadowCasterSegments = ti.simpleSegment(0, p.primitiveOffset, 0, p.primitiveLength); }
                upload(e) { this.vertexBuffer || this.vertexPositions.length === 0 || this.vertexNormals.length === 0 || this.indexArray.length === 0 || (this.vertexBuffer = e.createVertexBuffer(this.vertexPositions, R4.members), this.vertexBufferNormal = e.createVertexBuffer(this.vertexNormals, k4.members), this.indexBuffer = e.createIndexBuffer(this.indexArray)); }
                destroy() { this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBufferNormal.destroy(), this.indexBuffer.destroy()), this.maskSegments && (this.maskSegments.destroy(), this.depthSegments.destroy(), this.renderableSegments.destroy(), this.shadowCasterSegments.destroy()); }
                computeVertexConnections(e, i, c, h, p) { const m = new Map; for (let x = h; x < p; x++) {
                    const b = c[x], S = b.a, A = b.b, I = Bo.computePosHash(e[S]), M = Bo.computePosHash(e[A]);
                    m.has(I) || m.set(I, {}), m.has(M) || m.set(M, {});
                    const z = m.get(I), F = m.get(M);
                    i[S] <= 0 && i[A] <= 0 || (z.to = A, F.from = S);
                } return m; }
                constructBridgeStructures(e, i, c, h, p, m) { const x = this.computeVertexConnections(i, c, h, p.min, p.max), b = 1 / m, S = .5 * b, A = M => bt(i[M].x, i[M].y, c[M] * b), I = M => { const z = x.get(Bo.computePosHash(i[M])), F = z.from, U = z.to; if (!F || !U)
                    return; const X = A(F), Y = A(M), le = A(U), se = bt(0, 0, 0); if (!ss(X, Y)) {
                    const te = Gn(ct(), Y, X);
                    ir(se, se, an(te, te));
                } if (!ss(le, Y)) {
                    const te = Gn(ct(), le, Y);
                    ir(se, se, an(te, te));
                } const $ = Xo(se); return $ > 0 ? Ft(se, se, 1 / $) : void 0; }; for (let M = p.min; M < p.max; M++) {
                    const z = h[M], F = this.prepareEdgePoints(i, c, z, (mt, pr) => mt > pr);
                    if (F == null)
                        continue;
                    const U = F[0], X = F[1], Y = bt(U.coord.x, U.coord.y, b * U.height), le = bt(X.coord.x, X.coord.y, b * X.height);
                    if (ss(Y, le))
                        continue;
                    const se = Gn(ct(), le, Y);
                    an(se, se);
                    const $ = mt => an(mt, mt), te = I(z.a) || se, ae = I(z.b) || se, fe = $(bt(te[1], -te[0], 0)), Te = $(bt(ae[1], -ae[0], 0)), Pe = $(mn(ct(), fe, te)), Me = $(mn(ct(), Te, ae)), Oe = ct(), Ye = [ir(ct(), Y, Ft(Oe, Gn(Oe, fe, Pe), S)), ir(ct(), Y, Ft(Oe, ir(Oe, fe, Pe), S)), ir(ct(), Y, Ft(Oe, Pe, S)), Y], ut = [ir(ct(), le, Ft(Oe, Gn(Oe, Te, Me), S)), ir(ct(), le, Ft(Oe, ir(Oe, Te, Me), S)), ir(ct(), le, Ft(Oe, Me, S)), le], [it, lt] = e.addVertices(fe, m, Ye[0], Ye[1]), [pt, We] = e.addVertices(Te, m, ut[0], ut[1]);
                    e.addTriangles([it, lt, pt, lt, We, pt]);
                    const [at, Ge] = e.addVertices(Pe, m, Ye[1], Ye[2]), [Xe, gt] = e.addVertices(Me, m, ut[1], ut[2]);
                    e.addTriangles([at, Ge, Xe, Ge, gt, Xe]);
                    const [yt, Zt] = e.addVertices(Si(fe, fe), m, Ye[2], Ye[3]), [jt, Rt] = e.addVertices(Si(Te, Te), m, ut[2], ut[3]);
                    e.addTriangles([yt, Zt, jt, Zt, Rt, jt]);
                } }
                constructTunnelStructures(e, i, c, h, p, m) { const x = b => an(b, b); for (let b = p.min; b < p.max; b++) {
                    const S = this.prepareEdgePoints(i, c, h[b], (z, F) => z < F);
                    if (S == null)
                        continue;
                    const [A, I] = S, M = x(bt(I.coord.y - A.coord.y, -(I.coord.x - A.coord.x), 0));
                    e.addQuad([A, I, { coord: I.coord, height: h[b].isTunnel ? -.1 : 0 }, { coord: A.coord, height: h[b].isTunnel ? -.1 : 0 }], M);
                } for (let b = m.min; b < m.max; b++) {
                    const S = h[b], A = i[S.a], I = i[S.b], M = x(bt(I.y - A.y, -(I.x - A.x), 0));
                    e.addQuad([{ coord: I, height: 0 }, { coord: A, height: 0 }, { coord: A, height: c[S.a] + 4 }, { coord: I, height: c[S.b] + 4 }], M), e.addQuad([{ coord: A, height: 0 }, { coord: I, height: 0 }, { coord: I, height: c[S.b] + 4 }, { coord: A, height: c[S.a] + 4 }], M);
                } }
                prepareEdgePoints(e, i, c, h) { let p = i[c.a], m = i[c.b]; const x = h(p, 0), b = h(m, 0); if (x && b)
                    return [{ coord: e[c.a], height: p }, { coord: e[c.b], height: m }]; if (!x && !b)
                    return; const S = e[c.a].clone(), A = e[c.b].clone(); if (x) {
                    if (!b) {
                        const I = m / (m - p);
                        A.x = nr(A.x, S.x, I), A.y = nr(A.y, S.y, I), m = nr(m, p, I);
                    }
                }
                else {
                    const I = p / (p - m);
                    S.x = nr(S.x, A.x, I), S.y = nr(S.y, A.y, I), p = nr(p, m, I);
                } return [{ coord: S, height: p }, { coord: A, height: m }]; }
                prepareEdges(e, i) { if (i.length === 0)
                    return; i.sort((x, b) => x.hash === b.hash ? b.polygonIdx - x.polygonIdx : b.hash > x.hash ? 1 : -1); let c = 0, h = 0, p = 0, m = i[c].polygonIdx; do
                    h++, (h === i.length || i[c].hash !== i[h].hash) && ((h - c == 1 || i[h - 1].polygonIdx !== m) && (p < c && (i[p] = i[c], i[c] = null), i[p].type = "none", p++), c = h, c !== i.length && (m = i[c].polygonIdx));
                while (c !== i.length); if (i.splice(p), i.length !== 0 && e.length !== 0) {
                    i.sort((S, A) => S.portalHash < A.portalHash ? 1 : -1);
                    let x = 0, b = 0;
                    for (; x !== i.length && b !== e.length;) {
                        const S = i[x], A = e[b];
                        S.portalHash > A.hash ? x++ : A.hash > S.portalHash ? b++ : (S.type = A.type, x++);
                    }
                } }
                isOnBorder(e, i) { return e <= 0 && i <= 0 || e >= It && i >= It; }
                static computeEdgeHash(e, i) { return (e.y === i.y && e.x > i.x || e.y > i.y) && ([e, i] = [i, e]), BigInt(Bo.computePosHash(e)) << 32n | BigInt(Bo.computePosHash(i)); }
                static computePosHash(e) { return ((65535 & e.x) << 16 | 65535 & e.y) >>> 0; }
            }
            var pP, mP = { exports: {} }, gP = (pP || (pP = 1, function (a, e) { (function (i) { function c(he, pe) { return he > pe ? 1 : he < pe ? -1 : 0; } var h = function (he, pe) { he === void 0 && (he = c), pe === void 0 && (pe = !1), this._compare = he, this._root = null, this._size = 0, this._noDuplicates = !!pe; }, p = { size: { configurable: !0 } }; function m(he, pe, Je, Tt, Lt) { var Dt = Lt - Tt; if (Dt > 0) {
                var Ht = Tt + Math.floor(Dt / 2), lr = { key: pe[Ht], data: Je[Ht], parent: he };
                return lr.left = m(lr, pe, Je, Tt, Ht), lr.right = m(lr, pe, Je, Ht + 1, Lt), lr;
            } return null; } function x(he, pe, Je, Tt, Lt) { if (!(Je >= Tt)) {
                for (var Dt = he[Je + Tt >> 1], Ht = Je - 1, lr = Tt + 1;;) {
                    do
                        Ht++;
                    while (Lt(he[Ht], Dt) < 0);
                    do
                        lr--;
                    while (Lt(he[lr], Dt) > 0);
                    if (Ht >= lr)
                        break;
                    var Vr = he[Ht];
                    he[Ht] = he[lr], he[lr] = Vr, Vr = pe[Ht], pe[Ht] = pe[lr], pe[lr] = Vr;
                }
                x(he, pe, Je, lr, Lt), x(he, pe, lr + 1, Tt, Lt);
            } } h.prototype.rotateLeft = function (he) { var pe = he.right; pe && (he.right = pe.left, pe.left && (pe.left.parent = he), pe.parent = he.parent), he.parent ? he === he.parent.left ? he.parent.left = pe : he.parent.right = pe : this._root = pe, pe && (pe.left = he), he.parent = pe; }, h.prototype.rotateRight = function (he) { var pe = he.left; pe && (he.left = pe.right, pe.right && (pe.right.parent = he), pe.parent = he.parent), he.parent ? he === he.parent.left ? he.parent.left = pe : he.parent.right = pe : this._root = pe, pe && (pe.right = he), he.parent = pe; }, h.prototype._splay = function (he) { for (; he.parent;) {
                var pe = he.parent;
                pe.parent ? pe.left === he && pe.parent.left === pe ? (this.rotateRight(pe.parent), this.rotateRight(pe)) : pe.right === he && pe.parent.right === pe ? (this.rotateLeft(pe.parent), this.rotateLeft(pe)) : pe.left === he && pe.parent.right === pe ? (this.rotateRight(pe), this.rotateLeft(pe)) : (this.rotateLeft(pe), this.rotateRight(pe)) : pe.left === he ? this.rotateRight(pe) : this.rotateLeft(pe);
            } }, h.prototype.splay = function (he) { for (var pe, Je, Tt, Lt, Dt; he.parent;)
                (Je = (pe = he.parent).parent) && Je.parent ? ((Tt = Je.parent).left === Je ? Tt.left = he : Tt.right = he, he.parent = Tt) : (he.parent = null, this._root = he), Lt = he.left, Dt = he.right, he === pe.left ? (Je && (Je.left === pe ? (pe.right ? (Je.left = pe.right, Je.left.parent = Je) : Je.left = null, pe.right = Je, Je.parent = pe) : (Lt ? (Je.right = Lt, Lt.parent = Je) : Je.right = null, he.left = Je, Je.parent = he)), Dt ? (pe.left = Dt, Dt.parent = pe) : pe.left = null, he.right = pe, pe.parent = he) : (Je && (Je.right === pe ? (pe.left ? (Je.right = pe.left, Je.right.parent = Je) : Je.right = null, pe.left = Je, Je.parent = pe) : (Dt ? (Je.left = Dt, Dt.parent = Je) : Je.left = null, he.right = Je, Je.parent = he)), Lt ? (pe.right = Lt, Lt.parent = pe) : pe.right = null, he.left = pe, pe.parent = he); }, h.prototype.replace = function (he, pe) { he.parent ? he === he.parent.left ? he.parent.left = pe : he.parent.right = pe : this._root = pe, pe && (pe.parent = he.parent); }, h.prototype.minNode = function (he) { if (he === void 0 && (he = this._root), he)
                for (; he.left;)
                    he = he.left; return he; }, h.prototype.maxNode = function (he) { if (he === void 0 && (he = this._root), he)
                for (; he.right;)
                    he = he.right; return he; }, h.prototype.insert = function (he, pe) { var Je = this._root, Tt = null, Lt = this._compare; if (this._noDuplicates)
                for (; Je;) {
                    if (Tt = Je, Lt(Je.key, he) === 0)
                        return;
                    Je = Lt(Je.key, he) < 0 ? Je.right : Je.left;
                }
            else
                for (; Je;)
                    Tt = Je, Je = Lt(Je.key, he) < 0 ? Je.right : Je.left; return Je = { key: he, data: pe, left: null, right: null, parent: Tt }, Tt ? Lt(Tt.key, Je.key) < 0 ? Tt.right = Je : Tt.left = Je : this._root = Je, this.splay(Je), this._size++, Je; }, h.prototype.find = function (he) { for (var pe = this._root, Je = this._compare; pe;) {
                var Tt = Je(pe.key, he);
                if (Tt < 0)
                    pe = pe.right;
                else {
                    if (!(Tt > 0))
                        return pe;
                    pe = pe.left;
                }
            } return null; }, h.prototype.contains = function (he) { for (var pe = this._root, Je = this._compare; pe;) {
                var Tt = Je(he, pe.key);
                if (Tt === 0)
                    return !0;
                pe = Tt < 0 ? pe.left : pe.right;
            } return !1; }, h.prototype.remove = function (he) { var pe = this.find(he); if (!pe)
                return !1; if (this.splay(pe), pe.left)
                if (pe.right) {
                    var Je = this.minNode(pe.right);
                    Je.parent !== pe && (this.replace(Je, Je.right), Je.right = pe.right, Je.right.parent = Je), this.replace(pe, Je), Je.left = pe.left, Je.left.parent = Je;
                }
                else
                    this.replace(pe, pe.left);
            else
                this.replace(pe, pe.right); return this._size--, !0; }, h.prototype.removeNode = function (he) { if (!he)
                return !1; if (this.splay(he), he.left)
                if (he.right) {
                    var pe = this.minNode(he.right);
                    pe.parent !== he && (this.replace(pe, pe.right), pe.right = he.right, pe.right.parent = pe), this.replace(he, pe), pe.left = he.left, pe.left.parent = pe;
                }
                else
                    this.replace(he, he.left);
            else
                this.replace(he, he.right); return this._size--, !0; }, h.prototype.erase = function (he) { var pe = this.find(he); if (pe) {
                this.splay(pe);
                var Je = pe.left, Tt = pe.right, Lt = null;
                Je && (Je.parent = null, Lt = this.maxNode(Je), this.splay(Lt), this._root = Lt), Tt && (Je ? Lt.right = Tt : this._root = Tt, Tt.parent = Lt), this._size--;
            } }, h.prototype.pop = function () { var he = this._root, pe = null; if (he) {
                for (; he.left;)
                    he = he.left;
                pe = { key: he.key, data: he.data }, this.remove(he.key);
            } return pe; }, h.prototype.next = function (he) { var pe = he; if (pe)
                if (pe.right)
                    for (pe = pe.right; pe && pe.left;)
                        pe = pe.left;
                else
                    for (pe = he.parent; pe && pe.right === he;)
                        he = pe, pe = pe.parent; return pe; }, h.prototype.prev = function (he) { var pe = he; if (pe)
                if (pe.left)
                    for (pe = pe.left; pe && pe.right;)
                        pe = pe.right;
                else
                    for (pe = he.parent; pe && pe.left === he;)
                        he = pe, pe = pe.parent; return pe; }, h.prototype.forEach = function (he) { for (var pe = this._root, Je = [], Tt = !1, Lt = 0; !Tt;)
                pe ? (Je.push(pe), pe = pe.left) : Je.length > 0 ? (he(pe = Je.pop(), Lt++), pe = pe.right) : Tt = !0; return this; }, h.prototype.range = function (he, pe, Je, Tt) { for (var Lt = [], Dt = this._compare, Ht = this._root; Lt.length !== 0 || Ht;)
                if (Ht)
                    Lt.push(Ht), Ht = Ht.left;
                else {
                    if (Dt((Ht = Lt.pop()).key, pe) > 0)
                        break;
                    if (Dt(Ht.key, he) >= 0 && Je.call(Tt, Ht))
                        return this;
                    Ht = Ht.right;
                } return this; }, h.prototype.keys = function () { for (var he = this._root, pe = [], Je = [], Tt = !1; !Tt;)
                he ? (pe.push(he), he = he.left) : pe.length > 0 ? (he = pe.pop(), Je.push(he.key), he = he.right) : Tt = !0; return Je; }, h.prototype.values = function () { for (var he = this._root, pe = [], Je = [], Tt = !1; !Tt;)
                he ? (pe.push(he), he = he.left) : pe.length > 0 ? (he = pe.pop(), Je.push(he.data), he = he.right) : Tt = !0; return Je; }, h.prototype.at = function (he) { for (var pe = this._root, Je = [], Tt = !1, Lt = 0; !Tt;)
                if (pe)
                    Je.push(pe), pe = pe.left;
                else if (Je.length > 0) {
                    if (pe = Je.pop(), Lt === he)
                        return pe;
                    Lt++, pe = pe.right;
                }
                else
                    Tt = !0; return null; }, h.prototype.load = function (he, pe, Je) { if (he === void 0 && (he = []), pe === void 0 && (pe = []), Je === void 0 && (Je = !1), this._size !== 0)
                throw new Error("bulk-load: tree is not empty"); var Tt = he.length; return Je && x(he, pe, 0, Tt - 1, this._compare), this._root = m(null, he, pe, 0, Tt), this._size = Tt, this; }, h.prototype.min = function () { var he = this.minNode(this._root); return he ? he.key : null; }, h.prototype.max = function () { var he = this.maxNode(this._root); return he ? he.key : null; }, h.prototype.isEmpty = function () { return this._root === null; }, p.size.get = function () { return this._size; }, h.createTree = function (he, pe, Je, Tt, Lt) { return new h(Je, Lt).load(he, pe, Tt); }, Object.defineProperties(h.prototype, p); var b = 0, S = 1, A = 2, I = 3, M = 0, z = 1, F = 2, U = 3; function X(he, pe, Je) { pe === null ? (he.inOut = !1, he.otherInOut = !0) : (he.isSubject === pe.isSubject ? (he.inOut = !pe.inOut, he.otherInOut = pe.otherInOut) : (he.inOut = !pe.otherInOut, he.otherInOut = pe.isVertical() ? !pe.inOut : pe.inOut), pe && (he.prevInResult = !Y(pe, Je) || pe.isVertical() ? pe.prevInResult : pe)); var Tt = Y(he, Je); he.resultTransition = Tt ? function (Lt, Dt) { var Ht, lr = !Lt.inOut, Vr = !Lt.otherInOut; switch (Dt) {
                case M:
                    Ht = lr && Vr;
                    break;
                case z:
                    Ht = lr || Vr;
                    break;
                case U:
                    Ht = lr ^ Vr;
                    break;
                case F: Ht = Lt.isSubject ? lr && !Vr : Vr && !lr;
            } return Ht ? 1 : -1; }(he, Je) : 0; } function Y(he, pe) { switch (he.type) {
                case b:
                    switch (pe) {
                        case M: return !he.otherInOut;
                        case z: return he.otherInOut;
                        case F: return he.isSubject && he.otherInOut || !he.isSubject && !he.otherInOut;
                        case U: return !0;
                    }
                    break;
                case A: return pe === M || pe === z;
                case I: return pe === F;
                case S: return !1;
            } return !1; } var le = function (he, pe, Je, Tt, Lt) { this.left = pe, this.point = he, this.otherEvent = Je, this.isSubject = Tt, this.type = Lt || b, this.inOut = !1, this.otherInOut = !1, this.prevInResult = null, this.resultTransition = 0, this.otherPos = -1, this.outputContourId = -1, this.isExteriorRing = !0; }, se = { inResult: { configurable: !0 } }; function $(he, pe) { return he[0] === pe[0] && he[1] === pe[1]; } le.prototype.isBelow = function (he) { var pe = this.point, Je = this.otherEvent.point; return this.left ? (pe[0] - he[0]) * (Je[1] - he[1]) - (Je[0] - he[0]) * (pe[1] - he[1]) > 0 : (Je[0] - he[0]) * (pe[1] - he[1]) - (pe[0] - he[0]) * (Je[1] - he[1]) > 0; }, le.prototype.isAbove = function (he) { return !this.isBelow(he); }, le.prototype.isVertical = function () { return this.point[0] === this.otherEvent.point[0]; }, se.inResult.get = function () { return this.resultTransition !== 0; }, le.prototype.clone = function () { var he = new le(this.point, this.left, this.otherEvent, this.isSubject, this.type); return he.contourId = this.contourId, he.resultTransition = this.resultTransition, he.prevInResult = this.prevInResult, he.isExteriorRing = this.isExteriorRing, he.inOut = this.inOut, he.otherInOut = this.otherInOut, he; }, Object.defineProperties(le.prototype, se); var te = 11102230246251565e-32, ae = 134217729, fe = (3 + 8 * te) * te; function Te(he, pe, Je, Tt, Lt) { var Dt, Ht, lr, Vr, Ur = pe[0], Ir = Tt[0], pn = 0, Pn = 0; Ir > Ur == Ir > -Ur ? (Dt = Ur, Ur = pe[++pn]) : (Dt = Ir, Ir = Tt[++Pn]); var $r = 0; if (pn < he && Pn < Je)
                for (Ir > Ur == Ir > -Ur ? (lr = Dt - ((Ht = Ur + Dt) - Ur), Ur = pe[++pn]) : (lr = Dt - ((Ht = Ir + Dt) - Ir), Ir = Tt[++Pn]), Dt = Ht, lr !== 0 && (Lt[$r++] = lr); pn < he && Pn < Je;)
                    Ir > Ur == Ir > -Ur ? (lr = Dt - ((Ht = Dt + Ur) - (Vr = Ht - Dt)) + (Ur - Vr), Ur = pe[++pn]) : (lr = Dt - ((Ht = Dt + Ir) - (Vr = Ht - Dt)) + (Ir - Vr), Ir = Tt[++Pn]), Dt = Ht, lr !== 0 && (Lt[$r++] = lr); for (; pn < he;)
                lr = Dt - ((Ht = Dt + Ur) - (Vr = Ht - Dt)) + (Ur - Vr), Ur = pe[++pn], Dt = Ht, lr !== 0 && (Lt[$r++] = lr); for (; Pn < Je;)
                lr = Dt - ((Ht = Dt + Ir) - (Vr = Ht - Dt)) + (Ir - Vr), Ir = Tt[++Pn], Dt = Ht, lr !== 0 && (Lt[$r++] = lr); return Dt === 0 && $r !== 0 || (Lt[$r++] = Dt), $r; } function Pe(he) { return new Float64Array(he); } var Me = 33306690738754716e-32, Oe = 22204460492503146e-32, Ye = 11093356479670487e-47, ut = Pe(4), it = Pe(8), lt = Pe(12), pt = Pe(16), We = Pe(4); function at(he, pe, Je) { var Tt = function (Lt, Dt, Ht, lr, Vr, Ur) { var Ir = (Dt - Ur) * (Ht - Vr), pn = (Lt - Vr) * (lr - Ur), Pn = Ir - pn; if (Ir === 0 || pn === 0 || Ir > 0 != pn > 0)
                return Pn; var $r = Math.abs(Ir + pn); return Math.abs(Pn) >= Me * $r ? Pn : -function (ri, zn, hn, yi, Vn, Mn, Fn) { var _n, kr, wn, ni, ar, Zr, Un, di, Zn, ki, Sn, Pi, no, fs, ls, io, Wl, Di, Vi = ri - Vn, ps = hn - Vn, Ls = zn - Mn, xs = yi - Mn; ut[0] = (ls = (di = Vi - (Un = (Zr = ae * Vi) - (Zr - Vi))) * (ki = xs - (Zn = (Zr = ae * xs) - (Zr - xs))) - ((fs = Vi * xs) - Un * Zn - di * Zn - Un * ki)) - ((Sn = ls - (Wl = (di = Ls - (Un = (Zr = ae * Ls) - (Zr - Ls))) * (ki = ps - (Zn = (Zr = ae * ps) - (Zr - ps))) - ((io = Ls * ps) - Un * Zn - di * Zn - Un * ki))) + (ar = ls - Sn)) + (ar - Wl), ut[1] = (no = fs - ((Pi = fs + Sn) - (ar = Pi - fs)) + (Sn - ar)) - ((Sn = no - io) + (ar = no - Sn)) + (ar - io), ut[2] = Pi - ((Di = Pi + Sn) - (ar = Di - Pi)) + (Sn - ar), ut[3] = Di; var sh = function (iee, wk) { for (var bk = wk[0], $S = 1; $S < 4; $S++)
                bk += wk[$S]; return bk; }(0, ut), wy = Oe * Fn; if (sh >= wy || -sh >= wy || (_n = ri - (Vi + (ar = ri - Vi)) + (ar - Vn), wn = hn - (ps + (ar = hn - ps)) + (ar - Vn), kr = zn - (Ls + (ar = zn - Ls)) + (ar - Mn), ni = yi - (xs + (ar = yi - xs)) + (ar - Mn), _n === 0 && kr === 0 && wn === 0 && ni === 0) || (wy = Ye * Fn + fe * Math.abs(sh), (sh += Vi * ni + xs * _n - (Ls * wn + ps * kr)) >= wy || -sh >= wy))
                return sh; We[0] = (ls = (di = _n - (Un = (Zr = ae * _n) - (Zr - _n))) * (ki = xs - (Zn = (Zr = ae * xs) - (Zr - xs))) - ((fs = _n * xs) - Un * Zn - di * Zn - Un * ki)) - ((Sn = ls - (Wl = (di = kr - (Un = (Zr = ae * kr) - (Zr - kr))) * (ki = ps - (Zn = (Zr = ae * ps) - (Zr - ps))) - ((io = kr * ps) - Un * Zn - di * Zn - Un * ki))) + (ar = ls - Sn)) + (ar - Wl), We[1] = (no = fs - ((Pi = fs + Sn) - (ar = Pi - fs)) + (Sn - ar)) - ((Sn = no - io) + (ar = no - Sn)) + (ar - io), We[2] = Pi - ((Di = Pi + Sn) - (ar = Di - Pi)) + (Sn - ar), We[3] = Di; var PU = Te(4, ut, 4, We, it); We[0] = (ls = (di = Vi - (Un = (Zr = ae * Vi) - (Zr - Vi))) * (ki = ni - (Zn = (Zr = ae * ni) - (Zr - ni))) - ((fs = Vi * ni) - Un * Zn - di * Zn - Un * ki)) - ((Sn = ls - (Wl = (di = Ls - (Un = (Zr = ae * Ls) - (Zr - Ls))) * (ki = wn - (Zn = (Zr = ae * wn) - (Zr - wn))) - ((io = Ls * wn) - Un * Zn - di * Zn - Un * ki))) + (ar = ls - Sn)) + (ar - Wl), We[1] = (no = fs - ((Pi = fs + Sn) - (ar = Pi - fs)) + (Sn - ar)) - ((Sn = no - io) + (ar = no - Sn)) + (ar - io), We[2] = Pi - ((Di = Pi + Sn) - (ar = Di - Pi)) + (Sn - ar), We[3] = Di; var MU = Te(PU, it, 4, We, lt); We[0] = (ls = (di = _n - (Un = (Zr = ae * _n) - (Zr - _n))) * (ki = ni - (Zn = (Zr = ae * ni) - (Zr - ni))) - ((fs = _n * ni) - Un * Zn - di * Zn - Un * ki)) - ((Sn = ls - (Wl = (di = kr - (Un = (Zr = ae * kr) - (Zr - kr))) * (ki = wn - (Zn = (Zr = ae * wn) - (Zr - wn))) - ((io = kr * wn) - Un * Zn - di * Zn - Un * ki))) + (ar = ls - Sn)) + (ar - Wl), We[1] = (no = fs - ((Pi = fs + Sn) - (ar = Pi - fs)) + (Sn - ar)) - ((Sn = no - io) + (ar = no - Sn)) + (ar - io), We[2] = Pi - ((Di = Pi + Sn) - (ar = Di - Pi)) + (Sn - ar), We[3] = Di; var RU = Te(MU, lt, 4, We, pt); return pt[RU - 1]; }(Lt, Dt, Ht, lr, Vr, Ur, $r); }(he[0], he[1], pe[0], pe[1], Je[0], Je[1]); return Tt > 0 ? -1 : Tt < 0 ? 1 : 0; } function Ge(he, pe) { var Je = he.point, Tt = pe.point; return Je[0] > Tt[0] ? 1 : Je[0] < Tt[0] ? -1 : Je[1] !== Tt[1] ? Je[1] > Tt[1] ? 1 : -1 : function (Lt, Dt, Ht, lr) { return Lt.left !== Dt.left ? Lt.left ? 1 : -1 : at(Ht, Lt.otherEvent.point, Dt.otherEvent.point) !== 0 ? Lt.isBelow(Dt.otherEvent.point) ? -1 : 1 : !Lt.isSubject && Dt.isSubject ? 1 : -1; }(he, pe, Je); } function Xe(he, pe, Je) { var Tt = new le(pe, !1, he, he.isSubject), Lt = new le(pe, !0, he.otherEvent, he.isSubject); return $(he.point, he.otherEvent.point) && console.warn("what is that, a collapsed segment?", he), Tt.contourId = Lt.contourId = he.contourId, Ge(Lt, he.otherEvent) > 0 && (he.otherEvent.left = !0, Lt.left = !1), he.otherEvent.otherEvent = Lt, he.otherEvent = Tt, Je.push(Lt), Je.push(Tt), Je; } function gt(he, pe) { return he[0] * pe[1] - he[1] * pe[0]; } function yt(he, pe) { return he[0] * pe[0] + he[1] * pe[1]; } function Zt(he, pe, Je) { var Tt = function (Vr, Ur, Ir, pn, Pn) { var $r = [Ur[0] - Vr[0], Ur[1] - Vr[1]], ri = [pn[0] - Ir[0], pn[1] - Ir[1]]; function zn(Zr, Un, di) { return [Zr[0] + Un * di[0], Zr[1] + Un * di[1]]; } var hn = [Ir[0] - Vr[0], Ir[1] - Vr[1]], yi = gt($r, ri), Vn = yi * yi, Mn = yt($r, $r); if (Vn > 0) {
                var Fn = gt(hn, ri) / yi;
                if (Fn < 0 || Fn > 1)
                    return null;
                var _n = gt(hn, $r) / yi;
                return _n < 0 || _n > 1 ? null : Fn === 0 || Fn === 1 ? [zn(Vr, Fn, $r)] : _n === 0 || _n === 1 ? [zn(Ir, _n, ri)] : [zn(Vr, Fn, $r)];
            } if ((Vn = (yi = gt(hn, $r)) * yi) > 0)
                return null; var kr = yt($r, hn) / Mn, wn = kr + yt($r, ri) / Mn, ni = Math.min(kr, wn), ar = Math.max(kr, wn); return ni <= 1 && ar >= 0 ? ni === 1 ? [zn(Vr, ni > 0 ? ni : 0, $r)] : ar === 0 ? [zn(Vr, ar < 1 ? ar : 1, $r)] : [zn(Vr, ni > 0 ? ni : 0, $r), zn(Vr, ar < 1 ? ar : 1, $r)] : null; }(he.point, he.otherEvent.point, pe.point, pe.otherEvent.point), Lt = Tt ? Tt.length : 0; if (Lt === 0 || Lt === 1 && ($(he.point, pe.point) || $(he.otherEvent.point, pe.otherEvent.point)) || Lt === 2 && he.isSubject === pe.isSubject)
                return 0; if (Lt === 1)
                return $(he.point, Tt[0]) || $(he.otherEvent.point, Tt[0]) || Xe(he, Tt[0], Je), $(pe.point, Tt[0]) || $(pe.otherEvent.point, Tt[0]) || Xe(pe, Tt[0], Je), 1; var Dt = [], Ht = !1, lr = !1; return $(he.point, pe.point) ? Ht = !0 : Ge(he, pe) === 1 ? Dt.push(pe, he) : Dt.push(he, pe), $(he.otherEvent.point, pe.otherEvent.point) ? lr = !0 : Ge(he.otherEvent, pe.otherEvent) === 1 ? Dt.push(pe.otherEvent, he.otherEvent) : Dt.push(he.otherEvent, pe.otherEvent), Ht && lr || Ht ? (pe.type = S, he.type = pe.inOut === he.inOut ? A : I, Ht && !lr && Xe(Dt[1].otherEvent, Dt[0].point, Je), 2) : lr ? (Xe(Dt[0], Dt[1].point, Je), 3) : Dt[0] !== Dt[3].otherEvent ? (Xe(Dt[0], Dt[1].point, Je), Xe(Dt[1], Dt[2].point, Je), 3) : (Xe(Dt[0], Dt[1].point, Je), Xe(Dt[3].otherEvent, Dt[2].point, Je), 3); } function jt(he, pe) { if (he === pe)
                return 0; if (at(he.point, he.otherEvent.point, pe.point) !== 0 || at(he.point, he.otherEvent.point, pe.otherEvent.point) !== 0)
                return $(he.point, pe.point) ? he.isBelow(pe.otherEvent.point) ? -1 : 1 : he.point[0] === pe.point[0] ? he.point[1] < pe.point[1] ? -1 : 1 : Ge(he, pe) === 1 ? pe.isAbove(he.point) ? -1 : 1 : he.isBelow(pe.point) ? -1 : 1; if (he.isSubject !== pe.isSubject)
                return he.isSubject ? -1 : 1; var Je = he.point, Tt = pe.point; return Je[0] === Tt[0] && Je[1] === Tt[1] ? (Je = he.otherEvent.point)[0] === (Tt = pe.otherEvent.point)[0] && Je[1] === Tt[1] ? 0 : he.contourId > pe.contourId ? 1 : -1 : Ge(he, pe) === 1 ? 1 : -1; } var Rt = function () { this.points = [], this.holeIds = [], this.holeOf = null, this.depth = null; }; function mt(he, pe, Je, Tt) { var Lt, Dt = he + 1, Ht = pe[he].point, lr = pe.length; for (Dt < lr && (Lt = pe[Dt].point); Dt < lr && Lt[0] === Ht[0] && Lt[1] === Ht[1];) {
                if (!Je[Dt])
                    return Dt;
                ++Dt < lr && (Lt = pe[Dt].point);
            } for (Dt = he - 1; Je[Dt] && Dt > Tt;)
                Dt--; return Dt; } Rt.prototype.isExterior = function () { return this.holeOf == null; }; var pr = qt, Gt = qt; function qt(he, pe) { if (!(this instanceof qt))
                return new qt(he, pe); if (this.data = he || [], this.length = this.data.length, this.compare = pe || hr, this.length > 0)
                for (var Je = (this.length >> 1) - 1; Je >= 0; Je--)
                    this._down(Je); } function hr(he, pe) { return he < pe ? -1 : he > pe ? 1 : 0; } qt.prototype = { push: function (he) { this.data.push(he), this.length++, this._up(this.length - 1); }, pop: function () { if (this.length !== 0) {
                    var he = this.data[0];
                    return this.length--, this.length > 0 && (this.data[0] = this.data[this.length], this._down(0)), this.data.pop(), he;
                } }, peek: function () { return this.data[0]; }, _up: function (he) { for (var pe = this.data, Je = this.compare, Tt = pe[he]; he > 0;) {
                    var Lt = he - 1 >> 1, Dt = pe[Lt];
                    if (Je(Tt, Dt) >= 0)
                        break;
                    pe[he] = Dt, he = Lt;
                } pe[he] = Tt; }, _down: function (he) { for (var pe = this.data, Je = this.compare, Tt = this.length >> 1, Lt = pe[he]; he < Tt;) {
                    var Dt = 1 + (he << 1), Ht = Dt + 1, lr = pe[Dt];
                    if (Ht < this.length && Je(pe[Ht], lr) < 0 && (Dt = Ht, lr = pe[Ht]), Je(lr, Lt) >= 0)
                        break;
                    pe[he] = lr, he = Dt;
                } pe[he] = Lt; } }, pr.default = Gt; var wr = Math.max, Tr = Math.min, Lr = 0; function Pr(he, pe, Je, Tt, Lt, Dt) { var Ht, lr, Vr, Ur, Ir, pn; for (Ht = 0, lr = he.length - 1; Ht < lr; Ht++)
                if (Ur = he[Ht + 1], Ir = new le(Vr = he[Ht], !1, void 0, pe), pn = new le(Ur, !1, Ir, pe), Ir.otherEvent = pn, Vr[0] !== Ur[0] || Vr[1] !== Ur[1]) {
                    Ir.contourId = pn.contourId = Je, Dt || (Ir.isExteriorRing = !1, pn.isExteriorRing = !1), Ge(Ir, pn) > 0 ? pn.left = !0 : Ir.left = !0;
                    var Pn = Vr[0], $r = Vr[1];
                    Lt[0] = Tr(Lt[0], Pn), Lt[1] = Tr(Lt[1], $r), Lt[2] = wr(Lt[2], Pn), Lt[3] = wr(Lt[3], $r), Tt.push(Ir), Tt.push(pn);
                } } var Ar = []; function Tn(he, pe, Je) { typeof he[0][0][0] == "number" && (he = [he]), typeof pe[0][0][0] == "number" && (pe = [pe]); var Tt = function ($r, ri, zn) { var hn = null; return $r.length * ri.length == 0 && (zn === M ? hn = Ar : zn === F ? hn = $r : zn !== z && zn !== U || (hn = $r.length === 0 ? ri : $r)), hn; }(he, pe, Je); if (Tt)
                return Tt === Ar ? null : Tt; var Lt = [1 / 0, 1 / 0, -1 / 0, -1 / 0], Dt = [1 / 0, 1 / 0, -1 / 0, -1 / 0], Ht = function ($r, ri, zn, hn, yi) { var Vn, Mn, Fn, _n, kr, wn, ni = new pr(null, Ge); for (Fn = 0, _n = $r.length; Fn < _n; Fn++)
                for (kr = 0, wn = (Vn = $r[Fn]).length; kr < wn; kr++)
                    (Mn = kr === 0) && Lr++, Pr(Vn[kr], !0, Lr, ni, zn, Mn); for (Fn = 0, _n = ri.length; Fn < _n; Fn++)
                for (kr = 0, wn = (Vn = ri[Fn]).length; kr < wn; kr++)
                    Mn = kr === 0, yi === F && (Mn = !1), Mn && Lr++, Pr(Vn[kr], !1, Lr, ni, hn, Mn); return ni; }(he, pe, Lt, Dt, Je); if (Tt = function ($r, ri, zn, hn, yi) { var Vn = null; return (zn[0] > hn[2] || hn[0] > zn[2] || zn[1] > hn[3] || hn[1] > zn[3]) && (yi === M ? Vn = Ar : yi === F ? Vn = $r : yi !== z && yi !== U || (Vn = $r.concat(ri))), Vn; }(he, pe, Lt, Dt, Je))
                return Tt === Ar ? null : Tt; for (var lr = function ($r) { var ri, zn, hn = function (Fn) { var _n, kr, wn, ni, ar = []; for (kr = 0, wn = Fn.length; kr < wn; kr++)
                ((_n = Fn[kr]).left && _n.inResult || !_n.left && _n.otherEvent.inResult) && ar.push(_n); for (var Zr = !1; !Zr;)
                for (Zr = !0, kr = 0, wn = ar.length; kr < wn; kr++)
                    kr + 1 < wn && Ge(ar[kr], ar[kr + 1]) === 1 && (ni = ar[kr], ar[kr] = ar[kr + 1], ar[kr + 1] = ni, Zr = !1); for (kr = 0, wn = ar.length; kr < wn; kr++)
                (_n = ar[kr]).otherPos = kr; for (kr = 0, wn = ar.length; kr < wn; kr++)
                (_n = ar[kr]).left || (ni = _n.otherPos, _n.otherPos = _n.otherEvent.otherPos, _n.otherEvent.otherPos = ni); return ar; }($r), yi = {}, Vn = [], Mn = function () { if (!yi[ri]) {
                var Fn = Vn.length, _n = function (ar, Zr, Un) { var di = new Rt; if (ar.prevInResult != null) {
                    var Zn = ar.prevInResult, ki = Zn.outputContourId;
                    if (Zn.resultTransition > 0) {
                        var Sn = Zr[ki];
                        if (Sn.holeOf != null) {
                            var Pi = Sn.holeOf;
                            Zr[Pi].holeIds.push(Un), di.holeOf = Pi, di.depth = Zr[ki].depth;
                        }
                        else
                            Zr[ki].holeIds.push(Un), di.holeOf = ki, di.depth = Zr[ki].depth + 1;
                    }
                    else
                        di.holeOf = null, di.depth = Zr[ki].depth;
                }
                else
                    di.holeOf = null, di.depth = 0; return di; }(hn[ri], Vn, Fn), kr = function (ar) { yi[ar] = !0, ar < hn.length && hn[ar] && (hn[ar].outputContourId = Fn); }, wn = ri, ni = ri;
                for (_n.points.push(hn[ri].point); kr(wn), kr(wn = hn[wn].otherPos), _n.points.push(hn[wn].point), !((wn = mt(wn, hn, yi, ni)) == ni || wn >= hn.length) && hn[wn];)
                    ;
                Vn.push(_n);
            } }; for (ri = 0, zn = hn.length; ri < zn; ri++)
                Mn(); return Vn; }(function ($r, ri, zn, hn, yi, Vn) { for (var Mn, Fn, _n, kr = new h(jt), wn = [], ni = Math.min(hn[2], yi[2]); $r.length !== 0;) {
                var ar = $r.pop();
                if (wn.push(ar), Vn === M && ar.point[0] > ni || Vn === F && ar.point[0] > hn[2])
                    break;
                if (ar.left) {
                    Fn = Mn = kr.insert(ar), Mn = Mn !== (_n = kr.minNode()) ? kr.prev(Mn) : null, Fn = kr.next(Fn);
                    var Zr = Mn ? Mn.key : null;
                    if (X(ar, Zr, Vn), Fn && Zt(ar, Fn.key, $r) === 2 && (X(ar, Zr, Vn), X(Fn.key, ar, Vn)), Mn && Zt(Mn.key, ar, $r) === 2) {
                        var Un = Mn;
                        X(Zr, (Un = Un !== _n ? kr.prev(Un) : null) ? Un.key : null, Vn), X(ar, Zr, Vn);
                    }
                }
                else
                    Fn = Mn = kr.find(ar = ar.otherEvent), Mn && Fn && (Mn = Mn !== _n ? kr.prev(Mn) : null, Fn = kr.next(Fn), kr.remove(ar), Fn && Mn && Zt(Mn.key, Fn.key, $r));
            } return wn; }(Ht, 0, 0, Lt, Dt, Je)), Vr = [], Ur = 0; Ur < lr.length; Ur++) {
                var Ir = lr[Ur];
                if (Ir.isExterior()) {
                    for (var pn = [Ir.points], Pn = 0; Pn < Ir.holeIds.length; Pn++)
                        pn.push(lr[Ir.holeIds[Pn]].points);
                    Vr.push(pn);
                }
            } return Vr; } var On = { UNION: z, DIFFERENCE: F, INTERSECTION: M, XOR: U }; i.diff = function (he, pe) { return Tn(he, pe, F); }, i.intersection = function (he, pe) { return Tn(he, pe, M); }, i.operations = On, i.union = function (he, pe) { return Tn(he, pe, z); }, i.xor = function (he, pe) { return Tn(he, pe, U); }, Object.defineProperty(i, "__esModule", { value: !0 }); })(e); }(0, mP.exports)), mP.exports); /**
     * martinez v0.7.4
     * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor
     *
     * @author Alex Milevski <info@w8r.name>
     * @license MIT
     * @preserve
     */
            function Sx(a, e, i, c) { const h = [], p = c === 0 ? (m, x, b, S, A, I) => { m.push(new Et(I, b + (I - x) / (S - x) * (A - b))); } : (m, x, b, S, A, I) => { m.push(new Et(x + (I - b) / (A - b) * (S - x), I)); }; for (const m of a) {
                const x = [];
                for (const b of m) {
                    if (b.length <= 2)
                        continue;
                    const S = [];
                    for (let M = 0; M < b.length - 1; M++) {
                        const z = b[M].x, F = b[M].y, U = b[M + 1].x, X = b[M + 1].y, Y = c === 0 ? z : F, le = c === 0 ? U : X;
                        Y < e ? le > e && p(S, z, F, U, X, e) : Y > i ? le < i && p(S, z, F, U, X, i) : S.push(b[M]), le < e && Y >= e && p(S, z, F, U, X, e), le > i && Y <= i && p(S, z, F, U, X, i);
                    }
                    let A = b[b.length - 1];
                    const I = c === 0 ? A.x : A.y;
                    I >= e && I <= i && S.push(A), S.length && (A = S[S.length - 1], S[0].x === A.x && S[0].y === A.y || S.push(S[0]), x.push(S));
                }
                x.length && h.push(x);
            } return h; }
            function W4(a, e) { const i = jT(a), c = jT([e]), h = gP.intersection(i, c); return h == null ? [] : _P(h); }
            function Z4(a, e) { let c = jT(a, 65536); for (; e.valid(); e.next()) {
                const [h, p] = e.get(), m = h.x * 65536, x = h.y * 65536, b = p.x * 65536, S = p.y * 65536, A = b - m, I = S - x, M = Math.hypot(A, I), z = Math.trunc(I / M * 3), F = -Math.trunc(A / M * 3);
                c = gP.diff(c, [[[m, x], [b, S], [b + z, S + F], [m + z, x + F], [m, x]]]);
            } return _P(c, 1 / 65536); }
            function jT(a, e = 1) { return [a.map(i => i.map(c => [c.x * e, c.y * e]))]; }
            function _P(a, e = 1) { return a.map(i => i.map((c, h) => { const p = c.map(m => new Et(m[0] * e, m[1] * e).round()); return h > 0 && p.reverse(), p; })); }
            class VT {
                constructor(e, i) { this.layoutVertexArray = new Ja, this.indexArray = new Hi, this.lineIndexArray = new Vl, this.triangleSegments = new ti, this.lineSegments = new ti, this.programConfigurations = new Uc(e.layers, { zoom: e.zoom, lut: e.lut }), this.uploaded = !1, i && (this.elevatedLayoutVertexArray = new Vu); }
                update(e, i, c, h, p, m, x) { this.programConfigurations.updatePaintArrays(e, i, p, c, h, m, x); }
                isEmpty() { return this.layoutVertexArray.length === 0; }
                needsUpload() { return this.programConfigurations.needsUpload; }
                upload(e) { this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, P4.members), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.lineIndexBuffer = e.createIndexBuffer(this.lineIndexArray), this.elevatedLayoutVertexArray && this.elevatedLayoutVertexArray.length > 0 && (this.elevatedLayoutVertexBuffer = e.createVertexBuffer(this.elevatedLayoutVertexArray, M4.members))), this.programConfigurations.upload(e), this.uploaded = !0; }
                destroy() { this.layoutVertexBuffer && (this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.lineIndexBuffer.destroy(), this.programConfigurations.destroy(), this.triangleSegments.destroy(), this.lineSegments.destroy()); }
                populatePaintArrays(e, i, c, h, p, m) { this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, c, h, p, m); }
            }
            class UT {
                constructor(e) { this.zoom = e.zoom, this.pixelRatio = e.pixelRatio, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(i => i.fqid), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.bufferData = new VT(e, !1), this.elevationBufferData = new VT(e, !0), this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id), this.projection = e.projection, this.elevationMode = this.layers[0].layout.get("fill-elevation-reference"); }
                updateFootprints(e, i) { }
                populate(e, i, c, h) { this.hasPattern = DT("fill", this.layers, this.pixelRatio, i); const p = this.layers[0].layout.get("fill-sort-key"), m = []; for (const { feature: x, id: b, index: S, sourceLayerIndex: A } of e) {
                    const I = this.layers[0]._featureFilter.needGeometry, M = Xt(x, I);
                    if (!this.layers[0]._featureFilter.filter(new yn(this.zoom), M, c))
                        continue;
                    const z = p ? p.evaluate(M, {}, c, i.availableImages) : void 0, F = { id: b, properties: x.properties, type: x.type, sourceLayerIndex: A, index: S, geometry: I ? M.geometry : Vt(x, c, h), patterns: {}, sortKey: z };
                    m.push(F);
                } p && m.sort((x, b) => x.sortKey - b.sortKey); for (const x of m) {
                    const { geometry: b, index: S, sourceLayerIndex: A } = x;
                    if (this.hasPattern) {
                        const I = LT("fill", this.layers, x, this.zoom, this.pixelRatio, i);
                        this.patternFeatures.push(I);
                    }
                    else
                        this.addFeature(x, b, S, c, {}, i.availableImages, i.brightness, i.elevationFeatures);
                    i.featureIndex.insert(e[S].feature, b, S, A, this.index);
                } }
                update(e, i, c, h, p, m, x) { this.bufferData.update(e, i, c, h, p, m, x), this.elevationBufferData.update(e, i, c, h, p, m, x); }
                addFeatures(e, i, c, h, p, m) { for (const x of this.patternFeatures)
                    this.addFeature(x, x.geometry, x.index, i, c, h, m, e.elevationFeatures); }
                isEmpty() { return this.bufferData.isEmpty() && this.elevationBufferData.isEmpty(); }
                uploadPending() { return !this.uploaded || this.bufferData.needsUpload() || this.elevationBufferData.needsUpload(); }
                upload(e) { this.bufferData.upload(e), this.elevationBufferData.upload(e), this.elevatedStructures && this.elevatedStructures.upload(e); }
                destroy() { this.bufferData.destroy(), this.elevationBufferData.destroy(), this.elevatedStructures && this.elevatedStructures.destroy(); }
                addFeature(e, i, c, h, p, m = [], x, b) { const S = bx(i, 500); this.elevationMode !== "none" ? this.addElevatedRoadFeature(e, S, h, c, b) : this.addGeometry(S, this.bufferData), this.bufferData.populatePaintArrays(e, c, p, m, h, x), this.elevationBufferData.populatePaintArrays(e, c, p, m, h, x); }
                getUnevaluatedPortalGraph() { return this.elevatedStructures ? this.elevatedStructures.unevaluatedPortals : void 0; }
                getElevationPolygons() { return this.elevatedStructures ? this.elevatedStructures.portalPolygons : void 0; }
                setEvaluatedPortalGraph(e) { this.elevatedStructures && this.elevatedStructures.construct(e); }
                addElevatedRoadFeature(e, i, c, h, p) { const m = [], x = BT.getElevationFeature(e, p); if (x) {
                    {
                        const b = this.clipPolygonsToTile(i, 1);
                        b.length > 0 && m.push({ polygons: b, elevationFeature: x, elevationTileID: c });
                    }
                    for (const b of m)
                        if (b.elevationFeature) {
                            if (this.elevationMode === "hd-road-base") {
                                this.elevatedStructures || (this.elevatedStructures = new Bo(b.elevationTileID));
                                const A = b.elevationFeature.isTunnel();
                                let I = 0;
                                e.properties.hasOwnProperty(cP) && (I = +e.properties[cP]);
                                for (const M of b.polygons)
                                    this.elevatedStructures.addPortalCandidates(b.elevationFeature.id, M, A, b.elevationFeature, I);
                            }
                            b.elevationFeature.constantHeight == null && (b.polygons = this.prepareElevatedPolygons(b.polygons, b.elevationFeature, b.elevationTileID));
                            const S = new dP(c, b.elevationTileID);
                            this.addElevatedGeometry(b.polygons, S, b.elevationFeature, this.elevationMode === "hd-road-base" ? 0 : .05, h);
                        }
                }
                else
                    this.addGeometry(i, this.bufferData); }
                addElevatedGeometry(e, i, c, h, p) { const m = { elevation: c, elevationSampler: i, bias: h, index: p }, [x, b] = this.addGeometry(e, this.elevationBufferData, m); this.elevationBufferData.heightRange == null ? this.elevationBufferData.heightRange = { min: x, max: b } : (this.elevationBufferData.heightRange.min = Math.min(this.elevationBufferData.heightRange.min, x), this.elevationBufferData.heightRange.max = Math.max(this.elevationBufferData.heightRange.max, b)); }
                addGeometry(e, i, c) { let h = Number.POSITIVE_INFINITY, p = Number.NEGATIVE_INFINITY, m = null; c && (m = c.elevationSampler.constantElevation(c.elevation, c.bias), m != null && (h = m, p = m)); const x = (b, S, A) => { if (c != null)
                    if (S.push(b), m != null)
                        i.elevatedLayoutVertexArray.emplaceBack(m), A.push(m);
                    else {
                        const I = c.elevationSampler.pointElevation(b, c.elevation, c.bias);
                        i.elevatedLayoutVertexArray.emplaceBack(I), A.push(I), h = Math.min(h, I), p = Math.max(p, I);
                    } }; for (const b of e) {
                    let S = 0;
                    for (const se of b)
                        S += se.length;
                    const A = i.triangleSegments.prepareSegment(S, i.layoutVertexArray, i.indexArray), I = A.vertexLength, M = [], z = [], F = [], U = [], X = [], Y = i.layoutVertexArray.length;
                    for (const se of b) {
                        if (se.length === 0)
                            continue;
                        se !== b[0] && z.push(M.length / 2);
                        const $ = i.lineSegments.prepareSegment(se.length, i.layoutVertexArray, i.lineIndexArray), te = $.vertexLength;
                        c && X.push(i.layoutVertexArray.length - Y), x(se[0], F, U), i.layoutVertexArray.emplaceBack(se[0].x, se[0].y), i.lineIndexArray.emplaceBack(te + se.length - 1, te), M.push(se[0].x), M.push(se[0].y);
                        for (let ae = 1; ae < se.length; ae++)
                            x(se[ae], F, U), i.layoutVertexArray.emplaceBack(se[ae].x, se[ae].y), i.lineIndexArray.emplaceBack(te + ae - 1, te + ae), M.push(se[ae].x), M.push(se[ae].y);
                        $.vertexLength += se.length, $.primitiveLength += se.length;
                    }
                    const le = U_(M, z);
                    for (let se = 0; se < le.length; se += 3)
                        i.indexArray.emplaceBack(I + le[se], I + le[se + 1], I + le[se + 2]);
                    if (le.length > 0 && c && this.elevationMode === "hd-road-base") {
                        const se = c.elevation.isTunnel(), $ = c.elevation.safeArea, te = this.elevatedStructures.addVertices(F, U);
                        this.elevatedStructures.addTriangles(le, te, se);
                        const ae = X.length;
                        if (ae > 0) {
                            for (let fe = 0; fe < ae - 1; fe++)
                                this.elevatedStructures.addRenderableRing(c.index, X[fe] + te, X[fe + 1] - X[fe], se, $);
                            this.elevatedStructures.addRenderableRing(c.index, X[ae - 1] + te, F.length - X[ae - 1], se, $);
                        }
                    }
                    A.vertexLength += S, A.primitiveLength += le.length / 3;
                } return [h, p]; }
                prepareElevatedPolygons(e, i, c) { const h = 1 / Fe(c), p = []; for (const m of e) {
                    const x = Z4(m, new hP(i, h));
                    p.push(...x);
                } return p; }
                clipPolygonsToTile(e, i) { const c = -i, h = -i, p = It + i, m = It + i; let x = 0; const b = [], S = []; for (; x < e.length; x++) {
                    const M = e[x], z = $g(M);
                    (z.min.x >= c && z.max.x <= p && z.min.y >= h && z.max.y <= m ? b : S).push(M);
                } if (b.length === e.length)
                    return e; const A = [new Et(c, h), new Et(p, h), new Et(p, m), new Et(c, m), new Et(c, h)], I = b; for (const M of S)
                    I.push(...W4(M, A)); return I; }
            }
            let yP, vP, xP, wP;
            Nt(UT, "FillBucket", { omit: ["layers", "patternFeatures"] }), Nt(VT, "FillBufferData"), Nt(Bo, "ElevatedStructures");
            class $T {
                constructor(e, i, c, h) { if (this.triangleCount = i.length / 3, this.min = new Et(0, 0), this.max = new Et(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], this.triangleCount === 0 || e.length === 0)
                    return; const [p, m] = [e[0].clone(), e[0].clone()]; for (let I = 1; I < e.length; ++I) {
                    const M = e[I];
                    p.x = Math.min(p.x, M.x), p.y = Math.min(p.y, M.y), m.x = Math.max(m.x, M.x), m.y = Math.max(m.y, M.y);
                } if (h) {
                    const I = Math.ceil(Math.max(m.x - p.x, m.y - p.y) / h);
                    c = Math.max(c, I);
                } if (c === 0)
                    return; this.min = p, this.max = m; const x = this.max.sub(this.min); x.x = Math.max(x.x, 1), x.y = Math.max(x.y, 1); const b = Math.max(x.x, x.y) / c; this.cellsX = Math.max(1, Math.ceil(x.x / b)), this.cellsY = Math.max(1, Math.ceil(x.y / b)), this.xScale = 1 / b, this.yScale = 1 / b; const S = []; for (let I = 0; I < this.triangleCount; I++) {
                    const M = e[i[3 * I + 0]].sub(this.min), z = e[i[3 * I + 1]].sub(this.min), F = e[i[3 * I + 2]].sub(this.min), U = ql(Math.floor(Math.min(M.x, z.x, F.x)), this.xScale, this.cellsX), X = ql(Math.floor(Math.max(M.x, z.x, F.x)), this.xScale, this.cellsX), Y = ql(Math.floor(Math.min(M.y, z.y, F.y)), this.yScale, this.cellsY), le = ql(Math.floor(Math.max(M.y, z.y, F.y)), this.yScale, this.cellsY), se = new Et(0, 0), $ = new Et(0, 0), te = new Et(0, 0), ae = new Et(0, 0);
                    for (let fe = Y; fe <= le; ++fe) {
                        se.y = $.y = fe * b, te.y = ae.y = (fe + 1) * b;
                        for (let Te = U; Te <= X; ++Te)
                            se.x = te.x = Te * b, $.x = ae.x = (Te + 1) * b, (Kn(M, z, F, se, $, ae) || Kn(M, z, F, se, ae, te)) && S.push({ cellIdx: fe * this.cellsX + Te, triIdx: I });
                    }
                } if (S.length === 0)
                    return; S.sort((I, M) => I.cellIdx - M.cellIdx || I.triIdx - M.triIdx); let A = 0; for (; A < S.length;) {
                    const I = S[A].cellIdx, M = { start: this.payload.length, len: 0 };
                    for (; A < S.length && S[A].cellIdx === I;)
                        ++M.len, this.payload.push(S[A++].triIdx);
                    this.cells[I] = M;
                } }
                _lazyInitLookup() { this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0); }
                queryPoint(e, i) { if (this.triangleCount === 0 || this.cells.length === 0 || e.x > this.max.x || this.min.x > e.x || e.y > this.max.y || this.min.y > e.y)
                    return; const c = ql(e.x - this.min.x, this.xScale, this.cellsX), h = ql(e.y - this.min.y, this.yScale, this.cellsY), p = this.cells[h * this.cellsX + c]; if (p) {
                    this._lazyInitLookup();
                    for (let m = 0; m < p.len; m++) {
                        const x = this.payload[p.start + m], b = Math.floor(x / 8), S = 1 << x % 8;
                        if (!(this.lookup[b] & S) && (this.lookup[b] |= S, i.push(x), i.length === this.triangleCount))
                            return;
                    }
                } }
                query(e, i, c) { if (this.triangleCount === 0 || this.cells.length === 0 || e.x > this.max.x || this.min.x > i.x || e.y > this.max.y || this.min.y > i.y)
                    return; this._lazyInitLookup(); const h = ql(e.x - this.min.x, this.xScale, this.cellsX), p = ql(i.x - this.min.x, this.xScale, this.cellsX), m = ql(e.y - this.min.y, this.yScale, this.cellsY), x = ql(i.y - this.min.y, this.yScale, this.cellsY); for (let b = m; b <= x; b++)
                    for (let S = h; S <= p; S++) {
                        const A = this.cells[b * this.cellsX + S];
                        if (A)
                            for (let I = 0; I < A.len; I++) {
                                const M = this.payload[A.start + I], z = Math.floor(M / 8), F = 1 << M % 8;
                                if (!(this.lookup[z] & F) && (this.lookup[z] |= F, c.push(M), c.length === this.triangleCount))
                                    return;
                            }
                    } }
            }
            function ql(a, e, i) { return Math.max(0, Math.min(i - 1, Math.floor(a * e))); }
            Nt($T, "TriangleGridIndex");
            class bP {
                constructor(e) { this.zoom = e.zoom, this.layers = e.layers, this.layerIds = this.layers.map(i => i.fqid), this.index = e.index, this.hasPattern = !1, this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id), this.footprints = []; }
                updateFootprints(e, i) { for (const c of this.footprints)
                    i.push({ footprint: c, id: e }); }
                populate(e, i, c, h) { const p = []; for (const { feature: m, id: x, index: b, sourceLayerIndex: S } of e) {
                    const A = this.layers[0]._featureFilter.needGeometry, I = Xt(m, A);
                    if (!this.layers[0]._featureFilter.filter(new yn(this.zoom), I, c))
                        continue;
                    const M = { id: x, properties: m.properties, type: m.type, sourceLayerIndex: S, index: b, geometry: A ? I.geometry : Vt(m, c, h), patterns: {} };
                    p.push(M);
                } for (const m of p) {
                    const { geometry: x, index: b, sourceLayerIndex: S } = m;
                    this.addFeature(m, x, b, c, {}, i.availableImages, i.brightness), i.featureIndex.insert(e[b].feature, x, b, S, this.index);
                } }
                isEmpty() { return this.footprints.length === 0; }
                uploadPending() { return !1; }
                upload(e) { }
                update(e, i, c, h, p, m, x) { }
                destroy() { }
                addFeature(e, i, c, h, p, m = [], x) { for (const b of bx(i, 2)) {
                    const S = [], A = [], I = [], M = new Et(1 / 0, 1 / 0), z = new Et(-1 / 0, -1 / 0);
                    for (const X of b)
                        if (X.length !== 0) {
                            X !== b[0] && I.push(A.length / 2);
                            for (let Y = 0; Y < X.length; Y++)
                                A.push(X[Y].x), A.push(X[Y].y), S.push(X[Y]), M.x = Math.min(M.x, X[Y].x), M.y = Math.min(M.y, X[Y].y), z.x = Math.max(z.x, X[Y].x), z.y = Math.max(z.y, X[Y].y);
                        }
                    const F = U_(A, I), U = new $T(S, F, 8, 256);
                    this.footprints.push({ vertices: S, indices: F, grid: U, min: M, max: z });
                } }
            }
            Nt(bP, "ClipBucket", { omit: ["layers"] });
            const X4 = tn([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), K4 = tn([{ name: "a_pos_end", components: 4, type: "Int16" }, { name: "a_angular_offset_factor", components: 1, type: "Int16" }]), Y4 = tn([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Q4 = tn([{ name: "a_join_normal_inside", components: 3, type: "Int16" }]), J4 = tn([{ name: "a_hidden_by_landmark", components: 1, type: "Uint8" }]), e5 = tn([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: t5 } = X4, Ex = Number.MAX_SAFE_INTEGER;
            function TP(a, e, i, c) { return a.order < e || a.order === Ex || !(a.clipMask & i) || function (h, p) { return p.length !== 0 && p.find(m => m === h) === void 0; }(c, a.clipScope); }
            function Cx(a, e) { return a.x - e.x || a.y - e.y; }
            function SP(a, e) { return Cx(a.min, e.min) === 0 && Cx(a.max, e.max) === 0; }
            function GT(a, e) { return !(a.min.x > e.max.x || a.max.x < e.min.x || a.min.y > e.max.y || a.max.y < e.min.y); }
            function qT(a, e) { if (a.length !== e.length)
                return !1; for (let i = 0; i < a.length; i++)
                if (a[i].sourceId !== e[i].sourceId || !SP(a[i], e[i]) || a[i].order !== e[i].order || a[i].clipMask !== e[i].clipMask || !qa(a[i].clipScope, e[i].clipScope))
                    return !1; return !0; }
            function EP(a, e, i) { const c = 1 / It, h = 1 / (1 << i.canonical.z), p = (e.x * c + i.canonical.x) * h + i.wrap, m = (e.y * c + i.canonical.y) * h; return { min: new Et((a.x * c + i.canonical.x) * h + i.wrap, (a.y * c + i.canonical.y) * h), max: new Et(p, m) }; }
            function r5(a, e, i) { const c = 1 << i.canonical.z, h = ((e.x - i.wrap) * c - i.canonical.x) * It, p = (e.y * c - i.canonical.y) * It; return { min: new Et(((a.x - i.wrap) * c - i.canonical.x) * It, (a.y * c - i.canonical.y) * It), max: new Et(h, p) }; }
            function CP(a, e, i, c, h, p, m) { const x = a.indices, b = a.vertices, S = []; for (let A = c; A < c + h; A += 3) {
                const I = e[i[A + 0] + p], M = e[i[A + 1] + p], z = e[i[A + 2] + p], F = Math.min(I.x, M.x, z.x), U = Math.max(I.x, M.x, z.x), X = Math.min(I.y, M.y, z.y), Y = Math.max(I.y, M.y, z.y);
                S.length = 0, a.grid.query(new Et(F, X), new Et(U, Y), S);
                for (let le = 0; le < S.length; le++) {
                    const se = S[le];
                    if (Kn(b[x[3 * se + 0]], b[x[3 * se + 1]], b[x[3 * se + 2]], I, M, z, m))
                        return !0;
                }
            } return !1; }
            function AP(a, e, i, c) { if (!a || !i)
                return !1; let h = a.vertices; if (!e.canonical.equals(c.canonical) || e.wrap !== c.wrap) {
                if (i.vertices.length < a.vertices.length)
                    return AP(i, c, a, e);
                const p = e.canonical, m = c.canonical, x = Math.pow(2, m.z - p.z);
                h = a.vertices.map(b => new Et((b.x + p.x * It) * x - m.x * It, (b.y + p.y * It) * x - m.y * It));
            } return CP(i, h, a.indices, 0, a.indices.length, 0, 0); }
            function IP(a, e, i, c) { const h = Math.pow(2, c.z - i.z); return new Et((a + i.x * It) * h - c.x * It, (e + i.y * It) * h - c.y * It); }
            function PP(a, e) { const i = []; e.grid.queryPoint(a, i); const c = e.indices, h = e.vertices; for (let p = 0; p < i.length; p++) {
                const m = i[p];
                if (xn([h[c[3 * m + 0]], h[c[3 * m + 1]], h[c[3 * m + 2]]], a))
                    return !0;
            } return !1; }
            const HT = [new Et(0, 0), new Et(It, 0), new Et(It, It), new Et(0, It)];
            function MP(a, e) { const i = []; let c = []; if (!e || a.length < 2)
                return [a]; if (a.length === 2)
                return _i(a[0], a[1], HT) ? [a] : []; for (let h = 0; h < a.length + 2; h++) {
                const p = a[h % a.length], m = a[(h + 1) % a.length], x = _i(h === 0 ? a[a.length - 1] : a[(h - 1) % a.length], p, HT), b = _i(p, m, HT), S = x || b;
                S && c.push(p), S && b || c.length > 0 && (c.length > 1 && i.push(c), c = []);
            } return c.length > 1 && i.push(c), i; }
            const WT = Qu.VectorTileFeature.types, n5 = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius", "fill-extrusion-line-width", "fill-extrusion-emissive-strength"], i5 = ["fill-extrusion-flood-light-ground-radius"], s5 = Math.pow(2, 13), o5 = Math.pow(2, 15) - 1, RP = new Et(0, 1), Ju = 2147483648;
            function W_(a, e, i, c, h, p, m, x) { a.emplaceBack((e << 1) + m, (i << 1) + p, (Math.floor(c * s5) << 1) + h, Math.round(x)); }
            function Z_(a, e, i) { a.emplaceBack(e.x * It, e.y * It, i ? 1 : 0); }
            function Ax(a, e, i, c, h, p) { a.emplaceBack(e.x, e.y, (i.x << 1) + c, (i.y << 1) + h, p); }
            function X_(a, e, i) { a.emplaceBack(e.x, e.y, e.z, i[0] * 16384, i[1] * 16384, i[2] * 16384); }
            class kP {
                constructor() { this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0; }
            }
            class DP {
                constructor() { this.centroidXY = new Et(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new Et(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new Et(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0; }
                span() { return new Et(this.max.x - this.min.x, this.max.y - this.min.y); }
            }
            class LP {
                constructor() { this.acc = new Et(0, 0), this.accCount = 0, this.centroidDataIndex = 0; }
                startRing(e, i) { e.min.x === Number.MAX_VALUE && (e.min.x = e.max.x = i.x, e.min.y = e.max.y = i.y); }
                appendEdge(e, i, c) { this.accCount++, this.acc._add(i); let h = !!this.borders; i.x < e.min.x ? (e.min.x = i.x, h = !0) : i.x > e.max.x && (e.max.x = i.x, h = !0), i.y < e.min.y ? (e.min.y = i.y, h = !0) : i.y > e.max.y && (e.max.y = i.y, h = !0), ((i.x === 0 || i.x === It) && i.x === c.x) != ((i.y === 0 || i.y === It) && i.y === c.y) && this.processBorderOverlap(i, c), h && this.checkBorderIntersection(i, c); }
                checkBorderIntersection(e, i) { i.x < 0 != e.x < 0 && this.addBorderIntersection(0, nr(i.y, e.y, (0 - i.x) / (e.x - i.x))), i.x > It != e.x > It && this.addBorderIntersection(1, nr(i.y, e.y, (It - i.x) / (e.x - i.x))), i.y < 0 != e.y < 0 && this.addBorderIntersection(2, nr(i.x, e.x, (0 - i.y) / (e.y - i.y))), i.y > It != e.y > It && this.addBorderIntersection(3, nr(i.x, e.x, (It - i.y) / (e.y - i.y))); }
                addBorderIntersection(e, i) { this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]); const c = this.borders[e]; i < c[0] && (c[0] = i), i > c[1] && (c[1] = i); }
                processBorderOverlap(e, i) { if (e.x === i.x) {
                    if (e.y === i.y)
                        return;
                    const c = e.x === 0 ? 0 : 1;
                    this.addBorderIntersection(c, i.y), this.addBorderIntersection(c, e.y);
                }
                else {
                    const c = e.y === 0 ? 2 : 3;
                    this.addBorderIntersection(c, i.x), this.addBorderIntersection(c, e.x);
                } }
                centroid() { return this.accCount === 0 ? new Et(0, 0) : new Et(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount)); }
                intersectsCount() { return this.borders ? this.borders.reduce((e, i) => e + +(i[0] !== Number.MAX_VALUE), 0) : 0; }
            }
            function OP(a, e) { const i = a.add(e)._unit(), c = ke(a.x * i.x + a.y * i.y, -1, 1); var h, p, m; return h = Math.acos(c), Math.min(4, Math.max(-4, Math.tan(h))) / 4 * o5 * ((p = a).x * (m = e).y - p.y * m.x < 0 ? -1 : 1); }
            const a5 = [a => a.x < 0, a => a.x > It, a => a.y < 0, a => a.y > It];
            function l5(a, e, i, c) { const h = [4]; if (c === 0)
                return h; i._mult(c); const p = a.sub(i), m = e.sub(i), x = [a, e, p, m]; for (let b = 0; b < 4; b++)
                for (const S of x)
                    if (a5[b](S)) {
                        h.push(b);
                        break;
                    } return h; }
            class zP {
                constructor(e) { this.vertexArray = new A_, this.indexArray = new Hi, this.programConfigurations = new Uc(e.layers, { zoom: e.zoom, lut: e.lut }, i => i5.includes(i)), this._segments = new ti, this.hiddenByLandmarkVertexArray = new Vp, this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new ti; }
                getDefaultSegment() { return this.regionSegments[4]; }
                hasData() { return this.vertexArray.length !== 0; }
                addData(e, i, c, h = !1) { const p = e.length; if (p > 2) {
                    let m = Math.max(0, this._segments.get().length - 1);
                    const x = this._segments._prepareSegment(4 * p, this.vertexArray.length, 2 * this._segmentToGroundQuads[m].length);
                    let b;
                    m !== this._segments.get().length - 1 && (m++, this._segmentToGroundQuads[m] = [], this._segmentToRegionTriCounts[m] = [0, 0, 0, 0, 0]);
                    {
                        const S = e[0], A = e[1];
                        b = OP(S.sub(e[p - 1])._perp()._unit(), A.sub(S)._perp()._unit());
                    }
                    for (let S = 0; S < p; S++) {
                        const A = S === p - 1 ? 0 : S + 1, I = e[S], M = e[A], z = e[A === p - 1 ? 0 : A + 1], F = M.sub(I)._perp()._unit(), U = OP(F, z.sub(M)._perp()._unit()), X = b, Y = U;
                        if (ZT(I, M, i) || h && BP(I, i) && BP(M, i)) {
                            b = U;
                            continue;
                        }
                        const le = x.vertexLength;
                        Ax(this.vertexArray, I, M, 1, 1, X), Ax(this.vertexArray, I, M, 1, 0, X), Ax(this.vertexArray, I, M, 0, 1, Y), Ax(this.vertexArray, I, M, 0, 0, Y), x.vertexLength += 4;
                        const se = l5(I, M, F, c);
                        for (const $ of se)
                            this._segmentToGroundQuads[m].push({ id: le, region: $ }), this._segmentToRegionTriCounts[m][$] += 2, x.primitiveLength += 2;
                        b = U;
                    }
                } }
                prepareBorderSegments() { if (!this.hasData())
                    return; const e = this._segments.get(), i = e.length; for (let c = 0; c < i; c++)
                    this._segmentToGroundQuads[c].sort((h, p) => h.region - p.region); for (let c = 0; c < i; c++) {
                    const h = this._segmentToGroundQuads[c], p = e[c], m = this._segmentToRegionTriCounts[c];
                    m.reduce((b, S) => b + S, 0);
                    let x = 0;
                    for (let b = 0; b <= 4; b++) {
                        const S = m[b];
                        if (S !== 0) {
                            let A = this.regionSegments[b];
                            A || (A = this.regionSegments[b] = new ti);
                            const I = { vertexOffset: p.vertexOffset, primitiveOffset: p.primitiveOffset + x, vertexLength: p.vertexLength, primitiveLength: S };
                            A.get().push(I);
                        }
                        x += S;
                    }
                    for (let b = 0; b < h.length; b++) {
                        const S = h[b].id;
                        this.indexArray.emplaceBack(S, S + 1, S + 3), this.indexArray.emplaceBack(S, S + 3, S + 2);
                    }
                } this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null; }
                addPaintPropertiesData(e, i, c, h, p, m) { this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, e, i, c, h, p, m); }
                upload(e) { this.hasData() && (this.vertexBuffer = e.createVertexBuffer(this.vertexArray, K4.members), this.indexBuffer = e.createIndexBuffer(this.indexArray)); }
                uploadPaintProperties(e) { this.hasData() && this.programConfigurations.upload(e); }
                update(e, i, c, h, p, m, x) { this.hasData() && this.programConfigurations.updatePaintArrays(e, i, c, h, p, m, x); }
                updateHiddenByLandmark(e) { if (!this.hasData())
                    return; const i = e.groundVertexCount + e.groundVertexArrayOffset; if (e.groundVertexCount === 0)
                    return; const c = e.flags & Ju ? 1 : 0; for (let h = e.groundVertexArrayOffset; h < i; ++h)
                    this.hiddenByLandmarkVertexArray.emplace(h, c); this._needsHiddenByLandmarkUpdate = !0; }
                uploadHiddenByLandmark(e) { this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = e.createVertexBuffer(this.hiddenByLandmarkVertexArray, J4.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = !1); }
                destroy() { if (this.vertexBuffer) {
                    this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
                    for (let e = 0; e <= 4; e++) {
                        const i = this.regionSegments[e];
                        i && i.destroy();
                    }
                } }
            }
            class Ix {
                constructor(e) { this.zoom = e.zoom, this.canonical = e.canonical, this.overscaling = e.overscaling, this.layers = e.layers, this.pixelRatio = e.pixelRatio, this.layerIds = this.layers.map(i => i.fqid), this.index = e.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = e.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new Hi, this.footprintVertices = new Ja, this.footprintSegments = [], this.layoutVertexArray = new Bc, this.centroidVertexArray = new ux, this.wallVertexArray = new dx, this.indexArray = new Hi, this.programConfigurations = new Uc(e.layers, { zoom: e.zoom, lut: e.lut }, i => n5.includes(i)), this.segments = new ti, this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id), this.groundEffect = new zP(e), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = []; }
                updateFootprints(e, i) { }
                populate(e, i, c, h) { this.features = [], this.hasPattern = DT("fill-extrusion", this.layers, this.pixelRatio, i), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], this.tileToMeter = Fe(c), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1) !== 0; for (const { feature: p, id: m, index: x, sourceLayerIndex: b } of e) {
                    const S = this.layers[0]._featureFilter.needGeometry, A = Xt(p, S);
                    if (!this.layers[0]._featureFilter.filter(new yn(this.zoom), A, c))
                        continue;
                    const I = { id: m, sourceLayerIndex: b, index: x, geometry: S ? A.geometry : Vt(p, c, h), properties: p.properties, type: p.type, patterns: {} }, M = this.layoutVertexArray.length, z = WT[I.type] === "Polygon";
                    if (this.hasPattern)
                        this.features.push(LT("fill-extrusion", this.layers, I, this.zoom, this.pixelRatio, i));
                    else if (this.wallMode)
                        for (const F of I.geometry)
                            for (const U of MP(F, z))
                                this.addFeature(I, [U], x, c, {}, i.availableImages, h, i.brightness);
                    else
                        this.addFeature(I, I.geometry, x, c, {}, i.availableImages, h, i.brightness);
                    i.featureIndex.insert(p, I.geometry, x, b, this.index, M);
                } this.sortBorders(), this.projection.name === "mercator" && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0; }
                addFeatures(e, i, c, h, p, m) { for (const x of this.features) {
                    const b = WT[x.type] === "Polygon", { geometry: S } = x;
                    if (this.wallMode)
                        for (const A of S)
                            for (const I of MP(A, b))
                                this.addFeature(x, [I], x.index, i, c, h, p, m);
                    else
                        this.addFeature(x, S, x.index, i, c, h, p, m);
                } this.sortBorders(), this.projection.name === "mercator" && this.splitToSubtiles(); }
                update(e, i, c, h, p, m, x) { this.programConfigurations.updatePaintArrays(e, i, p, c, h, m, x), this.groundEffect.update(e, i, p, c, h, m, x); }
                isEmpty() { return this.layoutVertexArray.length === 0; }
                uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload; }
                upload(e) { this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, t5), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.wallVertexBuffer = e.createVertexBuffer(this.wallVertexArray, Q4.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = e.createVertexBuffer(this.layoutVertexExtArray, e5.members, !0)), this.groundEffect.upload(e)), this.groundEffect.uploadPaintProperties(e), this.programConfigurations.upload(e), this.uploaded = !0; }
                uploadCentroid(e) { this.groundEffect.uploadHiddenByLandmark(e), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, Y4.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = !1); }
                destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()); }
                addFeature(e, i, c, h, p, m, x, b) { const S = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(e, {}) / this.tileToMeter, A = [new Et(0, 0), new Et(It, It)], I = x.projection, M = I.name === "globe", z = this.wallMode || WT[e.type] === "Polygon", F = new LP; F.centroidDataIndex = this.centroidData.length; const U = new DP, X = this.layers[0].paint.get("fill-extrusion-base").evaluate(e, {}, h) <= 0, Y = this.layers[0].paint.get("fill-extrusion-height").evaluate(e, {}, h); let le; if (U.height = Y, U.vertexArrayOffset = this.layoutVertexArray.length, U.groundVertexArrayOffset = this.groundEffect.vertexArray.length, M && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new jc), this.wallMode) {
                    if (M)
                        return void Br("Non zero fill-extrusion-line-width is not yet supported on globe.");
                    if (i.length !== 1)
                        return;
                    le = function (Me) { const Oe = Me[0].x === Me[Me.length - 1].x && Me[0].y === Me[Me.length - 1].y; (function (Rt) { let mt = 0; const pr = Rt.length; for (let Gt = 0; Gt < pr; Gt++)
                        mt += (Rt[(Gt + 1) % pr].x - Rt[Gt].x) * (Rt[(Gt + 1) % pr].y + Rt[Gt].y); return mt >= 0; })(Me) || (Me = Me.reverse()); const ut = { geometry: [], joinNormals: [], indices: [] }, it = [], lt = [], pt = []; let We = Me.length; for (; We >= 2 && Me[We - 1].equals(Me[We - 2]);)
                        We--; if (We < (Oe ? 3 : 2))
                        return ut; let at, Ge, Xe, gt, yt, Zt = 0; for (; Zt < We - 1 && Me[Zt].equals(Me[Zt + 1]);)
                        Zt++; Oe && (at = Me[We - 2], yt = Me[Zt].sub(at)._unit()._perp()); for (let Rt = Zt; Rt < We; Rt++) {
                        if (Xe = Rt === We - 1 ? Oe ? Me[Zt + 1] : void 0 : Me[Rt + 1], Xe && Me[Rt].equals(Xe))
                            continue;
                        yt && (gt = yt), at && (Ge = at), at = Me[Rt], yt = Xe ? Xe.sub(at)._unit()._perp() : gt, gt = gt || yt;
                        let mt = gt.add(yt);
                        mt.x === 0 && mt.y === 0 || mt._unit();
                        const pr = mt.x * yt.x + mt.y * yt.y, Gt = pr !== 0 ? 1 / pr : 1 / 0, qt = gt.x * yt.y - gt.y * yt.x > 0;
                        let hr = "miter";
                        const wr = 2;
                        hr === "miter" && Gt > wr && (hr = "bevel"), hr === "bevel" && (Gt > 100 && (hr = "flipbevel"), Gt < wr && (hr = "miter"));
                        const Tr = (Lr, Pr, Ar, Tn) => { const On = new Et(Lr.x, Lr.y), he = new Et(Lr.x, Lr.y); On.x += Pr.x * Tn, On.y += Pr.y * Tn, he.x -= Pr.x * Math.max(Ar, 1), he.y -= Pr.y * Math.max(Ar, 1), pt.push(Pr), it.push(On), lt.push(he); };
                        if (hr === "miter")
                            mt._mult(Gt), Tr(at, mt, 0, 0);
                        else if (hr === "flipbevel")
                            mt = yt.mult(-1), Tr(at, mt, 0, 0), Tr(at, mt.mult(-1), 0, 0);
                        else {
                            const Lr = -Math.sqrt(Gt * Gt - 1), Pr = qt ? Lr : 0, Ar = qt ? 0 : Lr;
                            Ge && Tr(at, gt, Pr, Ar), Xe && Tr(at, yt, Pr, Ar);
                        }
                    } ut.geometry = [...it, ...lt.reverse(), it[0]], ut.joinNormals = [...pt, ...pt.reverse(), pt[pt.length - 1]]; const jt = ut.geometry.length - 1; for (let Rt = 0; Rt < jt / 2; Rt++)
                        if (Rt + 1 < jt / 2) {
                            let mt = Rt, pr = Rt + 1, Gt = jt - 1 - Rt, qt = jt - 2 - Rt;
                            mt = mt === 0 ? jt - 1 : mt - 1, pr = pr === 0 ? jt - 1 : pr - 1, Gt = Gt === 0 ? jt - 1 : Gt - 1, qt = qt === 0 ? jt - 1 : qt - 1, ut.indices.push(Gt), ut.indices.push(pr), ut.indices.push(mt), ut.indices.push(Gt), ut.indices.push(qt), ut.indices.push(pr);
                        } return ut; }(i[0]), i = [le.geometry];
                } const se = (Me, Oe) => Me < (Oe.length - 1) / 2 || Me === Oe.length - 1, $ = this.wallMode ? [i] : bx(i, 500); for (let Me = $.length - 1; Me >= 0; Me--) {
                    const Oe = $[Me];
                    (Oe.length === 0 || (te = Oe[0]).every(Ye => Ye.x <= 0) || te.every(Ye => Ye.x >= It) || te.every(Ye => Ye.y <= 0) || te.every(Ye => Ye.y >= It)) && $.splice(Me, 1);
                } var te; let ae; if (M)
                    ae = $P($, A, h);
                else {
                    ae = [];
                    for (const Me of $)
                        ae.push({ polygon: Me, bounds: A });
                } const fe = z ? this.edgeRadius : 0, Te = fe > 0 && this.zoom < 17, Pe = (Me, Oe) => { if (Me.length === 0)
                    return !1; const Ye = Me[Me.length - 1]; return Oe.x === Ye.x && Oe.y === Ye.y; }; for (const { polygon: Me, bounds: Oe } of ae) {
                    let Ye = 0, ut = 0;
                    for (const We of Me)
                        z && !We[0].equals(We[We.length - 1]) && We.push(We[0]), ut += z ? We.length - 1 : We.length;
                    const it = this.segments.prepareSegment((z ? 5 : 4) * ut, this.layoutVertexArray, this.indexArray);
                    U.footprintSegIdx < 0 && (U.footprintSegIdx = this.footprintSegments.length), U.polygonSegIdx < 0 && (U.polygonSegIdx = this.polygonSegments.length);
                    const lt = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 }, pt = new kP;
                    if (pt.vertexOffset = this.footprintVertices.length, pt.indexOffset = 3 * this.footprintIndices.length, pt.ringIndices = [], z) {
                        const We = [], at = [];
                        Ye = it.vertexLength;
                        for (let Xe = 0; Xe < Me.length; Xe++) {
                            const gt = Me[Xe];
                            gt.length && Xe !== 0 && at.push(We.length / 2);
                            const yt = [];
                            let Zt, jt;
                            Zt = gt[1].sub(gt[0])._perp()._unit(), pt.ringIndices.push(gt.length - 1);
                            for (let Rt = 1; Rt < gt.length; Rt++) {
                                const mt = gt[Rt], pr = gt[Rt === gt.length - 1 ? 1 : Rt + 1], Gt = mt.clone();
                                if (fe) {
                                    jt = pr.sub(mt)._perp()._unit();
                                    const qt = Zt.add(jt)._unit(), hr = fe * Math.min(4, 1 / (Zt.x * qt.x + Zt.y * qt.y));
                                    Gt.x += hr * qt.x, Gt.y += hr * qt.y, Gt.x = Math.round(Gt.x), Gt.y = Math.round(Gt.y), Zt = jt;
                                }
                                if (!X || fe !== 0 && !Te || Pe(yt, Gt) || yt.push(Gt), W_(this.layoutVertexArray, Gt.x, Gt.y, 0, 0, 1, 1, 0), this.wallMode) {
                                    const qt = se(Rt, gt);
                                    Z_(this.wallVertexArray, le.joinNormals[Rt], !qt);
                                }
                                it.vertexLength++, this.footprintVertices.emplaceBack(mt.x, mt.y), We.push(mt.x, mt.y), M && X_(this.layoutVertexExtArray, I.projectTilePoint(Gt.x, Gt.y, h), I.upVector(h, Gt.x, Gt.y));
                            }
                            X && (fe === 0 || Te) && (yt.length !== 0 && Pe(yt, yt[0]) && yt.pop(), this.groundEffect.addData(yt, Oe, S));
                        }
                        const Ge = this.wallMode ? le.indices : U_(We, at);
                        for (let Xe = 0; Xe < Ge.length; Xe += 3)
                            this.footprintIndices.emplaceBack(pt.vertexOffset + Ge[Xe + 0], pt.vertexOffset + Ge[Xe + 1], pt.vertexOffset + Ge[Xe + 2]), this.indexArray.emplaceBack(Ye + Ge[Xe], Ye + Ge[Xe + 2], Ye + Ge[Xe + 1]), it.primitiveLength++;
                        pt.indexCount += Ge.length, pt.vertexCount += this.footprintVertices.length - pt.vertexOffset;
                    }
                    for (let We = 0; We < Me.length; We++) {
                        const at = Me[We];
                        F.startRing(U, at[0]);
                        let Ge = at.length > 4 && jP(at[at.length - 2], at[0], at[1]), Xe = fe ? c5(at[at.length - 2], at[0], at[1], fe) : 0;
                        const gt = [];
                        let yt, Zt, jt;
                        Zt = at[1].sub(at[0])._perp()._unit();
                        let Rt = !0;
                        for (let mt = 1, pr = 0; mt < at.length; mt++) {
                            let Gt = at[mt - 1], qt = at[mt];
                            const hr = at[mt === at.length - 1 ? 1 : mt + 1];
                            if (F.appendEdge(U, qt, Gt), ZT(qt, Gt, Oe)) {
                                fe && (Zt = hr.sub(qt)._perp()._unit(), Rt = !Rt);
                                continue;
                            }
                            const wr = qt.sub(Gt)._perp(), Tr = wr.x / (Math.abs(wr.x) + Math.abs(wr.y)), Lr = wr.y > 0 ? 1 : 0, Pr = Gt.dist(qt);
                            if (pr + Pr > 32768 && (pr = 0), fe) {
                                jt = hr.sub(qt)._perp()._unit();
                                let he = NP(Gt, qt, hr, FP(Zt, jt), fe);
                                isNaN(he) && (he = 0);
                                const pe = qt.sub(Gt)._unit();
                                Gt = Gt.add(pe.mult(Xe))._round(), qt = qt.add(pe.mult(-he))._round(), Xe = he, Zt = jt, X && this.zoom >= 17 && (Pe(gt, Gt) || gt.push(Gt), Pe(gt, qt) || gt.push(qt));
                            }
                            const Ar = it.vertexLength, Tn = at.length > 4 && jP(Gt, qt, hr);
                            let On = VP(pr, Ge, Rt);
                            if (W_(this.layoutVertexArray, Gt.x, Gt.y, Tr, Lr, 0, 0, On), W_(this.layoutVertexArray, Gt.x, Gt.y, Tr, Lr, 0, 1, On), this.wallMode) {
                                const he = se(mt - 1, at), pe = le.joinNormals[mt - 1];
                                Z_(this.wallVertexArray, pe, he), Z_(this.wallVertexArray, pe, he);
                            }
                            if (pr += Pr, On = VP(pr, Tn, !Rt), Ge = Tn, W_(this.layoutVertexArray, qt.x, qt.y, Tr, Lr, 0, 0, On), W_(this.layoutVertexArray, qt.x, qt.y, Tr, Lr, 0, 1, On), this.wallMode) {
                                const he = se(mt, at), pe = le.joinNormals[mt];
                                Z_(this.wallVertexArray, pe, he), Z_(this.wallVertexArray, pe, he);
                            }
                            if (it.vertexLength += 4, this.indexArray.emplaceBack(Ar + 0, Ar + 1, Ar + 2), this.indexArray.emplaceBack(Ar + 1, Ar + 3, Ar + 2), it.primitiveLength += 2, fe) {
                                const he = Ye + (mt === 1 ? at.length - 2 : mt - 2), pe = mt === 1 ? Ye : he + 1;
                                if (this.indexArray.emplaceBack(Ar + 1, he, Ar + 3), this.indexArray.emplaceBack(he, pe, Ar + 3), it.primitiveLength += 2, yt === void 0 && (yt = Ar), !ZT(hr, at[mt], Oe)) {
                                    const Je = mt === at.length - 1 ? yt : it.vertexLength;
                                    this.indexArray.emplaceBack(Ar + 2, Ar + 3, Je), this.indexArray.emplaceBack(Ar + 3, Je + 1, Je), this.indexArray.emplaceBack(Ar + 3, pe, Je + 1), it.primitiveLength += 3;
                                }
                                Rt = !Rt;
                            }
                            if (M) {
                                const he = this.layoutVertexExtArray, pe = I.projectTilePoint(Gt.x, Gt.y, h), Je = I.projectTilePoint(qt.x, qt.y, h), Tt = I.upVector(h, Gt.x, Gt.y), Lt = I.upVector(h, qt.x, qt.y);
                                X_(he, pe, Tt), X_(he, pe, Tt), X_(he, Je, Lt), X_(he, Je, Lt);
                            }
                        }
                        z && (Ye += at.length - 1), X && fe && this.zoom >= 17 && (gt.length !== 0 && Pe(gt, gt[0]) && gt.pop(), this.groundEffect.addData(gt, Oe, S, fe > 0));
                    }
                    this.footprintSegments.push(pt), lt.triangleCount = this.indexArray.length - lt.triangleArrayOffset, this.polygonSegments.push(lt), ++U.footprintSegLen, ++U.polygonSegLen;
                } if (U.vertexCount = this.layoutVertexArray.length - U.vertexArrayOffset, U.groundVertexCount = this.groundEffect.vertexArray.length - U.groundVertexArrayOffset, U.vertexCount !== 0) {
                    if (U.centroidXY = F.borders ? RP : this.encodeCentroid(F, U), this.centroidData.push(U), F.borders) {
                        this.featuresOnBorder.push(F);
                        const Me = this.featuresOnBorder.length - 1;
                        for (let Oe = 0; Oe < F.borders.length; Oe++)
                            F.borders[Oe][0] !== Number.MAX_VALUE && this.borderFeatureIndices[Oe].push(Me);
                    }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, c, p, m, h, b), this.groundEffect.addPaintPropertiesData(e, c, p, m, h, b), this.maxHeight = Math.max(this.maxHeight, Y);
                } }
                sortBorders() { for (let e = 0; e < this.borderFeatureIndices.length; e++)
                    this.borderFeatureIndices[e].sort((i, c) => this.featuresOnBorder[i].borders[e][0] - this.featuresOnBorder[c].borders[e][0]); }
                splitToSubtiles() { const e = []; for (let x = 0; x < this.centroidData.length; x++) {
                    const b = this.centroidData[x], S = +(b.min.y + b.max.y > It), A = 2 * S + (+(b.min.x + b.max.x > It) ^ S);
                    for (let I = 0; I < b.polygonSegLen; I++) {
                        const M = b.polygonSegIdx + I;
                        e.push({ centroidIdx: x, subtile: A, polygonSegmentIdx: M, triangleSegmentIdx: this.polygonSegments[M].triangleSegIdx });
                    }
                } const i = new Hi; e.sort((x, b) => x.triangleSegmentIdx === b.triangleSegmentIdx ? x.subtile - b.subtile : x.triangleSegmentIdx - b.triangleSegmentIdx); let c = 0, h = 0, p = 0; for (const x of e) {
                    if (x.triangleSegmentIdx !== c)
                        break;
                    p++;
                } const m = e.length; for (; h !== e.length;) {
                    c = e[h].triangleSegmentIdx;
                    let x = 0, b = h, S = h;
                    for (let A = b; A < p && e[A].subtile === x; A++)
                        S++;
                    for (; b !== p;) {
                        const A = e[b];
                        x = A.subtile;
                        const I = this.centroidData[A.centroidIdx].min.clone(), M = this.centroidData[A.centroidIdx].max.clone(), z = { vertexOffset: this.segments.segments[c].vertexOffset, primitiveOffset: i.length, vertexLength: this.segments.segments[c].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
                        for (let F = b; F < S; F++) {
                            const U = e[F], X = this.polygonSegments[U.polygonSegmentIdx], Y = this.centroidData[U.centroidIdx].min, le = this.centroidData[U.centroidIdx].max, se = this.indexArray.uint16;
                            for (let $ = X.triangleArrayOffset; $ < X.triangleArrayOffset + X.triangleCount; $++)
                                i.emplaceBack(se[3 * $], se[3 * $ + 1], se[3 * $ + 2]);
                            z.primitiveLength += X.triangleCount, I.x = Math.min(I.x, Y.x), I.y = Math.min(I.y, Y.y), M.x = Math.max(M.x, le.x), M.y = Math.max(M.y, le.y);
                        }
                        z.primitiveLength > 0 && this.triangleSubSegments.push({ segment: z, min: I, max: M }), b = S;
                        for (let F = b; F < p && e[F].subtile === e[b].subtile; F++)
                            S++;
                    }
                    h = p;
                    for (let A = h; A < m && e[A].triangleSegmentIdx === e[h].triangleSegmentIdx; A++)
                        p++;
                } i._trim(), this.indexArray = i; }
                getVisibleSegments(e, i, c) { const h = new ti; if (this.wallMode) {
                    for (const U of this.triangleSubSegments)
                        h.segments.push(U.segment);
                    return h;
                } let p = 0, m = 0; const x = 1 << e.canonical.z; if (i) {
                    const U = i.getMinMaxForTile(e);
                    U && (p = U.min, m = U.max);
                } m += this.maxHeight; const b = e.toUnwrapped(); let S; const A = [b.canonical.x / x + b.wrap, b.canonical.y / x], I = [(b.canonical.x + 1) / x + b.wrap, (b.canonical.y + 1) / x], M = (U, X, Y) => [U[0] * (1 - Y[0]) + X[0] * Y[0], U[1] * (1 - Y[1]) + X[1] * Y[1]], z = [], F = []; for (const U of this.triangleSubSegments) {
                    z[0] = U.min.x / It, z[1] = U.min.y / It, F[0] = U.max.x / It, F[1] = U.max.y / It;
                    const X = M(A, I, z), Y = M(A, I, F);
                    if (new Wn([X[0], X[1], p], [Y[0], Y[1], m]).intersectsPrecise(c) === 0) {
                        S && (h.segments.push(S), S = void 0);
                        continue;
                    }
                    const le = U.segment;
                    S && S.vertexOffset !== le.vertexOffset && (h.segments.push(S), S = void 0), S ? (S.vertexLength += le.vertexLength, S.primitiveLength += le.primitiveLength) : S = { vertexOffset: le.vertexOffset, primitiveLength: le.primitiveLength, vertexLength: le.vertexLength, primitiveOffset: le.primitiveOffset, sortKey: void 0, vaos: {} };
                } return S && h.segments.push(S), h; }
                encodeCentroid(e, i) { const c = e.centroid(), h = i.span(), p = Math.min(7, Math.round(h.x * this.tileToMeter / 10)), m = Math.min(7, Math.round(h.y * this.tileToMeter / 10)); return new Et(ke(c.x, 1, It - 1) << 3 | p, ke(c.y, 1, It - 1) << 3 | m); }
                encodeBorderCentroid(e) { if (!e.borders)
                    return new Et(0, 0); const i = e.borders, c = Number.MAX_VALUE; if (i[0][0] !== c || i[1][0] !== c) {
                    const h = i[0][0] !== c ? 0 : 1;
                    return new Et(6 | (i[0][0] !== c ? 0 : 65528), (i[h][0] + i[h][1]) / 2 << 3 | 6);
                } {
                    const h = i[2][0] !== c ? 2 : 3;
                    return new Et((i[h][0] + i[h][1]) / 2 << 3 | 6, 6 | (i[2][0] !== c ? 0 : 65528));
                } }
                showCentroid(e) { const i = this.centroidData[e.centroidDataIndex]; i.flags &= Ju, i.centroidXY.x = 0, i.centroidXY.y = 0, this.writeCentroidToBuffer(i); }
                writeCentroidToBuffer(e) { this.groundEffect.updateHiddenByLandmark(e); const i = e.vertexArrayOffset, c = e.vertexCount + e.vertexArrayOffset, h = e.flags & Ju ? RP : e.centroidXY, p = this.centroidVertexArray.geta_centroid_pos0(i); if (this.centroidVertexArray.geta_centroid_pos1(i) !== h.y || p !== h.x) {
                    for (let m = i; m < c; ++m)
                        this.centroidVertexArray.emplace(m, h.x, h.y);
                    this.needsCentroidUpdate = !0;
                } }
                createCentroidsBuffer() { this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length); for (const e of this.centroidData)
                    this.writeCentroidToBuffer(e); }
                updateReplacement(e, i, c) { if (i.updateTime === this.replacementUpdateTime)
                    return; this.replacementUpdateTime = i.updateTime; const h = i.getReplacementRegionsForTile(e.toUnwrapped()); if (qT(this.activeReplacements, h))
                    return; if (this.activeReplacements = h, this.centroidVertexArray.length === 0)
                    this.createCentroidsBuffer();
                else
                    for (const m of this.centroidData)
                        m.flags &= 2147483647; const p = []; for (const m of this.activeReplacements) {
                    if (m.order < c)
                        continue;
                    const x = Math.max(1, Math.pow(2, m.footprintTileId.canonical.z - e.canonical.z));
                    for (const b of this.centroidData)
                        if (!(b.flags & Ju || m.min.x > b.max.x || b.min.x > m.max.x || m.min.y > b.max.y || b.min.y > m.max.y))
                            for (let S = 0; S < b.footprintSegLen; S++) {
                                const A = this.footprintSegments[b.footprintSegIdx + S];
                                if (p.length = 0, u5(this.footprintVertices, A.vertexOffset, A.vertexCount, m.footprintTileId.canonical, e.canonical, p), CP(m.footprint, p, this.footprintIndices.uint16, A.indexOffset, A.indexCount, -A.vertexOffset, -x)) {
                                    b.flags |= Ju;
                                    break;
                                }
                            }
                } for (const m of this.centroidData)
                    this.writeCentroidToBuffer(m); this.borderDoneWithNeighborZ = [-1, -1, -1, -1]; }
                footprintContainsPoint(e, i, c) { let h = !1; for (let p = 0; p < c.footprintSegLen; p++) {
                    const m = this.footprintSegments[c.footprintSegIdx + p];
                    let x = 0;
                    for (const b of m.ringIndices) {
                        for (let S = x, A = b + x - 1; S < b + x; A = S++) {
                            const I = this.footprintVertices.int16[2 * (S + m.vertexOffset) + 0], M = this.footprintVertices.int16[2 * (S + m.vertexOffset) + 1], z = this.footprintVertices.int16[2 * (A + m.vertexOffset) + 1];
                            M > i != z > i && e < (this.footprintVertices.int16[2 * (A + m.vertexOffset) + 0] - I) * (i - M) / (z - M) + I && (h = !h);
                        }
                        x = b;
                    }
                } return h; }
                getHeightAtTileCoord(e, i) { let c = Number.NEGATIVE_INFINITY, h = !0; const p = 4 * (e + It) * It + (i + It); if (this.partLookup.hasOwnProperty(p)) {
                    const m = this.partLookup[p];
                    return m ? { height: m.height, hidden: !!(m.flags & Ju) } : void 0;
                } for (const m of this.centroidData)
                    e > m.max.x || m.min.x > e || i > m.max.y || m.min.y > i || this.footprintContainsPoint(e, i, m) && m && m.height > c && (c = m.height, this.partLookup[p] = m, h = !!(m.flags & Ju)); if (c !== Number.NEGATIVE_INFINITY)
                    return { height: c, hidden: h }; this.partLookup[p] = void 0; }
            }
            function FP(a, e) { const i = a.add(e)._unit(); return a.x * i.x + a.y * i.y; }
            function c5(a, e, i, c) { const h = e.sub(a)._perp()._unit(), p = i.sub(e)._perp()._unit(); return NP(a, e, i, FP(h, p), c); }
            function NP(a, e, i, c, h) { const p = Math.sqrt(1 - c * c); return Math.min(a.dist(e) / 3, e.dist(i) / 3, h * p / c); }
            function ZT(a, e, i) { return a.x < i[0].x && e.x < i[0].x || a.x > i[1].x && e.x > i[1].x || a.y < i[0].y && e.y < i[0].y || a.y > i[1].y && e.y > i[1].y; }
            function BP(a, e) { return a.x < e[0].x || a.x > e[1].x || a.y < e[0].y || a.y > e[1].y; }
            function jP(a, e, i) { if (a.x < 0 || a.x >= It || e.x < 0 || e.x >= It || i.x < 0 || i.x >= It)
                return !1; const c = i.sub(e), h = c.perp(), p = a.sub(e); return (c.x * p.x + c.y * p.y) / Math.sqrt((c.x * c.x + c.y * c.y) * (p.x * p.x + p.y * p.y)) > -.866 && h.x * p.x + h.y * p.y < 0; }
            function VP(a, e, i) { const c = e ? 2 | a : -3 & a; return i ? 1 | c : -2 & c; }
            function UP() { const a = Math.PI / 32, e = Math.tan(a), i = G; return i * Math.sqrt(1 + 2 * e * e) - i; }
            function $P(a, e, i) { const c = 1 << i.z, h = Se(i.x / c), p = Se((i.x + 1) / c), m = Ce(i.y / c), x = Ce((i.y + 1) / c); return function (b, S, A, I, M = 0, z) { const F = []; if (!b.length || !A || !I)
                return F; const U = (ae, fe) => { for (const Te of ae)
                F.push({ polygon: Te, bounds: fe }); }, X = Math.ceil(Math.log2(A)), Y = Math.ceil(Math.log2(I)), le = X - Y, se = []; for (let ae = 0; ae < Math.abs(le); ae++)
                se.push(le > 0 ? 0 : 1); for (let ae = 0; ae < Math.min(X, Y); ae++)
                se.push(0), se.push(1); let $ = b; if ($ = Sx($, S[0].y - M, S[1].y + M, 1), $ = Sx($, S[0].x - M, S[1].x + M, 0), !$.length)
                return F; const te = []; for (se.length ? te.push({ polygons: $, bounds: S, depth: 0 }) : U($, S); te.length;) {
                const ae = te.pop(), fe = ae.depth, Te = se[fe], Pe = ae.bounds[0], Me = ae.bounds[1], Oe = Te === 0 ? Pe.x : Pe.y, Ye = Te === 0 ? Me.x : Me.y, ut = z ? z(Te, Oe, Ye) : .5 * (Oe + Ye), it = Sx(ae.polygons, Oe - M, ut + M, Te), lt = Sx(ae.polygons, ut - M, Ye + M, Te);
                if (it.length) {
                    const pt = [Pe, new Et(Te === 0 ? ut : Me.x, Te === 1 ? ut : Me.y)];
                    se.length > fe + 1 ? te.push({ polygons: it, bounds: pt, depth: fe + 1 }) : U(it, pt);
                }
                if (lt.length) {
                    const pt = [new Et(Te === 0 ? ut : Pe.x, Te === 1 ? ut : Pe.y), Me];
                    se.length > fe + 1 ? te.push({ polygons: lt, bounds: pt, depth: fe + 1 }) : U(lt, pt);
                }
            } return F; }(a, e, Math.ceil((p - h) / 11.25), Math.ceil((m - x) / 11.25), 1, (b, S, A) => { if (b === 0)
                return .5 * (S + A); {
                const I = Ce((i.y + S / It) / c);
                return (xe(.5 * (Ce((i.y + A / It) / c) + I)) * c - i.y) * It;
            } }); }
            function u5(a, e, i, c, h, p) { const m = Math.pow(2, c.z - h.z); for (let x = 0; x < i; x++) {
                let b = a.int16[2 * (x + e) + 0], S = a.int16[2 * (x + e) + 1];
                b = (b + h.x * It) * m - c.x * It, S = (S + h.y * It) * m - c.y * It, p.push(new Et(b, S));
            } }
            let GP, qP;
            Nt(Ix, "FillExtrusionBucket", { omit: ["layers", "features"] }), Nt(DP, "PartData"), Nt(kP, "FootprintSegment"), Nt(LP, "BorderCentroidData"), Nt(zP, "GroundEffect");
            class Yd extends Et {
                constructor(e, i, c) { super(e, i), this.z = c; }
            }
            class HP extends Yd {
                constructor(e, i, c, h) { super(e, i, c), this.w = h; }
            }
            function WP(a, e, i, c) { const h = i === "x" ? "y" : "x", p = (c - a[i]) / (e[i] - a[i]); a[h] = Math.round(a[h] + (e[h] - a[h]) * p), a[i] = c, a.hasOwnProperty("z") && (a.z = nr(a.z, e.z, p)), a.hasOwnProperty("w") && (a.w = nr(a.w, e.w, p)); }
            function ZP(a, e, i, c) { const h = i, p = c; for (const m of ["x", "y"]) {
                let x = a, b = e;
                x[m] >= b[m] && (x = e, b = a), x[m] < h && b[m] > h && WP(x, b, m, h), x[m] < p && b[m] > p && WP(b, x, m, p);
            } }
            function Px(a, e, i, c, h, p) { const m = []; for (let x = 0; x < a.length; x++) {
                const b = a[x];
                let S;
                const A = m.length;
                let I = 0;
                for (let M = 0; M < b.length - 1; M++) {
                    let z = b[M], F = b[M + 1], U = 0;
                    const X = I;
                    let Y, le;
                    p && (U = Math.hypot(F.x - z.x, F.y - z.y), I += U, Y = z, le = F), z.x < e && F.x < e || (z.x < e ? z = new Et(e, z.y + (e - z.x) / (F.x - z.x) * (F.y - z.y))._round() : F.x < e && (F = new Et(e, z.y + (e - z.x) / (F.x - z.x) * (F.y - z.y))._round()), z.y < i && F.y < i || (z.y < i ? z = new Et(z.x + (i - z.y) / (F.y - z.y) * (F.x - z.x), i)._round() : F.y < i && (F = new Et(z.x + (i - z.y) / (F.y - z.y) * (F.x - z.x), i)._round()), z.x >= c && F.x >= c || (z.x >= c ? z = new Et(c, z.y + (c - z.x) / (F.x - z.x) * (F.y - z.y))._round() : F.x >= c && (F = new Et(c, z.y + (c - z.x) / (F.x - z.x) * (F.y - z.y))._round()), z.y >= h && F.y >= h || (z.y >= h ? z = new Et(z.x + (h - z.y) / (F.y - z.y) * (F.x - z.x), h)._round() : F.y >= h && (F = new Et(z.x + (h - z.y) / (F.y - z.y) * (F.x - z.x), h)._round()), S && z.equals(S[S.length - 1]) || (S = [z], m.push(S), p && p.push({ progress: { min: X + XP(Y, le, z) * U, max: 1 }, parentIndex: x, prevPoint: Y, nextPoint: le })), S.push(F), p && (p[p.length - 1].progress.max = X + XP(Y, le, F) * U, p[p.length - 1].nextPoint = le)))));
                }
                if (p && I > 0)
                    for (let M = A; M < m.length; M++)
                        p[M].progress.min /= I, p[M].progress.max /= I;
            } return m; }
            function h5(a, e, i, c, h) { if (a.length < 2)
                return void c.push(a); const p = []; for (; e.valid();) {
                const [S, A] = e.get();
                for (let I = 0; I < a.length - 1; I++) {
                    const M = a[I], z = a[I + 1], F = Jn(M, z, S, A);
                    if (F) {
                        const [U] = F, X = new Et(nr(M.x, z.x, U), nr(M.y, z.y, U));
                        p.push({ t: I + U, distance: 0, point: X });
                    }
                }
                e.next();
            } if (p.length === 0)
                return void c.push(a); p.sort((S, A) => S.t - A.t); let m = 0, x = 0, b = []; for (c.push(b); m !== a.length;) {
                if (x === p.length) {
                    for (; m !== a.length;)
                        b.length !== 0 && b[b.length - 1].equals(a[m]) || b.push(a[m]), m++;
                    break;
                }
                p[x].t <= m ? (b.length !== 0 && b[b.length - 1].equals(p[x].point) || b.push(p[x].point), Math.trunc(p[x].t), x++) : (b.length !== 0 && b[b.length - 1].equals(a[m]) || b.push(a[m]), m++);
            } }
            function XP(a, e, i) { return a.x !== e.x ? (i.x - a.x) / (e.x - a.x) : a.y !== e.y ? (i.y - a.y) / (e.y - a.y) : 0; }
            function K_(a, e) { return a.x * e.x + a.y * e.y; }
            function KP(a, e) { if (a.length === 1) {
                let i = 0;
                const c = e[i++];
                let h;
                for (; !h || c.equals(h);)
                    if (h = e[i++], !h)
                        return 1 / 0;
                for (; i < e.length; i++) {
                    const p = e[i], m = a[0], x = h.sub(c), b = p.sub(c), S = m.sub(c), A = K_(x, x), I = K_(x, b), M = K_(b, b), z = K_(S, x), F = K_(S, b), U = A * M - I * I, X = (M * z - I * F) / U, Y = (A * F - I * z) / U, le = c.z * (1 - X - Y) + h.z * X + p.z * Y;
                    if (isFinite(le))
                        return le;
                }
                return 1 / 0;
            } {
                let i = 1 / 0;
                for (const c of e)
                    i = Math.min(i, c.z);
                return i;
            } }
            function YP(a, e, i, c, h, p, m, x) { const b = m * h.getElevationAt(a, e, !0, !0), S = p[0] !== 0, A = S ? p[1] === 0 ? m * (p[0] / 7 - 450) : m * function (I, M, z) { const F = Math.floor(M[0] / 8), U = Math.floor(M[1] / 8), X = 10 * (M[0] - 8 * F), Y = 10 * (M[1] - 8 * U), le = I.getElevationAt(F, U, !0, !0), se = I.getMeterToDEM(z), $ = Math.floor(.5 * (X * se - 1)), te = Math.floor(.5 * (Y * se - 1)), ae = I.tileCoordToPixel(F, U), fe = 2 * $ + 1, Te = 2 * te + 1, Pe = function (lt, pt, We, at, Ge) { return [lt.getElevationAtPixel(pt, We, !0), lt.getElevationAtPixel(pt + Ge, We, !0), lt.getElevationAtPixel(pt, We + Ge, !0), lt.getElevationAtPixel(pt + at, We + Ge, !0)]; }(I, ae.x - $, ae.y - te, fe, Te), Me = Math.abs(Pe[0] - Pe[1]), Oe = Math.abs(Pe[2] - Pe[3]), Ye = Math.abs(Pe[0] - Pe[2]) + Math.abs(Pe[1] - Pe[3]), ut = Math.min(.25, .5 * se * (Me + Oe) / fe), it = Math.min(.25, .5 * se * Ye / Te); return le + Math.max(ut * X, it * Y); }(h, p, x) : b; return { base: b + (i === 0 ? -1 : i), top: S ? Math.max(A + c, b + i + 2) : b + c }; }
            const d5 = tn([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), f5 = tn([{ name: "a_z_offset_width", components: 3, type: "Float32" }], 4), { members: p5 } = d5, m5 = tn([{ name: "a_packed", components: 3, type: "Float32" }]), { members: g5 } = m5, _5 = tn([{ name: "a_pattern_data", components: 3, type: "Float32" }]), { members: y5 } = _5;
            class QP {
                constructor(e, i) { this.width = e, this.height = i, this.nextRow = 0, this.image = new Yu({ width: e, height: i }), this.positions = {}, this.uploaded = !1; }
                getDash(e, i) { const c = this.getKey(e, i); return this.positions[c]; }
                trim() { const e = this.width, i = this.height = Wt(this.nextRow); this.image.resize({ width: e, height: i }); }
                getKey(e, i) { return e.join(",") + i; }
                getDashRanges(e, i, c) { const h = []; let p = e.length % 2 == 1 ? -e[e.length - 1] * c : 0, m = e[0] * c, x = !0; h.push({ left: p, right: m, isDash: x, zeroLength: e[0] === 0 }); let b = e[0]; for (let S = 1; S < e.length; S++) {
                    x = !x;
                    const A = e[S];
                    p = b * c, b += A, m = b * c, h.push({ left: p, right: m, isDash: x, zeroLength: A === 0 });
                } return h; }
                addRoundDash(e, i, c) { const h = i / 2; for (let p = -c; p <= c; p++) {
                    const m = this.width * (this.nextRow + c + p);
                    let x = 0, b = e[x];
                    for (let S = 0; S < this.width; S++) {
                        S / b.right > 1 && (b = e[++x]);
                        const A = Math.abs(S - b.left), I = Math.abs(S - b.right), M = Math.min(A, I);
                        let z;
                        const F = p / c * (h + 1);
                        if (b.isDash) {
                            const U = h - Math.abs(F);
                            z = Math.sqrt(M * M + U * U);
                        }
                        else
                            z = h - Math.sqrt(M * M + F * F);
                        this.image.data[m + S] = Math.max(0, Math.min(255, z + 128));
                    }
                } }
                addRegularDash(e, i) { for (let b = e.length - 1; b >= 0; --b) {
                    const S = e[b], A = e[b + 1];
                    S.zeroLength ? e.splice(b, 1) : A && A.isDash === S.isDash && (A.left = S.left, e.splice(b, 1));
                } const c = e[0], h = e[e.length - 1]; c.isDash === h.isDash && (c.left = h.left - this.width, h.right = c.right + this.width); const p = this.width * this.nextRow; let m = 0, x = e[m]; for (let b = 0; b < this.width; b++) {
                    b / x.right > 1 && (x = e[++m]);
                    const S = Math.abs(b - x.left), A = Math.abs(b - x.right), I = Math.min(S, A);
                    this.image.data[p + b] = Math.max(0, Math.min(255, (x.isDash ? I : -I) + i + 128));
                } }
                addDash(e, i) { const c = this.getKey(e, i); if (this.positions[c])
                    return this.positions[c]; const h = i === "round", p = h ? 7 : 0, m = 2 * p + 1; if (this.nextRow + m > this.height)
                    return Br("LineAtlas out of space"), null; e.length === 0 && e.push(1); let x = 0; for (let A = 0; A < e.length; A++)
                    e[A] < 0 && (Br("Negative value is found in line dasharray, replacing values with 0"), e[A] = 0), x += e[A]; if (x !== 0) {
                    const A = this.width / x, I = this.getDashRanges(e, this.width, A);
                    h ? this.addRoundDash(I, A, p) : this.addRegularDash(I, i === "square" ? .5 * A : 0);
                } const b = this.nextRow + p; this.nextRow += m; const S = { tl: [b, p], br: [x, 0] }; return this.positions[c] = S, S; }
            }
            Nt(QP, "LineAtlas");
            const v5 = Qu.VectorTileFeature.types, x5 = Math.cos(Math.PI / 180 * 37.5), w5 = Math.cos(Math.PI / 180 * 5);
            class XT {
                constructor(e) { this.evaluationGlobals = { zoom: 0, lineProgress: void 0 }, this.elevationType = "none", this.zoom = e.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = e.overscaling, this.pixelRatio = e.pixelRatio, this.layers = e.layers, this.layerIds = this.layers.map(i => i.fqid), this.index = e.index, this.projection = e.projection, this.hasPattern = !1, this.hasCrossSlope = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(i => { this.gradients[i.id] = {}; }), this.layoutVertexArray = new I_, this.layoutVertexArray2 = new Ea, this.patternVertexArray = new Ea, this.indexArray = new Hi, this.programConfigurations = new Uc(e.layers, { zoom: e.zoom, lut: e.lut }), this.segments = new ti, this.maxLineLength = 0, this.zOffsetVertexArray = new Ea, this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id), this.tessellationStep = e.tessellationStep ? e.tessellationStep : It / 64; }
                updateFootprints(e, i) { }
                populate(e, i, c, h) { this.hasPattern = DT("line", this.layers, this.pixelRatio, i); const p = this.layers[0].layout.get("line-sort-key"); this.tileToMeter = Fe(c); const m = this.layers[0].layout.get("line-elevation-reference"); if (m === "hd-road-markup")
                    this.elevationType = "road";
                else {
                    const M = this.layers[0].layout.get("line-z-offset"), z = M.isConstant() && !M.constantOr(0);
                    this.elevationType = m !== "sea" && m !== "ground" && z ? "none" : "offset", this.elevationType === "offset" && m === "none" && Br(`line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`);
                } const x = this.layers[0].layout.get("line-cross-slope"); this.hasCrossSlope = this.elevationType === "offset" && x !== void 0; const b = []; for (const { feature: M, id: z, index: F, sourceLayerIndex: U } of e) {
                    const X = this.layers[0]._featureFilter.needGeometry, Y = Xt(M, X);
                    if (!this.layers[0]._featureFilter.filter(new yn(this.zoom), Y, c))
                        continue;
                    const le = p ? p.evaluate(Y, {}, c) : void 0, se = { id: z, properties: M.properties, type: M.type, sourceLayerIndex: U, index: F, geometry: X ? Y.geometry : Vt(M, c, h), patterns: {}, sortKey: le };
                    b.push(se);
                } p && b.sort((M, z) => M.sortKey - z.sortKey); const { lineAtlas: S, featureIndex: A } = i, I = this.addConstantDashes(S); for (const M of b) {
                    const { geometry: z, index: F, sourceLayerIndex: U } = M;
                    if (I && this.addFeatureDashes(M, S), this.hasPattern) {
                        const X = LT("line", this.layers, M, this.zoom, this.pixelRatio, i);
                        this.patternFeatures.push(X);
                    }
                    else
                        this.addFeature(M, z, F, c, S.positions, i.availableImages, i.brightness, i.elevationFeatures);
                    A.insert(e[F].feature, z, F, U, this.index);
                } }
                addConstantDashes(e) { let i = !1; for (const c of this.layers) {
                    const h = c.paint.get("line-dasharray").value, p = c.layout.get("line-cap").value;
                    if (h.kind !== "constant" || p.kind !== "constant")
                        i = !0;
                    else {
                        const m = p.value, x = h.value;
                        if (!x)
                            continue;
                        e.addDash(x, m);
                    }
                } return i; }
                addFeatureDashes(e, i) { const c = this.zoom; for (const h of this.layers) {
                    const p = h.paint.get("line-dasharray").value, m = h.layout.get("line-cap").value;
                    if (p.kind === "constant" && m.kind === "constant")
                        continue;
                    let x, b;
                    if (p.kind === "constant") {
                        if (x = p.value, !x)
                            continue;
                    }
                    else
                        x = p.evaluate({ zoom: c }, e);
                    b = m.kind === "constant" ? m.value : m.evaluate({ zoom: c }, e), i.addDash(x, b), e.patterns[h.id] = [i.getKey(x, b)];
                } }
                update(e, i, c, h, p, m, x) { this.programConfigurations.updatePaintArrays(e, i, p, c, h, m, x); }
                addFeatures(e, i, c, h, p, m) { for (const x of this.patternFeatures)
                    this.addFeature(x, x.geometry, x.index, i, c, h, m); }
                isEmpty() { return this.layoutVertexArray.length === 0; }
                uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload; }
                upload(e) { this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, g5)), this.patternVertexArray.length !== 0 && (this.patternVertexBuffer = e.createVertexBuffer(this.patternVertexArray, y5)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = e.createVertexBuffer(this.zOffsetVertexArray, f5.members, !0)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, p5), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0; }
                destroy() { this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()); }
                lineFeatureClips(e) { if (e.properties && e.properties.hasOwnProperty("mapbox_clip_start") && e.properties.hasOwnProperty("mapbox_clip_end"))
                    return { start: +e.properties.mapbox_clip_start, end: +e.properties.mapbox_clip_end }; }
                addFeature(e, i, c, h, p, m, x, b) { const S = this.layers[0].layout, A = S.get("line-join").evaluate(e, {}), I = S.get("line-cap").evaluate(e, {}), M = S.get("line-miter-limit"), z = S.get("line-round-limit"); this.lineClips = this.lineFeatureClips(e), this.lineFeature = e, this.zOffsetValue = S.get("line-z-offset").value; const F = this.layers[0].paint.get("line-width").value; if (F.kind !== "constant" && F.isLineProgressConstant === !1 && (this.variableWidthValue = F), this.elevationType === "road") {
                    const U = this.layoutVertexArray.length;
                    if (!this.addElevatedRoadFeature(e, i, h, b, A, I, M, z)) {
                        const [X, Y] = this.clipRuntimeLinesToTile(i, 1);
                        for (let le = 0; le < X.length; le++) {
                            const se = X[le], $ = Y[le], te = { progress: { min: $.progress.min, max: $.progress.max }, nextDir: this.computeSegNextDir($, se), prevDir: this.computeSegPrevDir($, se) };
                            this.addLine(se, e, h, A, I, M, z, te);
                        }
                        this.fillNonElevatedRoadSegment(U);
                    }
                }
                else
                    for (const U of i)
                        this.addLine(U, e, h, A, I, M, z); this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, c, p, m, h, x); }
                computeSegNextDir(e, i) { return e.nextPoint.sub(i.at(-2)).unit(); }
                computeSegPrevDir(e, i) { return i[1].sub(e.prevPoint).unit(); }
                clipLinesToTile(e, i) { return Px(e, -i, -i, It + i, It + i); }
                clipRuntimeLinesToTile(e, i) { const c = []; return [Px(e, -i, -i, It + i, It + i, c), c]; }
                addElevatedRoadFeature(e, i, c, h, p, m, x, b) { const S = [], A = BT.getElevationFeature(e, h); if (A) {
                    const I = this.clipLinesToTile(i, 1), M = this.prepareElevatedLines(I, A, c);
                    for (const z of M)
                        S.push({ geometry: z, elevation: A, elevationTileID: c, segment: { progress: { min: 0, max: 1 }, nextDir: void 0, prevDir: void 0 } });
                } if (S.length === 0)
                    return !1; for (const I of S) {
                    const M = this.layoutVertexArray.length;
                    this.addLine(I.geometry, e, c, p, m, x, b);
                    const z = new dP(c, I.elevationTileID);
                    if (I.elevation)
                        for (let F = M; F < this.layoutVertexArray.length; F++) {
                            const U = new Et(this.layoutVertexArray.int16[6 * F] >> 1, this.layoutVertexArray.int16[6 * F + 1] >> 1), X = z.pointElevation(U, I.elevation, .05);
                            this.updateHeightRange(X), this.zOffsetVertexArray.emplaceBack(X, 0, 0);
                        }
                    else
                        this.fillNonElevatedRoadSegment(M);
                } return !0; }
                prepareElevatedLines(e, i, c) { if (i.constantHeight != null)
                    return e; const h = [], p = 1 / Fe(c); for (const m of e)
                    h5(m, new hP(i, p), 0, h); return h; }
                fillNonElevatedRoadSegment(e) { for (let i = e; i < this.layoutVertexArray.length; i++)
                    this.zOffsetVertexArray.emplaceBack(0, 0, 0); }
                updateHeightRange(e) { this.heightRange ? (this.heightRange.min = Math.min(this.heightRange.min, e), this.heightRange.max = Math.max(this.heightRange.max, e)) : this.heightRange = { min: e, max: e }; }
                addLine(e, i, c, h, p, m, x, b) { this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0; const S = h === "none"; this.patternJoinNone = this.hasPattern && S, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = []; const A = b && b.progress.min > 0, I = b && b.progress.max < 1; if (this.lineClips) {
                    let Te = { min: this.lineClips.start, max: this.lineClips.end }, Pe = 1;
                    if (b) {
                        const Ye = this.lineClips.end - this.lineClips.start;
                        Te = function (ut, it, lt) { return { min: Ji(ut.min, it, lt), max: Ji(ut.max, it, lt) }; }(b.progress, { min: 0, max: 1 }, Te), Ye > 0 && (Pe = (Te.max - Te.min) / Ye);
                    }
                    const Me = +i.properties.mapbox_clip_feature_len, Oe = +i.properties.mapbox_clip_seg_len;
                    if (Number.isNaN(Me) || Number.isNaN(Oe)) {
                        for (let ut = 0; ut < e.length - 1; ut++)
                            this.totalDistance += e[ut].dist(e[ut + 1]);
                        const Ye = this.totalDistance / (Te.max - Te.min);
                        this.totalFeatureLength = Number.isFinite(Ye) ? Ye : 0, this.lineClips.start = Te.min, this.lineClips.end = Te.max, this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
                    }
                    else
                        this.totalFeatureLength = Me, this.distance = Oe * Pe, this.lineClips.start = Te.min, this.lineClips.end = Te.max, this.maxLineLength = Math.max(this.maxLineLength, this.distance);
                    this.lineClipsArray.push(this.lineClips), this.updateScaledDistance();
                } const M = v5[i.type] === "Polygon"; let z = e.length; for (; z >= 2 && e[z - 1].equals(e[z - 2]);)
                    z--; let F = 0; for (; F < z - 1 && e[F].equals(e[F + 1]);)
                    F++; if (z < (M ? 3 : 2))
                    return; h === "bevel" && (m = 1.05); const U = this.segments.prepareSegment(10 * z, this.layoutVertexArray, this.indexArray); let X, Y, le, se, $, te, ae, fe; b && b.prevDir && (te = b.prevDir.perp()), b && b.nextDir && (ae = b.nextDir.perp()), this.e1 = this.e2 = -1, M && (X = e[z - 2], $ = e[F].sub(X)._unit()._perp()); for (let Te = F; Te < z; Te++) {
                    if (le = Te === z - 1 ? M ? e[F + 1] : void 0 : e[Te + 1], le && e[Te].equals(le))
                        continue;
                    $ && (se = $), X && (Y = X), X = e[Te], fe = this.evaluateLineProgressFeatures(Y ? Y.dist(X) : 0), $ = le ? le.sub(X)._unit()._perp() : se, se = se || $;
                    const Pe = Y && le;
                    let Me = Pe ? h : M || S ? "butt" : p;
                    const Oe = se.x * $.x + se.y * $.y;
                    if (S) {
                        const Ge = function (Xe) { if (Xe.patternJoinNone) {
                            const gt = Xe.segmentPoints.length / 2, yt = Xe.lineSoFar - Xe.segmentStart;
                            for (let Zt = 0; Zt < gt; ++Zt) {
                                const jt = Xe.segmentPoints[2 * Zt + 1], Rt = Math.round(Xe.segmentPoints[2 * Zt]) + .5 + .25 * jt;
                                Xe.patternVertexArray.emplaceBack(Rt, yt, Xe.segmentStart), Xe.patternVertexArray.emplaceBack(Rt, yt, Xe.segmentStart);
                            }
                            Xe.segmentPoints.length = 0;
                        } Xe.e1 = Xe.e2 = -1; };
                        if (Pe && Oe < w5) {
                            this.updateDistance(Y, X), this.addCurrentVertex(X, se, 1, 1, U, fe), Ge(this), this.addCurrentVertex(X, $, -1, -1, U, fe);
                            continue;
                        }
                        if (Y) {
                            if (!le) {
                                this.updateDistance(Y, X), this.addCurrentVertex(X, se, 1, 1, U, fe), Ge(this);
                                continue;
                            }
                            Me = "miter";
                        }
                    }
                    let Ye = se.add($);
                    Ye.x === 0 && Ye.y === 0 || Ye._unit();
                    const ut = Ye.x * $.x + Ye.y * $.y, it = ut !== 0 ? 1 / ut : 1 / 0, lt = 2 * Math.sqrt(2 - 2 * ut), pt = ut < x5 && Y && le, We = se.x * $.y - se.y * $.x > 0, at = this.overscaling <= 16 ? 15 * It / (512 * this.overscaling) : 0;
                    if (Pe && Me === "round") {
                        if (it < x)
                            Me = "miter";
                        else if (it <= 2) {
                            const Ge = KT(X, -10, It + 10);
                            Me = this.elevationType === "offset" && (Ge || this.hasCrossSlope) ? "miter" : "fakeround";
                        }
                    }
                    if (Me === "miter" && it > m && (Me = "bevel"), Me === "bevel" && (it > 2 && (Me = "flipbevel"), it < m && (Me = "miter")), Y && !(Me === "miter" && pt) && this.updateDistance(Y, X), Me === "miter")
                        if (pt) {
                            const Ge = X.dist(Y);
                            if (Ge > 2 * at) {
                                const gt = X.sub(X.sub(Y)._mult(at / Ge)._round());
                                this.updateDistance(Y, gt), this.addCurrentVertex(gt, se, 0, 0, U, fe), Y = gt;
                            }
                            this.updateDistance(Y, X), Ye._mult(it), this.addCurrentVertex(X, Ye, 0, 0, U, fe);
                            const Xe = X.dist(le);
                            if (Xe > 2 * at) {
                                const gt = X.add(le.sub(X)._mult(at / Xe)._round());
                                this.updateDistance(X, gt), this.addCurrentVertex(gt, $, 0, 0, U, fe), X = gt;
                            }
                        }
                        else
                            Ye._mult(it), this.addCurrentVertex(X, Ye, 0, 0, U, fe);
                    else if (Me === "flipbevel") {
                        if (it > 100)
                            Ye = $.mult(-1);
                        else {
                            const Ge = it * se.add($).mag() / se.sub($).mag();
                            Ye._perp()._mult(Ge * (We ? -1 : 1));
                        }
                        this.addCurrentVertex(X, Ye, 0, 0, U, fe), this.addCurrentVertex(X, Ye.mult(-1), 0, 0, U, fe);
                    }
                    else if (Me === "bevel" || Me === "fakeround") {
                        fe != null && Y && this.addCurrentVertex(X, ae || se, -1, -1, U, fe);
                        const Ge = X.dist(Y) <= 2 * at && Me !== "bevel", Xe = Ye.mult(We ? 1 : -1);
                        Xe._mult(it);
                        const gt = $.mult(We ? -1 : 1), yt = se.mult(We ? -1 : 1), Zt = this.evaluateLineProgressFeatures(this.distance);
                        if (fe == null && (this.addHalfVertex(X, Xe.x, Xe.y, !1, !We, 0, U, Zt), Ge || this.addHalfVertex(X, Xe.x + 2 * yt.x, Xe.y + 2 * yt.y, !1, We, 0, U, Zt)), Me === "fakeround") {
                            const jt = Math.round(180 * lt / Math.PI / 20);
                            this.addHalfVertex(X, yt.x, yt.y, !1, We, 0, U, Zt);
                            for (let Rt = 0; Rt < jt; Rt++) {
                                let mt = Rt / jt;
                                if (mt !== .5) {
                                    const Gt = mt - .5;
                                    mt += mt * Gt * (mt - 1) * ((1.0904 + Oe * (Oe * (3.55645 - 1.43519 * Oe) - 3.2452)) * Gt * Gt + (.848013 + Oe * (.215638 * Oe - 1.06021)));
                                }
                                const pr = gt.sub(yt)._mult(mt)._add(yt)._unit();
                                this.addHalfVertex(X, pr.x, pr.y, !1, We, 0, U, Zt);
                            }
                            this.addHalfVertex(X, gt.x, gt.y, !1, We, 0, U, Zt);
                        }
                        Ge || fe != null || this.addHalfVertex(X, Xe.x + 2 * gt.x, Xe.y + 2 * gt.y, !1, We, 0, U, Zt), fe != null && le && this.addCurrentVertex(X, te || $, 1, 1, U, fe);
                    }
                    else if (Me === "butt")
                        this.addCurrentVertex(X, Ye, 0, 0, U, fe);
                    else if (Me === "square") {
                        if (!Y) {
                            const Ge = A ? 0 : -1;
                            this.addCurrentVertex(X, Ye, Ge, Ge, U, fe);
                        }
                        if (this.addCurrentVertex(X, Ye, 0, 0, U, fe), Y) {
                            const Ge = I ? 0 : 1;
                            this.addCurrentVertex(X, Ye, Ge, Ge, U, fe);
                        }
                    }
                    else if (Me === "round") {
                        if (Y) {
                            const Ge = !Pe && ae ? ae : se;
                            this.addCurrentVertex(X, Ge, 0, 0, U, fe), !Pe && I || this.addCurrentVertex(X, Ge, 1, 1, U, fe, !0);
                        }
                        if (le) {
                            const Ge = !Pe && te ? te : $;
                            !Pe && A || this.addCurrentVertex(X, Ge, -1, -1, U, fe, !0), this.addCurrentVertex(X, Ge, 0, 0, U, fe);
                        }
                    }
                } }
                addVerticesTo(e, i, c, h, p, m, x, b, S, A) { const I = (i.w - e.w) / this.tessellationStep | 0; let M = 0; const z = this.scaledDistance; if (I > 1) {
                    this.lineSoFar = e.w;
                    const U = (i.x - e.x) / I, X = (i.y - e.y) / I, Y = (i.z - e.z) / I, le = (i.w - e.w) / I;
                    for (let se = 1; se < I; ++se) {
                        e.x += U, e.y += X, e.z += Y, this.lineSoFar += le, M += le;
                        const $ = this.evaluateLineProgressFeatures(this.prevDistance + M);
                        this.scaledDistance = (this.prevDistance + M) / this.totalDistance, this.addHalfVertex(e, c, h, A, !1, x, S, $), this.addHalfVertex(e, p, m, A, !0, -b, S, $);
                    }
                } this.lineSoFar = i.w, this.scaledDistance = z; const F = this.evaluateLineProgressFeatures(this.distance); this.addHalfVertex(i, c, h, A, !1, x, S, F), this.addHalfVertex(i, p, m, A, !0, -b, S, F); }
                evaluateLineProgressFeatures(e) { if (!this.variableWidthValue && this.elevationType !== "offset")
                    return null; this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + e) / this.totalFeatureLength) : Br(`line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`); let i = 0; return this.variableWidthValue && this.variableWidthValue.kind !== "constant" && (i = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), this.elevationType !== "offset" ? { zOffset: 0, variableWidth: i } : this.zOffsetValue.kind === "constant" ? { zOffset: this.zOffsetValue.value, variableWidth: i } : { zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0, variableWidth: i }; }
                addCurrentVertex(e, i, c, h, p, m, x = !1) { const b = i.x + i.y * c, S = i.y - i.x * c, A = i.y * h - i.x, I = -i.y - i.x * h; if (m != null) {
                    const M = this.elevationType === "offset", z = -10, F = It + 10, U = m.zOffset, X = new HP(e.x, e.y, U, this.lineSoFar), Y = !!M && KT(e, z, F), le = this.lineSoFar, se = this.distance;
                    if (this.currentVertex)
                        if (Y) {
                            const $ = this.currentVertexIsOutside, te = this.currentVertex, ae = new HP(e.x, e.y, U, this.lineSoFar);
                            if (ZP(te, ae, z, F), !KT(ae, z, F)) {
                                if ($) {
                                    this.e1 = this.e2 = -1, this.distance -= te.dist(X), this.lineSoFar = te.w;
                                    const fe = this.evaluateLineProgressFeatures(te.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                                    this.addHalfVertex(te, b, S, x, !1, c, p, fe), this.addHalfVertex(te, A, I, x, !0, -h, p, fe), this.prevDistance = this.distance;
                                }
                                this.distance = this.prevDistance + te.dist(ae), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(te, ae, b, S, A, I, c, h, p, x), this.distance = se, this.scaledDistance = this.distance / this.totalDistance;
                            }
                        }
                        else {
                            const $ = this.currentVertex;
                            if (this.currentVertexIsOutside) {
                                ZP($, X, z, F), this.e1 = this.e2 = -1, this.distance -= $.dist(X), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = $.w;
                                const te = this.evaluateLineProgressFeatures($.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                                this.addHalfVertex($, b, S, x, !1, c, p, te), this.addHalfVertex($, A, I, x, !0, -h, p, te), this.prevDistance = this.distance, this.distance = se, this.scaledDistance = this.distance / this.totalDistance;
                            }
                            this.addVerticesTo($, X, b, S, A, I, c, h, p, x);
                        }
                    else
                        Y || (this.addHalfVertex(e, b, S, x, !1, c, p, m), this.addHalfVertex(e, A, I, x, !0, -h, p, m));
                    this.currentVertex = X, this.currentVertexIsOutside = Y, this.lineSoFar = le;
                }
                else
                    this.addHalfVertex(e, b, S, x, !1, c, p, m), this.addHalfVertex(e, A, I, x, !0, -h, p, m); }
                addHalfVertex({ x: e, y: i }, c, h, p, m, x, b, S) { if (this.patternJoinNone && (this.segmentPoints.length === 0 && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), m || this.segmentPoints.push(this.lineSoFar - this.segmentStart, x)), this.layoutVertexArray.emplaceBack((e << 1) + (p ? 1 : 0), (i << 1) + (m ? 1 : 0), Math.round(63 * c) + 128, Math.round(63 * h) + 128, 1 + (x === 0 ? 0 : x < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips) {
                    const I = nr(this.lineClips.start, this.lineClips.end, this.scaledDistance);
                    this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, I);
                } const A = b.vertexLength++; this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, A), b.primitiveLength++), m ? this.e2 = A : this.e1 = A, S != null && this.zOffsetVertexArray.emplaceBack(S.zOffset, S.variableWidth, S.variableWidth); }
                updateScaledDistance() { this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance; }
                updateDistance(e, i) { this.prevDistance = this.distance, this.distance += e.dist(i), this.updateScaledDistance(); }
            }
            function KT(a, e, i) { return a.x < e || a.x > i || a.y < e || a.y > i; }
            let JP, eM;
            function tM(a, e, i) { return e * (It / (a.tileSize * Math.pow(2, i - a.tileID.overscaledZ))); }
            Nt(XT, "LineBucket", { omit: ["layers", "patternFeatures", "currentVertex", "currentVertexIsOutside"] });
            const rM = (a, e, i) => (1 - i) * a + i * e;
            function nM(a, e) { return 1 / tM(a, 1, e.tileZoom); }
            function iM(a, e, i, c) { return a.translatePosMatrix(c || e.tileID.projMatrix, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor")); }
            const sM = a => { const e = []; oM(a) && e.push("RENDER_LINE_DASH"), a.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT"); const i = a.paint.get("line-trim-offset"); i[0] === 0 && i[1] === 0 || e.push("RENDER_LINE_TRIM_OFFSET"), a.paint.get("line-border-width").constantOr(1) !== 0 && e.push("RENDER_LINE_BORDER"); const c = a.layout.get("line-join").constantOr("miter") === "none", h = !!a.paint.get("line-pattern").constantOr(1); return c && h && e.push("LINE_JOIN_NONE"), e; };
            function oM(a) { const e = a.paint.get("line-dasharray").value; return e.value || e.kind !== "constant"; }
            let YT;
            const aM = () => YT || (YT = { layout: JP || (JP = new gi({ "line-cap": new zt(Ne.layout_line["line-cap"]), "line-join": new zt(Ne.layout_line["line-join"]), "line-miter-limit": new wt(Ne.layout_line["line-miter-limit"]), "line-round-limit": new wt(Ne.layout_line["line-round-limit"]), "line-sort-key": new zt(Ne.layout_line["line-sort-key"]), "line-z-offset": new zt(Ne.layout_line["line-z-offset"]), "line-elevation-reference": new wt(Ne.layout_line["line-elevation-reference"]), "line-cross-slope": new wt(Ne.layout_line["line-cross-slope"]), visibility: new wt(Ne.layout_line.visibility), "line-width-unit": new wt(Ne.layout_line["line-width-unit"]) })), paint: eM || (eM = new gi({ "line-opacity": new zt(Ne.paint_line["line-opacity"]), "line-color": new zt(Ne.paint_line["line-color"]), "line-translate": new wt(Ne.paint_line["line-translate"]), "line-translate-anchor": new wt(Ne.paint_line["line-translate-anchor"]), "line-width": new zt(Ne.paint_line["line-width"]), "line-gap-width": new zt(Ne.paint_line["line-gap-width"]), "line-offset": new zt(Ne.paint_line["line-offset"]), "line-blur": new zt(Ne.paint_line["line-blur"]), "line-dasharray": new zt(Ne.paint_line["line-dasharray"]), "line-pattern": new zt(Ne.paint_line["line-pattern"]), "line-pattern-cross-fade": new wt(Ne.paint_line["line-pattern-cross-fade"]), "line-gradient": new Fc(Ne.paint_line["line-gradient"]), "line-trim-offset": new wt(Ne.paint_line["line-trim-offset"]), "line-trim-fade-range": new wt(Ne.paint_line["line-trim-fade-range"]), "line-trim-color": new wt(Ne.paint_line["line-trim-color"]), "line-emissive-strength": new wt(Ne.paint_line["line-emissive-strength"]), "line-border-width": new zt(Ne.paint_line["line-border-width"]), "line-border-color": new zt(Ne.paint_line["line-border-color"]), "line-occlusion-opacity": new wt(Ne.paint_line["line-occlusion-opacity"]), "line-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "line-gradient-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "line-trim-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "line-border-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, YT);
            class b5 extends zt {
                possiblyEvaluate(e, i) { return i = new yn(Math.floor(i.zoom), { now: i.now, fadeDuration: i.fadeDuration, transition: i.transition }), super.possiblyEvaluate(e, i); }
                evaluate(e, i, c, h) { return i = $e({}, i, { zoom: Math.floor(i.zoom) }), super.evaluate(e, i, c, h); }
            }
            let Y_;
            function lM(a, e) { return e > 0 ? e + 2 * a : a; }
            const T5 = tn([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), S5 = tn([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), E5 = tn([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
            tn([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
            const C5 = tn([{ name: "a_auto_z_offset", components: 1, type: "Float32" }], 4), A5 = tn([{ name: "a_texb", components: 2, type: "Uint16" }]), I5 = tn([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_elevation_from_sea", components: 2, type: "Float32" }]), P5 = tn([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }, { name: "a_auto_z_offset", components: 1, type: "Float32" }]);
            tn([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
            const cM = tn([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), M5 = tn([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
            tn([{ name: "triangle", components: 3, type: "Uint16" }]), tn([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), tn([{ type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Float32", name: "zOffset" }, { type: "Uint8", name: "hasIconTextFit" }, { type: "Uint16", name: "elevationFeatureIndex" }]), tn([{ type: "Float32", name: "offsetX" }]), tn([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
            var ts = 24;
            function R5(a, e, i) { return a.sections.forEach(c => { c.text = function (h, p, m) { const x = p.layout.get("text-transform").evaluate(m, {}); return x === "uppercase" ? h = h.toLocaleUpperCase() : x === "lowercase" && (h = h.toLocaleLowerCase()), zo.applyArabicShaping && (h = zo.applyArabicShaping(h)), h; }(c.text, e, i); }), a; }
            const Q_ = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
            function k5(a) { return a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === ""; }
            function D5(a) { return a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === ""; }
            var uM, QT, hM, JT = {}; /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
            function L5() { return uM || (uM = 1, JT.read = function (a, e, i, c, h) { var p, m, x = 8 * h - c - 1, b = (1 << x) - 1, S = b >> 1, A = -7, I = i ? h - 1 : 0, M = i ? -1 : 1, z = a[e + I]; for (I += M, p = z & (1 << -A) - 1, z >>= -A, A += x; A > 0; p = 256 * p + a[e + I], I += M, A -= 8)
                ; for (m = p & (1 << -A) - 1, p >>= -A, A += c; A > 0; m = 256 * m + a[e + I], I += M, A -= 8)
                ; if (p === 0)
                p = 1 - S;
            else {
                if (p === b)
                    return m ? NaN : 1 / 0 * (z ? -1 : 1);
                m += Math.pow(2, c), p -= S;
            } return (z ? -1 : 1) * m * Math.pow(2, p - c); }, JT.write = function (a, e, i, c, h, p) { var m, x, b, S = 8 * p - h - 1, A = (1 << S) - 1, I = A >> 1, M = h === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, z = c ? 0 : p - 1, F = c ? 1 : -1, U = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (x = isNaN(e) ? 1 : 0, m = A) : (m = Math.floor(Math.log(e) / Math.LN2), e * (b = Math.pow(2, -m)) < 1 && (m--, b *= 2), (e += m + I >= 1 ? M / b : M * Math.pow(2, 1 - I)) * b >= 2 && (m++, b /= 2), m + I >= A ? (x = 0, m = A) : m + I >= 1 ? (x = (e * b - 1) * Math.pow(2, h), m += I) : (x = e * Math.pow(2, I - 1) * Math.pow(2, h), m = 0)); h >= 8; a[i + z] = 255 & x, z += F, x /= 256, h -= 8)
                ; for (m = m << h | x, S += h; S > 0; a[i + z] = 255 & m, z += F, m /= 256, S -= 8)
                ; a[i + z - F] |= 128 * U; }), JT; }
            function dM() { if (hM)
                return QT; hM = 1, QT = e; var a = L5(); function e($) { this.buf = ArrayBuffer.isView && ArrayBuffer.isView($) ? $ : new Uint8Array($ || 0), this.pos = 0, this.type = 0, this.length = this.buf.length; } e.Varint = 0, e.Fixed64 = 1, e.Bytes = 2, e.Fixed32 = 5; var i = 4294967296, c = 1 / i, h = typeof TextDecoder > "u" ? null : new TextDecoder("utf8"); function p($) { return $.type === e.Bytes ? $.readVarint() + $.pos : $.pos + 1; } function m($, te, ae) { return ae ? 4294967296 * te + ($ >>> 0) : 4294967296 * (te >>> 0) + ($ >>> 0); } function x($, te, ae) { var fe = te <= 16383 ? 1 : te <= 2097151 ? 2 : te <= 268435455 ? 3 : Math.floor(Math.log(te) / (7 * Math.LN2)); ae.realloc(fe); for (var Te = ae.pos - 1; Te >= $; Te--)
                ae.buf[Te + fe] = ae.buf[Te]; } function b($, te) { for (var ae = 0; ae < $.length; ae++)
                te.writeVarint($[ae]); } function S($, te) { for (var ae = 0; ae < $.length; ae++)
                te.writeSVarint($[ae]); } function A($, te) { for (var ae = 0; ae < $.length; ae++)
                te.writeFloat($[ae]); } function I($, te) { for (var ae = 0; ae < $.length; ae++)
                te.writeDouble($[ae]); } function M($, te) { for (var ae = 0; ae < $.length; ae++)
                te.writeBoolean($[ae]); } function z($, te) { for (var ae = 0; ae < $.length; ae++)
                te.writeFixed32($[ae]); } function F($, te) { for (var ae = 0; ae < $.length; ae++)
                te.writeSFixed32($[ae]); } function U($, te) { for (var ae = 0; ae < $.length; ae++)
                te.writeFixed64($[ae]); } function X($, te) { for (var ae = 0; ae < $.length; ae++)
                te.writeSFixed64($[ae]); } function Y($, te) { return ($[te] | $[te + 1] << 8 | $[te + 2] << 16) + 16777216 * $[te + 3]; } function le($, te, ae) { $[ae] = te, $[ae + 1] = te >>> 8, $[ae + 2] = te >>> 16, $[ae + 3] = te >>> 24; } function se($, te) { return ($[te] | $[te + 1] << 8 | $[te + 2] << 16) + ($[te + 3] << 24); } return e.prototype = { destroy: function () { this.buf = null; }, readFields: function ($, te, ae) { for (ae = ae || this.length; this.pos < ae;) {
                    var fe = this.readVarint(), Te = fe >> 3, Pe = this.pos;
                    this.type = 7 & fe, $(Te, te, this), this.pos === Pe && this.skip(fe);
                } return te; }, readMessage: function ($, te) { return this.readFields($, te, this.readVarint() + this.pos); }, readFixed32: function () { var $ = Y(this.buf, this.pos); return this.pos += 4, $; }, readSFixed32: function () { var $ = se(this.buf, this.pos); return this.pos += 4, $; }, readFixed64: function () { var $ = Y(this.buf, this.pos) + Y(this.buf, this.pos + 4) * i; return this.pos += 8, $; }, readSFixed64: function () { var $ = Y(this.buf, this.pos) + se(this.buf, this.pos + 4) * i; return this.pos += 8, $; }, readFloat: function () { var $ = a.read(this.buf, this.pos, !0, 23, 4); return this.pos += 4, $; }, readDouble: function () { var $ = a.read(this.buf, this.pos, !0, 52, 8); return this.pos += 8, $; }, readVarint: function ($) { var te, ae, fe = this.buf; return te = 127 & (ae = fe[this.pos++]), ae < 128 ? te : (te |= (127 & (ae = fe[this.pos++])) << 7, ae < 128 ? te : (te |= (127 & (ae = fe[this.pos++])) << 14, ae < 128 ? te : (te |= (127 & (ae = fe[this.pos++])) << 21, ae < 128 ? te : function (Te, Pe, Me) { var Oe, Ye, ut = Me.buf; if (Oe = (112 & (Ye = ut[Me.pos++])) >> 4, Ye < 128 || (Oe |= (127 & (Ye = ut[Me.pos++])) << 3, Ye < 128) || (Oe |= (127 & (Ye = ut[Me.pos++])) << 10, Ye < 128) || (Oe |= (127 & (Ye = ut[Me.pos++])) << 17, Ye < 128) || (Oe |= (127 & (Ye = ut[Me.pos++])) << 24, Ye < 128) || (Oe |= (1 & (Ye = ut[Me.pos++])) << 31, Ye < 128))
                    return m(Te, Oe, Pe); throw new Error("Expected varint not more than 10 bytes"); }(te |= (15 & (ae = fe[this.pos])) << 28, $, this)))); }, readVarint64: function () { return this.readVarint(!0); }, readSVarint: function () { var $ = this.readVarint(); return $ % 2 == 1 ? ($ + 1) / -2 : $ / 2; }, readBoolean: function () { return !!this.readVarint(); }, readString: function () { var $ = this.readVarint() + this.pos, te = this.pos; return this.pos = $, $ - te >= 12 && h ? function (ae, fe, Te) { return h.decode(ae.subarray(fe, Te)); }(this.buf, te, $) : function (ae, fe, Te) { for (var Pe = "", Me = fe; Me < Te;) {
                    var Oe, Ye, ut, it = ae[Me], lt = null, pt = it > 239 ? 4 : it > 223 ? 3 : it > 191 ? 2 : 1;
                    if (Me + pt > Te)
                        break;
                    pt === 1 ? it < 128 && (lt = it) : pt === 2 ? (192 & (Oe = ae[Me + 1])) == 128 && (lt = (31 & it) << 6 | 63 & Oe) <= 127 && (lt = null) : pt === 3 ? (Ye = ae[Me + 2], (192 & (Oe = ae[Me + 1])) == 128 && (192 & Ye) == 128 && ((lt = (15 & it) << 12 | (63 & Oe) << 6 | 63 & Ye) <= 2047 || lt >= 55296 && lt <= 57343) && (lt = null)) : pt === 4 && (Ye = ae[Me + 2], ut = ae[Me + 3], (192 & (Oe = ae[Me + 1])) == 128 && (192 & Ye) == 128 && (192 & ut) == 128 && ((lt = (15 & it) << 18 | (63 & Oe) << 12 | (63 & Ye) << 6 | 63 & ut) <= 65535 || lt >= 1114112) && (lt = null)), lt === null ? (lt = 65533, pt = 1) : lt > 65535 && (lt -= 65536, Pe += String.fromCharCode(lt >>> 10 & 1023 | 55296), lt = 56320 | 1023 & lt), Pe += String.fromCharCode(lt), Me += pt;
                } return Pe; }(this.buf, te, $); }, readBytes: function () { var $ = this.readVarint() + this.pos, te = this.buf.subarray(this.pos, $); return this.pos = $, te; }, readPackedVarint: function ($, te) { if (this.type !== e.Bytes)
                    return $.push(this.readVarint(te)); var ae = p(this); for ($ = $ || []; this.pos < ae;)
                    $.push(this.readVarint(te)); return $; }, readPackedSVarint: function ($) { if (this.type !== e.Bytes)
                    return $.push(this.readSVarint()); var te = p(this); for ($ = $ || []; this.pos < te;)
                    $.push(this.readSVarint()); return $; }, readPackedBoolean: function ($) { if (this.type !== e.Bytes)
                    return $.push(this.readBoolean()); var te = p(this); for ($ = $ || []; this.pos < te;)
                    $.push(this.readBoolean()); return $; }, readPackedFloat: function ($) { if (this.type !== e.Bytes)
                    return $.push(this.readFloat()); var te = p(this); for ($ = $ || []; this.pos < te;)
                    $.push(this.readFloat()); return $; }, readPackedDouble: function ($) { if (this.type !== e.Bytes)
                    return $.push(this.readDouble()); var te = p(this); for ($ = $ || []; this.pos < te;)
                    $.push(this.readDouble()); return $; }, readPackedFixed32: function ($) { if (this.type !== e.Bytes)
                    return $.push(this.readFixed32()); var te = p(this); for ($ = $ || []; this.pos < te;)
                    $.push(this.readFixed32()); return $; }, readPackedSFixed32: function ($) { if (this.type !== e.Bytes)
                    return $.push(this.readSFixed32()); var te = p(this); for ($ = $ || []; this.pos < te;)
                    $.push(this.readSFixed32()); return $; }, readPackedFixed64: function ($) { if (this.type !== e.Bytes)
                    return $.push(this.readFixed64()); var te = p(this); for ($ = $ || []; this.pos < te;)
                    $.push(this.readFixed64()); return $; }, readPackedSFixed64: function ($) { if (this.type !== e.Bytes)
                    return $.push(this.readSFixed64()); var te = p(this); for ($ = $ || []; this.pos < te;)
                    $.push(this.readSFixed64()); return $; }, skip: function ($) { var te = 7 & $; if (te === e.Varint)
                    for (; this.buf[this.pos++] > 127;)
                        ;
                else if (te === e.Bytes)
                    this.pos = this.readVarint() + this.pos;
                else if (te === e.Fixed32)
                    this.pos += 4;
                else {
                    if (te !== e.Fixed64)
                        throw new Error("Unimplemented type: " + te);
                    this.pos += 8;
                } }, writeTag: function ($, te) { this.writeVarint($ << 3 | te); }, realloc: function ($) { for (var te = this.length || 16; te < this.pos + $;)
                    te *= 2; if (te !== this.length) {
                    var ae = new Uint8Array(te);
                    ae.set(this.buf), this.buf = ae, this.length = te;
                } }, finish: function () { return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length); }, writeFixed32: function ($) { this.realloc(4), le(this.buf, $, this.pos), this.pos += 4; }, writeSFixed32: function ($) { this.realloc(4), le(this.buf, $, this.pos), this.pos += 4; }, writeFixed64: function ($) { this.realloc(8), le(this.buf, -1 & $, this.pos), le(this.buf, Math.floor($ * c), this.pos + 4), this.pos += 8; }, writeSFixed64: function ($) { this.realloc(8), le(this.buf, -1 & $, this.pos), le(this.buf, Math.floor($ * c), this.pos + 4), this.pos += 8; }, writeVarint: function ($) { ($ = +$ || 0) > 268435455 || $ < 0 ? function (te, ae) { var fe, Te; if (te >= 0 ? (fe = te % 4294967296 | 0, Te = te / 4294967296 | 0) : (Te = ~(-te / 4294967296), 4294967295 ^ (fe = ~(-te % 4294967296)) ? fe = fe + 1 | 0 : (fe = 0, Te = Te + 1 | 0)), te >= 18446744073709552e3 || te < -18446744073709552e3)
                    throw new Error("Given varint doesn't fit into 10 bytes"); ae.realloc(10), function (Pe, Me, Oe) { Oe.buf[Oe.pos++] = 127 & Pe | 128, Pe >>>= 7, Oe.buf[Oe.pos++] = 127 & Pe | 128, Pe >>>= 7, Oe.buf[Oe.pos++] = 127 & Pe | 128, Pe >>>= 7, Oe.buf[Oe.pos++] = 127 & Pe | 128, Oe.buf[Oe.pos] = 127 & (Pe >>>= 7); }(fe, 0, ae), function (Pe, Me) { var Oe = (7 & Pe) << 4; Me.buf[Me.pos++] |= Oe | ((Pe >>>= 3) ? 128 : 0), Pe && (Me.buf[Me.pos++] = 127 & Pe | ((Pe >>>= 7) ? 128 : 0), Pe && (Me.buf[Me.pos++] = 127 & Pe | ((Pe >>>= 7) ? 128 : 0), Pe && (Me.buf[Me.pos++] = 127 & Pe | ((Pe >>>= 7) ? 128 : 0), Pe && (Me.buf[Me.pos++] = 127 & Pe | ((Pe >>>= 7) ? 128 : 0), Pe && (Me.buf[Me.pos++] = 127 & Pe))))); }(Te, ae); }($, this) : (this.realloc(4), this.buf[this.pos++] = 127 & $ | ($ > 127 ? 128 : 0), $ <= 127 || (this.buf[this.pos++] = 127 & ($ >>>= 7) | ($ > 127 ? 128 : 0), $ <= 127 || (this.buf[this.pos++] = 127 & ($ >>>= 7) | ($ > 127 ? 128 : 0), $ <= 127 || (this.buf[this.pos++] = $ >>> 7 & 127)))); }, writeSVarint: function ($) { this.writeVarint($ < 0 ? 2 * -$ - 1 : 2 * $); }, writeBoolean: function ($) { this.writeVarint(!!$); }, writeString: function ($) { $ = String($), this.realloc(4 * $.length), this.pos++; var te = this.pos; this.pos = function (fe, Te, Pe) { for (var Me, Oe, Ye = 0; Ye < Te.length; Ye++) {
                    if ((Me = Te.charCodeAt(Ye)) > 55295 && Me < 57344) {
                        if (!Oe) {
                            Me > 56319 || Ye + 1 === Te.length ? (fe[Pe++] = 239, fe[Pe++] = 191, fe[Pe++] = 189) : Oe = Me;
                            continue;
                        }
                        if (Me < 56320) {
                            fe[Pe++] = 239, fe[Pe++] = 191, fe[Pe++] = 189, Oe = Me;
                            continue;
                        }
                        Me = Oe - 55296 << 10 | Me - 56320 | 65536, Oe = null;
                    }
                    else
                        Oe && (fe[Pe++] = 239, fe[Pe++] = 191, fe[Pe++] = 189, Oe = null);
                    Me < 128 ? fe[Pe++] = Me : (Me < 2048 ? fe[Pe++] = Me >> 6 | 192 : (Me < 65536 ? fe[Pe++] = Me >> 12 | 224 : (fe[Pe++] = Me >> 18 | 240, fe[Pe++] = Me >> 12 & 63 | 128), fe[Pe++] = Me >> 6 & 63 | 128), fe[Pe++] = 63 & Me | 128);
                } return Pe; }(this.buf, $, this.pos); var ae = this.pos - te; ae >= 128 && x(te, ae, this), this.pos = te - 1, this.writeVarint(ae), this.pos += ae; }, writeFloat: function ($) { this.realloc(4), a.write(this.buf, $, this.pos, !0, 23, 4), this.pos += 4; }, writeDouble: function ($) { this.realloc(8), a.write(this.buf, $, this.pos, !0, 52, 8), this.pos += 8; }, writeBytes: function ($) { var te = $.length; this.writeVarint(te), this.realloc(te); for (var ae = 0; ae < te; ae++)
                    this.buf[this.pos++] = $[ae]; }, writeRawMessage: function ($, te) { this.pos++; var ae = this.pos; $(te, this); var fe = this.pos - ae; fe >= 128 && x(ae, fe, this), this.pos = ae - 1, this.writeVarint(fe), this.pos += fe; }, writeMessage: function ($, te, ae) { this.writeTag($, e.Bytes), this.writeRawMessage(te, ae); }, writePackedVarint: function ($, te) { te.length && this.writeMessage($, b, te); }, writePackedSVarint: function ($, te) { te.length && this.writeMessage($, S, te); }, writePackedBoolean: function ($, te) { te.length && this.writeMessage($, M, te); }, writePackedFloat: function ($, te) { te.length && this.writeMessage($, A, te); }, writePackedDouble: function ($, te) { te.length && this.writeMessage($, I, te); }, writePackedFixed32: function ($, te) { te.length && this.writeMessage($, z, te); }, writePackedSFixed32: function ($, te) { te.length && this.writeMessage($, F, te); }, writePackedFixed64: function ($, te) { te.length && this.writeMessage($, U, te); }, writePackedSFixed64: function ($, te) { te.length && this.writeMessage($, X, te); }, writeBytesField: function ($, te) { this.writeTag($, e.Bytes), this.writeBytes(te); }, writeFixed32Field: function ($, te) { this.writeTag($, e.Fixed32), this.writeFixed32(te); }, writeSFixed32Field: function ($, te) { this.writeTag($, e.Fixed32), this.writeSFixed32(te); }, writeFixed64Field: function ($, te) { this.writeTag($, e.Fixed64), this.writeFixed64(te); }, writeSFixed64Field: function ($, te) { this.writeTag($, e.Fixed64), this.writeSFixed64(te); }, writeVarintField: function ($, te) { this.writeTag($, e.Varint), this.writeVarint(te); }, writeSVarintField: function ($, te) { this.writeTag($, e.Varint), this.writeSVarint(te); }, writeStringField: function ($, te) { this.writeTag($, e.Bytes), this.writeString(te); }, writeFloatField: function ($, te) { this.writeTag($, e.Fixed32), this.writeFloat(te); }, writeDoubleField: function ($, te) { this.writeTag($, e.Fixed64), this.writeDouble(te); }, writeBooleanField: function ($, te) { this.writeVarintField($, !!te); } }, QT; }
            var Mx = ba(dM());
            const eS = 3;
            function O5(a, e, i) { e.glyphs = [], a === 1 && i.readMessage(z5, e); }
            function z5(a, e, i) { if (a === 3) {
                const { id: c, bitmap: h, width: p, height: m, left: x, top: b, advance: S } = i.readMessage(F5, {});
                e.glyphs.push({ id: c, bitmap: new Yu({ width: p + 2 * eS, height: m + 2 * eS }, h), metrics: { width: p, height: m, left: x, top: b, advance: S } });
            }
            else
                a === 4 ? e.ascender = i.readSVarint() : a === 5 && (e.descender = i.readSVarint()); }
            function F5(a, e, i) { a === 1 ? e.id = i.readVarint() : a === 2 ? e.bitmap = i.readBytes() : a === 3 ? e.width = i.readVarint() : a === 4 ? e.height = i.readVarint() : a === 5 ? e.left = i.readSVarint() : a === 6 ? e.top = i.readSVarint() : a === 7 && (e.advance = i.readVarint()); }
            const fM = eS, go = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
            class J_ {
                constructor() { this.scale = 1, this.fontStack = "", this.image = null; }
                static forText(e, i) { const c = new J_; return c.scale = e || 1, c.fontStack = i, c; }
                static forImage(e) { const i = new J_; return i.image = e, i; }
            }
            class Kp {
                constructor() { this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null; }
                static fromFeature(e, i, c) { const h = new Kp; for (let p = 0; p < e.sections.length; p++) {
                    const m = e.sections[p];
                    m.image ? h.addImageSection(m, c) : h.addTextSection(m, i);
                } return h; }
                length() { return this.text.length; }
                getSection(e) { return this.sections[this.sectionIndex[e]]; }
                getSections() { return this.sections; }
                getSectionIndex(e) { return this.sectionIndex[e]; }
                getCodePoint(e) { return this.text.codePointAt(e); }
                verticalizePunctuation(e) { this.text = function (i, c) { let h = ""; for (let p = 0; p < i.length; p++) {
                    const m = i.charCodeAt(p + 1) || null, x = i.charCodeAt(p - 1) || null;
                    h += !c && (m && H0(m) && !Q_[i[p + 1]] || x && H0(x) && !Q_[i[p - 1]]) || !Q_[i[p]] ? i[p] : Q_[i[p]];
                } return h; }(this.text, e); }
                trim() { let e = 0; for (let c = 0; c < this.text.length && Rx[this.text.charCodeAt(c)]; c++)
                    e++; let i = this.text.length; for (let c = this.text.length - 1; c >= 0 && c >= e && Rx[this.text.charCodeAt(c)]; c--)
                    i--; this.text = this.text.substring(e, i), this.sectionIndex = this.sectionIndex.slice(e, i); }
                substring(e, i) { const c = new Kp; return c.text = this.text.substring(e, i), c.sectionIndex = this.sectionIndex.slice(e, i), c.sections = this.sections, c; }
                toString() { return this.text; }
                getMaxScale() { return this.sectionIndex.reduce((e, i) => Math.max(e, this.sections[i].scale), 0); }
                addTextSection(e, i) { this.text += e.text, this.sections.push(J_.forText(e.scale, e.fontStack || i)); const c = this.sections.length - 1; for (let h = 0; h < e.text.length; ++h)
                    this.sectionIndex.push(c); }
                addImageSection(e, i) { const c = e.image ? e.image.getPrimary() : null; if (!c)
                    return void Br("Can't add FormattedSection with an empty image."); c.scaleSelf(i); const h = this.getNextImageSectionCharCode(); h ? (this.text += String.fromCodePoint(h), this.sections.push(J_.forImage(c)), this.sectionIndex.push(this.sections.length - 1)) : Br("Reached maximum number of images 6401"); }
                getNextImageSectionCharCode() { return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID); }
            }
            function tS(a, e, i, c, h, p, m, x, b, S, A, I, M, z, F, U = 1) { const X = Kp.fromFeature(a, h, U); I === go.vertical && X.verticalizePunctuation(M); let Y = []; const le = function (fe, Te, Pe, Me, Oe, Ye) { if (!fe)
                return []; const ut = [], it = function (at, Ge, Xe, gt, yt, Zt) { let jt = 0; for (let Rt = 0; Rt < at.length(); Rt++) {
                const mt = at.getSection(Rt);
                jt += pM(at.getCodePoint(Rt), mt, gt, yt, Ge, Zt);
            } return jt / Math.max(1, Math.ceil(jt / Xe)); }(fe, Te, Pe, Me, Oe, Ye), lt = fe.text.indexOf("") >= 0; let pt = 0; for (let at = 0; at < fe.length(); at++) {
                const Ge = fe.getSection(at), Xe = fe.getCodePoint(at);
                if (Rx[Xe] || (pt += pM(Xe, Ge, Me, Oe, Te, Ye)), at < fe.length() - 1) {
                    const gt = !((We = Xe) < 11904 || !(sr["Bopomofo Extended"](We) || sr.Bopomofo(We) || sr["CJK Compatibility Forms"](We) || sr["CJK Compatibility Ideographs"](We) || sr["CJK Compatibility"](We) || sr["CJK Radicals Supplement"](We) || sr["CJK Strokes"](We) || sr["CJK Symbols and Punctuation"](We) || sr["CJK Unified Ideographs Extension A"](We) || sr["CJK Unified Ideographs"](We) || sr["Enclosed CJK Letters and Months"](We) || sr["Halfwidth and Fullwidth Forms"](We) || sr.Hiragana(We) || sr["Ideographic Description Characters"](We) || sr["Kangxi Radicals"](We) || sr["Katakana Phonetic Extensions"](We) || sr.Katakana(We) || sr["Vertical Forms"](We) || sr["Yi Radicals"](We) || sr["Yi Syllables"](We)));
                    (N5[Xe] || gt || Ge.image) && ut.push(gM(at + 1, pt, it, ut, B5(Xe, fe.getCodePoint(at + 1), gt && lt), !1));
                }
            } var We; return _M(gM(fe.length(), pt, it, ut, 0, !0)); }(X, S, p, e, c, z), { processBidirectionalText: se, processStyledBidirectionalText: $ } = zo; if (se && X.sections.length === 1) {
                const fe = se(X.toString(), le);
                for (const Te of fe) {
                    const Pe = new Kp;
                    Pe.text = Te, Pe.sections = X.sections;
                    for (let Me = 0; Me < Te.length; Me++)
                        Pe.sectionIndex.push(0);
                    Y.push(Pe);
                }
            }
            else if ($) {
                const fe = $(X.text, X.sectionIndex, le);
                for (const Te of fe) {
                    const Pe = new Kp;
                    Pe.text = Te[0], Pe.sectionIndex = Te[1], Pe.sections = X.sections, Y.push(Pe);
                }
            }
            else
                Y = function (fe, Te) { const Pe = [], Me = fe.text; let Oe = 0; for (const Ye of Te)
                    Pe.push(fe.substring(Oe, Ye)), Oe = Ye; return Oe < Me.length && Pe.push(fe.substring(Oe, Me.length)), Pe; }(X, le); const te = [], ae = { positionedLines: te, text: X.toString(), top: A[1], bottom: A[1], left: A[0], right: A[0], writingMode: I, iconsInText: !1, verticalizable: !1, hasBaseline: !1 }; if (function (fe, Te, Pe, Me, Oe, Ye, ut, it, lt, pt, We, at) { let Ge = 0, Xe = 0, gt = 0; const yt = it === "right" ? 1 : it === "left" ? 0 : .5; let Zt = !1; for (const qt of Oe) {
                const hr = qt.getSections();
                for (const wr of hr) {
                    if (wr.image)
                        continue;
                    const Tr = Te[wr.fontStack];
                    if (Tr && (Zt = Tr.ascender !== void 0 && Tr.descender !== void 0, !Zt))
                        break;
                }
                if (!Zt)
                    break;
            } let jt = 0; for (const qt of Oe) {
                qt.trim();
                const hr = qt.getMaxScale(), wr = (hr - 1) * ts, Tr = { positionedGlyphs: [], lineOffset: 0 };
                fe.positionedLines[jt] = Tr;
                const Lr = Tr.positionedGlyphs;
                let Pr = 0;
                if (!qt.length()) {
                    Xe += Ye, ++jt;
                    continue;
                }
                let Ar = 0, Tn = 0;
                for (let he = 0; he < qt.length(); he++) {
                    const pe = qt.getSection(he), Je = qt.getSectionIndex(he), Tt = qt.getCodePoint(he);
                    let Lt = pe.scale, Dt = null, Ht = null, lr = null, Vr = ts, Ur = 0;
                    lt === go.vertical && ((Rt = Tt) === 12312 || Rt === 12313 || Rt === 12316 || Rt === 12540 || Rt === 12448) && (lt = go.horizontal);
                    const Ir = !(lt === go.horizontal || !We && !Dd(Tt) || We && (Rx[Tt] || fT(Tt)));
                    if (pe.image) {
                        const pn = Me.get(pe.image.toString());
                        if (!pn)
                            continue;
                        lr = pe.image, fe.iconsInText = fe.iconsInText || !0, Ht = pn.paddedRect;
                        const Pn = pn.displaySize;
                        Lt = Lt * ts / at, Dt = { width: Pn[0], height: Pn[1], left: 0, top: -fM, advance: Ir ? Pn[1] : Pn[0], localGlyph: !1 }, Ur = Zt ? -Dt.height * Lt : hr * ts - 17 - Pn[1] * Lt, Vr = Dt.advance;
                        const $r = (Ir ? Pn[0] : Pn[1]) * Lt - ts * hr;
                        $r > 0 && $r > Pr && (Pr = $r);
                    }
                    else {
                        const pn = Pe[pe.fontStack];
                        if (!pn)
                            continue;
                        pn[Tt] && (Ht = pn[Tt]);
                        const Pn = Te[pe.fontStack];
                        if (!Pn)
                            continue;
                        const $r = Pn.glyphs[Tt];
                        if (!$r)
                            continue;
                        if (Dt = $r.metrics, Vr = Tt !== 8203 ? ts : 0, Zt) {
                            const ri = Pn.ascender !== void 0 ? Math.abs(Pn.ascender) : 0, zn = Pn.descender !== void 0 ? Math.abs(Pn.descender) : 0, hn = (ri + zn) * Lt;
                            Ar < hn && (Ar = hn, Tn = (ri - zn) / 2 * Lt), Ur = -ri * Lt;
                        }
                        else
                            Ur = (hr - Lt) * ts - 17;
                    }
                    Ir ? (fe.verticalizable = !0, Lr.push({ glyph: Tt, image: lr, x: Ge, y: Xe + Ur, vertical: Ir, scale: Lt, localGlyph: Dt.localGlyph, fontStack: pe.fontStack, sectionIndex: Je, metrics: Dt, rect: Ht }), Ge += Vr * Lt + pt) : (Lr.push({ glyph: Tt, image: lr, x: Ge, y: Xe + Ur, vertical: Ir, scale: Lt, localGlyph: Dt.localGlyph, fontStack: pe.fontStack, sectionIndex: Je, metrics: Dt, rect: Ht }), Ge += Dt.advance * Lt + pt);
                }
                Lr.length !== 0 && (gt = Math.max(Ge - pt, gt), Zt ? yM(Lr, yt, Pr, Tn, Ye * hr / 2) : yM(Lr, yt, Pr, 0, Ye / 2)), Ge = 0;
                const On = Ye * hr + Pr;
                Tr.lineOffset = Math.max(Pr, wr), Xe += On, ++jt;
            } var Rt; const mt = Xe, { horizontalAlign: pr, verticalAlign: Gt } = rS(ut); (function (qt, hr, wr, Tr, Lr, Pr) { const Ar = (hr - wr) * Lr, Tn = -Pr * Tr; for (const On of qt)
                for (const he of On.positionedGlyphs)
                    he.x += Ar, he.y += Tn; })(fe.positionedLines, yt, pr, Gt, gt, mt), fe.top += -Gt * mt, fe.bottom = fe.top + mt, fe.left += -pr * gt, fe.right = fe.left + gt, fe.hasBaseline = Zt; }(ae, e, i, c, Y, m, x, b, I, S, M, F), !function (fe) { for (const Te of fe)
                if (Te.positionedGlyphs.length !== 0)
                    return !1; return !0; }(te))
                return ae; }
            const Rx = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, N5 = { 10: !0, 32: !0, 38: !0, 40: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 };
            function pM(a, e, i, c, h, p) { if (e.image) {
                const m = c.get(e.image.toString());
                return m ? m.displaySize[0] * e.scale * ts / p + h : 0;
            } {
                const m = i[e.fontStack], x = m && m.glyphs[a];
                return x ? x.metrics.advance * e.scale + h : 0;
            } }
            function mM(a, e, i, c) { const h = Math.pow(a - e, 2); return c ? a < e ? h / 2 : 2 * h : h + Math.abs(i) * i; }
            function B5(a, e, i) { let c = 0; return a === 10 && (c -= 1e4), i && (c += 150), a !== 40 && a !== 65288 || (c += 50), e !== 41 && e !== 65289 || (c += 50), c; }
            function gM(a, e, i, c, h, p) { let m = null, x = mM(e, i, h, p); for (const b of c) {
                const S = mM(e - b.x, i, h, p) + b.badness;
                S <= x && (m = b, x = S);
            } return { index: a, x: e, priorBreak: m, badness: x }; }
            function _M(a) { return a ? _M(a.priorBreak).concat(a.index) : []; }
            function rS(a) { let e = .5, i = .5; switch (a) {
                case "right":
                case "top-right":
                case "bottom-right":
                    e = 1;
                    break;
                case "left":
                case "top-left":
                case "bottom-left": e = 0;
            } switch (a) {
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                    i = 1;
                    break;
                case "top":
                case "top-right":
                case "top-left": i = 0;
            } return { horizontalAlign: e, verticalAlign: i }; }
            function yM(a, e, i, c, h) { if (!(e || i || c || h))
                return; const p = a.length - 1, m = a[p], x = (m.x + m.metrics.advance * m.scale) * e; for (let b = 0; b <= p; b++)
                a[b].x -= x, a[b].y += i + c + h; }
            function vM(a) { return a.imagePrimary !== void 0 && a.top !== void 0 && a.bottom !== void 0 && a.left !== void 0 && a.right !== void 0; }
            function j5(a, e, i, c) { const { horizontalAlign: h, verticalAlign: p } = rS(c), m = i[0] - a.displaySize[0] * h, x = i[1] - a.displaySize[1] * p; return { imagePrimary: a, imageSecondary: e, top: x, bottom: x + a.displaySize[1], left: m, right: m + a.displaySize[0] }; }
            function xM(a, e, i, c, h, p) { const m = a.imagePrimary; let x; if (m.content) {
                const X = m.content, Y = m.pixelRatio || 1;
                x = [X[0] / Y, X[1] / Y, m.displaySize[0] - X[2] / Y, m.displaySize[1] - X[3] / Y];
            } const b = e.left * p, S = e.right * p; let A, I, M, z; i === "width" || i === "both" ? (z = h[0] + b - c[3], I = h[0] + S + c[1]) : (z = h[0] + (b + S - m.displaySize[0]) / 2, I = z + m.displaySize[0]); const F = e.top * p, U = e.bottom * p; return i === "height" || i === "both" ? (A = h[1] + F - c[0], M = h[1] + U + c[2]) : (A = h[1] + (F + U - m.displaySize[1]) / 2, M = A + m.displaySize[1]), { imagePrimary: m, imageSecondary: void 0, top: A, right: I, bottom: M, left: z, collisionPadding: x }; }
            function wM(a) { return !a.imagePrimary.stretchX; }
            function bM(a) { return !a.imagePrimary.stretchY; }
            function TM(a) { return { width: a.right - a.left, height: a.bottom - a.top }; }
            const Hl = 128;
            function SM(a, e) { const { expression: i } = e; if (i.kind === "constant")
                return { kind: "constant", layoutSize: i.evaluate(new yn(a + 1)) }; if (i.kind === "source")
                return { kind: "source" }; {
                const { zoomStops: c, interpolationType: h } = i;
                let p = 0;
                for (; p < c.length && c[p] <= a;)
                    p++;
                p = Math.max(0, p - 1);
                let m = p;
                for (; m < c.length && c[m] < a + 1;)
                    m++;
                m = Math.min(c.length - 1, m);
                const x = c[p], b = c[m];
                return i.kind === "composite" ? { kind: "composite", minZoom: x, maxZoom: b, interpolationType: h } : { kind: "camera", minZoom: x, maxZoom: b, minSize: i.evaluate(new yn(x)), maxSize: i.evaluate(new yn(b)), interpolationType: h };
            } }
            function nS(a, { uSize: e, uSizeT: i }, { lowerSize: c, upperSize: h }) { return a.kind === "source" ? c / Hl : a.kind === "composite" ? nr(c / Hl, h / Hl, i) : e; }
            function ey(a, e, i = 1) { let c = 0, h = 0; if (a.kind === "constant")
                h = a.layoutSize * i;
            else if (a.kind !== "source") {
                const { interpolationType: p, minZoom: m, maxZoom: x } = a, b = p ? ke($s.interpolationFactor(p, e, m, x), 0, 1) : 0;
                a.kind === "camera" ? h = nr(a.minSize, a.maxSize, b) * i : c = b * i;
            } return { uSizeT: c, uSize: h }; }
            class qc extends Et {
                constructor(e, i, c, h, p) { super(e, i), this.angle = h, this.z = c, p !== void 0 && (this.segment = p); }
                clone() { return new qc(this.x, this.y, this.z, this.angle, this.segment); }
            }
            function EM(a, e, i, c, h) { if (e.segment === void 0)
                return !0; let p = e, m = e.segment + 1, x = 0; for (; x > -i / 2;) {
                if (m--, m < 0)
                    return !1;
                x -= a[m].dist(p), p = a[m];
            } x += a[m].dist(a[m + 1]), m++; const b = []; let S = 0; for (; x < i / 2;) {
                const A = a[m], I = a[m + 1];
                if (!I)
                    return !1;
                let M = a[m - 1].angleTo(A) - A.angleTo(I);
                for (M = Math.abs((M + 3 * Math.PI) % (2 * Math.PI) - Math.PI), b.push({ distance: x, angleDelta: M }), S += M; x - b[0].distance > c;)
                    S -= b.shift().angleDelta;
                if (S > h)
                    return !1;
                m++, x += A.dist(I);
            } return !0; }
            function CM(a) { let e = 0; for (let i = 0; i < a.length - 1; i++)
                e += a[i].dist(a[i + 1]); return e; }
            function AM(a, e, i) { return a ? .6 * e * i : 0; }
            function IM(a, e) { return Math.max(a ? a.right - a.left : 0, e ? e.right - e.left : 0); }
            function V5(a, e, i, c, h, p) { const m = AM(i, h, p), x = IM(i, c) * p; let b = 0; const S = CM(a) / 2; for (let A = 0; A < a.length - 1; A++) {
                const I = a[A], M = a[A + 1], z = I.dist(M);
                if (b + z > S) {
                    const F = (S - b) / z, U = nr(I.x, M.x, F), X = nr(I.y, M.y, F), Y = new qc(U, X, 0, M.angleTo(I), A);
                    return !m || EM(a, Y, x, m, e) ? Y : void 0;
                }
                b += z;
            } }
            function U5(a, e, i, c, h, p, m, x, b) { const S = AM(c, p, m), A = IM(c, h), I = A * m, M = a[0].x === 0 || a[0].x === b || a[0].y === 0 || a[0].y === b; return e - I < e / 4 && (e = I + e / 4), PM(a, M ? e / 2 * x % e : (A / 2 + 2 * p) * m * x % e, e, S, i, I, M, !1, b); }
            function PM(a, e, i, c, h, p, m, x, b) { const S = p / 2, A = CM(a); let I = 0, M = e - i, z = []; for (let F = 0; F < a.length - 1; F++) {
                const U = a[F], X = a[F + 1], Y = U.dist(X), le = X.angleTo(U);
                for (; M + i < I + Y;) {
                    M += i;
                    const se = (M - I) / Y, $ = nr(U.x, X.x, se), te = nr(U.y, X.y, se);
                    if ($ >= 0 && $ < b && te >= 0 && te < b && M - S >= 0 && M + S <= A) {
                        const ae = new qc($, te, 0, le, F);
                        c && !EM(a, ae, p, c, h) || z.push(ae);
                    }
                }
                I += Y;
            } return x || z.length || m || (z = PM(a, I / 2, i, c, h, p, m, !0, b)), z; }
            function MM(a) { let e = 0, i = 0; for (const m of a)
                e += m.w * m.h, i = Math.max(i, m.w); a.sort((m, x) => x.h - m.h); const c = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / .95)), i), h: 1 / 0 }]; let h = 0, p = 0; for (const m of a)
                for (let x = c.length - 1; x >= 0; x--) {
                    const b = c[x];
                    if (!(m.w > b.w || m.h > b.h)) {
                        if (m.x = b.x, m.y = b.y, p = Math.max(p, m.y + m.h), h = Math.max(h, m.x + m.w), m.w === b.w && m.h === b.h) {
                            const S = c.pop();
                            x < c.length && (c[x] = S);
                        }
                        else
                            m.h === b.h ? (b.x += m.w, b.w -= m.w) : m.w === b.w ? (b.y += m.h, b.h -= m.h) : (c.push({ x: b.x + m.w, y: b.y, w: b.w - m.w, h: m.h }), b.y += m.h, b.h -= m.h);
                        break;
                    }
                } return { w: h, h: p, fill: e / (h * p) || 0 }; }
            Nt(qc, "Anchor");
            const Qd = 1;
            class ty {
                static getImagePositionScale(e, i, c) { if (i && e && e.options && e.options.transform) {
                    const h = e.options.transform;
                    return { x: h.a, y: h.d };
                } return { x: c, y: c }; }
                constructor(e, i, c, h) { this.paddedRect = e; const { pixelRatio: p, version: m, stretchX: x, stretchY: b, content: S, sdf: A, usvg: I } = i; this.pixelRatio = p, this.stretchX = x, this.stretchY = b, this.content = S, this.version = m, this.padding = c, this.sdf = A, this.scale = ty.getImagePositionScale(h, I, p); }
                get tl() { return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding]; }
                get br() { return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding]; }
                get displaySize() { return [(this.paddedRect.w - 2 * this.padding) / this.scale.x, (this.paddedRect.h - 2 * this.padding) / this.scale.y]; }
            }
            function iS(a, e, i) { const c = ea.parse(a), h = function (p, m, x = [1, 1]) { return { x: 0, y: 0, w: (p.data ? p.data.width : p.width * x[0]) + 2 * m, h: (p.data ? p.data.height : p.height * x[1]) + 2 * m }; }(e, i, [c.options.transform.a, c.options.transform.d]); return { bin: h, imagePosition: new ty(h, e, i, c), imageVariant: c }; }
            class RM {
                constructor(e, i, c) { const h = new Map, p = new Map; this.haveRenderCallbacks = []; const m = []; this.addImages(e, h, Qd, m), this.addImages(i, p, 2, m); const { w: x, h: b } = MM(m), S = new ds({ width: x || 1, height: b || 1 }); for (const [A, I] of e.entries()) {
                    const M = h.get(A).paddedRect;
                    ds.copy(I.data, S, { x: 0, y: 0 }, { x: M.x + Qd, y: M.y + Qd }, I.data, c, I.sdf);
                } for (const [A, I] of i.entries()) {
                    const M = p.get(A), z = M.paddedRect;
                    let F = M.padding;
                    const U = z.x + F, X = z.y + F, Y = I.data.width, le = I.data.height;
                    F = F > 1 ? F - 1 : F, ds.copy(I.data, S, { x: 0, y: 0 }, { x: U, y: X }, I.data, c), ds.copy(I.data, S, { x: 0, y: le - F }, { x: U, y: X - F }, { width: Y, height: F }, c), ds.copy(I.data, S, { x: 0, y: 0 }, { x: U, y: X + le }, { width: Y, height: F }, c), ds.copy(I.data, S, { x: Y - F, y: 0 }, { x: U - F, y: X }, { width: F, height: le }, c), ds.copy(I.data, S, { x: 0, y: 0 }, { x: U + Y, y: X }, { width: F, height: le }, c), ds.copy(I.data, S, { x: Y - F, y: le - F }, { x: U - F, y: X - F }, { width: F, height: F }, c), ds.copy(I.data, S, { x: 0, y: le - F }, { x: U + Y, y: X - F }, { width: F, height: F }, c), ds.copy(I.data, S, { x: 0, y: 0 }, { x: U + Y, y: X + le }, { width: F, height: F }, c), ds.copy(I.data, S, { x: Y - F, y: 0 }, { x: U - F, y: X + le }, { width: F, height: F }, c);
                } this.lut = c, this.image = S, this.iconPositions = h, this.patternPositions = p; }
                addImages(e, i, c, h) { for (const [p, m] of e.entries()) {
                    const { bin: x, imagePosition: b, imageVariant: S } = iS(p, m, c);
                    i.set(p, b), h.push(x), m.hasRenderCallback && this.haveRenderCallbacks.push(S.id);
                } }
                patchUpdatedImages(e, i, c) { this.haveRenderCallbacks = this.haveRenderCallbacks.filter(h => e.hasImage(h, c)), e.dispatchRenderCallbacks(this.haveRenderCallbacks, c); for (const h of e.getUpdatedImages(c)) {
                    for (const p of this.iconPositions.keys()) {
                        const m = ea.parse(p);
                        if (eo.isEqual(m.id, h)) {
                            const x = e.getImage(h, c);
                            this.patchUpdatedImage(this.iconPositions.get(p), x, i);
                        }
                    }
                    for (const p of this.patternPositions.keys()) {
                        const m = ea.parse(p);
                        if (eo.isEqual(m.id, h)) {
                            const x = e.getImage(h, c);
                            this.patchUpdatedImage(this.patternPositions.get(p), x, i);
                        }
                    }
                } }
                patchUpdatedImage(e, i, c) { if (!e || !i || e.version === i.version)
                    return; e.version = i.version; const [h, p] = e.tl, m = e.sdf; if (this.lut || m) {
                    const x = { width: i.data.width, height: i.data.height }, b = new ds(x);
                    ds.copy(i.data, b, { x: 0, y: 0 }, { x: 0, y: 0 }, x, this.lut, m), c.update(b, { position: { x: h, y: p } });
                }
                else
                    c.update(i.data, { position: { x: h, y: p } }); }
            }
            Nt(ty, "ImagePosition"), Nt(RM, "ImageAtlas");
            const ry = 1e20;
            function kM(a, e, i, c, h, p, m, x, b) { for (let S = e; S < e + c; S++)
                DM(a, i * p + S, p, h, m, x, b); for (let S = i; S < i + h; S++)
                DM(a, S * p + e, 1, c, m, x, b); }
            function DM(a, e, i, c, h, p, m) { p[0] = 0, m[0] = -ry, m[1] = ry, h[0] = a[e]; for (let x = 1, b = 0, S = 0; x < c; x++) {
                h[x] = a[e + x * i];
                const A = x * x;
                do {
                    const I = p[b];
                    S = (h[x] - h[I] + A - I * I) / (x - I) / 2;
                } while (S <= m[b] && --b > -1);
                b++, p[b] = x, m[b] = S, m[b + 1] = ry;
            } for (let x = 0, b = 0; x < c; x++) {
                for (; m[b + 1] < x;)
                    b++;
                const S = p[b], A = x - S;
                a[e + x * i] = h[S] + A * A;
            } }
            const nl = 2, sS = { none: 0, ideographs: 1, all: 2 };
            class Yp {
                constructor(e, i, c) { this.requestManager = e, this.localGlyphMode = i, this.localFontFamily = c, this.urls = {}, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} }; }
                setURL(e, i) { this.urls[i] = e; }
                getGlyphs(e, i, c) { const h = [], p = this.urls[i] || hs.GLYPHS_URL; for (const m in e)
                    for (const x of e[m])
                        h.push({ stack: m, id: x }); tt(h, ({ stack: m, id: x }, b) => { let S = this.entries[m]; S || (S = this.entries[m] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 }); let A = S.glyphs[x]; if (A !== void 0)
                    return void b(null, { stack: m, id: x, glyph: A }); if (A = this._tinySDF(S, m, x), A)
                    return S.glyphs[x] = A, void b(null, { stack: m, id: x, glyph: A }); const I = Math.floor(x / 256); if (256 * I > 65535)
                    return Br("glyphs > 65535 not supported"), void b(null, { stack: m, id: x, glyph: A }); if (S.ranges[I])
                    return void b(null, { stack: m, id: x, glyph: A }); let M = S.requests[I]; M || (M = S.requests[I] = [], Yp.loadGlyphRange(m, I, p, this.requestManager, (z, F) => { if (F) {
                    S.ascender = F.ascender, S.descender = F.descender;
                    for (const U in F.glyphs)
                        this._doesCharSupportLocalGlyph(+U) || (S.glyphs[+U] = F.glyphs[+U]);
                    S.ranges[I] = !0;
                } for (const U of M)
                    U(z, F); delete S.requests[I]; })), M.push((z, F) => { z ? b(z) : F && b(null, { stack: m, id: x, glyph: F.glyphs[x] || null }); }); }, (m, x) => { if (m)
                    c(m);
                else if (x) {
                    const b = {};
                    for (const { stack: S, id: A, glyph: I } of x)
                        b[S] === void 0 && (b[S] = {}), b[S].glyphs === void 0 && (b[S].glyphs = {}), b[S].glyphs[A] = I && { id: I.id, bitmap: I.bitmap.clone(), metrics: I.metrics }, b[S].ascender = this.entries[S].ascender, b[S].descender = this.entries[S].descender;
                    c(null, b);
                } }); }
                _doesCharSupportLocalGlyph(e) { return this.localGlyphMode !== sS.none && (this.localGlyphMode === sS.all ? !!this.localFontFamily : !!this.localFontFamily && (sr["CJK Unified Ideographs"](e) || sr["Hangul Syllables"](e) || sr.Hiragana(e) || sr.Katakana(e) || sr["CJK Symbols and Punctuation"](e) || sr["CJK Unified Ideographs Extension A"](e) || sr["CJK Unified Ideographs Extension B"](e) || sr.Osage(e))); }
                _tinySDF(e, i, c) { const h = this.localFontFamily; if (!h || !this._doesCharSupportLocalGlyph(c))
                    return; let p = e.tinySDF; if (!p) {
                    let U = "400";
                    /bold/i.test(i) ? U = "900" : /medium/i.test(i) ? U = "500" : /light/i.test(i) && (U = "200"), p = e.tinySDF = new Yp.TinySDF({ fontFamily: h, fontWeight: U, fontSize: 24 * nl, buffer: 3 * nl, radius: 8 * nl }), p.fontWeight = U;
                } if (this.localGlyphs[p.fontWeight][c])
                    return this.localGlyphs[p.fontWeight][c]; const m = String.fromCodePoint(c), { data: x, width: b, height: S, glyphWidth: A, glyphHeight: I, glyphLeft: M, glyphTop: z, glyphAdvance: F } = p.draw(m); return this.localGlyphs[p.fontWeight][c] = { id: c, bitmap: new Yu({ width: b, height: S }, x), metrics: { width: A / nl, height: I / nl, left: M / nl, top: z / nl - 27, advance: F / nl, localGlyph: !0 } }; }
            }
            Yp.loadGlyphRange = function (a, e, i, c, h) { const p = 256 * e, m = p + 255, x = c.transformRequest(c.normalizeGlyphsURL(i).replace("{fontstack}", a).replace("{range}", `${p}-${m}`), Xf.Glyphs); yu(x, (b, S) => { if (b)
                h(b);
            else if (S) {
                const A = {}, I = function (M) { return new Mx(M).readFields(O5, {}); }(S);
                for (const M of I.glyphs)
                    A[M.id] = M;
                h(null, { glyphs: A, ascender: I.ascender, descender: I.descender });
            } }); }, Yp.TinySDF = class {
                constructor({ fontSize: a = 24, buffer: e = 3, radius: i = 8, cutoff: c = .25, fontFamily: h = "sans-serif", fontWeight: p = "normal", fontStyle: m = "normal" } = {}) { this.buffer = e, this.cutoff = c, this.radius = i; const x = this.size = a + 4 * e, b = this._createCanvas(x), S = this.ctx = b.getContext("2d", { willReadFrequently: !0 }); S.font = `${m} ${p} ${a}px ${h}`, S.textBaseline = "alphabetic", S.textAlign = "left", S.fillStyle = "black", this.gridOuter = new Float64Array(x * x), this.gridInner = new Float64Array(x * x), this.f = new Float64Array(x), this.z = new Float64Array(x + 1), this.v = new Uint16Array(x); }
                _createCanvas(a) { const e = document.createElement("canvas"); return e.width = e.height = a, e; }
                draw(a) { const { width: e, actualBoundingBoxAscent: i, actualBoundingBoxDescent: c, actualBoundingBoxLeft: h, actualBoundingBoxRight: p } = this.ctx.measureText(a), m = Math.ceil(i), x = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(p - h))), b = Math.min(this.size - this.buffer, m + Math.ceil(c)), S = x + 2 * this.buffer, A = b + 2 * this.buffer, I = Math.max(S * A, 0), M = new Uint8ClampedArray(I), z = { data: M, width: S, height: A, glyphWidth: x, glyphHeight: b, glyphTop: m, glyphLeft: 0, glyphAdvance: e }; if (x === 0 || b === 0)
                    return z; const { ctx: F, buffer: U, gridInner: X, gridOuter: Y } = this; F.clearRect(U, U, x, b), F.fillText(a, U, U + m); const le = F.getImageData(U, U, x, b); Y.fill(ry, 0, I), X.fill(0, 0, I); for (let se = 0; se < b; se++)
                    for (let $ = 0; $ < x; $++) {
                        const te = le.data[4 * (se * x + $) + 3] / 255;
                        if (te === 0)
                            continue;
                        const ae = (se + U) * S + $ + U;
                        if (te === 1)
                            Y[ae] = 0, X[ae] = ry;
                        else {
                            const fe = .5 - te;
                            Y[ae] = fe > 0 ? fe * fe : 0, X[ae] = fe < 0 ? fe * fe : 0;
                        }
                    } kM(Y, 0, 0, S, A, S, this.f, this.v, this.z), kM(X, U, U, x, b, S, this.f, this.v, this.z); for (let se = 0; se < I; se++) {
                    const $ = Math.sqrt(Y[se]) - Math.sqrt(X[se]);
                    M[se] = Math.round(255 - 255 * ($ / this.radius + this.cutoff));
                } return z; }
            };
            const eh = Qd;
            function LM(a, e) { return a + e[1] - e[0]; }
            function OM(a, e, i, c, h = 1) { const p = [], m = a.imagePrimary, x = m.pixelRatio, b = m.paddedRect.w - 2 * eh, S = m.paddedRect.h - 2 * eh, A = (a.right - a.left) * h, I = (a.bottom - a.top) * h, M = m.stretchX || [[0, b]], z = m.stretchY || [[0, S]], F = M.reduce(LM, 0), U = z.reduce(LM, 0), X = b - F, Y = S - U; let le = 0, se = F, $ = 0, te = U, ae = 0, fe = X, Te = 0, Pe = Y; if (m.content && c) {
                const Oe = m.content;
                le = kx(M, 0, Oe[0]), $ = kx(z, 0, Oe[1]), se = kx(M, Oe[0], Oe[2]), te = kx(z, Oe[1], Oe[3]), ae = Oe[0] - le, Te = Oe[1] - $, fe = Oe[2] - Oe[0] - se, Pe = Oe[3] - Oe[1] - te;
            } const Me = (Oe, Ye, ut, it) => { const lt = Dx(Oe.stretch - le, se, A, a.left * h), pt = Lx(Oe.fixed - ae, fe, Oe.stretch, F), We = Dx(Ye.stretch - $, te, I, a.top * h), at = Lx(Ye.fixed - Te, Pe, Ye.stretch, U), Ge = Dx(ut.stretch - le, se, A, a.left * h), Xe = Lx(ut.fixed - ae, fe, ut.stretch, F), gt = Dx(it.stretch - $, te, I, a.top * h), yt = Lx(it.fixed - Te, Pe, it.stretch, U), Zt = new Et(lt, We), jt = new Et(Ge, We), Rt = new Et(Ge, gt), mt = new Et(lt, gt), pr = new Et(pt / x, at / x), Gt = new Et(Xe / x, yt / x), qt = e * Math.PI / 180; if (qt) {
                const Ar = Math.sin(qt), Tn = Math.cos(qt), On = [Tn, -Ar, Ar, Tn];
                Zt._matMult(On), jt._matMult(On), mt._matMult(On), Rt._matMult(On);
            } const hr = Oe.stretch + Oe.fixed, wr = ut.stretch + ut.fixed, Tr = Ye.stretch + Ye.fixed, Lr = it.stretch + it.fixed, Pr = a.imageSecondary; return { tl: Zt, tr: jt, bl: mt, br: Rt, texPrimary: { x: m.paddedRect.x + eh + hr, y: m.paddedRect.y + eh + Tr, w: wr - hr, h: Lr - Tr }, texSecondary: Pr ? { x: Pr.paddedRect.x + eh + hr, y: Pr.paddedRect.y + eh + Tr, w: wr - hr, h: Lr - Tr } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: pr, pixelOffsetBR: Gt, minFontScaleX: fe / x / A, minFontScaleY: Pe / x / I, isSDF: i }; }; if (c && (m.stretchX || m.stretchY)) {
                const Oe = zM(M, X, F), Ye = zM(z, Y, U);
                for (let ut = 0; ut < Oe.length - 1; ut++) {
                    const it = Oe[ut], lt = Oe[ut + 1];
                    for (let pt = 0; pt < Ye.length - 1; pt++)
                        p.push(Me(it, Ye[pt], lt, Ye[pt + 1]));
                }
            }
            else
                p.push(Me({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: b + 1 }, { fixed: 0, stretch: S + 1 })); return p; }
            function kx(a, e, i) { let c = 0; for (const h of a)
                c += Math.max(e, Math.min(i, h[1])) - Math.max(e, Math.min(i, h[0])); return c; }
            function zM(a, e, i) { const c = [{ fixed: -eh, stretch: 0 }]; for (const [h, p] of a) {
                const m = c[c.length - 1];
                c.push({ fixed: h - m.stretch, stretch: m.stretch }), c.push({ fixed: h - m.stretch, stretch: m.stretch + (p - h) });
            } return c.push({ fixed: e + eh, stretch: i }), c; }
            function Dx(a, e, i, c) { return a / e * i + c; }
            function Lx(a, e, i, c) { return a - e * i / c; }
            function $5(a, e, i, c) { const h = e + a.positionedLines[c].lineOffset; return c === 0 ? i + h / 2 : i + (h + (e + a.positionedLines[c - 1].lineOffset)) / 2; }
            function G5(a, e = 1, i = !1) { let c = 1 / 0, h = 1 / 0, p = -1 / 0, m = -1 / 0; const x = a[0]; for (let z = 0; z < x.length; z++) {
                const F = x[z];
                (!z || F.x < c) && (c = F.x), (!z || F.y < h) && (h = F.y), (!z || F.x > p) && (p = F.x), (!z || F.y > m) && (m = F.y);
            } const b = Math.min(p - c, m - h); let S = b / 2; const A = new op([], q5); if (b === 0)
                return new Et(c, h); for (let z = c; z < p; z += b)
                for (let F = h; F < m; F += b)
                    A.push(new Qp(z + S, F + S, S, a)); let I = function (z) { let F = 0, U = 0, X = 0; const Y = z[0]; for (let le = 0, se = Y.length, $ = se - 1; le < se; $ = le++) {
                const te = Y[le], ae = Y[$], fe = te.x * ae.y - ae.x * te.y;
                U += (te.x + ae.x) * fe, X += (te.y + ae.y) * fe, F += 3 * fe;
            } return new Qp(U / F, X / F, 0, z); }(a), M = A.length; for (; A.length;) {
                const z = A.pop();
                (z.d > I.d || !I.d) && (I = z, i && console.log("found best %d after %d probes", Math.round(1e4 * z.d) / 1e4, M)), z.max - I.d <= e || (S = z.h / 2, A.push(new Qp(z.p.x - S, z.p.y - S, S, a)), A.push(new Qp(z.p.x + S, z.p.y - S, S, a)), A.push(new Qp(z.p.x - S, z.p.y + S, S, a)), A.push(new Qp(z.p.x + S, z.p.y + S, S, a)), M += 4);
            } return i && (console.log(`num probes: ${M}`), console.log(`best distance: ${I.d}`)), I.p; }
            function q5(a, e) { return e.max - a.max; }
            class Qp {
                constructor(e, i, c, h) { this.p = new Et(e, i), this.h = c, this.d = function (p, m) { let x = !1, b = 1 / 0; for (let S = 0; S < m.length; S++) {
                    const A = m[S];
                    for (let I = 0, M = A.length, z = M - 1; I < M; z = I++) {
                        const F = A[I], U = A[z];
                        F.y > p.y != U.y > p.y && p.x < (U.x - F.x) * (p.y - F.y) / (U.y - F.y) + F.x && (x = !x), b = Math.min(b, Hr(p, F, U));
                    }
                } return (x ? 1 : -1) * Math.sqrt(b); }(this.p, h), this.max = this.d + this.h * Math.SQRT2; }
            }
            const H5 = Object.keys, oS = Number.POSITIVE_INFINITY, W5 = Math.sqrt(2);
            function FM(a, [e, i]) { let c = 0, h = 0; if (i === oS) {
                e < 0 && (e = 0);
                const p = e / W5;
                switch (a) {
                    case "top-right":
                    case "top-left":
                        h = p - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                        h = 7 - p;
                        break;
                    case "bottom":
                        h = 7 - e;
                        break;
                    case "top": h = e - 7;
                }
                switch (a) {
                    case "top-right":
                    case "bottom-right":
                        c = -p;
                        break;
                    case "top-left":
                    case "bottom-left":
                        c = p;
                        break;
                    case "left":
                        c = e;
                        break;
                    case "right": c = -e;
                }
            }
            else {
                switch (e = Math.abs(e), i = Math.abs(i), a) {
                    case "top-right":
                    case "top-left":
                    case "top":
                        h = i - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                    case "bottom": h = 7 - i;
                }
                switch (a) {
                    case "top-right":
                    case "bottom-right":
                    case "right":
                        c = -e;
                        break;
                    case "top-left":
                    case "bottom-left":
                    case "left": c = e;
                }
            } return [c, h]; }
            function Ox(a, e, i, c, h, p, m, x, b) { if (!e || !e.usvg)
                return; const S = TM(c), A = TM(h), I = p !== "both" && p !== "width" || !wM(c) ? 1 : Math.max(1, A.width / S.width), M = p !== "both" && p !== "height" || !bM(c) ? 1 : Math.max(1, A.height / S.height); i.scaleSelf(I, M); const z = i.toString(); m.set(z, i), x.set(z, e); const { imagePosition: F } = iS(z, e, Qd); b.set(z, F); }
            function NM(a, e, i, c, h, p, m, x) { if (!a)
                return; const b = function (S, A, I, M, z) { if (S.kind === "camera")
                return S.maxSize; if (S.kind === "composite") {
                const F = A.possiblyEvaluate(new yn(S.maxZoom), I).evaluate(z, {}, I), U = A.possiblyEvaluate(new yn(S.minZoom), I).evaluate(z, {}, I);
                return Math.max(F, U);
            } return A.possiblyEvaluate(new yn(M)).evaluate(z, {}, I); }(e, i, c, h, p); return a.scaleSelf(b * x * m); }
            function BM(a, e, i, c, h, p, m, x) { return { iconPrimary: NM(a.getPrimary(), e, i, c, h, p, m, x), iconSecondary: NM(a.getSecondary(), e, i, c, h, p, m, x) }; }
            function jM(a, e, i, c) { if (!a)
                return; const h = e.get(i.toString()); if (a.imagePrimary = h, c) {
                const p = e.get(c.toString());
                a.imageSecondary = p;
            } }
            function Z5(a, e) { for (const i in a.horizontal)
                VM(a.horizontal[i], e); VM(a.vertical, e); }
            function VM(a, e) { if (a) {
                for (const i of a.positionedLines)
                    for (const c of i.positionedGlyphs)
                        if (c.image !== null) {
                            const h = c.image.toString();
                            c.rect = e.get(h).paddedRect;
                        }
            } }
            function aS(a) { switch (a) {
                case "right":
                case "top-right":
                case "bottom-right": return "right";
                case "left":
                case "top-left":
                case "bottom-left": return "left";
            } return "center"; }
            function X5(a, e, i, c, h, p, m, x, b) { const S = lS(p.horizontal) || p.vertical, A = i.get("icon-text-fit-padding").evaluate(c, {}, h); let I, M = e; return e && b !== "none" && (a.allowVerticalPlacement && p.vertical && (I = xM(e, p.vertical, b, A, x, m)), S && (M = xM(e, S, b, A, x, m))), { defaultShapedIcon: M, verticallyShapedIcon: I }; }
            function K5(a, e, i, c, h, p, m, x, b, S, A, I, M, z, F, U, X, Y, le, se) { let $ = m.textMaxSize.evaluate(e, {}, M); $ === void 0 ? $ = x * m.textScaleFactor : $ *= m.textScaleFactor; const te = a.layers[0].layout, ae = lS(i.horizontal) || i.vertical, fe = z.name === "globe", Te = ts, Pe = a.tilePixelRatio * $ / Te, Me = (pt = a.overscaling, a.zoom > 18 && pt > 2 && (pt >>= 1), Math.max(It / (512 * pt), 1) * te.get("symbol-spacing")), Oe = te.get("text-padding") * a.tilePixelRatio, Ye = te.get("icon-padding") * a.tilePixelRatio, ut = Z(te.get("text-max-angle")), it = te.get("icon-rotation-alignment") === "map" && se !== "point", lt = Me / 2; var pt; a.hasAnyIconTextFit === !1 && X !== "none" && (a.hasAnyIconTextFit = !0); const We = e.properties ? +e.properties[Zd] : null, at = We && a.elevationFeatureIdToIndex ? a.elevationFeatureIdToIndex.get(We) : 65535, Ge = (Xe, gt, yt) => { if (gt.x < 0 || gt.x >= It || gt.y < 0 || gt.y >= It)
                return; let Zt = null; if (fe) {
                const { x: jt, y: Rt, z: mt } = z.projectTilePoint(gt.x, gt.y, yt);
                Zt = { anchor: new qc(jt, Rt, mt, 0, void 0), up: z.upVector(yt, gt.x, gt.y) };
            } (function (jt, Rt, mt, pr, Gt, qt, hr, wr, Tr, Lr, Pr, Ar, Tn, On, he, pe, Je, Tt, Lt, Dt, Ht, lr, Vr, Ur, Ir, pn, Pn, $r, ri) { const zn = jt.addToLineVertexArray(Rt, pr); let hn, yi, Vn, Mn, Fn, _n, kr, wn = 0, ni = 0, ar = 0, Zr = 0, Un = -1, di = -1; const Zn = {}; let ki = Js(""); const Sn = mt ? mt.anchor : Rt, Pi = $r !== "none"; let no = 0, fs = 0; if (Tr._unevaluatedLayout.getValue("text-radial-offset") === void 0) {
                const Di = Tr.layout.get("text-offset").evaluate(Ht, {}, Ir);
                no = Di[0] * ts, fs = Di[1] * ts;
            }
            else
                no = Tr.layout.get("text-radial-offset").evaluate(Ht, {}, Ir) * ts, fs = oS; if (jt.allowVerticalPlacement && Gt.vertical) {
                const Di = Gt.vertical;
                if (he)
                    _n = cS(Di), wr && (kr = cS(wr));
                else {
                    const Vi = Tr.layout.get("text-rotate").evaluate(Ht, {}, Ir) + 90;
                    Vn = zx(Lr, Sn, Rt, Pr, Ar, Tn, Di, On, Vi, pe), wr && (Mn = zx(Lr, Sn, Rt, Pr, Ar, Tn, wr, Tt, Vi));
                }
            } if (qt) {
                const Di = jt.iconSizeData, Vi = Tr.layout.get("icon-rotate").evaluate(Ht, {}, Ir), ps = OM(qt, Vi, Vr, Pi, lr.iconScaleFactor), Ls = wr ? OM(wr, Vi, Vr, Pi, lr.iconScaleFactor) : void 0;
                yi = zx(Lr, Sn, Rt, Pr, Ar, Tn, qt, Tt, Vi, null), wn = 4 * ps.length;
                let xs = null;
                Di.kind === "source" ? (xs = [Hl * Tr.layout.get("icon-size").evaluate(Ht, {}, Ir) * lr.iconScaleFactor], xs[0] > th && Br(`${jt.layerIds[0]}: Value for "icon-size" is >= ${ny}. Reduce your "icon-size".`)) : Di.kind === "composite" && (xs = [Hl * lr.compositeIconSizes[0].evaluate(Ht, {}, Ir) * lr.iconScaleFactor, Hl * lr.compositeIconSizes[1].evaluate(Ht, {}, Ir) * lr.iconScaleFactor], (xs[0] > th || xs[1] > th) && Br(`${jt.layerIds[0]}: Value for "icon-size" is >= ${ny}. Reduce your "icon-size".`)), jt.addSymbols(jt.icon, ps, xs, Dt, Lt, Ht, void 0, mt, Rt, zn.lineStartIndex, zn.lineLength, -1, Ur, Ir, pn, Pn), Un = jt.icon.placedSymbolArray.length - 1, Ls && (ni = 4 * Ls.length, jt.addSymbols(jt.icon, Ls, xs, Dt, Lt, Ht, go.vertical, mt, Rt, zn.lineStartIndex, zn.lineLength, -1, Ur, Ir, pn, Pn), di = jt.icon.placedSymbolArray.length - 1);
            } for (const Di in Gt.horizontal) {
                const Vi = Di, ps = Gt.horizontal[Vi];
                hn || (ki = Js(ps.text), he ? Fn = cS(ps) : hn = zx(Lr, Sn, Rt, Pr, Ar, Tn, ps, On, Tr.layout.get("text-rotate").evaluate(Ht, {}, Ir), pe));
                const Ls = ps.positionedLines.length === 1;
                if (ar += UM(jt, mt, Rt, ps, hr, Tr, he, Ht, pe, zn, Gt.vertical ? go.horizontal : go.horizontalOnly, Ls ? H5(Gt.horizontal) : [Vi], Zn, Un, lr, Ur, Ir, pn), Ls)
                    break;
            } Gt.vertical && (Zr += UM(jt, mt, Rt, Gt.vertical, hr, Tr, he, Ht, pe, zn, go.vertical, ["vertical"], Zn, di, lr, Ur, Ir, pn)); let ls = -1; const io = (Di, Vi) => Di ? Math.max(Di, Vi) : Vi; ls = io(Fn, ls), ls = io(_n, ls), ls = io(kr, ls); const Wl = ls > -1 ? 1 : 0; jt.glyphOffsetArray.length >= 65535 && Br("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Ht.sortKey !== void 0 && jt.addToSortKeyRanges(jt.symbolInstances.length, Ht.sortKey), jt.symbolInstances.emplaceBack(Rt.x, Rt.y, Sn.x, Sn.y, Sn.z, Zn.right >= 0 ? Zn.right : -1, Zn.center >= 0 ? Zn.center : -1, Zn.left >= 0 ? Zn.left : -1, Zn.vertical >= 0 ? Zn.vertical : -1, Un, di, ki, hn !== void 0 ? hn : jt.collisionBoxArray.length, hn !== void 0 ? hn + 1 : jt.collisionBoxArray.length, Vn !== void 0 ? Vn : jt.collisionBoxArray.length, Vn !== void 0 ? Vn + 1 : jt.collisionBoxArray.length, yi !== void 0 ? yi : jt.collisionBoxArray.length, yi !== void 0 ? yi + 1 : jt.collisionBoxArray.length, Mn || jt.collisionBoxArray.length, Mn ? Mn + 1 : jt.collisionBoxArray.length, Pr, ar, Zr, wn, ni, Wl, 0, no, fs, ls, 0, Pi ? 1 : 0, ri); })(a, gt, Zt, Xe, i, c, p, h, a.layers[0], a.collisionBoxArray, e.index, e.sourceLayerIndex, a.index, Oe, le, S, 0, Ye, it, Y, e, m, A, I, M, F, U, X, at); }; if (se === "line")
                for (const Xe of Px(e.geometry, 0, 0, It, It)) {
                    const gt = U5(Xe, Me, ut, i.vertical || ae, c, Te, Pe, a.overscaling, It);
                    for (const yt of gt)
                        ae && Y5(a, ae.text, lt, yt) || Ge(Xe, yt, M);
                }
            else if (se === "line-center") {
                for (const Xe of e.geometry)
                    if (Xe.length > 1) {
                        const gt = V5(Xe, ut, i.vertical || ae, c, Te, Pe);
                        gt && Ge(Xe, gt, M);
                    }
            }
            else if (e.type === "Polygon")
                for (const Xe of bx(e.geometry, 0)) {
                    const gt = G5(Xe, 16);
                    Ge(Xe[0], new qc(gt.x, gt.y, 0, 0, void 0), M);
                }
            else if (e.type === "LineString")
                for (const Xe of e.geometry)
                    Ge(Xe, new qc(Xe[0].x, Xe[0].y, 0, 0, void 0), M);
            else if (e.type === "Point")
                for (const Xe of e.geometry)
                    for (const gt of Xe)
                        Ge([gt], new qc(gt.x, gt.y, 0, 0, void 0), M); }
            const ny = 255, th = ny * Hl;
            function UM(a, e, i, c, h, p, m, x, b, S, A, I, M, z, F, U, X, Y) { const le = function (te, ae, fe, Te, Pe, Me, Oe, Ye) { const ut = []; if (ae.positionedLines.length === 0)
                return ut; const it = Te.layout.get("text-rotate").evaluate(Me, {}) * Math.PI / 180, lt = function (Xe) { const gt = Xe[0], yt = Xe[1], Zt = gt * yt; return Zt > 0 ? [gt, -yt] : Zt < 0 ? [-gt, yt] : gt === 0 ? [yt, gt] : [yt, -gt]; }(fe); let pt = Math.abs(ae.top - ae.bottom); for (const Xe of ae.positionedLines)
                pt -= Xe.lineOffset; const We = ae.positionedLines.length, at = pt / We; let Ge = ae.top - fe[1]; for (let Xe = 0; Xe < We; ++Xe) {
                const gt = ae.positionedLines[Xe];
                Ge = $5(ae, at, Ge, Xe);
                for (const yt of gt.positionedGlyphs) {
                    if (!yt.rect)
                        continue;
                    const Zt = yt.rect || {};
                    let jt = fM + 1, Rt = !0, mt = 1, pr = 0;
                    if (yt.image) {
                        const Ht = Oe.get(yt.image.toString());
                        if (!Ht)
                            continue;
                        if (Ht.sdf) {
                            Br("SDF images are not supported in formatted text and will be ignored.");
                            continue;
                        }
                        Rt = !1, mt = Ht.pixelRatio, jt = Qd / mt;
                    }
                    const Gt = (Pe || Ye) && yt.vertical, qt = yt.metrics.advance * yt.scale / 2, hr = yt.metrics, wr = yt.rect;
                    if (wr === null)
                        continue;
                    Ye && ae.verticalizable && (pr = yt.image ? qt - yt.metrics.width * yt.scale / 2 : 0);
                    const Tr = Pe ? [yt.x + qt, yt.y] : [0, 0];
                    let Lr = [0, 0], Pr = [0, 0], Ar = !1;
                    Pe || (Gt ? (Pr = [yt.x + qt + lt[0], yt.y + lt[1] - pr], Ar = !0) : Lr = [yt.x + qt + fe[0], yt.y + fe[1] - pr]);
                    const Tn = wr.w * yt.scale / (mt * (yt.localGlyph ? nl : 1)), On = wr.h * yt.scale / (mt * (yt.localGlyph ? nl : 1));
                    let he, pe, Je, Tt;
                    if (Gt) {
                        const Ht = yt.y - Ge, lr = new Et(-qt, qt - Ht), Vr = -Math.PI / 2, Ur = new Et(...Pr);
                        he = new Et(-qt + Lr[0], Lr[1]), he._rotateAround(Vr, lr)._add(Ur), he.x += -Ht + qt, he.y -= (hr.left - jt) * yt.scale;
                        const Ir = yt.image ? hr.advance * yt.scale : ts * yt.scale, pn = String.fromCodePoint(yt.glyph);
                        k5(pn) ? he.x += (1 - jt) * yt.scale : D5(pn) ? he.x += Ir - hr.height * yt.scale + (-jt - 1) * yt.scale : he.x += yt.image || hr.width + 2 * jt === wr.w && hr.height + 2 * jt === wr.h ? (Ir - On) / 2 : (Ir - (hr.height + 2 * jt) * yt.scale) / 2, pe = new Et(he.x, he.y - Tn), Je = new Et(he.x + On, he.y), Tt = new Et(he.x + On, he.y - Tn);
                    }
                    else {
                        const Ht = (hr.left - jt) * yt.scale - qt + Lr[0], lr = (-hr.top - jt) * yt.scale + Lr[1], Vr = Ht + Tn, Ur = lr + On;
                        he = new Et(Ht, lr), pe = new Et(Vr, lr), Je = new Et(Ht, Ur), Tt = new Et(Vr, Ur);
                    }
                    if (it) {
                        let Ht;
                        Ht = Pe ? new Et(0, 0) : Ar ? new Et(lt[0], lt[1]) : new Et(fe[0], fe[1]), he._rotateAround(it, Ht), pe._rotateAround(it, Ht), Je._rotateAround(it, Ht), Tt._rotateAround(it, Ht);
                    }
                    const Lt = new Et(0, 0), Dt = new Et(0, 0);
                    ut.push({ tl: he, tr: pe, bl: Je, br: Tt, texPrimary: Zt, texSecondary: void 0, writingMode: ae.writingMode, glyphOffset: Tr, sectionIndex: yt.sectionIndex, isSDF: Rt, pixelOffsetTL: Lt, pixelOffsetBR: Dt, minFontScaleX: 0, minFontScaleY: 0 });
                }
            } return ut; }(0, c, b, p, m, x, h, a.allowVerticalPlacement), se = a.textSizeData; let $ = null; se.kind === "source" ? ($ = [Hl * p.layout.get("text-size").evaluate(x, {}, X) * F.textScaleFactor], $[0] > th && Br(`${a.layerIds[0]}: Value for "text-size" is >= ${ny}. Reduce your "text-size".`)) : se.kind === "composite" && ($ = [Hl * F.compositeTextSizes[0].evaluate(x, {}, X) * F.textScaleFactor, Hl * F.compositeTextSizes[1].evaluate(x, {}, X) * F.textScaleFactor], ($[0] > th || $[1] > th) && Br(`${a.layerIds[0]}: Value for "text-size" is >= ${ny}. Reduce your "text-size".`)), a.addSymbols(a.text, le, $, b, m, x, A, e, i, S.lineStartIndex, S.lineLength, z, U, X, Y, !1); for (const te of I)
                M[te] = a.text.placedSymbolArray.length - 1; return 4 * le.length; }
            function lS(a) { for (const e in a)
                return a[e]; return null; }
            function zx(a, e, i, c, h, p, m, x, b, S) { let A = m.top, I = m.bottom, M = m.left, z = m.right; if (vM(m) && m.collisionPadding) {
                const F = m.collisionPadding;
                M -= F[0], A -= F[1], z += F[2], I += F[3];
            } if (b) {
                const F = new Et(M, A), U = new Et(z, A), X = new Et(M, I), Y = new Et(z, I), le = Z(b);
                let se = new Et(0, 0);
                S && (se = new Et(S[0], S[1])), F._rotateAround(le, se), U._rotateAround(le, se), X._rotateAround(le, se), Y._rotateAround(le, se), M = Math.min(F.x, U.x, X.x, Y.x), z = Math.max(F.x, U.x, X.x, Y.x), A = Math.min(F.y, U.y, X.y, Y.y), I = Math.max(F.y, U.y, X.y, Y.y);
            } return a.emplaceBack(e.x, e.y, e.z, i.x, i.y, M, A, z, I, x, c, h, p), a.length - 1; }
            function cS(a) { vM(a) && a.collisionPadding && (a.top -= a.collisionPadding[1], a.bottom += a.collisionPadding[3]); const e = a.bottom - a.top; return e > 0 ? Math.max(10, e) : null; }
            function Y5(a, e, i, c) { const h = a.compareText; if (e in h) {
                const p = h[e];
                for (let m = p.length - 1; m >= 0; m--)
                    if (c.dist(p[m]) < i)
                        return !0;
            }
            else
                h[e] = []; return h[e].push(c), !1; }
            function $M(a, e) { const i = a.fovAboveCenter, c = a.elevation ? a.elevation.getMinElevationBelowMSL() * e : 0, h = (a._camera.position[2] * a.worldSize - c) / Math.cos(a._pitch), p = Math.sin(i) * h / Math.sin(Math.max(Math.PI / 2 - a._pitch - i, .01)); let m = Math.sin(a._pitch) * p + h; const x = h * (1 / a._horizonShift); if (!a.elevation || a.elevation.exaggeration() === 0) {
                let b = Math.max(a.zoom - 17, 0);
                a.isOrthographic && (b /= 10), m *= 1 + b;
            } return Math.min(1.01 * m, x); }
            function iy(a, e) { if (!e.isReprojectedInTileSpace)
                return { scale: 1 << a.z, x: a.x, y: a.y, x2: a.x + 1, y2: a.y + 1, projection: e }; const i = Math.pow(2, -a.z), c = a.x * i, h = (a.x + 1) * i, p = a.y * i, m = (a.y + 1) * i, x = Se(c), b = Se(h), S = Ce(p), A = Ce(m), I = e.project(x, S), M = e.project(b, S), z = e.project(b, A), F = e.project(x, A); let U = Math.min(I.x, M.x, z.x, F.x), X = Math.min(I.y, M.y, z.y, F.y), Y = Math.max(I.x, M.x, z.x, F.x), le = Math.max(I.y, M.y, z.y, F.y); const se = i / 16; function $(ae, fe, Te, Pe, Me, Oe) { const Ye = (Te + Me) / 2, ut = (Pe + Oe) / 2, it = e.project(Se(Ye), Ce(ut)), lt = Math.max(0, U - it.x, X - it.y, it.x - Y, it.y - le); U = Math.min(U, it.x), Y = Math.max(Y, it.x), X = Math.min(X, it.y), le = Math.max(le, it.y), lt > se && ($(ae, it, Te, Pe, Ye, ut), $(it, fe, Ye, ut, Me, Oe)); } $(I, M, c, p, h, p), $(M, z, h, p, h, m), $(z, F, h, m, c, m), $(F, I, c, m, c, p), U -= se, X -= se, Y += se, le += se; const te = 1 / Math.max(Y - U, le - X); return { scale: te, x: U * te, y: X * te, x2: Y * te, y2: le * te, projection: e }; }
            function GM(a, { x: e, y: i }, c = 0) { return new Et(((e - c) * a.scale - a.x) * It, (i * a.scale - a.y) * It); }
            const Q5 = J(new Float32Array(16));
            class rh {
                constructor(e) { this.spec = e, this.name = e.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7]; }
                project(e, i) { return { x: 0, y: 0, z: 0 }; }
                unproject(e, i) { return new W(0, 0); }
                projectTilePoint(e, i, c) { return { x: e, y: i, z: 0 }; }
                locationPoint(e, i, c, h = !0) { return e._coordinatePoint(e.locationCoordinate(i, c), h); }
                pixelsPerMeter(e, i) { return ge(1, e) * i; }
                pixelSpaceConversion(e, i, c) { return 1; }
                farthestPixelDistance(e) { return $M(e, e.pixelsPerMeter); }
                pointCoordinate(e, i, c, h) { const p = e.horizonLineFromTop(!1), m = new Et(i, Math.max(p, c)); return e.rayIntersectionCoordinate(e.pointRayIntersection(m, h)); }
                pointCoordinate3D(e, i, c) { const h = new Et(i, c); if (e.elevation)
                    return e.elevation.pointCoordinate(h); {
                    const p = this.pointCoordinate(e, h.x, h.y, 0);
                    return [p.x, p.y, p.z];
                } }
                isPointAboveHorizon(e, i) { if (e.elevation && e.elevation.visibleDemTiles.length)
                    return !this.pointCoordinate3D(e, i.x, i.y); const c = e.horizonLineFromTop(); return i.y < c; }
                createInversionMatrix(e, i) { return Q5; }
                createTileMatrix(e, i, c) { let h, p, m; const x = c.canonical, b = J(new Float64Array(16)); if (this.isReprojectedInTileSpace) {
                    const S = iy(x, this);
                    h = 1, p = S.x + c.wrap * S.scale, m = S.y, ue(b, b, [h / S.scale, h / S.scale, e.pixelsPerMeter / i]);
                }
                else
                    h = i / e.zoomScale(x.z), p = (x.x + Math.pow(2, x.z) * c.wrap) * h, m = x.y * h; return Q(b, b, [p, m, 0]), ue(b, b, [h / It, h / It, 1]), b; }
                upVector(e, i, c) { return [0, 0, 1]; }
                upVectorScale(e, i, c) { return { metersToTile: 1 }; }
            }
            class J5 extends rh {
                constructor(e) { super(e), this.range = [4, 7], this.center = e.center || [-96, 37.5]; const [i, c] = this.parallels = e.parallels || [29.5, 45.5], h = Math.sin(Z(i)); this.n = (h + Math.sin(Z(c))) / 2, this.c = 1 + h * (2 * this.n - h), this.r0 = Math.sqrt(this.c) / this.n; }
                project(e, i) { const { n: c, c: h, r0: p } = this, m = Z(e - this.center[0]), x = Z(i), b = Math.sqrt(h - 2 * c * Math.sin(x)) / c; return { x: b * Math.sin(m * c), y: b * Math.cos(m * c) - p, z: 0 }; }
                unproject(e, i) { const { n: c, c: h, r0: p } = this, m = p + i; let x = Math.atan2(e, Math.abs(m)) * Math.sign(m); m * c < 0 && (x -= Math.PI * Math.sign(e) * Math.sign(m)); const b = Z(this.center[0]) * c; x = qe(x, -Math.PI - b, Math.PI - b); const S = ke(re(x / c) + this.center[0], -180, 180), A = Math.asin(ke((h - (e * e + m * m) * c * c) / (2 * c), -1, 1)), I = ke(re(A), -ze, ze); return new W(S, I); }
            }
            const sy = 1.340264, oy = -.081106, ay = 893e-6, ly = .003796, Fx = Math.sqrt(3) / 2;
            class eV extends rh {
                project(e, i) { i = i / 180 * Math.PI, e = e / 180 * Math.PI; const c = Math.asin(Fx * Math.sin(i)), h = c * c, p = h * h * h; return { x: .5 * (e * Math.cos(c) / (Fx * (sy + 3 * oy * h + p * (7 * ay + 9 * ly * h))) / Math.PI + .5), y: 1 - .5 * (c * (sy + oy * h + p * (ay + ly * h)) / Math.PI + 1), z: 0 }; }
                unproject(e, i) { e = (2 * e - .5) * Math.PI; let c = i = (2 * (1 - i) - 1) * Math.PI, h = c * c, p = h * h * h; for (let A, I, M, z = 0; z < 12 && (I = c * (sy + oy * h + p * (ay + ly * h)) - i, M = sy + 3 * oy * h + p * (7 * ay + 9 * ly * h), A = I / M, c = ke(c - A, -Math.PI / 3, Math.PI / 3), h = c * c, p = h * h * h, !(Math.abs(A) < 1e-12)); ++z)
                    ; const m = Fx * e * (sy + 3 * oy * h + p * (7 * ay + 9 * ly * h)) / Math.cos(c), x = Math.asin(Math.sin(c) / Fx), b = ke(180 * m / Math.PI, -180, 180), S = ke(180 * x / Math.PI, -ze, ze); return new W(b, S); }
            }
            class tV extends rh {
                constructor(e) { super(e), this.wrap = !0, this.supportsWorldCopies = !0; }
                project(e, i) { return { x: .5 + e / 360, y: .5 - i / 360, z: 0 }; }
                unproject(e, i) { const c = 360 * (e - .5), h = ke(360 * (.5 - i), -ze, ze); return new W(c, h); }
            }
            const Jp = Math.PI / 2;
            function Nx(a) { return Math.tan((Jp + a) / 2); }
            class rV extends rh {
                constructor(e) { super(e), this.center = e.center || [0, 30]; const [i, c] = this.parallels = e.parallels || [30, 30]; let h = Z(i), p = Z(c); this.southernCenter = h + p < 0, this.southernCenter && (h = -h, p = -p); const m = Math.cos(h), x = Nx(h); this.n = h === p ? Math.sin(h) : Math.log(m / Math.cos(p)) / Math.log(Nx(p) / x), this.f = m * Math.pow(Nx(h), this.n) / this.n; }
                project(e, i) { i = Z(i), this.southernCenter && (i = -i), e = Z(e - this.center[0]); const c = 1e-6, { n: h, f: p } = this; p > 0 ? i < -Jp + c && (i = -Jp + c) : i > Jp - c && (i = Jp - c); const m = p / Math.pow(Nx(i), h); let x = m * Math.sin(h * e), b = p - m * Math.cos(h * e); return x = .5 * (x / Math.PI + .5), b = .5 * (b / Math.PI + .5), { x, y: this.southernCenter ? b : 1 - b, z: 0 }; }
                unproject(e, i) { e = (2 * e - .5) * Math.PI, this.southernCenter && (i = 1 - i), i = (2 * (1 - i) - .5) * Math.PI; const { n: c, f: h } = this, p = h - i, m = Math.sign(p), x = Math.sign(c) * Math.sqrt(e * e + p * p); let b = Math.atan2(e, Math.abs(p)) * m; p * c < 0 && (b -= Math.PI * Math.sign(e) * m); const S = ke(re(b / c) + this.center[0], -180, 180), A = ke(re(2 * Math.atan(Math.pow(h / x, 1 / c)) - Jp), -ze, ze); return new W(S, this.southernCenter ? -A : A); }
            }
            class qM extends rh {
                constructor(e) { super(e), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null; }
                project(e, i) { return { x: ve(e), y: xe(i), z: 0 }; }
                unproject(e, i) { const c = Se(e), h = Ce(i); return new W(c, h); }
            }
            const HM = Z(ze);
            class nV extends rh {
                project(e, i) { const c = (i = Z(i)) * i, h = c * c; return { x: .5 * ((e = Z(e)) * (.8707 - .131979 * c + h * (h * (.003971 * c - .001529 * h) - .013791)) / Math.PI + .5), y: 1 - .5 * (i * (1.007226 + c * (.015085 + h * (.028874 * c - .044475 - .005916 * h))) / Math.PI + 1), z: 0 }; }
                unproject(e, i) { e = (2 * e - .5) * Math.PI; let c = i = (2 * (1 - i) - 1) * Math.PI, h = 25, p = 0, m = c * c; do {
                    m = c * c;
                    const S = m * m;
                    p = (c * (1.007226 + m * (.015085 + S * (.028874 * m - .044475 - .005916 * S))) - i) / (1.007226 + m * (.045255 + S * (.259866 * m - .311325 - .005916 * 11 * S))), c = ke(c - p, -HM, HM);
                } while (Math.abs(p) > 1e-6 && --h > 0); m = c * c; const x = ke(re(e / (.8707 + m * (m * (m * m * m * (.003971 - .001529 * m) - .013791) - .131979))), -180, 180), b = re(c); return new W(x, b); }
            }
            const WM = Z(ze);
            class iV extends rh {
                project(e, i) { i = Z(i), e = Z(e); const c = Math.cos(i), h = 2 / Math.PI, p = Math.acos(c * Math.cos(e / 2)), m = Math.sin(p) / p, x = .5 * (e * h + 2 * c * Math.sin(e / 2) / m) || 0, b = .5 * (i + Math.sin(i) / m) || 0; return { x: .5 * (x / Math.PI + .5), y: 1 - .5 * (b / Math.PI + 1), z: 0 }; }
                unproject(e, i) { let c = e = (2 * e - .5) * Math.PI, h = i = (2 * (1 - i) - 1) * Math.PI, p = 25; const m = 1e-6; let x = 0, b = 0; do {
                    const S = Math.cos(h), A = Math.sin(h), I = 2 * A * S, M = A * A, z = S * S, F = Math.cos(c / 2), U = Math.sin(c / 2), X = 2 * F * U, Y = U * U, le = 1 - z * F * F, se = le ? 1 / le : 0, $ = le ? Math.acos(S * F) * Math.sqrt(1 / le) : 0, te = .5 * (2 * $ * S * U + 2 * c / Math.PI) - e, ae = .5 * ($ * A + h) - i, fe = .5 * se * (z * Y + $ * S * F * M) + 1 / Math.PI, Te = se * (X * I / 4 - $ * A * U), Pe = .125 * se * (I * U - $ * A * z * X), Me = .5 * se * (M * F + $ * Y * S) + .5, Oe = Te * Pe - Me * fe;
                    x = (ae * Te - te * Me) / Oe, b = (te * Pe - ae * fe) / Oe, c = ke(c - x, -Math.PI, Math.PI), h = ke(h - b, -WM, WM);
                } while ((Math.abs(x) > m || Math.abs(b) > m) && --p > 0); return new W(re(c), re(h)); }
            }
            class ZM extends rh {
                constructor(e) { super(e), this.center = e.center || [0, 0], this.parallels = e.parallels || [0, 0], this.cosPhi = Math.max(.01, Math.cos(Z(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0; }
                project(e, i) { const { scale: c, cosPhi: h } = this; return { x: Z(e) * h * c + .5, y: -Math.sin(Z(i)) / h * c + .5, z: 0 }; }
                unproject(e, i) { const { scale: c, cosPhi: h } = this, p = -(i - .5) / c, m = ke(re((e - .5) / c) / h, -180, 180), x = Math.asin(ke(p * h, -1, 1)), b = ke(re(x), -ze, ze); return new W(m, b); }
            }
            class sV extends qM {
                constructor(e) { super(e), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5]; }
                projectTilePoint(e, i, c) { const h = j_(e, i, c); return ln(h, h, vx(Gl(c))), { x: h[0], y: h[1], z: h[2] }; }
                locationPoint(e, i, c) { const h = q(i.lat, i.lng), p = an([], h), m = c ? e._centerAltitude + c : e.elevation ? e.elevation.getAtPointOrZero(e.locationCoordinate(i), e._centerAltitude) : e._centerAltitude; gr(h, h, p, ge(1, 0) * It * m); const x = J(new Float64Array(16)); return ie(x, e.pixelMatrix, e.globeMatrix), ln(h, h, x), new Et(h[0], h[1]); }
                pixelsPerMeter(e, i) { return ge(1, 0) * i; }
                pixelSpaceConversion(e, i, c) { const h = ge(1, e) * i, p = nr(ge(1, 45) * i, h, c); return this.pixelsPerMeter(e, i) / p; }
                createTileMatrix(e, i, c) { const h = AT(Gl(c.canonical)); return ie(new Float64Array(16), e.globeMatrix, h); }
                createInversionMatrix(e, i) { const { center: c } = e, h = vx(Gl(i)); return Ie(h, h, Z(c.lng)), be(h, h, Z(c.lat)), ue(h, h, [e._pixelsPerMercatorPixel, e._pixelsPerMercatorPixel, 1]), Float32Array.from(h); }
                pointCoordinate(e, i, c, h) { return RI(e, i, c, !0) || new Ve(0, 0); }
                pointCoordinate3D(e, i, c) { const h = this.pointCoordinate(e, i, c, 0); return [h.x, h.y, h.z]; }
                isPointAboveHorizon(e, i) { return !RI(e, i.x, i.y, !1); }
                farthestPixelDistance(e) { const i = function (h, p) { const m = h.cameraToCenterDistance, x = h._centerAltitude * p, b = h._camera, S = h._camera.forward(), A = ir([], Ft([], S, -m), [0, 0, x]), I = h.worldSize / (2 * Math.PI), M = [0, 0, -I], z = h.width / h.height, F = Math.tan(h.fovAboveCenter), U = Ft([], b.up(), F), X = Ft([], b.right(), F * z), Y = an([], ir([], ir([], S, U), X)), le = []; let se; if (new aa(A, Y).closestPointOnSphere(M, I, le)) {
                    const $ = ir([], le, M), te = Gn([], $, A);
                    se = Math.cos(h.fovAboveCenter) * Kt(te);
                }
                else {
                    const $ = Gn([], A, M), te = Gn([], M, A);
                    an(te, te);
                    const ae = Kt($) - I;
                    se = Math.sqrt(ae * (ae + 2 * I));
                    const fe = Math.acos(se / (I + ae)) - Math.acos(Kr(S, te));
                    se *= Math.cos(fe);
                } return 1.01 * se; }(e, this.pixelsPerMeter(e.center.lat, e.worldSize)), c = Ku(e.zoom); if (c > 0) {
                    const h = $M(e, ge(1, e.center.lat) * e.worldSize), p = e.worldSize / (2 * Math.PI), m = Math.max(e.width, e.height) / e.worldSize * Math.PI;
                    return nr(i, h + p * (1 - Math.cos(m)), Math.pow(c, 10));
                } return i; }
                upVector(e, i, c) { return j_(i, c, e, 1); }
                upVectorScale(e) { return { metersToTile: Xu(yx(Gl(e))) }; }
            }
            function XM(a) { const e = a.parallels, i = !!e && Math.abs(e[0] + e[1]) < .01; switch (a.name) {
                case "mercator": return new qM(a);
                case "equirectangular": return new tV(a);
                case "naturalEarth": return new nV(a);
                case "equalEarth": return new eV(a);
                case "winkelTripel": return new iV(a);
                case "albers": return i ? new ZM(a) : new J5(a);
                case "lambertConformalConic": return i ? new ZM(a) : new rV(a);
                case "globe": return new sV(a);
            } throw new Error(`Invalid projection name: ${a.name}`); }
            const oV = Qu.VectorTileFeature.types, aV = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
            function Bx(a, e, i, c, h, p, m, x, b, S, A, I, M) { const z = x ? Math.min(th, Math.round(x[0])) : 0, F = x ? Math.min(th, Math.round(x[1])) : 0; a.emplaceBack(e, i, Math.round(32 * c), Math.round(32 * h), p, m, (z << 1) + (b ? 1 : 0), F, 16 * S, 16 * A, 256 * I, 256 * M); }
            function jx(a, e, i) { a.emplaceBack(e, i); }
            function Vx(a, e, i, c, h, p, m) { a.emplaceBack(e, i, c, h, p, m); }
            function Ux(a, e, i, c, h) { a.emplaceBack(e, i, c, h), a.emplaceBack(e, i, c, h), a.emplaceBack(e, i, c, h), a.emplaceBack(e, i, c, h); }
            function lV(a) { for (const e of a.sections)
                if (mT(e.text))
                    return !0; return !1; }
            class uS {
                constructor(e) { this.layoutVertexArray = new $u, this.indexArray = new Hi, this.programConfigurations = e, this.segments = new ti, this.dynamicLayoutVertexArray = new Ca, this.opacityVertexArray = new P_, this.placedSymbolArray = new ix, this.iconTransitioningVertexArray = new Vl, this.globeExtVertexArray = new Gs, this.zOffsetVertexArray = new Vu; }
                isEmpty() { return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0 && this.iconTransitioningVertexArray.length === 0; }
                upload(e, i, c, h, p) { this.isEmpty() || (c && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, T5.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, i), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, E5.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, aV, !0), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = e.createVertexBuffer(this.iconTransitioningVertexArray, A5.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, S5.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || p) && (this.zOffsetVertexBuffer = e.createVertexBuffer(this.zOffsetVertexArray, C5.members, !0)), this.opacityVertexBuffer.itemSize = 1), (c || h) && this.programConfigurations.upload(e)); }
                destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy()); }
            }
            Nt(uS, "SymbolBuffers");
            class hS {
                constructor(e, i, c) { this.layoutVertexArray = new e, this.layoutAttributes = i, this.indexArray = new c, this.segments = new ti, this.collisionVertexArray = new R_, this.collisionVertexArrayExt = new Ca; }
                upload(e) { this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, I5.members, !0), this.collisionVertexBufferExt = e.createVertexBuffer(this.collisionVertexArrayExt, P5.members, !0); }
                destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy()); }
            }
            Nt(hS, "CollisionBuffers");
            class $x {
                constructor(e) { this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.lut = e.lut, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(m => m.fqid), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.hasAnyIconTextFit = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = J([]), this.placementViewportMatrix = J([]); const i = this.layers[0]._unevaluatedLayout._values; this.textSizeData = SM(this.zoom, i["text-size"]), this.iconSizeData = SM(this.zoom, i["icon-size"]); const c = this.layers[0].layout, h = c.get("symbol-sort-key"), p = c.get("symbol-z-order"); this.canOverlap = c.get("text-allow-overlap") || c.get("icon-allow-overlap") || c.get("text-ignore-placement") || c.get("icon-ignore-placement"), this.sortFeaturesByKey = p !== "viewport-y" && h.constantOr(1) !== void 0, this.sortFeaturesByY = (p === "viewport-y" || p === "auto" && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = c.get("text-writing-mode").map(m => go[m]), this.stateDependentLayerIds = this.layers.filter(m => m.isStateDependent()).map(m => m.id), this.sourceID = e.sourceID, this.projection = e.projection, this.hasAnyZOffset = !1, this.zOffsetSortDirty = !1, this.zOffsetBuffersNeedUpload = !1, this.elevationType = "none", this.elevationStateComplete = !1, this.activeReplacements = [], this.replacementUpdateTime = 0; }
                createArrays() { this.text = new uS(new Uc(this.layers, { zoom: this.zoom, lut: this.lut }, e => e.startsWith("text") || e.startsWith("symbol"))), this.icon = new uS(new Uc(this.layers, { zoom: this.zoom, lut: this.lut }, e => e.startsWith("icon") || e.startsWith("symbol"))), this.glyphOffsetArray = new F_, this.lineVertexArray = new ax, this.symbolInstances = new ox; }
                calculateGlyphDependencies(e, i, c, h, p) { for (const m of e) {
                    const x = m.codePointAt(0);
                    if (x === void 0)
                        break;
                    if (i[x] = !0, h && p && x <= 65535) {
                        const b = Q_[m];
                        b && (i[b.charCodeAt(0)] = !0);
                    }
                } }
                updateFootprints(e, i) { }
                updateReplacement(e, i) { if (i.updateTime === this.replacementUpdateTime)
                    return !1; this.replacementUpdateTime = i.updateTime; const c = i.getReplacementRegionsForTile(e.toUnwrapped(), !0); return !qT(this.activeReplacements, c) && (this.activeReplacements = c, !0); }
                populate(e, i, c, h) { const p = this.layers[0], m = p.layout, x = this.projection.name === "globe", b = m.get("text-font"), S = m.get("text-field"), A = m.get("icon-image"), [I, M] = m.get("icon-size-scale-range"), z = ke(i.scaleFactor || 1, I, M), F = (S.value.kind !== "constant" || S.value.value instanceof Ps && !S.value.value.isEmpty() || S.value.value.toString().length > 0) && (b.value.kind !== "constant" || b.value.value.length > 0), U = A.value.kind !== "constant" || !!A.value.value || Object.keys(A.parameters).length > 0, X = m.get("symbol-sort-key"); if (this.features = [], !F && !U)
                    return; const Y = i.iconDependencies, le = i.glyphDependencies, se = i.availableImages, $ = new yn(this.zoom); for (const { feature: te, id: ae, index: fe, sourceLayerIndex: Te } of e) {
                    const Pe = p._featureFilter.needGeometry, Me = Xt(te, Pe);
                    if (!p._featureFilter.filter($, Me, c))
                        continue;
                    if (Pe || (Me.geometry = Vt(te, c, h)), x && te.type !== 1 && c.z <= 5) {
                        const lt = Me.geometry, pt = .98078528056, We = (at, Ge) => Kr(j_(at.x, at.y, c, 1), j_(Ge.x, Ge.y, c, 1)) < pt;
                        for (let at = 0; at < lt.length; at++)
                            lt[at] = ht(lt[at], We);
                    }
                    let Oe, Ye;
                    if (F) {
                        const lt = p.getValueAndResolveTokens("text-field", Me, c, se), pt = Ps.factory(lt);
                        lV(pt) && (this.hasRTLText = !0), (!this.hasRTLText || Nu() === "unavailable" || this.hasRTLText && zo.isParsed()) && (Oe = R5(pt, p, Me));
                    }
                    if (U) {
                        const lt = p.getValueAndResolveTokens("icon-image", Me, c, se);
                        Ye = typeof lt == "string" ? Us.build(lt) : lt;
                    }
                    if (!Oe && !Ye)
                        continue;
                    const ut = this.sortFeaturesByKey ? X.evaluate(Me, {}, c) : void 0, it = { id: ae, text: Oe, icon: Ye, index: fe, sourceLayerIndex: Te, geometry: Me.geometry, properties: te.properties, type: oV[te.type], sortKey: ut };
                    if (this.features.push(it), Ye) {
                        const lt = this.layers[0]._unevaluatedLayout._values, { iconPrimary: pt, iconSecondary: We } = BM(Ye, this.iconSizeData, lt["icon-size"], c, this.zoom, it, this.pixelRatio, z), at = pt.id.toString();
                        if (Y.has(at) ? Y.get(at).push(pt) : Y.set(at, [pt]), We) {
                            const Ge = We.id.toString();
                            Y.has(Ge) ? Y.get(Ge).push(We) : Y.set(Ge, [We]);
                        }
                    }
                    if (Oe) {
                        const lt = b.evaluate(Me, {}, c).join(","), pt = m.get("text-rotation-alignment") === "map" && m.get("symbol-placement") !== "point";
                        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(go.vertical) >= 0;
                        for (const We of Oe.sections)
                            if (We.image) {
                                const at = We.image.getPrimary().scaleSelf(this.pixelRatio), Ge = at.id.toString(), Xe = Y.get(Ge) || [];
                                Xe.push(at), Y.set(Ge, Xe);
                            }
                            else {
                                const at = __(Oe.toString()), Ge = We.fontStack || lt, Xe = le[Ge] = le[Ge] || {};
                                this.calculateGlyphDependencies(We.text, Xe, pt, this.allowVerticalPlacement, at);
                            }
                    }
                } if (m.get("symbol-placement") === "line" && (this.features = function (te) { const ae = {}, fe = {}, Te = []; let Pe = 0; function Me(it) { Te.push(te[it]), Pe++; } function Oe(it, lt, pt) { const We = fe[it]; return delete fe[it], fe[lt] = We, Te[We].geometry[0].pop(), Te[We].geometry[0] = Te[We].geometry[0].concat(pt[0]), We; } function Ye(it, lt, pt) { const We = ae[lt]; return delete ae[lt], ae[it] = We, Te[We].geometry[0].shift(), Te[We].geometry[0] = pt[0].concat(Te[We].geometry[0]), We; } function ut(it, lt, pt) { const We = pt ? lt[0][lt[0].length - 1] : lt[0][0]; return `${it}:${We.x}:${We.y}`; } for (let it = 0; it < te.length; it++) {
                    const lt = te[it], pt = lt.geometry, We = lt.text ? lt.text.toString() : null;
                    if (!We) {
                        Me(it);
                        continue;
                    }
                    const at = ut(We, pt), Ge = ut(We, pt, !0);
                    if (at in fe && Ge in ae && fe[at] !== ae[Ge]) {
                        const Xe = Ye(at, Ge, pt), gt = Oe(at, Ge, Te[Xe].geometry);
                        delete ae[at], delete fe[Ge], fe[ut(We, Te[gt].geometry, !0)] = gt, Te[Xe].geometry = null;
                    }
                    else
                        at in fe ? Oe(at, Ge, pt) : Ge in ae ? Ye(at, Ge, pt) : (Me(it), ae[at] = Pe - 1, fe[Ge] = Pe - 1);
                } return Te.filter(it => it.geometry); }(this.features)), m.get("symbol-elevation-reference") === "hd-road-markup") {
                    if (this.elevationType = "road", i.elevationFeatures) {
                        !this.elevationFeatures && i.elevationFeatures.length > 0 && (this.elevationFeatures = [], this.elevationFeatureIdToIndex = new Map);
                        for (const te of i.elevationFeatures)
                            this.elevationFeatureIdToIndex.set(te.id, this.elevationFeatures.length), this.elevationFeatures.push(te);
                    }
                }
                else
                    m.get("symbol-z-elevate") && (this.elevationType = "offset"); this.elevationType !== "none" && (this.zOffsetBuffersNeedUpload = !0), this.sortFeaturesByKey && this.features.sort((te, ae) => te.sortKey - ae.sortKey); }
                update(e, i, c, h, p, m, x) { this.text.programConfigurations.updatePaintArrays(e, i, p, c, h, m, x), this.icon.programConfigurations.updatePaintArrays(e, i, p, c, h, m, x); }
                updateRoadElevation() { if (this.elevationType !== "road" || !this.elevationFeatures || this.elevationStateComplete)
                    return; this.elevationStateComplete = !0, this.hasAnyZOffset = !1; let e = !1; for (let i = 0; i < this.symbolInstances.length; i++) {
                    const c = this.symbolInstances.get(i);
                    if (c.elevationFeatureIndex === 65535)
                        continue;
                    const h = this.elevationFeatures[c.elevationFeatureIndex];
                    if (h) {
                        const p = .05 + h.pointElevation(new Et(c.tileAnchorX, c.tileAnchorY));
                        c.zOffset !== p && (e = !0, c.zOffset = p);
                    }
                } e && (this.zOffsetBuffersNeedUpload = !0, this.zOffsetSortDirty = !0); }
                updateZOffset() { const e = (p, m, x) => { c += m, c > p.length && p.resize(c); for (let b = -m; b < 0; b++)
                    p.emplace(b + c, x); }, i = (p, m, x) => { h += m, h > p.length && p.resize(h); for (let b = -m; b < 0; b++)
                    p.emplace(b + h, x); }; if (!this.zOffsetBuffersNeedUpload)
                    return; this.zOffsetBuffersNeedUpload = !1; let c = 0, h = 0; for (let p = 0; p < this.symbolInstances.length; p++) {
                    const m = this.symbolInstances.get(p), { numHorizontalGlyphVertices: x, numVerticalGlyphVertices: b, numIconVertices: S } = m, A = m.zOffset, I = S > 0;
                    if ((x > 0 || b > 0) && (e(this.text.zOffsetVertexArray, x, A), e(this.text.zOffsetVertexArray, b, A)), I) {
                        const { placedIconSymbolIndex: M, verticalPlacedIconSymbolIndex: z } = m;
                        M >= 0 && i(this.icon.zOffsetVertexArray, S, A), z >= 0 && i(this.icon.zOffsetVertexArray, m.numVerticalIconVertices, A);
                    }
                } this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray); }
                isEmpty() { return this.symbolInstances.length === 0 && !this.hasRTLText; }
                uploadPending() { return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload; }
                upload(e) { !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = !0; }
                destroyDebugData() { this.textCollisionBox.destroy(), this.iconCollisionBox.destroy(); }
                getProjection() { return this.projectionInstance || (this.projectionInstance = XM(this.projection)), this.projectionInstance; }
                destroy() { this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData(); }
                addToLineVertexArray(e, i) { const c = this.lineVertexArray.length; if (e.segment !== void 0)
                    for (const { x: h, y: p } of i)
                        this.lineVertexArray.emplaceBack(h, p); return { lineStartIndex: c, lineLength: this.lineVertexArray.length - c }; }
                addSymbols(e, i, c, h, p, m, x, b, S, A, I, M, z, F, U, X) { const Y = e.indexArray, le = e.layoutVertexArray, se = e.globeExtVertexArray, $ = e.segments.prepareSegment(4 * i.length, le, Y, this.canOverlap ? m.sortKey : void 0), te = this.glyphOffsetArray.length, ae = $.vertexLength, fe = this.allowVerticalPlacement && x === go.vertical ? Math.PI / 2 : 0, Te = m.text && m.text.sections; for (let Me = 0; Me < i.length; Me++) {
                    const { tl: Oe, tr: Ye, bl: ut, br: it, texPrimary: lt, texSecondary: pt, pixelOffsetTL: We, pixelOffsetBR: at, minFontScaleX: Ge, minFontScaleY: Xe, glyphOffset: gt, isSDF: yt, sectionIndex: Zt } = i[Me], jt = $.vertexLength, Rt = gt[1];
                    if (Bx(le, S.x, S.y, Oe.x, Rt + Oe.y, lt.x, lt.y, c, yt, We.x, We.y, Ge, Xe), Bx(le, S.x, S.y, Ye.x, Rt + Ye.y, lt.x + lt.w, lt.y, c, yt, at.x, We.y, Ge, Xe), Bx(le, S.x, S.y, ut.x, Rt + ut.y, lt.x, lt.y + lt.h, c, yt, We.x, at.y, Ge, Xe), Bx(le, S.x, S.y, it.x, Rt + it.y, lt.x + lt.w, lt.y + lt.h, c, yt, at.x, at.y, Ge, Xe), b) {
                        const { x: mt, y: pr, z: Gt } = b.anchor, [qt, hr, wr] = b.up;
                        Vx(se, mt, pr, Gt, qt, hr, wr), Vx(se, mt, pr, Gt, qt, hr, wr), Vx(se, mt, pr, Gt, qt, hr, wr), Vx(se, mt, pr, Gt, qt, hr, wr), Ux(e.dynamicLayoutVertexArray, mt, pr, Gt, fe);
                    }
                    else
                        Ux(e.dynamicLayoutVertexArray, S.x, S.y, S.z, fe);
                    if (X) {
                        const mt = pt || lt;
                        jx(e.iconTransitioningVertexArray, mt.x, mt.y), jx(e.iconTransitioningVertexArray, mt.x + mt.w, mt.y), jx(e.iconTransitioningVertexArray, mt.x, mt.y + mt.h), jx(e.iconTransitioningVertexArray, mt.x + mt.w, mt.y + mt.h);
                    }
                    Y.emplaceBack(jt, jt + 1, jt + 2), Y.emplaceBack(jt + 1, jt + 2, jt + 3), $.vertexLength += 4, $.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(gt[0]), Me !== i.length - 1 && Zt === i[Me + 1].sectionIndex || e.programConfigurations.populatePaintArrays(le.length, m, m.index, {}, z, F, U, Te && Te[Zt]);
                } const Pe = b ? b.anchor : S; e.placedSymbolArray.emplaceBack(Pe.x, Pe.y, Pe.z, S.x, S.y, te, this.glyphOffsetArray.length - te, ae, A, I, S.segment, c ? c[0] : 0, c ? c[1] : 0, h[0], h[1], x, 0, 0, 0, M, 0); }
                _commitLayoutVertex(e, i, c, h, p, m, x) { e.emplaceBack(i, c, h, p, m, Math.round(x.x), Math.round(x.y)); }
                _addCollisionDebugVertices(e, i, c, h, p, m, x) { const b = c.segments.prepareSegment(4, c.layoutVertexArray, c.indexArray), S = b.vertexLength, A = x.tileAnchorX, I = x.tileAnchorY; for (let z = 0; z < 4; z++)
                    c.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0); this._commitDebugCollisionVertexUpdate(c.collisionVertexArrayExt, i, e.padding, x.zOffset), this._commitLayoutVertex(c.layoutVertexArray, h, p, m, A, I, new Et(e.x1, e.y1)), this._commitLayoutVertex(c.layoutVertexArray, h, p, m, A, I, new Et(e.x2, e.y1)), this._commitLayoutVertex(c.layoutVertexArray, h, p, m, A, I, new Et(e.x2, e.y2)), this._commitLayoutVertex(c.layoutVertexArray, h, p, m, A, I, new Et(e.x1, e.y2)), b.vertexLength += 4; const M = c.indexArray; M.emplaceBack(S, S + 1), M.emplaceBack(S + 1, S + 2), M.emplaceBack(S + 2, S + 3), M.emplaceBack(S + 3, S), b.primitiveLength += 4; }
                _addTextDebugCollisionBoxes(e, i, c, h, p, m) { for (let x = h; x < p; x++) {
                    const b = c.get(x), S = this.getSymbolInstanceTextSize(e, m, i, x);
                    this._addCollisionDebugVertices(b, S, this.textCollisionBox, b.projectedAnchorX, b.projectedAnchorY, b.projectedAnchorZ, m);
                } }
                _addIconDebugCollisionBoxes(e, i, c, h, p, m) { for (let x = h; x < p; x++) {
                    const b = c.get(x), S = this.getSymbolInstanceIconSize(e, i, m.placedIconSymbolIndex);
                    this._addCollisionDebugVertices(b, S, this.iconCollisionBox, b.projectedAnchorX, b.projectedAnchorY, b.projectedAnchorZ, m);
                } }
                generateCollisionDebugBuffers(e, i, c) { this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new hS(Bp, cM.members, Vl), this.iconCollisionBox = new hS(Bp, cM.members, Vl); const h = ey(this.iconSizeData, e), p = ey(this.textSizeData, e, c); for (let m = 0; m < this.symbolInstances.length; m++) {
                    const x = this.symbolInstances.get(m);
                    this._addTextDebugCollisionBoxes(p, e, i, x.textBoxStartIndex, x.textBoxEndIndex, x), this._addTextDebugCollisionBoxes(p, e, i, x.verticalTextBoxStartIndex, x.verticalTextBoxEndIndex, x), this._addIconDebugCollisionBoxes(h, e, i, x.iconBoxStartIndex, x.iconBoxEndIndex, x), this._addIconDebugCollisionBoxes(h, e, i, x.verticalIconBoxStartIndex, x.verticalIconBoxEndIndex, x);
                } }
                getSymbolInstanceTextSize(e, i, c, h) { const p = this.text.placedSymbolArray.get(i.rightJustifiedTextSymbolIndex >= 0 ? i.rightJustifiedTextSymbolIndex : i.centerJustifiedTextSymbolIndex >= 0 ? i.centerJustifiedTextSymbolIndex : i.leftJustifiedTextSymbolIndex >= 0 ? i.leftJustifiedTextSymbolIndex : i.verticalPlacedTextSymbolIndex >= 0 ? i.verticalPlacedTextSymbolIndex : h), m = nS(this.textSizeData, e, p) / ts; return this.tilePixelRatio * m; }
                getSymbolInstanceIconSize(e, i, c) { const h = this.icon.placedSymbolArray.get(c), p = nS(this.iconSizeData, e, h); return this.tilePixelRatio * p; }
                _commitDebugCollisionVertexUpdate(e, i, c, h) { e.emplaceBack(i, -c, -c, h), e.emplaceBack(i, c, -c, h), e.emplaceBack(i, c, c, h), e.emplaceBack(i, -c, c, h); }
                _updateTextDebugCollisionBoxes(e, i, c, h, p, m, x) { for (let b = h; b < p; b++) {
                    const S = c.get(b), A = this.getSymbolInstanceTextSize(e, m, i, b);
                    this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, A, S.padding, m.zOffset);
                } }
                _updateIconDebugCollisionBoxes(e, i, c, h, p, m, x) { for (let b = h; b < p; b++) {
                    const S = c.get(b), A = this.getSymbolInstanceIconSize(e, i, m.placedIconSymbolIndex);
                    this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, A, S.padding, m.zOffset);
                } }
                updateCollisionDebugBuffers(e, i, c, h) { if (!this.hasDebugData())
                    return; this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear(); const p = ey(this.iconSizeData, e, h), m = ey(this.textSizeData, e, c); for (let x = 0; x < this.symbolInstances.length; x++) {
                    const b = this.symbolInstances.get(x);
                    this._updateTextDebugCollisionBoxes(m, e, i, b.textBoxStartIndex, b.textBoxEndIndex, b, c), this._updateTextDebugCollisionBoxes(m, e, i, b.verticalTextBoxStartIndex, b.verticalTextBoxEndIndex, b, c), this._updateIconDebugCollisionBoxes(p, e, i, b.iconBoxStartIndex, b.iconBoxEndIndex, b, h), this._updateIconDebugCollisionBoxes(p, e, i, b.verticalIconBoxStartIndex, b.verticalIconBoxEndIndex, b, h);
                } this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt); }
                _deserializeCollisionBoxesForSymbol(e, i, c, h, p, m, x, b, S) { const A = {}; if (i < c) {
                    const { x1: I, y1: M, x2: z, y2: F, padding: U, projectedAnchorX: X, projectedAnchorY: Y, projectedAnchorZ: le, tileAnchorX: se, tileAnchorY: $, featureIndex: te } = e.get(i);
                    A.textBox = { x1: I, y1: M, x2: z, y2: F, padding: U, projectedAnchorX: X, projectedAnchorY: Y, projectedAnchorZ: le, tileAnchorX: se, tileAnchorY: $ }, A.textFeatureIndex = te;
                } if (h < p) {
                    const { x1: I, y1: M, x2: z, y2: F, padding: U, projectedAnchorX: X, projectedAnchorY: Y, projectedAnchorZ: le, tileAnchorX: se, tileAnchorY: $, featureIndex: te } = e.get(h);
                    A.verticalTextBox = { x1: I, y1: M, x2: z, y2: F, padding: U, projectedAnchorX: X, projectedAnchorY: Y, projectedAnchorZ: le, tileAnchorX: se, tileAnchorY: $ }, A.verticalTextFeatureIndex = te;
                } if (m < x) {
                    const { x1: I, y1: M, x2: z, y2: F, padding: U, projectedAnchorX: X, projectedAnchorY: Y, projectedAnchorZ: le, tileAnchorX: se, tileAnchorY: $, featureIndex: te } = e.get(m);
                    A.iconBox = { x1: I, y1: M, x2: z, y2: F, padding: U, projectedAnchorX: X, projectedAnchorY: Y, projectedAnchorZ: le, tileAnchorX: se, tileAnchorY: $ }, A.iconFeatureIndex = te;
                } if (b < S) {
                    const { x1: I, y1: M, x2: z, y2: F, padding: U, projectedAnchorX: X, projectedAnchorY: Y, projectedAnchorZ: le, tileAnchorX: se, tileAnchorY: $, featureIndex: te } = e.get(b);
                    A.verticalIconBox = { x1: I, y1: M, x2: z, y2: F, padding: U, projectedAnchorX: X, projectedAnchorY: Y, projectedAnchorZ: le, tileAnchorX: se, tileAnchorY: $ }, A.verticalIconFeatureIndex = te;
                } return A; }
                deserializeCollisionBoxes(e) { this.collisionArrays = []; for (let i = 0; i < this.symbolInstances.length; i++) {
                    const c = this.symbolInstances.get(i);
                    this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, c.textBoxStartIndex, c.textBoxEndIndex, c.verticalTextBoxStartIndex, c.verticalTextBoxEndIndex, c.iconBoxStartIndex, c.iconBoxEndIndex, c.verticalIconBoxStartIndex, c.verticalIconBoxEndIndex));
                } }
                hasTextData() { return this.text.segments.get().length > 0; }
                hasIconData() { return this.icon.segments.get().length > 0; }
                hasDebugData() { return this.textCollisionBox && this.iconCollisionBox; }
                hasTextCollisionBoxData() { return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0; }
                hasIconCollisionBoxData() { return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0; }
                hasIconTextFit() { return this.hasAnyIconTextFit; }
                addIndicesForPlacedSymbol(e, i) { const c = e.placedSymbolArray.get(i), h = c.vertexStartIndex + 4 * c.numGlyphs; for (let p = c.vertexStartIndex; p < h; p += 4)
                    e.indexArray.emplaceBack(p, p + 1, p + 2), e.indexArray.emplaceBack(p + 1, p + 2, p + 3); }
                getSortedSymbolIndexes(e) { if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0)
                    return this.symbolInstanceIndexes; const i = Math.sin(e), c = Math.cos(e), h = [], p = [], m = []; for (let x = 0; x < this.symbolInstances.length; ++x) {
                    m.push(x);
                    const b = this.symbolInstances.get(x);
                    h.push(0 | Math.round(i * b.tileAnchorX + c * b.tileAnchorY)), p.push(b.featureIndex);
                } return m.sort((x, b) => h[x] - h[b] || p[b] - p[x]), m; }
                getSortedIndexesByZOffset() { if (!this.zOffsetSortDirty)
                    return this.symbolInstanceIndexesSortedZOffset; if (!this.symbolInstanceIndexesSortedZOffset) {
                    this.symbolInstanceIndexesSortedZOffset = [];
                    for (let e = 0; e < this.symbolInstances.length; ++e)
                        this.symbolInstanceIndexesSortedZOffset.push(e);
                } return this.zOffsetSortDirty = !1, this.symbolInstanceIndexesSortedZOffset.sort((e, i) => this.symbolInstances.get(i).zOffset - this.symbolInstances.get(e).zOffset); }
                addToSortKeyRanges(e, i) { const c = this.sortKeyRanges[this.sortKeyRanges.length - 1]; c && c.sortKey === i ? c.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: i, symbolInstanceStart: e, symbolInstanceEnd: e + 1 }); }
                sortFeatures(e) { if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                    this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                    for (const i of this.symbolInstanceIndexes) {
                        const c = this.symbolInstances.get(i);
                        this.featureSortOrder.push(c.featureIndex);
                        const { rightJustifiedTextSymbolIndex: h, centerJustifiedTextSymbolIndex: p, leftJustifiedTextSymbolIndex: m, verticalPlacedTextSymbolIndex: x, placedIconSymbolIndex: b, verticalPlacedIconSymbolIndex: S } = c;
                        h >= 0 && this.addIndicesForPlacedSymbol(this.text, h), p >= 0 && p !== h && this.addIndicesForPlacedSymbol(this.text, p), m >= 0 && m !== p && m !== h && this.addIndicesForPlacedSymbol(this.text, m), x >= 0 && this.addIndicesForPlacedSymbol(this.text, x), b >= 0 && this.addIndicesForPlacedSymbol(this.icon, b), S >= 0 && this.addIndicesForPlacedSymbol(this.icon, S);
                    }
                    this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
                } }
            }
            let KM, YM, dS;
            Nt($x, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), $x.addDynamicAttributes = Ux;
            class QM {
                constructor(e) { this.type = e.property.overrides ? e.property.overrides.runtimeType : Il, this.defaultValue = e; }
                evaluate(e) { if (e.formattedSection) {
                    const i = this.defaultValue.property.overrides;
                    if (i && i.hasOverride(e.formattedSection))
                        return i.getOverride(e.formattedSection);
                } return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default; }
                eachChild(e) { this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression); }
                outputDefined() { return !1; }
                serialize() { return null; }
            }
            Nt(QM, "FormatSectionOverride", { omit: ["defaultValue"] });
            const fS = () => dS || (dS = { layout: KM || (KM = new gi({ "symbol-placement": new wt(Ne.layout_symbol["symbol-placement"]), "symbol-spacing": new wt(Ne.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new wt(Ne.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new zt(Ne.layout_symbol["symbol-sort-key"]), "symbol-z-order": new wt(Ne.layout_symbol["symbol-z-order"]), "symbol-z-elevate": new wt(Ne.layout_symbol["symbol-z-elevate"]), "symbol-elevation-reference": new wt(Ne.layout_symbol["symbol-elevation-reference"]), "icon-allow-overlap": new wt(Ne.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new wt(Ne.layout_symbol["icon-ignore-placement"]), "icon-optional": new wt(Ne.layout_symbol["icon-optional"]), "icon-rotation-alignment": new wt(Ne.layout_symbol["icon-rotation-alignment"]), "icon-size": new zt(Ne.layout_symbol["icon-size"]), "icon-size-scale-range": new wt(Ne.layout_symbol["icon-size-scale-range"]), "icon-text-fit": new zt(Ne.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new zt(Ne.layout_symbol["icon-text-fit-padding"]), "icon-image": new zt(Ne.layout_symbol["icon-image"]), "icon-rotate": new zt(Ne.layout_symbol["icon-rotate"]), "icon-padding": new wt(Ne.layout_symbol["icon-padding"]), "icon-keep-upright": new wt(Ne.layout_symbol["icon-keep-upright"]), "icon-offset": new zt(Ne.layout_symbol["icon-offset"]), "icon-anchor": new zt(Ne.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new wt(Ne.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new wt(Ne.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new wt(Ne.layout_symbol["text-rotation-alignment"]), "text-field": new zt(Ne.layout_symbol["text-field"]), "text-font": new zt(Ne.layout_symbol["text-font"]), "text-size": new zt(Ne.layout_symbol["text-size"]), "text-size-scale-range": new wt(Ne.layout_symbol["text-size-scale-range"]), "text-max-width": new zt(Ne.layout_symbol["text-max-width"]), "text-line-height": new zt(Ne.layout_symbol["text-line-height"]), "text-letter-spacing": new zt(Ne.layout_symbol["text-letter-spacing"]), "text-justify": new zt(Ne.layout_symbol["text-justify"]), "text-radial-offset": new zt(Ne.layout_symbol["text-radial-offset"]), "text-variable-anchor": new wt(Ne.layout_symbol["text-variable-anchor"]), "text-anchor": new zt(Ne.layout_symbol["text-anchor"]), "text-max-angle": new wt(Ne.layout_symbol["text-max-angle"]), "text-writing-mode": new wt(Ne.layout_symbol["text-writing-mode"]), "text-rotate": new zt(Ne.layout_symbol["text-rotate"]), "text-padding": new wt(Ne.layout_symbol["text-padding"]), "text-keep-upright": new wt(Ne.layout_symbol["text-keep-upright"]), "text-transform": new zt(Ne.layout_symbol["text-transform"]), "text-offset": new zt(Ne.layout_symbol["text-offset"]), "text-allow-overlap": new wt(Ne.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new wt(Ne.layout_symbol["text-ignore-placement"]), "text-optional": new wt(Ne.layout_symbol["text-optional"]), visibility: new wt(Ne.layout_symbol.visibility) })), paint: YM || (YM = new gi({ "icon-opacity": new zt(Ne.paint_symbol["icon-opacity"]), "icon-occlusion-opacity": new zt(Ne.paint_symbol["icon-occlusion-opacity"]), "icon-emissive-strength": new zt(Ne.paint_symbol["icon-emissive-strength"]), "text-emissive-strength": new zt(Ne.paint_symbol["text-emissive-strength"]), "icon-color": new zt(Ne.paint_symbol["icon-color"]), "icon-halo-color": new zt(Ne.paint_symbol["icon-halo-color"]), "icon-halo-width": new zt(Ne.paint_symbol["icon-halo-width"]), "icon-halo-blur": new zt(Ne.paint_symbol["icon-halo-blur"]), "icon-translate": new wt(Ne.paint_symbol["icon-translate"]), "icon-translate-anchor": new wt(Ne.paint_symbol["icon-translate-anchor"]), "icon-image-cross-fade": new wt(Ne.paint_symbol["icon-image-cross-fade"]), "text-opacity": new zt(Ne.paint_symbol["text-opacity"]), "text-occlusion-opacity": new zt(Ne.paint_symbol["text-occlusion-opacity"]), "text-color": new zt(Ne.paint_symbol["text-color"], { runtimeType: Vs, getOverride: a => a.textColor, hasOverride: a => !!a.textColor }), "text-halo-color": new zt(Ne.paint_symbol["text-halo-color"]), "text-halo-width": new zt(Ne.paint_symbol["text-halo-width"]), "text-halo-blur": new zt(Ne.paint_symbol["text-halo-blur"]), "text-translate": new wt(Ne.paint_symbol["text-translate"]), "text-translate-anchor": new wt(Ne.paint_symbol["text-translate-anchor"]), "icon-color-saturation": new wt(Ne.paint_symbol["icon-color-saturation"]), "icon-color-contrast": new wt(Ne.paint_symbol["icon-color-contrast"]), "icon-color-brightness-min": new wt(Ne.paint_symbol["icon-color-brightness-min"]), "icon-color-brightness-max": new wt(Ne.paint_symbol["icon-color-brightness-max"]), "symbol-z-offset": new zt(Ne.paint_symbol["symbol-z-offset"]), "icon-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "icon-halo-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "text-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "text-halo-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, dS);
            class Gx extends Ds {
                constructor(e, i, c, h) { super(e, fS(), i, c, h), this._colorAdjustmentMatrix = J([]), this.hasInitialOcclusionOpacityProperties = e.paint !== void 0 && ("icon-occlusion-opacity" in e.paint || "text-occlusion-opacity" in e.paint); }
                recalculate(e, i) { super.recalculate(e, i), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")); const c = this.layout.get("text-writing-mode"); if (c) {
                    const h = [];
                    for (const p of c)
                        h.indexOf(p) < 0 && h.push(p);
                    this.layout._values["text-writing-mode"] = h;
                }
                else
                    this.layout._values["text-writing-mode"] = this.layout.get("symbol-placement") === "point" ? ["horizontal"] : ["horizontal", "vertical"]; this._setPaintOverrides(); }
                getColorAdjustmentMatrix(e, i, c, h) { return this._saturation === e && this._contrast === i && this._brightnessMin === c && this._brightnessMax === h || (this._colorAdjustmentMatrix = function (p, m, x, b) { p = ys(p), m = _s(m); const S = ce(), A = p / 3, I = 1 - 2 * A, M = [I, A, A, 0, A, I, A, 0, A, A, I, 0, 0, 0, 0, 1], z = .5 - .5 * m, F = b - x; return ie(S, [F, 0, 0, 0, 0, F, 0, 0, 0, 0, F, 0, x, x, x, 1], [m, 0, 0, 0, 0, m, 0, 0, 0, 0, m, 0, z, z, z, 1]), ie(S, S, M), S; }(e, i, c, h), this._saturation = e, this._contrast = i, this._brightnessMin = c, this._brightnessMax = h), this._colorAdjustmentMatrix; }
                getValueAndResolveTokens(e, i, c, h) { const p = this.layout.get(e).evaluate(i, {}, c, h), m = this._unevaluatedLayout._values[e]; return m.isDataDriven() || Ap(m.value) || !p ? p : function (x, b) { return b.replace(/{([^{}]+)}/g, (S, A) => A in x ? String(x[A]) : ""); }(i.properties, p); }
                createBucket(e) { return new $x(e); }
                queryRadius() { return 0; }
                queryIntersectsFeature() { return !1; }
                _setPaintOverrides() { for (const e of fS().paint.overridableProperties) {
                    if (!Gx.hasPaintOverride(this.layout, e))
                        continue;
                    const i = this.paint.get(e), c = new QM(i), h = new p_(c, i.property.specification, this.scope, this.options);
                    let p = null;
                    p = i.value.kind === "constant" || i.value.kind === "source" ? new Dc("source", h) : new zu("composite", h, i.value.zoomStops, i.value.interpolationType), this.paint._values[e] = new Bu(i.property, p, i.parameters);
                } }
                _handleOverridablePaintPropertyUpdate(e, i, c) { return !(!this.layout || i.isDataDriven() || c.isDataDriven()) && Gx.hasPaintOverride(this.layout, e); }
                static hasPaintOverride(e, i) { const c = e.get("text-field"), h = fS().paint.properties[i]; let p = !1; const m = x => { for (const b of x)
                    if (h.overrides && h.overrides.hasOverride(b))
                        return void (p = !0); }; if (c.value.kind === "constant" && c.value.value instanceof Ps)
                    m(c.value.value.sections);
                else if (c.value.kind === "source") {
                    const x = S => { p || (S instanceof Rr && ji(S.value) === md ? m(S.value.sections) : S instanceof Sc ? m(S.sections) : S.eachChild(x)); }, b = c.value;
                    b._styleExpression && x(b._styleExpression.expression);
                } return p; }
                getProgramIds() { return ["symbol"]; }
                getDefaultProgramParams(e, i, c) { return { config: new $l(this, { zoom: i, lut: c }), overrideFog: !1 }; }
                hasElevation() { return this.layout && this.layout.get("symbol-elevation-reference") === "hd-road-markup"; }
            }
            let JM, eR, tR, rR;
            var pS = tn([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
            function mS(a) { switch (a) {
                case WebGL2RenderingContext.RGBA8: return WebGL2RenderingContext.RGBA;
                case WebGL2RenderingContext.DEPTH_COMPONENT16: return WebGL2RenderingContext.DEPTH_COMPONENT;
                case WebGL2RenderingContext.DEPTH24_STENCIL8: return WebGL2RenderingContext.DEPTH_STENCIL;
                case WebGL2RenderingContext.R8:
                case WebGL2RenderingContext.R32F: return WebGL2RenderingContext.RED;
            } }
            function gS(a) { switch (a) {
                case WebGL2RenderingContext.RGBA8: return WebGL2RenderingContext.UNSIGNED_BYTE;
                case WebGL2RenderingContext.DEPTH_COMPONENT16: return WebGL2RenderingContext.UNSIGNED_SHORT;
                case WebGL2RenderingContext.DEPTH24_STENCIL8: return WebGL2RenderingContext.UNSIGNED_INT_24_8;
                case WebGL2RenderingContext.R8: return WebGL2RenderingContext.UNSIGNED_BYTE;
                case WebGL2RenderingContext.R32F: return WebGL2RenderingContext.FLOAT;
            } }
            class _S {
                constructor(e, i, c, h) { this.context = e, this.format = c, this.useMipmap = h && h.useMipmap, this.texture = e.gl.createTexture(), this.update(i, { premultiply: h && h.premultiply }); }
                update(e, i) { const c = e && e instanceof HTMLVideoElement && e.width === 0 ? e.videoWidth : e.width, h = e && e instanceof HTMLVideoElement && e.height === 0 ? e.videoHeight : e.height, { context: p } = this, { gl: m } = p, { x, y: b } = i && i.position ? i.position : { x: 0, y: 0 }, S = x + c, A = b + h; !this.size || this.size[0] === S && this.size[1] === A || (m.bindTexture(m.TEXTURE_2D, null), m.deleteTexture(this.texture), this.texture = m.createTexture(), this.size = null), m.bindTexture(m.TEXTURE_2D, this.texture), p.pixelStoreUnpackFlipY.set(!1), p.pixelStoreUnpack.set(1), p.pixelStoreUnpackPremultiplyAlpha.set(this.format === m.RGBA8 && (!i || i.premultiply !== !1)); const I = e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ImageBitmap && e instanceof ImageBitmap; if (!this.size && S > 0 && A > 0) {
                    const M = this.useMipmap ? Math.floor(Math.log2(Math.max(S, A))) + 1 : 1;
                    m.texStorage2D(m.TEXTURE_2D, M, this.format, S, A), this.size = [S, A];
                } if (this.size)
                    if (I)
                        m.texSubImage2D(m.TEXTURE_2D, 0, x, b, mS(this.format), gS(this.format), e);
                    else {
                        const M = e.data;
                        M && m.texSubImage2D(m.TEXTURE_2D, 0, x, b, c, h, mS(this.format), gS(this.format), M);
                    } this.useMipmap && m.generateMipmap(m.TEXTURE_2D); }
                bind(e, i, c = !1) { const { context: h } = this, { gl: p } = h; p.bindTexture(p.TEXTURE_2D, this.texture), e !== this.minFilter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, e), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, this.useMipmap && !c ? e === p.NEAREST ? p.NEAREST_MIPMAP_NEAREST : p.LINEAR_MIPMAP_LINEAR : e), this.minFilter = e), i !== this.wrapS && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, i), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, i), this.wrapS = i); }
                bindExtraParam(e, i, c, h) { const { context: p } = this, { gl: m } = p; m.bindTexture(m.TEXTURE_2D, this.texture), i !== this.magFilter && (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, i), this.magFilter = i), e !== this.minFilter && (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, this.useMipmap ? e === m.NEAREST ? m.NEAREST_MIPMAP_NEAREST : m.LINEAR_MIPMAP_LINEAR : e), this.minFilter = e), c !== this.wrapS && (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, c), this.wrapS = c), h !== this.wrapT && (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, h), this.wrapT = h); }
                destroy() { const { gl: e } = this.context; e.deleteTexture(this.texture), this.texture = null; }
            }
            class qx {
                constructor(e, i) { this.context = e, this.texture = i; }
                bind(e, i) { const { context: c } = this, { gl: h } = c; h.bindTexture(h.TEXTURE_2D, this.texture), e !== this.minFilter && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, e), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, e), this.minFilter = e), i !== this.wrapS && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, i), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, i), this.wrapS = i); }
            }
            function Hx(a, e, i, c, h, p, m, x) { const b = [a, e, 1, i, c, 1, h, p, 1], S = [m, x, 1], A = H([], b), [I, M, z] = Bs(S, S, A); return ee(b, b, [I, 0, 0, 0, M, 0, 0, 0, z]); }
            function nR(a, e, i, c, h, p, m, x) { const b = function (S, A, I, M, z, F, U, X) { const Y = Hx(0, 0, 1, 0, 1, 1, 0, 1), le = Hx(S, A, I, M, z, F, U, X); return ee(le, le, H([], Y)); }(a, e, i, c, h, p, m, x); return [b[2] / b[8] / It, b[5] / b[8] / It]; }
            function Wx(a) { return [a[0], Math.min(Math.max(a[1], -ze), ze)]; }
            class iR extends wc {
                constructor(e, i, c, h) { super(), this.id = e, this.dispatcher = c, this.coordinates = i.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.onNorthPole = !1, this.onSouthPole = !1, this.setEventedParent(h), this.options = i, this._dirty = !1; }
                load(e, i) { if (this._loaded = i || !1, this.fire(new Al("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url)
                    return e && (this.coordinates = e), this._loaded = !0, void this._finishLoading(); this._imageRequest = vu(this.map._requestManager.transformRequest(this.url, Xf.Image), (c, h) => { this._imageRequest = null, this._loaded = !0, c ? this.fire(new Ng(c)) : h && (this.image = h instanceof HTMLImageElement ? Yo.getImageData(h) : h, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, e && (this.coordinates = e), this._finishLoading()); }); }
                loaded() { return this._loaded; }
                updateImage(e) { return e.url ? (this._imageRequest && e.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e.url, this.load(e.coordinates, this._loaded), this) : this; }
                setTexture(e) { if (!(e.handle instanceof WebGLTexture))
                    throw new Error("The provided handle is not a WebGLTexture instance"); return this.texture = new qx(this.map.painter.context, e.handle), this.width = e.dimensions[0], this.height = e.dimensions[1], this._dirty = !1, this._loaded = !0, this._finishLoading(), this; }
                _finishLoading() { this.map && (this.setCoordinates(this.coordinates), this.fire(new Al("data", { dataType: "source", sourceDataType: "metadata" }))); }
                onAdd(e) { this.map = e, this.load(); }
                onRemove(e) { this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof qx || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()); }
                setCoordinates(e) { if (this.coordinates = e, this._boundsArray = void 0, this._unsupportedCoords = !1, !e.length)
                    return this; this.onNorthPole = !1, this.onSouthPole = !1; let i = e[0][1], c = e[0][1]; for (const p of e)
                    p[1] > c && (c = p[1]), p[1] < i && (i = p[1]); const h = (c + i) / 2; if (h > ze ? this.onNorthPole = !0 : h < -ze && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole) {
                    const p = e.map(Ve.fromLngLat);
                    this.tileID = function (m) { let x = 1 / 0, b = 1 / 0, S = -1 / 0, A = -1 / 0; for (const U of m)
                        x = Math.min(x, U.x), b = Math.min(b, U.y), S = Math.max(S, U.x), A = Math.max(A, U.y); const I = Math.max(S - x, A - b), M = Math.max(0, Math.floor(-Math.log(I) / Math.LN2)), z = Math.pow(2, M); let F = Math.floor((x + S) / 2 * z); return F > 1 && (F -= 1), new Ln(M, F, Math.floor((b + A) / 2 * z)); }(p), this.minzoom = this.maxzoom = this.tileID.z;
                } return this.fire(new Al("data", { dataType: "source", sourceDataType: "content" })), this; }
                _clear() { this._boundsArray = void 0, this._unsupportedCoords = !1; }
                _prepareData(e) { for (const Y in this.tiles) {
                    const le = this.tiles[Y];
                    le.state !== "loaded" && (le.state = "loaded", le.texture = this.texture);
                } if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords)
                    return; const i = iy(new Ln(0, 0, 0), this.map.transform.projection), c = [i.projection.project(this.coordinates[0][0], this.coordinates[0][1]), i.projection.project(this.coordinates[1][0], this.coordinates[1][1]), i.projection.project(this.coordinates[2][0], this.coordinates[2][1]), i.projection.project(this.coordinates[3][0], this.coordinates[3][1])]; if (!function (Y) { const le = Y[1].x - Y[0].x, se = Y[1].y - Y[0].y, $ = Y[2].x - Y[1].x, te = Y[2].y - Y[1].y, ae = Y[3].x - Y[2].x, fe = Y[3].y - Y[2].y, Te = Y[0].x - Y[3].x, Pe = Y[0].y - Y[3].y, Me = le * te - $ * se, Oe = $ * fe - ae * te, Ye = ae * Pe - Te * fe, ut = Te * se - le * Pe; return Me > 0 && Oe > 0 && Ye > 0 && ut > 0 || Me < 0 && Oe < 0 && Ye < 0 && ut < 0; }(c))
                    return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = !0); const h = iy(this.tileID, this.map.transform.projection), [p, m, x, b] = this.coordinates.map(Y => { const le = h.projection.project(Y[0], Y[1]); return GM(h, le)._round(); }); this.perspectiveTransform = nR(p.x, p.y, m.x, m.y, x.x, x.y, b.x, b.y); const S = this._boundsArray = new Bc; S.emplaceBack(p.x, p.y, 0, 0), S.emplaceBack(m.x, m.y, It, 0), S.emplaceBack(b.x, b.y, 0, It), S.emplaceBack(x.x, x.y, It, It), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = e.createVertexBuffer(S, pS.members), this.boundsSegments = ti.simpleSegment(0, 0, 4, 2); const A = [], I = [Wx((M = this.coordinates)[0]), Wx(M[1]), Wx(M[2]), Wx(M[3])]; var M; const [z, F, U, X] = function (Y) { let le = Y[0][0], se = le, $ = Y[0][1], te = $; for (let ae = 1; ae < Y.length; ae++)
                    Y[ae][0] < le ? le = Y[ae][0] : Y[ae][0] > se && (se = Y[ae][0]), Y[ae][1] < $ ? $ = Y[ae][1] : Y[ae][1] > te && (te = Y[ae][1]); return [le, $, se - le, te - $]; }(I); {
                    const Y = new Bc, [le, se, $, te] = function (We) { let at = We[0].x, Ge = at, Xe = We[0].y, gt = Xe; for (let yt = 1; yt < We.length; yt++)
                        We[yt].x < at ? at = We[yt].x : We[yt].x > Ge && (Ge = We[yt].x), We[yt].y < Xe ? Xe = We[yt].y : We[yt].y > gt && (gt = We[yt].y); return [at, Xe, Ge - at, gt - Xe]; }(c), ae = We => [(We.x - le) / $, (We.y - se) / te], [fe, Te, Pe, Me] = c.map(ae), Oe = function (We, at, Ge, Xe, gt, yt, Zt, jt) { const Rt = Hx(0, 0, 1, 0, 1, 1, 0, 1); return ee(Rt, Rt, H([], Hx(We, at, Ge, Xe, gt, yt, Zt, jt))); }(fe[0], fe[1], Te[0], Te[1], Pe[0], Pe[1], Me[0], Me[1]);
                    this.elevatedGlobePerspectiveTransform = nR(fe[0], fe[1], Te[0], Te[1], Pe[0], Pe[1], Me[0], Me[1]);
                    const Ye = (We, at) => { A.push(We.lng); const Ge = Math.round((We.lng - z) / U * It), Xe = Math.round((We.lat - F) / X * It), gt = ae(at), yt = Bs([], [gt[0], gt[1], 1], Oe), Zt = Math.round(yt[0] / yt[2] * It), jt = Math.round(yt[1] / yt[2] * It); Y.emplaceBack(Ge, Xe, Zt, jt); }, ut = c[3].x - c[0].x, it = c[3].y - c[0].y, lt = c[2].x - c[1].x, pt = c[2].y - c[1].y;
                    for (let We = 0; We < 65; We++) {
                        const at = We / 64, Ge = [c[0].x + at * ut, c[0].y + at * it], Xe = [c[1].x + at * lt, c[1].y + at * pt], gt = Xe[0] - Ge[0], yt = Xe[1] - Ge[1];
                        for (let Zt = 0; Zt < 65; Zt++) {
                            const jt = Zt / 64, Rt = { x: Ge[0] + gt * jt, y: Ge[1] + yt * jt, z: 0 };
                            Ye(i.projection.unproject(Rt.x, Rt.y), Rt);
                        }
                    }
                    this.elevatedGlobeVertexBuffer = e.createVertexBuffer(Y, pS.members);
                } {
                    this.maxLongitudeTriangleSize = 0;
                    let Y = [], le = new Hi;
                    const se = ($, te, ae) => { le.emplaceBack($, te, ae); const fe = A[$], Te = A[te], Pe = A[ae], Me = Math.min(Math.min(fe, Te), Pe), Oe = Math.max(Math.max(fe, Te), Pe) - Me; Oe > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = Oe), Y.push(Me + Oe / 2); };
                    for (let $ = 0; $ < 64; $++)
                        for (let te = 0; te < 64; te++) {
                            const ae = 65 * $ + te, fe = ae + 1, Te = ae + 65, Pe = Te + 1;
                            se(ae, Te, fe), se(fe, Te, Pe);
                        }
                    [Y, le] = function ($, te) { const ae = Array.from({ length: $.length }, (Pe, Me) => Me); ae.sort((Pe, Me) => $[Pe] - $[Me]); const fe = [], Te = new Hi; for (let Pe = 0; Pe < ae.length; Pe++) {
                        const Me = ae[Pe];
                        fe.push($[Me]);
                        const Oe = 3 * Me, Ye = Oe + 1;
                        Te.emplaceBack(te.uint16[Oe], te.uint16[Ye], te.uint16[Ye + 1]);
                    } return [fe, Te]; }(Y, le), this.elevatedGlobeTrianglesCenterLongitudes = Y, this.elevatedGlobeIndexBuffer = e.createIndexBuffer(le);
                } this.elevatedGlobeSegments = ti.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, U / It, 0, X / It, 0, 0, F, z, 0]); }
                prepare() { const e = Object.keys(this.tiles).length !== 0; if (this.tileID && !e)
                    return; const i = this.map.painter.context, c = i.gl; !this._dirty || this.texture instanceof qx || (this.texture ? this.texture.update(this.image) : (this.texture = new _S(i, this.image, c.RGBA8), this.texture.bind(c.LINEAR, c.CLAMP_TO_EDGE)), this._dirty = !1), e && this._prepareData(i); }
                loadTile(e, i) { this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}, i(null)) : (e.state = "errored", i(null)); }
                serialize() { return { type: "image", url: this.options.url, coordinates: this.coordinates }; }
                hasTransition() { return !1; }
                getSegmentsForLongitude(e) { const i = this.elevatedGlobeSegments; if (!this.elevatedGlobeTrianglesCenterLongitudes || !i)
                    return null; const c = this.elevatedGlobeTrianglesCenterLongitudes; let h = (p = e + 180) + 360 * Math.round((c[0] - p) / 360); var p; const m = new ti, x = (I, M) => { m.segments.push({ vertexOffset: 0, primitiveOffset: I, vertexLength: i.segments[0].vertexLength, primitiveLength: M, sortKey: void 0, vaos: {} }); }, b = .51 * this.maxLongitudeTriangleSize; if (Math.abs(c[0] - h) <= b) {
                    const I = Ha(c, 0, c.length, h + b);
                    return I === c.length || x(I, os(c, I + 1, c.length, h + 360 - b) - I), m;
                } h < c[0] && (h += 360); const S = os(c, 0, c.length, h - b); if (S === c.length)
                    return x(0, c.length), m; x(0, S - 0); const A = Ha(c, S + 1, c.length, h + b); return A !== c.length && x(A, c.length - A), m; }
            }
            const cV = (Math.pow(256, 2) - 1) / 16907520;
            class sR extends Ds {
                constructor(e, i, c, h) { super(e, { layout: tR || (tR = new gi({ visibility: new wt(Ne.layout_raster.visibility) })), paint: rR || (rR = new gi({ "raster-opacity": new wt(Ne.paint_raster["raster-opacity"]), "raster-color": new Fc(Ne.paint_raster["raster-color"]), "raster-color-mix": new wt(Ne.paint_raster["raster-color-mix"]), "raster-color-range": new wt(Ne.paint_raster["raster-color-range"]), "raster-hue-rotate": new wt(Ne.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new wt(Ne.paint_raster["raster-brightness-min"]), "raster-brightness-max": new wt(Ne.paint_raster["raster-brightness-max"]), "raster-saturation": new wt(Ne.paint_raster["raster-saturation"]), "raster-contrast": new wt(Ne.paint_raster["raster-contrast"]), "raster-resampling": new wt(Ne.paint_raster["raster-resampling"]), "raster-fade-duration": new wt(Ne.paint_raster["raster-fade-duration"]), "raster-emissive-strength": new wt(Ne.paint_raster["raster-emissive-strength"]), "raster-array-band": new wt(Ne.paint_raster["raster-array-band"]), "raster-elevation": new wt(Ne.paint_raster["raster-elevation"]), "raster-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, i, c, h), this.updateColorRamp(), this._curRampRange = [NaN, NaN]; }
                getProgramIds() { return ["raster"]; }
                hasColorMap() { return !!this._transitionablePaint._values["raster-color"].value.value; }
                tileCoverLift() { return this.paint.get("raster-elevation"); }
                isDraped(e) { return !(e && e._source instanceof iR && (e._source.onNorthPole || e._source.onSouthPole)) && this.paint.get("raster-elevation") === 0; }
                _handleSpecialPaintPropertyUpdate(e) { e !== "raster-color" && e !== "raster-color-range" || (this._curRampRange = [NaN, NaN], this.updateColorRamp()); }
                updateColorRamp(e) { if (!this.hasColorMap() || !this._curRampRange)
                    return; const i = this._transitionablePaint._values["raster-color"].value.expression, [c, h] = e || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 }) || [NaN, NaN]; isNaN(c) && isNaN(h) || c === this._curRampRange[0] && h === this._curRampRange[1] || (this.colorRamp = V_({ expression: i, evaluationKey: "rasterValue", image: this.colorRamp, clips: [{ start: c, end: h }], resolution: 256 }), this.colorRampTexture = null, this._curRampRange = [c, h]); }
            }
            let oR, aR, lR, cR, uR;
            class hR extends Ds {
                constructor(e, i, c, h) { super(e, { layout: oR || (oR = new gi({ visibility: new wt(Ne["layout_raster-particle"].visibility) })), paint: aR || (aR = new gi({ "raster-particle-array-band": new wt(Ne["paint_raster-particle"]["raster-particle-array-band"]), "raster-particle-count": new wt(Ne["paint_raster-particle"]["raster-particle-count"]), "raster-particle-color": new Fc(Ne["paint_raster-particle"]["raster-particle-color"]), "raster-particle-max-speed": new wt(Ne["paint_raster-particle"]["raster-particle-max-speed"]), "raster-particle-speed-factor": new wt(Ne["paint_raster-particle"]["raster-particle-speed-factor"]), "raster-particle-fade-opacity-factor": new wt(Ne["paint_raster-particle"]["raster-particle-fade-opacity-factor"]), "raster-particle-reset-rate-factor": new wt(Ne["paint_raster-particle"]["raster-particle-reset-rate-factor"]), "raster-particle-elevation": new wt(Ne["paint_raster-particle"]["raster-particle-elevation"]), "raster-particle-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, i, c, h), this._updateColorRamp(), this.lastInvalidatedAt = Yo.now(); }
                onRemove(e) { this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy(); }
                hasColorMap() { return !!this._transitionablePaint._values["raster-particle-color"].value.value; }
                getProgramIds() { return ["rasterParticle"]; }
                hasOffscreenPass() { return this.visibility !== "none"; }
                isDraped(e) { return !1; }
                _handleSpecialPaintPropertyUpdate(e) { e !== "raster-particle-color" && e !== "raster-particle-max-speed" || (this._updateColorRamp(), this._invalidateAnimationState()), e === "raster-particle-count" && this._invalidateAnimationState(); }
                _updateColorRamp() { if (!this.hasColorMap())
                    return; const e = this._transitionablePaint._values["raster-particle-color"].value.expression, i = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({ zoom: 0 }); this.colorRamp = V_({ expression: e, evaluationKey: "rasterParticleSpeed", image: this.colorRamp, clips: [{ start: 0, end: i }], resolution: 256 }), this.colorRampTexture = null; }
                _invalidateAnimationState() { this.lastInvalidatedAt = Yo.now(); }
                tileCoverLift() { return this.paint.get("raster-particle-elevation"); }
            }
            class uV extends Ds {
                constructor(e, i) { super(e, {}, i, null), this.implementation = e, e.slot && (this.slot = e.slot); }
                is3D(e) { return this.implementation.renderingMode === "3d"; }
                hasOffscreenPass() { return this.implementation.prerender !== void 0; }
                isDraped(e) { return this.implementation.renderToTile !== void 0; }
                shouldRedrape() { return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles(); }
                recalculate() { }
                updateTransitions() { }
                hasTransition() { return !1; }
                serialize() { }
                onAdd(e) { this.implementation.onAdd && this.implementation.onAdd(e, e.painter.context.gl); }
                onRemove(e) { this.implementation.onRemove && this.implementation.onRemove(e, e.painter.context.gl); }
            }
            function yS(a, e, i) { const c = [0, 0, 1], h = Ko([]); return _t(h, h, i ? -Z(a) + Math.PI : Z(a)), Ue(h, h, -Z(e)), js(c, c, h), an(c, c); }
            function dR(a, e) { const i = Zx(a.projection, a.zoom, a.width, a.height), c = function (p, m, x, b, S) { const A = new W(x.lng - 180 * nh, x.lat), I = new W(x.lng + 180 * nh, x.lat), M = p.project(A.lng, A.lat), z = p.project(I.lng, I.lat), F = -Math.atan2(z.y - M.y, z.x - M.x), U = Ve.fromLngLat(x); U.y = ke(U.y, -1 + nh, 1 - nh); const X = U.toLngLat(), Y = p.project(X.lng, X.lat), le = Ve.fromLngLat(X); le.x += nh; const se = le.toLngLat(), $ = p.project(se.lng, se.lat), te = pR($.x - Y.x, $.y - Y.y, F), ae = Ve.fromLngLat(X); ae.y += nh; const fe = ae.toLngLat(), Te = p.project(fe.lng, fe.lat), Pe = pR(Te.x - Y.x, Te.y - Y.y, F), Me = Math.abs(te.x) / Math.abs(Pe.y), Oe = J([]); Be(Oe, Oe, -F * (1 - (S ? 0 : b))); const Ye = J([]); return ue(Ye, Ye, [1, 1 - (1 - Me) * b, 1]), Ye[4] = -Pe.x / Pe.y * b, Be(Ye, Ye, F), ie(Ye, Oe, Ye), Ye; }(a.projection, 0, a.center, i, e), h = fR(a); return ue(c, c, [h, h, 1]), c; }
            function fR(a) { const e = a.projection, i = Zx(a.projection, a.zoom, a.width, a.height), c = vS(e, a.center), h = vS(e, W.convert(e.center)); return Math.pow(2, c * i + (1 - i) * h); }
            function Zx(a, e, i, c, h = 1 / 0) { const p = a.range; if (!p)
                return 0; const m = Math.min(h, Math.max(i, c)), x = Math.log(m / 1024) / Math.LN2; return De(p[0] + x, p[1] + x, e); }
            const nh = 1 / 4e4;
            function vS(a, e) { const i = ke(e.lat, -ze, ze), c = new W(e.lng - 180 * nh, i), h = new W(e.lng + 180 * nh, i), p = a.project(c.lng, i), m = a.project(h.lng, i), x = Ve.fromLngLat(c), b = Ve.fromLngLat(h), S = m.x - p.x, A = m.y - p.y, I = b.x - x.x, M = b.y - x.y, z = Math.sqrt((I * I + M * M) / (S * S + A * A)); return Math.log(z) / Math.LN2; }
            function pR(a, e, i) { const c = Math.cos(i), h = Math.sin(i); return { x: a * c - e * h, y: a * h + e * c }; }
            function mR(a, e, i) { J(a), Be(a, a, Z(e[2])), be(a, a, Z(e[0])), Ie(a, a, Z(e[1])), ue(a, a, i), ie(a, a, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]); }
            function Xx(a, e, i, c, h, p, m, x) { const b = [i[0] - e[0], i[1] - e[1], 0], S = [c[0] - e[0], c[1] - e[1], 0]; if (Kt(b) < 1e-12 || Kt(S) < 1e-12)
                return Ko(a); const A = mn([], b, S); an(A, A), tr(S, c, e), b[2] = (p - h) * x, S[2] = (m - h) * x; const I = b; return mn(I, b, S), an(I, I), mi(a, A, I); }
            function xS(a, e, i = !1) { const c = Ku(e.zoom), h = function (p, m, x) { const b = m.worldSize, S = [p[12], p[13], p[14]], A = Ce(S[1] / b), I = Se(S[0] / b), M = J([]), z = ge(1, A) * b, F = ge(1, 0) * b * et(A, m.zoom), U = 1 / IT(b); let X = F * U; if (x) {
                const $ = Zx(m.projection, m.zoom, m.width, m.height, 1024);
                X = U * m.projection.pixelSpaceConversion(m.center.lat, b, $);
            } const Y = q(A, I); ir(Y, Y, Ft([], an([], Y), z * X * S[2])); const le = function ($) { const te = [$[0], $[1], $[2]]; let ae = [0, 1, 0]; const fe = mn([], ae, te); return mn(ae, te, fe), pi(ae) === 0 && (ae = [0, 1, 0], mn(fe, te, ae)), an(fe, fe), an(ae, ae), an(te, te), [fe[0], fe[1], fe[2], 0, ae[0], ae[1], ae[2], 0, te[0], te[1], te[2], 0, $[0], $[1], $[2], 1]; }(Y); ue(M, M, [X, X, X * z]), Q(M, M, [-S[0], -S[1], -S[2]]); const se = ie([], m.globeMatrix, le); return ie(se, se, M), ie(se, se, p), se; }(a, e, i); if (c > 0) {
                const p = function (m, x) { const b = x.worldSize, S = ge(1, 0) * b * et(x.center.lat, x.zoom) / IT(b), A = ge(1, x.center.lat) * b, I = J([]); return Ie(I, I, Z(x.center.lng)), be(I, I, Z(x.center.lat)), Q(I, I, [0, 0, v]), ue(I, I, [S, S, S * A]), Q(I, I, [x.point.x - .5 * b, x.point.y - .5 * b, 0]), ie(I, I, m), ie(I, x.globeMatrix, I); }(a, e);
                return function (m, x, b) { const S = (F, U, X) => { const Y = Kt(F), le = Kt(U), se = Gc(F, U, X); return Ft(se, se, 1 / Kt(se) * nr(Y, le, X)); }, A = S([m[0], m[1], m[2]], [x[0], x[1], x[2]], b), I = S([m[4], m[5], m[6]], [x[4], x[5], x[6]], b), M = S([m[8], m[9], m[10]], [x[8], x[9], x[10]], b), z = Gc([m[12], m[13], m[14]], [x[12], x[13], x[14]], b); return [A[0], A[1], A[2], 0, I[0], I[1], I[2], 0, M[0], M[1], M[2], 0, z[0], z[1], z[2], 1]; }(h, p, c);
            } return h; }
            function gR(a, e, i, c) { const h = Wn.projectAabbCorners(c, i); let p = Number.MAX_VALUE, m = -1; for (let S = 0; S < h.length; ++S) {
                const A = h[S];
                A[0] = (.5 * A[0] + .5) * e.width, A[1] = (.5 - .5 * A[1]) * e.height, A[2] < p && (m = S, p = A[2]);
            } const x = S => new Et(h[S][0], h[S][1]); let b; switch (m) {
                case 0:
                case 6:
                    b = [x(1), x(5), x(4), x(7), x(3), x(2), x(1)];
                    break;
                case 1:
                case 7:
                    b = [x(0), x(4), x(5), x(6), x(2), x(3), x(0)];
                    break;
                case 3:
                case 5:
                    b = [x(1), x(0), x(4), x(7), x(6), x(2), x(1)];
                    break;
                default: b = [x(1), x(5), x(6), x(7), x(3), x(0), x(1)];
            } if (or(a, b))
                return p; }
            const hV = tn([{ name: "a_pos_3f", components: 3, type: "Float32" }]), dV = tn([{ name: "a_color_3f", components: 3, type: "Float32" }]), fV = tn([{ name: "a_color_4f", components: 4, type: "Float32" }]), pV = tn([{ name: "a_uv_2f", components: 2, type: "Float32" }]), mV = tn([{ name: "a_normal_3f", components: 3, type: "Float32" }]), gV = tn([{ name: "a_normal_matrix0", components: 4, type: "Float32" }, { name: "a_normal_matrix1", components: 4, type: "Float32" }, { name: "a_normal_matrix2", components: 4, type: "Float32" }, { name: "a_normal_matrix3", components: 4, type: "Float32" }]), _V = tn([{ name: "a_pbr", components: 4, type: "Uint16" }, { name: "a_heightBasedEmissiveStrength", components: 3, type: "Float32" }]), _R = { None: 0, Model: 1, Symbol: 2, FillExtrusion: 4, All: 7 };
            class Kx {
                constructor(e, i, c, h) { this.message = (e ? `${e}: ` : "") + c, h && (this.identifier = h), i != null && i.__line__ && (this.line = i.__line__); }
            }
            function wS(a, e) { const i = a.indexOf("://") === -1; try {
                return new URL(a, i && e ? "http://example.com" : void 0), !0;
            }
            catch {
                return !1;
            } }
            class yR {
                constructor(e, i) { this.feature = e, this.instancedDataOffset = i, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0]; }
            }
            class vR {
                constructor() { this.instancedDataArray = new Gu, this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {}; }
            }
            class bS {
                constructor(e) { this.zoom = e.zoom, this.canonical = e.canonical, this.layers = e.layers, this.layerIds = this.layers.map(i => i.fqid), this.projection = e.projection, this.index = e.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id), this.hasPattern = !1, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = { id: null, timestamp: 0 }, this.modelUris = [], this.modelsRequested = !1, this.activeReplacements = [], this.replacementUpdateTime = 0, this.styleDefinedModelURLs = e.styleDefinedModelURLs; }
                updateFootprints(e, i) { }
                populate(e, i, c, h) { this.tileToMeter = Fe(c); const p = this.layers[0]._featureFilter.needGeometry; this.lookup = new Uint8Array(this.lookupDim * this.lookupDim); for (const { feature: m, id: x, index: b, sourceLayerIndex: S } of e) {
                    const A = x ?? (m.properties && m.properties.hasOwnProperty("id") ? m.properties.id : void 0), I = Xt(m, p);
                    if (!this.layers[0]._featureFilter.filter(new yn(this.zoom), I, c))
                        continue;
                    const M = { id: A, sourceLayerIndex: S, index: b, geometry: p ? I.geometry : Vt(m, c, h), properties: m.properties, type: m.type, patterns: {} }, z = this.addFeature(M, M.geometry, I);
                    z && i.featureIndex.insert(m, M.geometry, b, S, this.index, this.instancesPerModel[z].instancedDataArray.length, It / 32);
                } this.lookup = null; }
                update(e, i, c, h) { for (const p in this.instancesPerModel) {
                    const m = this.instancesPerModel[p];
                    for (const x in e)
                        m.idToFeaturesIndex.hasOwnProperty(x) && (this.evaluate(m.features[m.idToFeaturesIndex[x]], e[x], m, !0), this.uploaded = !1);
                } this.maxHeight = 0; }
                updateZoomBasedPaintProperties() { if (!this.hasZoomDependentProperties)
                    return !1; let e = !1; for (const i in this.instancesPerModel) {
                    const c = this.instancesPerModel[i];
                    for (const h of c.features) {
                        const p = this.layers[0], m = h.feature, x = this.canonical, b = p.paint.get("model-rotation").evaluate(m, {}, x), S = p.paint.get("model-scale").evaluate(m, {}, x), A = p.paint.get("model-translation").evaluate(m, {}, x);
                        ss(h.rotation, b) && ss(h.scale, S) && ss(h.translation, A) || (this.evaluate(h, h.featureStates, c, !0), e = !0);
                    }
                } return e; }
                updateReplacement(e, i, c, h) { if (i.updateTime === this.replacementUpdateTime)
                    return !1; this.replacementUpdateTime = i.updateTime; const p = i.getReplacementRegionsForTile(e.toUnwrapped(), !0); if (qT(this.activeReplacements, p))
                    return !1; this.activeReplacements = p; let m = !1; for (const x in this.instancesPerModel) {
                    const b = this.instancesPerModel[x], S = b.instancedDataArray;
                    for (const A of b.features) {
                        const I = A.instancedDataOffset, M = A.instancedDataCount;
                        for (let z = 0; z < M; z++) {
                            const F = 16 * (z + I);
                            let U = S.float32[F + 0];
                            const X = U > It;
                            U = X ? U - It : U;
                            const Y = Math.floor(U), le = S.float32[F + 1];
                            let se = !1;
                            for (const $ of this.activeReplacements)
                                if (!TP($, c, _R.Model, h) && !($.min.x > Y || Y > $.max.x || $.min.y > le || le > $.max.y) && (se = PP(IP(Y, le, e.canonical, $.footprintTileId.canonical), $.footprint), se))
                                    break;
                            S.float32[F] = se ? U + It : U, m = m || se !== X;
                        }
                    }
                } return m; }
                isEmpty() { for (const e in this.instancesPerModel)
                    if (this.instancesPerModel[e].instancedDataArray.length !== 0)
                        return !1; return !0; }
                uploadPending() { return !this.uploaded; }
                upload(e) { if (!this.uploaded)
                    for (const i in this.instancesPerModel) {
                        const c = this.instancesPerModel[i];
                        c.instancedDataArray.length < 0 || c.instancedDataArray.length === 0 || (c.instancedDataBuffer ? c.instancedDataBuffer.updateData(c.instancedDataArray) : c.instancedDataBuffer = e.createVertexBuffer(c.instancedDataArray, gV.members, !0, void 0, this.instanceCount));
                    } this.uploaded = !0; }
                destroy() { for (const i in this.instancesPerModel) {
                    const c = this.instancesPerModel[i];
                    c.instancedDataArray.length !== 0 && c.instancedDataBuffer && c.instancedDataBuffer.destroy();
                } const e = this.layers[0].modelManager; if (e && this.modelUris && this.modelsRequested)
                    for (const i of this.modelUris)
                        e.removeModel(i, "", !0); }
                addFeature(e, i, c) { const h = this.layers[0], p = h.layout.get("model-id").evaluate(c, {}, this.canonical); if (!p)
                    return Br(`modelId is not evaluated for layer ${h.id} and it is not going to get rendered.`), p; (wS(p, !1) || this.styleDefinedModelURLs[p] !== void 0) && (this.modelUris.includes(p) || this.modelUris.push(p)), this.instancesPerModel[p] || (this.instancesPerModel[p] = new vR); const m = this.instancesPerModel[p], x = m.instancedDataArray, b = new yR(c, x.length); for (const S of i)
                    for (const A of S) {
                        if (A.x < 0 || A.x >= It || A.y < 0 || A.y >= It)
                            continue;
                        const I = (this.lookupDim - 1) / It, M = this.lookupDim * (A.y * I | 0) + A.x * I | 0;
                        if (this.lookup) {
                            if (this.lookup[M] !== 0)
                                continue;
                            this.lookup[M] = 1;
                        }
                        this.instanceCount++;
                        const z = x.length;
                        x.resize(z + 1), m.instancesEvaluatedElevation.push(0), x.float32[16 * z] = A.x, x.float32[16 * z + 1] = A.y;
                    } return b.instancedDataCount = m.instancedDataArray.length - b.instancedDataOffset, b.instancedDataCount > 0 && (e.id && (m.idToFeaturesIndex[e.id] = m.features.length), m.features.push(b), this.evaluate(b, {}, m, !1)), p; }
                getModelUris() { return this.modelUris; }
                evaluate(e, i, c, h) { const p = this.layers[0], m = e.feature, x = this.canonical, b = e.rotation = p.paint.get("model-rotation").evaluate(m, i, x), S = e.scale = p.paint.get("model-scale").evaluate(m, i, x), A = e.translation = p.paint.get("model-translation").evaluate(m, i, x), I = p.paint.get("model-color").evaluate(m, i, x); I.a = p.paint.get("model-color-mix-intensity").evaluate(m, i, x); const M = []; this.maxVerticalOffset < A[2] && (this.maxVerticalOffset = A[2]), this.maxScale = Math.max(Math.max(this.maxScale, S[0]), Math.max(S[1], S[2])), mR(M, b, S); const z = Math.round(100 * I.a) + I.b / 1.05; for (let F = 0; F < e.instancedDataCount; ++F) {
                    const U = e.instancedDataOffset + F, X = 16 * U, Y = c.instancedDataArray.float32;
                    let le = 0;
                    h && (le = Y[X + 6] - c.instancesEvaluatedElevation[U]);
                    const se = 0 | Y[X + 1];
                    Y[X] = (0 | Y[X]) + I.r / 1.05, Y[X + 1] = se + I.g / 1.05, Y[X + 2] = z, Y[X + 3] = 1 / (x.z > 10 ? this.tileToMeter : Fe(x, se)), Y[X + 4] = A[0], Y[X + 5] = A[1], Y[X + 6] = A[2] + le, Y[X + 7] = M[0], Y[X + 8] = M[1], Y[X + 9] = M[2], Y[X + 10] = M[4], Y[X + 11] = M[5], Y[X + 12] = M[6], Y[X + 13] = M[8], Y[X + 14] = M[9], Y[X + 15] = M[10], c.instancesEvaluatedElevation[U] = A[2];
                } }
            }
            let xR, wR;
            Nt(bS, "ModelBucket", { omit: ["layers"] }), Nt(vR, "PerModelAttributes"), Nt(yR, "ModelFeature");
            const Jd = 64, em = { CoordinateSpaceTile: 1, CoordinateSpaceYUp: 2, HasMapboxMeshFeatures: 4, HasMeshoptCompression: 8 };
            function bR(a, e, i, c, h, p, m, x, b, S = !1) { const A = i.zoom, I = i.project(c), M = et(c.lat, A), z = 1 / M; J(a), Q(a, a, [I.x + m[0] * z, I.y + m[1] * z, m[2]]); let F = 1, U = 1; const X = i.worldSize; if (S) {
                if (i.projection.name === "mercator") {
                    let $ = 0;
                    i.elevation && ($ = i.elevation.getAtPointOrZero(new Ve(I.x / X, I.y / X), 0));
                    const te = Gi([], [I.x, I.y, $, 1], i.projMatrix)[3] / i.cameraToCenterDistance;
                    F = te, U = te * et(i.center.lat, A);
                }
                else if (i.projection.name === "globe") {
                    const $ = xS(a, i), te = [0, 0, 0, 1];
                    Gi(te, te, ie([], i.projMatrix, $));
                    const ae = te[3] / i.cameraToCenterDistance, fe = Ku(A), Te = i.projection.pixelsPerMeter(c.lat, X) * et(c.lat, A), Pe = i.projection.pixelsPerMeter(i.center.lat, X) * et(i.center.lat, A);
                    F = ae / nr(Te, rt(i.center.lat), fe), U = ae * M / Te, F *= Pe, U *= Pe;
                }
            }
            else
                F = z; ue(a, a, [F, F, U]); const Y = [...a], le = e.orientation, se = []; if (mR(se, [le[0] + h[0], le[1] + h[1], le[2] + h[2]], p), ie(a, Y, se), x && i.elevation) {
                let $ = 0;
                const te = [];
                if (b && i.elevation) {
                    $ = function (fe, Te, Pe, Me, Oe) { const Ye = Te.elevation; if (!Ye)
                        return 0; const ut = Wn.projectAabbCorners(Pe, Me), it = ge(1, Oe.lat) * Te.worldSize, lt = function (mt, pr) { const Gt = [0, 0, 1], qt = [{ corners: [0, 1, 3, 2], dotProductWithUp: 0 }, { corners: [1, 5, 2, 6], dotProductWithUp: 0 }, { corners: [0, 4, 1, 5], dotProductWithUp: 0 }, { corners: [2, 6, 3, 7], dotProductWithUp: 0 }, { corners: [4, 7, 5, 6], dotProductWithUp: 0 }, { corners: [0, 3, 4, 7], dotProductWithUp: 0 }]; for (const hr of qt) {
                        const wr = mt[hr.corners[0]], Tr = mt[hr.corners[1]], Lr = mt[hr.corners[2]], Pr = [Tr[0] - wr[0], Tr[1] - wr[1], pr * (Tr[2] - wr[2])], Ar = mn(Pr, Pr, [Lr[0] - wr[0], Lr[1] - wr[1], pr * (Lr[2] - wr[2])]);
                        an(Ar, Ar), hr.dotProductWithUp = Kr(Ar, Gt);
                    } return qt.sort((hr, wr) => hr.dotProductWithUp - wr.dotProductWithUp), qt[0].corners; }(ut, it), pt = ut[lt[0]], We = ut[lt[1]], at = ut[lt[2]], Ge = ut[lt[3]], Xe = Ye.getAtPointOrZero(new Ve(pt[0] / Te.worldSize, pt[1] / Te.worldSize), 0), gt = Ye.getAtPointOrZero(new Ve(We[0] / Te.worldSize, We[1] / Te.worldSize), 0), yt = Ye.getAtPointOrZero(new Ve(at[0] / Te.worldSize, at[1] / Te.worldSize), 0), Zt = Ye.getAtPointOrZero(new Ve(Ge[0] / Te.worldSize, Ge[1] / Te.worldSize), 0), jt = (Xe + Zt) / 2, Rt = (gt + yt) / 2; return jt > Rt ? gt < yt ? Xx(fe, We, Ge, pt, gt, Zt, Xe, it) : Xx(fe, at, pt, Ge, yt, Xe, Zt, it) : Xe < Zt ? Xx(fe, pt, We, at, Xe, gt, yt, it) : Xx(fe, Ge, at, We, Zt, yt, gt, it), Math.max(jt, Rt); }(te, i, e.aabb, a, c);
                    const ae = ie([], At([], te), se);
                    ie(a, Y, ae);
                }
                else
                    $ = i.elevation.getAtPointOrZero(new Ve(I.x / X, I.y / X), 0);
                $ !== 0 && (a[14] += $);
            } }
            function cy(a, e, i = !1) { a.uploaded || (a.gfxTexture = new _S(e, a.image, i ? e.gl.R8 : e.gl.RGBA8, { useMipmap: a.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST }), a.uploaded = !0, a.image = null); }
            function yV(a, e, i) { a.indexBuffer = e.createIndexBuffer(a.indexArray, !1, !0), a.vertexBuffer = e.createVertexBuffer(a.vertexArray, hV.members, !1, !0), a.normalArray && (a.normalBuffer = e.createVertexBuffer(a.normalArray, mV.members, !1, !0)), a.texcoordArray && (a.texcoordBuffer = e.createVertexBuffer(a.texcoordArray, pV.members, !1, !0)), a.colorArray && (a.colorBuffer = e.createVertexBuffer(a.colorArray, (a.colorArray.bytesPerElement === 12 ? dV : fV).members, !1, !0)), a.featureArray && (a.pbrBuffer = e.createVertexBuffer(a.featureArray, _V.members, !0)), a.segments = ti.simpleSegment(0, 0, a.vertexArray.length, a.indexArray.length); const c = a.material; c.pbrMetallicRoughness.baseColorTexture && cy(c.pbrMetallicRoughness.baseColorTexture, e), c.pbrMetallicRoughness.metallicRoughnessTexture && cy(c.pbrMetallicRoughness.metallicRoughnessTexture, e), c.normalTexture && cy(c.normalTexture, e), c.occlusionTexture && cy(c.occlusionTexture, e, i), c.emissionTexture && cy(c.emissionTexture, e); }
            function TS(a, e, i) { if (a.meshes)
                for (const c of a.meshes)
                    yV(c, e, i); if (a.children)
                for (const c of a.children)
                    TS(c, e, i); }
            function Yx(a) { if (a.meshes)
                for (const e of a.meshes)
                    e.indexArray.destroy(), e.vertexArray.destroy(), e.colorArray && e.colorArray.destroy(), e.normalArray && e.normalArray.destroy(), e.texcoordArray && e.texcoordArray.destroy(), e.featureArray && e.featureArray.destroy(); if (a.children)
                for (const e of a.children)
                    Yx(e); }
            function SS(a) { if (a.meshes)
                for (const i of a.meshes)
                    i.vertexBuffer && (i.vertexBuffer.destroy(), i.indexBuffer.destroy(), i.normalBuffer && i.normalBuffer.destroy(), i.texcoordBuffer && i.texcoordBuffer.destroy(), i.colorBuffer && i.colorBuffer.destroy(), i.pbrBuffer && i.pbrBuffer.destroy(), i.segments.destroy(), i.material && ((e = i.material).pbrMetallicRoughness.baseColorTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e.pbrMetallicRoughness.metallicRoughnessTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e.normalTexture && e.normalTexture.gfxTexture && e.normalTexture.gfxTexture.destroy(), e.emissionTexture && e.emissionTexture.gfxTexture && e.emissionTexture.gfxTexture.destroy(), e.occlusionTexture && e.occlusionTexture.gfxTexture && e.occlusionTexture.gfxTexture.destroy())); var e; if (a.children)
                for (const i of a.children)
                    SS(i); }
            class tm {
                constructor(e, i, c) { this._demTile = e, this._dem = this._demTile.dem, this._scale = i, this._offset = c; }
                static create(e, i, c) { const h = c || e.findDEMTileFor(i); if (!h || !h.dem)
                    return; const p = h.dem, m = h.tileID, x = 1 << i.canonical.z - m.canonical.z; return new tm(h, p.dim / It / x, [(i.canonical.x / x - m.canonical.x) * p.dim, (i.canonical.y / x - m.canonical.y) * p.dim]); }
                tileCoordToPixel(e, i) { const c = i * this._scale + this._offset[1], h = Math.floor(e * this._scale + this._offset[0]), p = Math.floor(c); return new Et(h, p); }
                getElevationAt(e, i, c, h) { const p = e * this._scale + this._offset[0], m = i * this._scale + this._offset[1], x = Math.floor(p), b = Math.floor(m), S = this._dem; return h = !!h, c ? nr(nr(S.get(x, b, h), S.get(x, b + 1, h), m - b), nr(S.get(x + 1, b, h), S.get(x + 1, b + 1, h), m - b), p - x) : S.get(x, b, h); }
                getElevationAtPixel(e, i, c) { return this._dem.get(e, i, !!c); }
                getMeterToDEM(e) { return (1 << this._demTile.tileID.canonical.z) * ge(1, e) * this._dem.stride; }
            }
            const ES = new Float32Array(262144), ef = new Uint8Array(262144);
            function TR(a) { let e = 0; if (a.meshes)
                for (const i of a.meshes)
                    e = Math.max(e, i.aabb.max[2]); if (a.children)
                for (const i of a.children)
                    e = Math.max(e, TR(i)); return e; }
            function SR(a, e, i) { if (a.meshes)
                for (const c of a.meshes) {
                    if (c.aabb.min[0] === 1 / 0)
                        continue;
                    const h = Wn.applyTransform(c.aabb, a.matrix);
                    i.insert(e, h.min[0], h.min[1], h.max[0], h.max[1]);
                } if (a.children)
                for (const c of a.children)
                    SR(c, e, i); }
            const ER = ["", "wall", "door", "roof", "window", "lamp", "logo"];
            class CR {
                constructor(e) { this.node = e, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = !1, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = { type: "Point", id: e.id, geometry: [], properties: { height: TR(e) } }, this.aabb = this._getLocalBounds(), this.state = null; }
                _getLocalBounds() { if (!this.node.meshes)
                    return new Wn([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]); if (!this.aabb) {
                    let e = 0;
                    const i = new Wn([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
                    for (const c of this.node.meshes)
                        this.node.lightMeshIndex !== e && (c.transformedAabb = Wn.applyTransformFast(c.aabb, this.node.matrix), i.encapsulate(c.transformedAabb)), e++;
                    this.aabb = i;
                } return this.aabb; }
            }
            class Qx {
                constructor(e, i, c, h, p, m, x) { this.id = c, this.layers = e, this.layerIds = this.layers.map(b => b.fqid), this.stateDependentLayerIds = this.layers.filter(b => b.isStateDependent()).map(b => b.id), this.modelTraits |= em.CoordinateSpaceTile, this.uploaded = !1, this.hasPattern = !1, h && (this.modelTraits |= em.HasMapboxMeshFeatures), p && (this.modelTraits |= em.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = m, this.dirty = !0, this.needsUpload = !1, this.filter = null, this.nodesInfo = []; for (const b of i)
                    this.nodesInfo.push(new CR(b)), SR(b, x.featureIndexArray.length, x.grid), x.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, x.bucketLayerIDs.length - 1, 0); this.states = {}; }
                updateFootprints(e, i) { for (const c of this.getNodesInfo()) {
                    const h = c.node;
                    h.footprint && i.push({ footprint: h.footprint, id: e });
                } }
                update(e) { const i = Object.keys(e).length !== 0; if (i && !this.stateDependentLayers.length)
                    return; const c = i ? this.stateDependentLayers : this.layers; if (!qa(e, this.states))
                    for (const h of c)
                        this.evaluate(h, e); this.states = structuredClone(e); }
                populate() { console.log("populate 3D model bucket"); }
                uploadPending() { return !this.uploaded || this.needsUpload; }
                upload(e) { if (!this.needsUpload)
                    return; const i = this.getNodesInfo(); for (const c of i) {
                    const h = c.node;
                    this.uploaded ? this.updatePbrBuffer(h) : TS(h, e, !0);
                } for (const c of i)
                    Yx(c.node); this.uploaded = !0, this.needsUpload = !1; }
                updatePbrBuffer(e) { let i = !1; if (!e.meshes)
                    return i; for (const c of e.meshes)
                    c.pbrBuffer && (c.pbrBuffer.updateData(c.featureArray), i = !0); return i; }
                needsReEvaluation(e, i, c) { const h = e.transform.projectionOptions, p = e.style.getBrightness(), m = this.brightness !== p; if (!this.uploaded || this.dirty || h.name !== this.projection.name || uy(c.paint.get("model-color").value, m) || uy(c.paint.get("model-color-mix-intensity").value, m) || uy(c.paint.get("model-roughness").value, m) || uy(c.paint.get("model-emissive-strength").value, m) || uy(c.paint.get("model-height-based-emissive-strength-multiplier").value, m)) {
                    this.projection = h, this.brightness = p;
                    const x = this.getNodesInfo();
                    for (const b of x)
                        b.state = null;
                    return !0;
                } return !1; }
                evaluateScale(e, i) { if (e.transform.zoom === this.zoom)
                    return; this.zoom = e.transform.zoom; const c = this.getNodesInfo(), h = this.id.canonical; for (const p of c) {
                    const m = p.feature;
                    p.evaluatedScale = i.paint.get("model-scale").evaluate(m, {}, h);
                } }
                evaluate(e, i) { const c = this.getNodesInfo(); for (const h of c) {
                    if (!h.node.meshes)
                        continue;
                    const p = h.feature, m = i && i[p.id];
                    if (qa(m, h.state))
                        continue;
                    h.state = structuredClone(m);
                    const x = h.node.meshes && h.node.meshes[0].featureData, b = h.evaluatedColor[2], S = h.evaluatedRMEA[2], A = this.id.canonical;
                    if (h.hasTranslucentParts = !1, x) {
                        for (let I = 0; I < ER.length; I++) {
                            const M = ER[I];
                            M.length && (p.properties.part = M);
                            const z = e.paint.get("model-color").evaluate(p, m, A).toRenderColor(null), F = e.paint.get("model-color-mix-intensity").evaluate(p, m, A);
                            h.evaluatedColor[I] = [z.r, z.g, z.b, F], h.evaluatedRMEA[I][0] = e.paint.get("model-roughness").evaluate(p, m, A), h.evaluatedRMEA[I][2] = e.paint.get("model-emissive-strength").evaluate(p, m, A), h.evaluatedRMEA[I][3] = z.a, h.emissionHeightBasedParams[I] = e.paint.get("model-height-based-emissive-strength-multiplier").evaluate(p, m, A), !h.hasTranslucentParts && z.a < 1 && (h.hasTranslucentParts = !0);
                        }
                        delete p.properties.part, xV(h, b !== h.evaluatedColor[2] || S !== h.evaluatedRMEA[2], this.modelTraits);
                    }
                    else
                        h.evaluatedRMEA[0][2] = e.paint.get("model-emissive-strength").evaluate(p, m, A);
                    h.evaluatedScale = e.paint.get("model-scale").evaluate(p, m, A), this.updatePbrBuffer(h.node) || (this.needsUpload = !0);
                } this.dirty = !1; }
                elevationUpdate(e, i, c, h) { const p = e.findDEMTileFor(c); if (p && (p.tileID.canonical !== this.terrainTile || i !== this.terrainExaggeration)) {
                    if (p.dem && p.tileID.overscaledZ !== this.elevationReadFromZ) {
                        this.elevationReadFromZ = p.tileID.overscaledZ;
                        const m = tm.create(e, c, p);
                        if (!m)
                            return;
                        this.modelTraits & em.HasMapboxMeshFeatures && this.updateDEM(e, m, c, h);
                        for (const x of this.getNodesInfo()) {
                            const b = x.node;
                            if (!b.footprint || !b.footprint.vertices || !b.footprint.vertices.length)
                                continue;
                            const S = b.footprint.vertices;
                            let A = m.getElevationAt(S[0].x, S[0].y, !0, !0);
                            for (let I = 1; I < S.length; I++)
                                A = Math.min(A, m.getElevationAt(S[I].x, S[I].y, !0, !0));
                            b.elevation = A;
                        }
                    }
                    this.terrainTile = p.tileID.canonical, this.terrainExaggeration = i;
                } }
                updateDEM(e, i, c, h) { let p = i._dem._modifiedForSources[h]; if (p === void 0 && (i._dem._modifiedForSources[h] = [], p = i._dem._modifiedForSources[h]), p.includes(c.canonical))
                    return; const m = i._dem.dim; p.push(c.canonical); let x = !1; for (const b of this.getNodesInfo()) {
                    const S = b.node;
                    if (!S.footprint || !S.footprint.grid)
                        continue;
                    const A = S.footprint.grid, I = i.tileCoordToPixel(A.min.x, A.min.y), M = i.tileCoordToPixel(A.max.x, A.max.y), z = Math.min(Math.min(m - M.y, I.x), Math.min(I.y, m - M.x));
                    if (z < 0)
                        continue;
                    const F = ke(z, 2, 5);
                    let U = Math.max(0, I.x - F), X = Math.max(0, I.y - F), Y = Math.min(M.x + F, m - 1), le = Math.min(M.y + F, m - 1);
                    for (let ae = X; ae <= le; ++ae)
                        for (let fe = U; fe <= Y; ++fe)
                            ef[ae * m + fe] = 255;
                    let se = 0, $ = 0;
                    for (let ae = 0; ae < A.cellsY; ++ae)
                        for (let fe = 0; fe < A.cellsX; ++fe) {
                            if (!A.cells[ae * A.cellsX + fe])
                                continue;
                            const Te = i.tileCoordToPixel(A.min.x + fe / A.xScale, A.min.y + ae / A.yScale), Pe = i.tileCoordToPixel(A.min.x + (fe + 1) / A.xScale, A.min.y + (ae + 1) / A.yScale);
                            for (let Me = Te.y; Me <= Math.min(Pe.y + 1, m - 1); ++Me)
                                for (let Oe = Te.x; Oe <= Math.min(Pe.x + 1, m - 1); ++Oe)
                                    ef[Me * m + Oe] === 255 && (ef[Me * m + Oe] = 0, se += i.getElevationAtPixel(Oe, Me), $++);
                        }
                    const te = se / $;
                    U = Math.max(1, I.x - F), X = Math.max(1, I.y - F), Y = Math.min(M.x + F, m - 2), le = Math.min(M.y + F, m - 2), x = !0;
                    for (let ae = X; ae <= le; ++ae)
                        for (let fe = U; fe <= Y; ++fe)
                            ef[ae * m + fe] === 0 && (ES[ae * m + fe] = i._dem.set(fe, ae, te));
                    for (let ae = 1; ae < F; ++ae) {
                        U = Math.max(1, I.x - ae), X = Math.max(1, I.y - ae), Y = Math.min(M.x + ae, m - 2), le = Math.min(M.y + ae, m - 2);
                        for (let fe = X; fe <= le; ++fe)
                            for (let Te = U; Te <= Y; ++Te) {
                                const Pe = fe * m + Te;
                                if (ef[Pe] === 255) {
                                    let Me = 0, Oe = 0, Ye = -1, ut = -1;
                                    for (let it = -1; it <= 1; ++it)
                                        for (let lt = -1; lt <= 1; ++lt) {
                                            const pt = (fe + it) * m + Te + lt;
                                            if (ef[pt] >= ae)
                                                continue;
                                            const We = ES[pt], at = Math.abs(We);
                                            at > Oe && (Me = We, Oe = at, Ye = lt, ut = it);
                                        }
                                    if (Oe > .1) {
                                        const it = 1 - (ae + .5 * Math.abs(Ye * ut)) / F;
                                        let lt = i._dem.get(Te, fe) + Me * it;
                                        const pt = i._dem.get(Te + Ye, fe + ut), We = i._dem.get(Te - Ye, fe - ut, !0);
                                        (lt - pt) * (lt - We) > 0 && (lt = (pt + We) / 2), ES[Pe] = i._dem.set(Te, fe, lt), ef[Pe] = ae;
                                    }
                                }
                            }
                    }
                } x && (i._demTile.needsDEMTextureUpload = !0, i._dem._timestamp = Yo.now()); }
                setFilter(e) { this.filter = e ? b_(e) : null; }
                getNodesInfo() { return this.filter ? this.nodesInfo.filter(e => this.filter.filter(new yn(this.id.overscaledZ), e.feature, this.id.canonical)) : this.nodesInfo; }
                destroy() { const e = this.getNodesInfo(); for (const i of e)
                    Yx(i.node), SS(i.node); }
                isEmpty() { return !this.nodesInfo.length; }
                updateReplacement(e, i) { if (i.updateTime === this.replacementUpdateTime)
                    return; this.replacementUpdateTime = i.updateTime; const c = i.getReplacementRegionsForTile(e.toUnwrapped()), h = this.getNodesInfo(); for (let p = 0; p < this.nodesInfo.length; p++) {
                    const m = h[p].node;
                    h[p].hiddenByReplacement = !!m.footprint && !c.find(x => x.footprint === m.footprint);
                } }
                getHeightAtTileCoord(e, i) { const c = this.getNodesInfo(), h = [], p = [0, 0, 0], m = J([]); for (let x = 0; x < this.nodesInfo.length; x++) {
                    const b = c[x], S = b.node.meshes[0], A = S.transformedAabb;
                    if (e < A.min[0] || i < A.min[1] || e > A.max[0] || i > A.max[1])
                        continue;
                    if (b.node.hidden === !0)
                        return { height: 1 / 0, maxHeight: b.feature.properties.height, hidden: !1, verticalScale: b.evaluatedScale[2] };
                    ye(m, b.node.matrix), p[0] = e, p[1] = i, ln(p, p, m);
                    const I = (p[0] - S.aabb.min[0]) / (S.aabb.max[0] - S.aabb.min[0]) * Jd | 0, M = Math.min(63, (p[1] - S.aabb.min[1]) / (S.aabb.max[1] - S.aabb.min[1]) * Jd | 0) * Jd + Math.min(63, I), z = S.heightmap[M];
                    if (!(z < 0 && b.node.footprint))
                        return b.hiddenByReplacement ? void 0 : { height: z, maxHeight: b.feature.properties.height, hidden: !1, verticalScale: b.evaluatedScale[2] };
                    if (b.node.footprint.grid.query(new Et(e, i), new Et(e, i), h), h.length > 0)
                        return { height: void 0, maxHeight: b.feature.properties.height, hidden: b.hiddenByReplacement, verticalScale: b.evaluatedScale[2] };
                } }
            }
            function uy(a, e) { return a instanceof Dc && !a.isLightConstant && e; }
            function vV(a, e, i, c, h, p, m, x) { let b = (61440 & e | (61440 & e) >> 4) >> 8, S = (3840 & e | (3840 & e) >> 4) >> 4, A = 240 & e | (240 & e) >> 4; i[3] > 0 && (b = nr(b, 255 * i[0], i[3]), S = nr(S, 255 * i[1], i[3]), A = nr(A, 255 * i[2], i[3])); const I = b << 8 | S, M = A << 8 | Math.floor(255 * c[3]), z = function (ae) { const fe = ke(ae, 0, 2); return Math.min(Math.round(.5 * fe * 255), 255); }(c[2]) << 8 | 15 * c[0] << 4 | 15 * c[1], F = ke(h[0], 0, 1), U = ke(h[1], 0, 1), X = ke(h[2], 0, 1), Y = ke(h[3], 0, 1); let le, se, $, te; if (F !== U && m !== p && U !== F) {
                const ae = m - p;
                se = 1 / (ae * (U - F)), $ = -(p + ae * F) / (ae * (U - F));
                const fe = ke(h[4], -1, 1);
                te = Math.pow(10, fe), le = 255 * X << 8 | 255 * Y;
            }
            else
                le = 65535, se = 0, $ = 1, te = 1; if (a.emplaceBack(I, M, z, le, se, $, te), x) {
                const ae = x.length;
                x.clear();
                for (let fe = 0; fe < ae; fe++)
                    x.emplaceBack(I, M, z, le, se, $, te);
            } }
            function xV(a, e, i) { const c = a.node; let h = 0; const p = i & em.HasMeshoptCompression; for (const m of c.meshes) {
                if (c.lights && c.lightMeshIndex === h || !m.featureData)
                    continue;
                m.featureArray = new jd, m.featureArray.reserve(m.featureData.length);
                let x = e;
                for (const b of m.featureData) {
                    const S = p ? 65535 & b : b >> 16 & 65535, A = p ? b >> 16 & 65535 : 65535 & b, I = (15 & A) < 8 ? 15 & A : 0, M = a.evaluatedRMEA[I], z = a.evaluatedColor[I], F = a.emissionHeightBasedParams[I];
                    let U;
                    if (x && I === 2 && c.lights && (U = new jd, U.resize(10 * c.lights.length)), vV(m.featureArray, S, z, M, F, m.aabb.min[2], m.aabb.max[2], U), U && x) {
                        x = !1;
                        const X = c.meshes[c.lightMeshIndex];
                        X.featureArray = U, X.featureArray._trim();
                    }
                }
                m.featureArray._trim(), h++;
            } }
            function AR(a, e, i, c) { const h = 1 << a.z; e.lat = Ce((c / It + a.y) / h), e.lng = Se((i / It + a.x) / h); }
            Nt(Qx, "Tiled3dModelBucket", { omit: ["layers"] }), Nt(CR, "Tiled3dModelFeature");
            const wV = { circle: class extends Ds {
                    constructor(a, e, i, c) { super(a, { layout: sn || (sn = new gi({ "circle-sort-key": new zt(Ne.layout_circle["circle-sort-key"]), "circle-elevation-reference": new wt(Ne.layout_circle["circle-elevation-reference"]), visibility: new wt(Ne.layout_circle.visibility) })), paint: Yn || (Yn = new gi({ "circle-radius": new zt(Ne.paint_circle["circle-radius"]), "circle-color": new zt(Ne.paint_circle["circle-color"]), "circle-blur": new zt(Ne.paint_circle["circle-blur"]), "circle-opacity": new zt(Ne.paint_circle["circle-opacity"]), "circle-translate": new wt(Ne.paint_circle["circle-translate"]), "circle-translate-anchor": new wt(Ne.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new wt(Ne.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new wt(Ne.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new zt(Ne.paint_circle["circle-stroke-width"]), "circle-stroke-color": new zt(Ne.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new zt(Ne.paint_circle["circle-stroke-opacity"]), "circle-emissive-strength": new wt(Ne.paint_circle["circle-emissive-strength"]), "circle-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "circle-stroke-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, c); }
                    createBucket(a) { return new $t(a); }
                    queryRadius(a) { const e = a; return Cr("circle-radius", this, e) + Cr("circle-stroke-width", this, e) + qn(this.paint.get("circle-translate")); }
                    queryIntersectsFeature(a, e, i, c, h, p, m, x) { const b = Hn(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), p.angle, a.pixelToTileUnitsFactor), S = this.paint.get("circle-radius").evaluate(e, i) + this.paint.get("circle-stroke-width").evaluate(e, i); return jI(a, c, p, m, x, this.paint.get("circle-pitch-alignment") === "map", this.paint.get("circle-pitch-scale") === "map", b, S); }
                    getProgramIds() { return ["circle"]; }
                    getDefaultProgramParams(a, e, i) { const c = BI(this); return { config: new $l(this, { zoom: e, lut: i }), defines: c, overrideFog: !1 }; }
                    hasElevation() { return this.layout && this.layout.get("circle-elevation-reference") !== "none"; }
                }, heatmap: class extends Ds {
                    createBucket(a) { return new UI(a); }
                    constructor(a, e, i, c) { super(a, { layout: $I || ($I = new gi({ visibility: new wt(Ne.layout_heatmap.visibility) })), paint: GI || (GI = new gi({ "heatmap-radius": new zt(Ne.paint_heatmap["heatmap-radius"]), "heatmap-weight": new zt(Ne.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new wt(Ne.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Fc(Ne.paint_heatmap["heatmap-color"]), "heatmap-opacity": new wt(Ne.paint_heatmap["heatmap-opacity"]), "heatmap-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, c), this._updateColorRamp(); }
                    _handleSpecialPaintPropertyUpdate(a) { a === "heatmap-color" && this._updateColorRamp(); }
                    _updateColorRamp() { this.colorRamp = V_({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null; }
                    resize() { this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null); }
                    queryRadius(a) { return Cr("heatmap-radius", this, a); }
                    queryIntersectsFeature(a, e, i, c, h, p, m, x) { const b = this.paint.get("heatmap-radius").evaluate(e, i); return jI(a, c, p, m, x, !0, !0, new Et(0, 0), b); }
                    hasOffscreenPass() { return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"; }
                    getProgramIds() { return ["heatmap", "heatmapTexture"]; }
                    getDefaultProgramParams(a, e, i) { return a === "heatmap" ? { config: new $l(this, { zoom: e, lut: i }), overrideFog: !1 } : {}; }
                }, hillshade: class extends Ds {
                    constructor(a, e, i, c) { super(a, { layout: qI || (qI = new gi({ visibility: new wt(Ne.layout_hillshade.visibility) })), paint: HI || (HI = new gi({ "hillshade-illumination-direction": new wt(Ne.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new wt(Ne.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new wt(Ne.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new wt(Ne.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new wt(Ne.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new wt(Ne.paint_hillshade["hillshade-accent-color"]), "hillshade-emissive-strength": new wt(Ne.paint_hillshade["hillshade-emissive-strength"]), "hillshade-shadow-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-highlight-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-accent-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, c); }
                    shouldRedrape() { return this.hasOffscreenPass() && this.paint.get("hillshade-illumination-anchor") === "viewport"; }
                    hasOffscreenPass() { return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"; }
                    getProgramIds() { return ["hillshade", "hillshadePrepare"]; }
                    getDefaultProgramParams(a, e, i) { return { overrideFog: !1 }; }
                }, fill: class extends Ds {
                    constructor(a, e, i, c) { super(a, { layout: yP || (yP = new gi({ "fill-sort-key": new zt(Ne.layout_fill["fill-sort-key"]), visibility: new wt(Ne.layout_fill.visibility), "fill-elevation-reference": new wt(Ne.layout_fill["fill-elevation-reference"]), "fill-construct-bridge-guard-rail": new zt(Ne.layout_fill["fill-construct-bridge-guard-rail"]) })), paint: vP || (vP = new gi({ "fill-antialias": new wt(Ne.paint_fill["fill-antialias"]), "fill-opacity": new zt(Ne.paint_fill["fill-opacity"]), "fill-color": new zt(Ne.paint_fill["fill-color"]), "fill-outline-color": new zt(Ne.paint_fill["fill-outline-color"]), "fill-translate": new wt(Ne.paint_fill["fill-translate"]), "fill-translate-anchor": new wt(Ne.paint_fill["fill-translate-anchor"]), "fill-pattern": new zt(Ne.paint_fill["fill-pattern"]), "fill-pattern-cross-fade": new wt(Ne.paint_fill["fill-pattern-cross-fade"]), "fill-emissive-strength": new wt(Ne.paint_fill["fill-emissive-strength"]), "fill-z-offset": new zt(Ne.paint_fill["fill-z-offset"]), "fill-bridge-guard-rail-color": new zt(Ne.paint_fill["fill-bridge-guard-rail-color"]), "fill-tunnel-structure-color": new zt(Ne.paint_fill["fill-tunnel-structure-color"]), "fill-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "fill-outline-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "fill-bridge-guard-rail-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "fill-tunnel-structure-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, c); }
                    getProgramIds() { const a = this.paint.get("fill-pattern"), e = a && a.constantOr(1), i = [e ? "fillPattern" : "fill"]; return this.paint.get("fill-antialias") && i.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), i; }
                    getDefaultProgramParams(a, e, i) { return { config: new $l(this, { zoom: e, lut: i }), overrideFog: !1 }; }
                    recalculate(a, e) { super.recalculate(a, e); const i = this.paint._values["fill-outline-color"]; i.value.kind === "constant" && i.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]); }
                    createBucket(a) { return new UT(a); }
                    queryRadius() { return qn(this.paint.get("fill-translate")); }
                    queryIntersectsFeature(a, e, i, c, h, p) { return !a.queryGeometry.isAboveHorizon && Nr(Xr(a.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), p.angle, a.pixelToTileUnitsFactor), c); }
                    isTileClipped() { return this.paint.get("fill-z-offset").constantOr(1) === 0; }
                    is3D(a) { if (this.paint.get("fill-z-offset").constantOr(1) !== 0)
                        return !0; const e = this.layout && this.layout.get("fill-elevation-reference") !== "none"; return a != null ? e && !a : e; }
                    hasElevation() { return this.layout && this.layout.get("fill-elevation-reference") !== "none"; }
                    hasShadowPass() { return this.layout && this.layout.get("fill-elevation-reference") !== "none"; }
                }, "fill-extrusion": class extends Ds {
                    constructor(a, e, i, c) { super(a, { layout: GP || (GP = new gi({ visibility: new wt(Ne["layout_fill-extrusion"].visibility), "fill-extrusion-edge-radius": new wt(Ne["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) })), paint: qP || (qP = new gi({ "fill-extrusion-opacity": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new zt(Ne["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new zt(Ne["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-pattern-cross-fade": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-pattern-cross-fade"]), "fill-extrusion-height": new zt(Ne["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new zt(Ne["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-height-alignment": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-height-alignment"]), "fill-extrusion-base-alignment": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-base-alignment"]), "fill-extrusion-vertical-gradient": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-ambient-occlusion-wall-radius": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]), "fill-extrusion-ambient-occlusion-ground-radius": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]), "fill-extrusion-ambient-occlusion-ground-attenuation": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]), "fill-extrusion-flood-light-color": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]), "fill-extrusion-flood-light-intensity": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]), "fill-extrusion-flood-light-wall-radius": new zt(Ne["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]), "fill-extrusion-flood-light-ground-radius": new zt(Ne["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]), "fill-extrusion-flood-light-ground-attenuation": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]), "fill-extrusion-vertical-scale": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]), "fill-extrusion-rounded-roof": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]), "fill-extrusion-cutoff-fade-range": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]), "fill-extrusion-emissive-strength": new zt(Ne["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]), "fill-extrusion-line-width": new zt(Ne["paint_fill-extrusion"]["fill-extrusion-line-width"]), "fill-extrusion-cast-shadows": new wt(Ne["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]), "fill-extrusion-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "fill-extrusion-flood-light-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, c), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 }; }
                    createBucket(a) { return new Ix(a); }
                    queryRadius() { return qn(this.paint.get("fill-extrusion-translate")); }
                    is3D(a) { return !0; }
                    hasShadowPass() { return this.paint.get("fill-extrusion-cast-shadows"); }
                    cutoffRange() { return this.paint.get("fill-extrusion-cutoff-fade-range"); }
                    canCastShadows() { return !0; }
                    getProgramIds() { return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"]; }
                    queryIntersectsFeature(a, e, i, c, h, p, m, x, b) { const S = Hn(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), p.angle, a.pixelToTileUnitsFactor), A = this.paint.get("fill-extrusion-height").evaluate(e, i), I = this.paint.get("fill-extrusion-base").evaluate(e, i), M = [0, 0], z = x && p.elevation, F = p.elevation ? p.elevation.exaggeration() : 1, U = a.tile.getBucket(this); if (z && U instanceof Ix) {
                        const $ = U.centroidVertexArray, te = b + 1;
                        te < $.length && (M[0] = $.geta_centroid_pos0(te), M[1] = $.geta_centroid_pos1(te));
                    } if (M[0] === 0 && M[1] === 1)
                        return !1; p.projection.name === "globe" && (c = $P([c], [new Et(0, 0), new Et(It, It)], a.tileID.canonical).map($ => $.polygon).flat()); const X = z ? x : null, [Y, le] = function ($, te, ae, fe, Te, Pe, Me, Oe, Ye, ut, it) { return $.projection.name === "globe" ? function (lt, pt, We, at, Ge, Xe, gt, yt, Zt, jt, Rt) { const mt = [], pr = [], Gt = lt.projection.upVectorScale(Rt, lt.center.lat, lt.worldSize).metersToTile, qt = [0, 0, 0, 1], hr = [0, 0, 0, 1], wr = (Lr, Pr, Ar, Tn) => { Lr[0] = Pr, Lr[1] = Ar, Lr[2] = Tn, Lr[3] = 1; }, Tr = UP(); We > 0 && (We += Tr), at += Tr; for (const Lr of pt) {
                        const Pr = [], Ar = [];
                        for (const Tn of Lr) {
                            const On = Tn.x + Ge.x, he = Tn.y + Ge.y, pe = lt.projection.projectTilePoint(On, he, Rt), Je = lt.projection.upVector(Rt, Tn.x, Tn.y);
                            let Tt = We, Lt = at;
                            if (gt) {
                                const Dt = YP(On, he, We, at, gt, yt, Zt, jt);
                                Tt += Dt.base, Lt += Dt.top;
                            }
                            We !== 0 ? wr(qt, pe.x + Je[0] * Gt * Tt, pe.y + Je[1] * Gt * Tt, pe.z + Je[2] * Gt * Tt) : wr(qt, pe.x, pe.y, pe.z), wr(hr, pe.x + Je[0] * Gt * Lt, pe.y + Je[1] * Gt * Lt, pe.z + Je[2] * Gt * Lt), ln(qt, qt, Xe), ln(hr, hr, Xe), Pr.push(new Yd(qt[0], qt[1], qt[2])), Ar.push(new Yd(hr[0], hr[1], hr[2]));
                        }
                        mt.push(Pr), pr.push(Ar);
                    } return [mt, pr]; }($, te, ae, fe, Te, Pe, Me, Oe, Ye, ut, it) : Me ? function (lt, pt, We, at, Ge, Xe, gt, yt, Zt) { const jt = [], Rt = [], mt = [0, 0, 0, 1]; for (const pr of lt) {
                        const Gt = [], qt = [];
                        for (const hr of pr) {
                            const wr = hr.x + at.x, Tr = hr.y + at.y, Lr = YP(wr, Tr, pt, We, Xe, gt, yt, Zt);
                            mt[0] = wr, mt[1] = Tr, mt[2] = Lr.base, mt[3] = 1, Gi(mt, mt, Ge), mt[3] = Math.max(mt[3], 1e-5);
                            const Pr = new Yd(mt[0] / mt[3], mt[1] / mt[3], mt[2] / mt[3]);
                            mt[0] = wr, mt[1] = Tr, mt[2] = Lr.top, mt[3] = 1, Gi(mt, mt, Ge), mt[3] = Math.max(mt[3], 1e-5);
                            const Ar = new Yd(mt[0] / mt[3], mt[1] / mt[3], mt[2] / mt[3]);
                            Gt.push(Pr), qt.push(Ar);
                        }
                        jt.push(Gt), Rt.push(qt);
                    } return [jt, Rt]; }(te, ae, fe, Te, Pe, Me, Oe, Ye, ut) : function (lt, pt, We, at, Ge) { const Xe = [], gt = [], yt = Ge[8] * pt, Zt = Ge[9] * pt, jt = Ge[10] * pt, Rt = Ge[11] * pt, mt = Ge[8] * We, pr = Ge[9] * We, Gt = Ge[10] * We, qt = Ge[11] * We; for (const hr of lt) {
                        const wr = [], Tr = [];
                        for (const Lr of hr) {
                            const Pr = Lr.x + at.x, Ar = Lr.y + at.y, Tn = Ge[0] * Pr + Ge[4] * Ar + Ge[12], On = Ge[1] * Pr + Ge[5] * Ar + Ge[13], he = Ge[2] * Pr + Ge[6] * Ar + Ge[14], pe = Ge[3] * Pr + Ge[7] * Ar + Ge[15], Je = Tn + yt, Tt = On + Zt, Lt = he + jt, Dt = Math.max(pe + Rt, 1e-5), Ht = Tn + mt, lr = On + pr, Vr = he + Gt, Ur = Math.max(pe + qt, 1e-5);
                            wr.push(new Yd(Je / Dt, Tt / Dt, Lt / Dt)), Tr.push(new Yd(Ht / Ur, lr / Ur, Vr / Ur));
                        }
                        Xe.push(wr), gt.push(Tr);
                    } return [Xe, gt]; }(te, ae, fe, Te, Pe); }(p, c, I, A, S, m, X, M, F, p.center.lat, a.tileID.canonical), se = a.queryGeometry; return function ($, te, ae) { let fe = 1 / 0; Nr(ae, te) && (fe = KP(ae, te[0])); for (let Te = 0; Te < te.length; Te++) {
                        const Pe = te[Te], Me = $[Te];
                        for (let Oe = 0; Oe < Pe.length - 1; Oe++) {
                            const Ye = Pe[Oe], ut = [Ye, Pe[Oe + 1], Me[Oe + 1], Me[Oe], Ye];
                            or(ae, ut) && (fe = Math.min(fe, KP(ae, ut)));
                        }
                    } return fe !== 1 / 0 && fe; }(Y, le, se.isPointQuery() ? se.screenBounds : se.screenGeometry); }
                }, line: class extends Ds {
                    constructor(a, e, i, c) { const h = aM(); super(a, h, e, i, c), h.layout && (this.layout = new zc(h.layout)), this.gradientVersion = 0, this.hasElevatedBuckets = !1, this.hasNonElevatedBuckets = !1; }
                    _handleSpecialPaintPropertyUpdate(a) { if (a === "line-gradient") {
                        const e = this._transitionablePaint._values["line-gradient"].value.expression;
                        this.stepInterpolant = e._styleExpression && e._styleExpression.expression instanceof Sd, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
                    } }
                    gradientExpression() { return this._transitionablePaint._values["line-gradient"].value.expression; }
                    widthExpression() { return this._transitionablePaint._values["line-width"].value.expression; }
                    recalculate(a, e) { super.recalculate(a, e), this.paint._values["line-floorwidth"] = (() => { if (Y_)
                        return Y_; const i = aM(); return Y_ = new b5(i.paint.properties["line-width"].specification), Y_.useIntegerZoom = !0, Y_; })().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, a); }
                    createBucket(a) { return new XT(a); }
                    getProgramIds() { return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"]; }
                    getDefaultProgramParams(a, e, i) { const c = sM(this); return { config: new $l(this, { zoom: e, lut: i }), defines: c, overrideFog: !1 }; }
                    queryRadius(a) { const e = a, i = lM(Cr("line-width", this, e), Cr("line-gap-width", this, e)), c = Cr("line-offset", this, e); return i / 2 + Math.abs(c) + qn(this.paint.get("line-translate")); }
                    queryIntersectsFeature(a, e, i, c, h, p) { if (a.queryGeometry.isAboveHorizon)
                        return !1; const m = Xr(a.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), p.angle, a.pixelToTileUnitsFactor), x = a.pixelToTileUnitsFactor / 2 * lM(this.paint.get("line-width").evaluate(e, i), this.paint.get("line-gap-width").evaluate(e, i)), b = this.paint.get("line-offset").evaluate(e, i); return b && (c = function (S, A) { const I = [], M = new Et(0, 0); for (let z = 0; z < S.length; z++) {
                        const F = S[z], U = [];
                        for (let X = 0; X < F.length; X++) {
                            const Y = F[X], le = F[X + 1], se = X === 0 ? M : Y.sub(F[X - 1])._unit()._perp(), $ = X === F.length - 1 ? M : le.sub(Y)._unit()._perp(), te = se._add($)._unit();
                            te._mult(1 / (te.x * $.x + te.y * $.y)), U.push(te._mult(A)._add(Y));
                        }
                        I.push(U);
                    } return I; }(c, b * a.pixelToTileUnitsFactor)), function (S, A, I) { for (let M = 0; M < A.length; M++) {
                        const z = A[M];
                        if (S.length >= 3) {
                            for (let F = 0; F < z.length; F++)
                                if (xn(S, z[F]))
                                    return !0;
                        }
                        if (vn(S, z, I))
                            return !0;
                    } return !1; }(m, c, x); }
                    isTileClipped() { return this.hasNonElevatedBuckets; }
                    isDraped(a) { return !this.hasElevatedBuckets; }
                    hasElevation() { return this.layout && this.layout.get("line-elevation-reference") !== "none"; }
                }, symbol: Gx, background: class extends Ds {
                    constructor(a, e, i, c) { super(a, { layout: JM || (JM = new gi({ visibility: new wt(Ne.layout_background.visibility) })), paint: eR || (eR = new gi({ "background-pitch-alignment": new wt(Ne.paint_background["background-pitch-alignment"]), "background-color": new wt(Ne.paint_background["background-color"]), "background-pattern": new wt(Ne.paint_background["background-pattern"]), "background-opacity": new wt(Ne.paint_background["background-opacity"]), "background-emissive-strength": new wt(Ne.paint_background["background-emissive-strength"]), "background-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, c); }
                    getProgramIds() { return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"]; }
                    getDefaultProgramParams(a, e, i) { return { overrideFog: !1 }; }
                    is3D(a) { return this.paint.get("background-pitch-alignment") === "viewport"; }
                }, raster: sR, "raster-particle": hR, sky: class extends Ds {
                    constructor(a, e, i, c) { super(a, { layout: lR || (lR = new gi({ visibility: new wt(Ne.layout_sky.visibility) })), paint: cR || (cR = new gi({ "sky-type": new wt(Ne.paint_sky["sky-type"]), "sky-atmosphere-sun": new wt(Ne.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new wt(Ne.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new wt(Ne.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new wt(Ne.paint_sky["sky-gradient-radius"]), "sky-gradient": new Fc(Ne.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new wt(Ne.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new wt(Ne.paint_sky["sky-atmosphere-color"]), "sky-opacity": new wt(Ne.paint_sky["sky-opacity"]), "sky-gradient-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-halo-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, c), this._updateColorRamp(); }
                    _handleSpecialPaintPropertyUpdate(a) { a === "sky-gradient" ? this._updateColorRamp() : a !== "sky-atmosphere-sun" && a !== "sky-atmosphere-halo-color" && a !== "sky-atmosphere-color" && a !== "sky-atmosphere-sun-intensity" || (this._skyboxInvalidated = !0); }
                    _updateColorRamp() { this.colorRamp = V_({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null); }
                    needsSkyboxCapture(a) { if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
                        return !0; if (!this.paint.get("sky-atmosphere-sun")) {
                        const e = a.style.light.properties.get("position");
                        return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;
                    } return !1; }
                    getCenter(a, e) { if (this.paint.get("sky-type") === "atmosphere") {
                        const c = this.paint.get("sky-atmosphere-sun"), h = !c, p = a.style.light, m = p.properties.get("position");
                        return h && p.properties.get("anchor") === "viewport" && Br("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), h ? yS(m.azimuthal, 90 - m.polar, e) : yS(c[0], 90 - c[1], e);
                    } const i = this.paint.get("sky-gradient-center"); return yS(i[0], 90 - i[1], e); }
                    isSky() { return !0; }
                    markSkyboxValid(a) { this._skyboxInvalidated = !1, this._lightPosition = a.style.light.properties.get("position"); }
                    hasOffscreenPass() { return !0; }
                    getProgramIds() { const a = this.paint.get("sky-type"); return a === "atmosphere" ? ["skyboxCapture", "skybox"] : a === "gradient" ? ["skyboxGradient"] : null; }
                }, slot: class extends Ds {
                    constructor(a, e, i, c) { super(a, { paint: uR || (uR = new gi({})) }, e, null); }
                }, model: class extends Ds {
                    constructor(a, e, i, c) { super(a, { layout: xR || (xR = new gi({ visibility: new wt(Ne.layout_model.visibility), "model-id": new zt(Ne.layout_model["model-id"]) })), paint: wR || (wR = new gi({ "model-opacity": new zt(Ne.paint_model["model-opacity"]), "model-rotation": new zt(Ne.paint_model["model-rotation"]), "model-scale": new zt(Ne.paint_model["model-scale"]), "model-translation": new zt(Ne.paint_model["model-translation"]), "model-color": new zt(Ne.paint_model["model-color"]), "model-color-mix-intensity": new zt(Ne.paint_model["model-color-mix-intensity"]), "model-type": new wt(Ne.paint_model["model-type"]), "model-cast-shadows": new wt(Ne.paint_model["model-cast-shadows"]), "model-receive-shadows": new wt(Ne.paint_model["model-receive-shadows"]), "model-ambient-occlusion-intensity": new wt(Ne.paint_model["model-ambient-occlusion-intensity"]), "model-emissive-strength": new zt(Ne.paint_model["model-emissive-strength"]), "model-roughness": new zt(Ne.paint_model["model-roughness"]), "model-height-based-emissive-strength-multiplier": new zt(Ne.paint_model["model-height-based-emissive-strength-multiplier"]), "model-cutoff-fade-range": new wt(Ne.paint_model["model-cutoff-fade-range"]), "model-front-cutoff": new wt(Ne.paint_model["model-front-cutoff"]), "model-color-use-theme": new zt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, c), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 }; }
                    createBucket(a) { return new bS(a); }
                    getProgramIds() { return ["model"]; }
                    is3D(a) { return !0; }
                    hasShadowPass() { return !0; }
                    canCastShadows() { return !0; }
                    hasLightBeamPass() { return !0; }
                    cutoffRange() { return this.paint.get("model-cutoff-fade-range"); }
                    queryRadius(a) { return a instanceof Qx ? It - 1 : 0; }
                    queryIntersectsFeature(a, e, i, c, h, p) { if (!this.modelManager)
                        return !1; const m = this.modelManager, x = a.tile.getBucket(this); if (!(x && x instanceof bS))
                        return !1; for (const b in x.instancesPerModel) {
                        const S = x.instancesPerModel[b], A = e.id !== void 0 ? e.id : e.properties && e.properties.hasOwnProperty("id") ? e.properties.id : void 0;
                        if (S.idToFeaturesIndex.hasOwnProperty(A)) {
                            const I = S.features[S.idToFeaturesIndex[A]], M = m.getModel(b, this.scope);
                            if (!M)
                                return !1;
                            let z = ce();
                            const F = new W(0, 0), U = x.canonical;
                            let X = Number.MAX_VALUE;
                            for (let Y = 0; Y < I.instancedDataCount; ++Y) {
                                const le = 16 * (I.instancedDataOffset + Y), se = S.instancedDataArray.float32, $ = [se[le + 4], se[le + 5], se[le + 6]];
                                AR(U, F, se[le], 0 | se[le + 1]), bR(z, M, p, F, I.rotation, I.scale, $, !1, !1, !1), p.projection.name === "globe" && (z = xS(z, p));
                                const te = ie([], p.projMatrix, z), ae = a.queryGeometry, fe = gR(ae.isPointQuery() ? ae.screenBounds : ae.screenGeometry, p, te, M.aabb);
                                fe != null && (X = Math.min(fe, X));
                            }
                            return X !== Number.MAX_VALUE && X;
                        }
                    } return !1; }
                    _handleOverridablePaintPropertyUpdate(a, e, i) { return !(!this.layout || e.isDataDriven() || i.isDataDriven() || a !== "model-color" && a !== "model-color-mix-intensity" && a !== "model-rotation" && a !== "model-scale" && a !== "model-translation" && a !== "model-emissive-strength"); }
                    _isPropertyZoomDependent(a) { const e = this._transitionablePaint._values[a]; return e != null && e.value != null && e.value.expression != null && e.value.expression instanceof zu; }
                    isZoomDependent() { return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation"); }
                }, clip: class extends Ds {
                    constructor(a, e, i, c) { super(a, { layout: xP || (xP = new gi({ "clip-layer-types": new wt(Ne.layout_clip["clip-layer-types"]), "clip-layer-scope": new wt(Ne.layout_clip["clip-layer-scope"]) })), paint: wP || (wP = new gi({})) }, e, i, c); }
                    recalculate(a, e) { super.recalculate(a, e); }
                    createBucket(a) { return new bP(a); }
                    is3D(a) { return !0; }
                } };
            class bV {
                constructor(e) { this._callback = e, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => { this._triggered = !1, this._callback(); }); }
                trigger() { this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => { this._triggered = !1, this._callback(); }, 0)); }
                remove() { this._channel = void 0, this._callback = () => { }; }
            }
            class TV {
                constructor() { this.tasks = {}, this.taskQueue = [], _r(["process"], this), this.invoker = new bV(this.process), this.nextId = 0; }
                add(e, i) { const c = this.nextId++, h = function ({ type: p, isSymbolTile: m, zoom: x }) { return x = x || 0, p === "message" ? 0 : p !== "maybePrepare" || m ? p !== "parseTile" || m ? p === "parseTile" && m ? 300 - x : p === "maybePrepare" && m ? 400 - x : 500 : 200 - x : 100 - x; }(i); if (h === 0) {
                    try {
                        e();
                    }
                    finally { }
                    return null;
                } return this.tasks[c] = { fn: e, metadata: i, priority: h, id: c }, this.taskQueue.push(c), this.invoker.trigger(), { cancel: () => { delete this.tasks[c]; } }; }
                process() { try {
                    if (this.taskQueue = this.taskQueue.filter(c => !!this.tasks[c]), !this.taskQueue.length)
                        return;
                    const e = this.pick();
                    if (e === null)
                        return;
                    const i = this.tasks[e];
                    if (delete this.tasks[e], this.taskQueue.length && this.invoker.trigger(), !i)
                        return;
                    i.fn();
                }
                finally { } }
                pick() { let e = null, i = 1 / 0; for (let h = 0; h < this.taskQueue.length; h++) {
                    const p = this.tasks[this.taskQueue[h]];
                    p.priority < i && (i = p.priority, e = h);
                } if (e === null)
                    return null; const c = this.taskQueue[e]; return this.taskQueue.splice(e, 1), c; }
                remove() { this.invoker.remove(); }
            }
            class IR {
                constructor(e, i, c) { this.target = e, this.parent = i, this.mapId = c, this.callbacks = {}, this.cancelCallbacks = {}, _r(["receive"], this), this.target.addEventListener("message", this.receive, !1), this.scheduler = new TV; }
                send(e, i, c, h, p = !1, m) { const x = Math.round(1e18 * Math.random()).toString(36).substring(0, 10); c && (c.metadata = m, this.callbacks[x] = c); const b = new Set; return this.target.postMessage({ id: x, type: e, hasCallback: !!c, targetMapId: h, mustQueue: p, sourceMapId: this.mapId, data: zl(i, b) }, b), { cancel: () => { c && delete this.callbacks[x], this.target.postMessage({ id: x, type: "<cancel>", targetMapId: h, sourceMapId: this.mapId }); } }; }
                receive(e) { const i = e.data; if (!i)
                    return; const c = i.id; if (c && (!i.targetMapId || this.mapId === i.targetMapId))
                    if (i.type === "<cancel>") {
                        const h = this.cancelCallbacks[c];
                        delete this.cancelCallbacks[c], h && h.cancel();
                    }
                    else if (i.mustQueue || Dn(self)) {
                        const h = this.callbacks[c], p = this.scheduler.add(() => this.processTask(c, i), h && h.metadata || { type: "message" });
                        p && (this.cancelCallbacks[c] = p);
                    }
                    else
                        this.processTask(c, i); }
                processTask(e, i) { if (delete this.cancelCallbacks[e], i.type === "<response>") {
                    const c = this.callbacks[e];
                    delete this.callbacks[e], c && (i.error ? c(Fl(i.error)) : c(null, Fl(i.data)));
                }
                else {
                    const c = new Set, h = i.hasCallback ? (m, x) => { this.target.postMessage({ id: e, type: "<response>", sourceMapId: this.mapId, error: m ? zl(m) : null, data: zl(x, c) }, c); } : () => { }, p = Fl(i.data);
                    if (this.parent[i.type])
                        this.parent[i.type](i.sourceMapId, p, h);
                    else if (this.parent.getWorkerSource) {
                        const m = i.type.split("."), { source: x, scope: b } = p;
                        this.parent.getWorkerSource(i.sourceMapId, m[0], x, b)[m[1]](p, h);
                    }
                    else
                        h(new Error(`Could not find function ${i.type}`));
                } }
                remove() { this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1); }
            }
            var hy = { workerUrl: "", workerClass: null, workerParams: void 0 };
            const CS = "mapboxgl_preloaded_worker_pool";
            class tf {
                constructor() { this.active = {}; }
                acquire(e, i = tf.workerCount) { if (!this.workers)
                    for (this.workers = []; this.workers.length < i;)
                        this.workers.push(hy.workerClass != null ? new hy.workerClass : new self.Worker(hy.workerUrl, hy.workerParams)); return this.active[e] = !0, this.workers.slice(); }
                release(e) { delete this.active[e], this.workers && this.numActive() === 0 && (this.workers.forEach(i => { i.terminate(); }), this.workers = null); }
                isPreloaded() { return !!this.active[CS]; }
                numActive() { return Object.keys(this.active).length; }
            }
            tf.workerCount = 2;
            class rm {
                constructor(e, i, c = "Worker", h = tf.workerCount) { this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = Ot(); const p = this.workerPool.acquire(this.id, h); for (let m = 0; m < p.length; m++) {
                    const x = new rm.Actor(p[m], i, this.id);
                    x.name = `${c} ${m}`, this.actors.push(x);
                } this.ready = !1, this.broadcast("checkIfReady", null, () => { this.ready = !0; }); }
                broadcast(e, i, c) { tt(this.actors, (h, p) => { h.send(e, i, p); }, c = c || function () { }); }
                getActor() { return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]; }
                remove() { this.actors.forEach(e => { e.remove(); }), this.actors = [], this.workerPool.release(this.id); }
            }
            let dy, AS;
            function Jx() { return dy || (dy = new tf), dy; }
            rm.Actor = IR;
            const IS = new nn(0, 0, 0), PS = { PATH_RULE_UNSPECIFIED: 0, PATH_RULE_NON_ZERO: 1, PATH_RULE_EVEN_ODD: 2 }, MS = { LINE_CAP_UNSPECIFIED: 0, LINE_CAP_BUTT: 1, LINE_CAP_ROUND: 2, LINE_CAP_SQUARE: 3 }, e1 = { LINE_JOIN_UNSPECIFIED: 0, LINE_JOIN_MITER: 1, LINE_JOIN_MITER_CLIP: 2, LINE_JOIN_ROUND: 3, LINE_JOIN_BEVEL: 4 }, SV = { PAINT_ORDER_UNSPECIFIED: 0, PAINT_ORDER_FILL_AND_STROKE: 1, PAINT_ORDER_STROKE_AND_FILL: 2 }, fy = { PATH_COMMAND_UNSPECIFIED: 0, PATH_COMMAND_MOVE: 1, PATH_COMMAND_LINE: 2, PATH_COMMAND_QUAD: 3, PATH_COMMAND_CUBIC: 4, PATH_COMMAND_CLOSE: 5 }, PR = { MASK_TYPE_UNSPECIFIED: 0, MASK_TYPE_LUMINANCE: 1, MASK_TYPE_ALPHA: 2 };
            function EV(a, e, i) { a === 1 && e.icons.push(function (c, h) { return function (p) { if (p.usvg_tree.height || (p.usvg_tree.height = p.usvg_tree.width), !p.metadata)
                return p; const { metadata: m } = p; if (m.content_area) {
                const { content_area: x } = m;
                x.top == null && (x.top = x.left), x.width == null && (x.width = p.usvg_tree.width), x.height == null && (x.height = x.width);
            } return m.stretch_x && m.stretch_x.length && MR(m, "x"), m.stretch_y && m.stretch_y.length && MR(m, "y"), p; }(c.readFields(CV, { name: void 0 }, h)); }(i, i.readVarint() + i.pos)); }
            function MR(a, e) { const i = [], c = a[`stretch_${e}`]; let h = null; for (let p = 0; p < c.length; p++)
                h === null ? h = i.length === 0 ? c[0] : i[i.length - 1][1] + c[p] : (i.push([h, h + c[p]]), h = null); a[`stretch_${e}_areas`] = i; }
            function CV(a, e, i) { a === 1 ? e.name = i.readString() : a === 2 ? e.metadata = function (c, h) { return c.readFields(AV, { stretch_x: null, stretch_y: null, stretch_x_areas: null, stretch_y_areas: null, variables: [] }, h); }(i, i.readVarint() + i.pos) : a === 3 && (e.usvg_tree = function (c, h) { return c.readFields(MV, { width: 20, children: [], linear_gradients: [], radial_gradients: [], clip_paths: [], masks: [] }, h); }(i, i.readVarint() + i.pos), e.data = "usvg_tree"); }
            function AV(a, e, i) { a === 1 ? e.stretch_x = i.readPackedVarint() : a === 2 ? e.stretch_y = i.readPackedVarint() : a === 3 ? e.content_area = function (c, h) { return c.readFields(IV, { left: 0 }, h); }(i, i.readVarint() + i.pos) : a === 4 && e.variables.push(function (c, h) { return c.readFields(PV, { name: void 0 }, h); }(i, i.readVarint() + i.pos)); }
            function IV(a, e, i) { a === 1 ? e.left = i.readVarint() : a === 2 ? e.width = i.readVarint() : a === 3 ? e.top = i.readVarint() : a === 4 && (e.height = i.readVarint()); }
            function PV(a, e, i) { a === 1 ? e.name = i.readString() : a === 2 && (e.rgb_color = n1(i.readVarint()), e.value = "rgb_color"); }
            function MV(a, e, i) { a === 1 ? e.width = e.height = i.readVarint() : a === 2 ? e.height = i.readVarint() : a === 3 ? e.children.push(t1(i, i.readVarint() + i.pos)) : a === 4 ? e.linear_gradients.push(function (c, h) { return c.readFields(FV, { spread_method: 1, stops: [], x1: 0, y1: 0, x2: 1, y2: 0 }, h); }(i, i.readVarint() + i.pos)) : a === 5 ? e.radial_gradients.push(function (c, h) { return c.readFields(BV, { spread_method: 1, stops: [], cx: .5, cy: .5, r: .5, fx: .5, fy: .5, fr: 0 }, h); }(i, i.readVarint() + i.pos)) : a === 7 ? e.clip_paths.push(function (c, h) { return c.readFields(jV, { children: [] }, h); }(i, i.readVarint() + i.pos)) : a === 8 && e.masks.push(function (c, h) { const p = c.readFields(VV, { left: 0, width: 20, mask_type: PR.MASK_TYPE_LUMINANCE, children: [] }, h); return p.height == null && (p.height = p.width), p.top == null && (p.top = p.left), p; }(i, i.readVarint() + i.pos)); }
            function t1(a, e) { return a.readFields(RV, {}, e); }
            function RV(a, e, i) { a === 1 ? (e.group = function (c, h) { return c.readFields(kV, { opacity: 255, children: [] }, h); }(i, i.readVarint() + i.pos), e.node = "group") : a === 2 && (e.path = function (c, h) { return c.readFields(LV, { paint_order: 1, commands: [], step: 1, diffs: [], rule: PS.PATH_RULE_NON_ZERO }, h); }(i, i.readVarint() + i.pos), e.node = "path"); }
            function kV(a, e, i) { a === 1 ? e.transform = r1(i, i.readVarint() + i.pos) : a === 2 ? e.opacity = i.readVarint() : a === 5 ? e.clip_path_idx = i.readVarint() : a === 6 ? e.mask_idx = i.readVarint() : a === 7 && e.children.push(t1(i, i.readVarint() + i.pos)); }
            function r1(a, e) { return a.readFields(DV, { sx: 1, ky: 0, kx: 0, sy: 1, tx: 0, ty: 0 }, e); }
            function DV(a, e, i) { a === 1 ? e.sx = i.readFloat() : a === 2 ? e.ky = i.readFloat() : a === 3 ? e.kx = i.readFloat() : a === 4 ? e.sy = i.readFloat() : a === 5 ? e.tx = i.readFloat() : a === 6 && (e.ty = i.readFloat()); }
            function LV(a, e, i) { a === 1 ? e.fill = function (c, h) { return c.readFields(OV, { rgb_color: IS, paint: "rgb_color", opacity: 255 }, h); }(i, i.readVarint() + i.pos) : a === 2 ? e.stroke = function (c, h) { return c.readFields(zV, { rgb_color: IS, paint: "rgb_color", dasharray: [], dashoffset: 0, miterlimit: 4, opacity: 255, width: 1, linecap: 1, linejoin: 1 }, h); }(i, i.readVarint() + i.pos) : a === 3 ? e.paint_order = i.readVarint() : a === 5 ? i.readPackedVarint(e.commands) : a === 6 ? e.step = i.readFloat() : a === 7 ? i.readPackedSVarint(e.diffs) : a === 8 && (e.rule = i.readVarint()); }
            function OV(a, e, i) { a === 1 ? (e.rgb_color = n1(i.readVarint()), e.paint = "rgb_color") : a === 2 ? (e.linear_gradient_idx = i.readVarint(), e.paint = "linear_gradient_idx") : a === 3 ? (e.radial_gradient_idx = i.readVarint(), e.paint = "radial_gradient_idx") : a === 5 && (e.opacity = i.readVarint()); }
            function n1(a) { return new nn((a >> 16 & 255) / 255, (a >> 8 & 255) / 255, (255 & a) / 255, 1); }
            function zV(a, e, i) { a === 1 ? (e.rgb_color = n1(i.readVarint()), e.paint = "rgb_color") : a === 2 ? (e.linear_gradient_idx = i.readVarint(), e.paint = "linear_gradient_idx") : a === 3 ? (e.radial_gradient_idx = i.readVarint(), e.paint = "radial_gradient_idx") : a === 5 ? i.readPackedFloat(e.dasharray) : a === 6 ? e.dashoffset = i.readFloat() : a === 7 ? e.miterlimit = i.readFloat() : a === 8 ? e.opacity = i.readVarint() : a === 9 ? e.width = i.readFloat() : a === 10 ? e.linecap = i.readVarint() : a === 11 && (e.linejoin = i.readVarint()); }
            function FV(a, e, i) { a === 1 ? e.transform = r1(i, i.readVarint() + i.pos) : a === 2 ? e.spread_method = i.readVarint() : a === 3 ? e.stops.push(RR(i, i.readVarint() + i.pos)) : a === 4 ? e.x1 = i.readFloat() : a === 5 ? e.y1 = i.readFloat() : a === 6 ? e.x2 = i.readFloat() : a === 7 && (e.y2 = i.readFloat()); }
            function RR(a, e) { return a.readFields(NV, { offset: 0, opacity: 255, rgb_color: IS }, e); }
            function NV(a, e, i) { a === 1 ? e.offset = i.readFloat() : a === 2 ? e.opacity = i.readVarint() : a === 3 && (e.rgb_color = n1(i.readVarint())); }
            function BV(a, e, i) { a === 1 ? e.transform = r1(i, i.readVarint() + i.pos) : a === 2 ? e.spread_method = i.readVarint() : a === 3 ? e.stops.push(RR(i, i.readVarint() + i.pos)) : a === 4 ? e.cx = i.readFloat() : a === 5 ? e.cy = i.readFloat() : a === 6 ? e.r = i.readFloat() : a === 7 ? e.fx = i.readFloat() : a === 8 ? e.fy = i.readFloat() : a === 9 && (e.fr = i.readFloat()); }
            function jV(a, e, i) { a === 1 ? e.transform = r1(i, i.readVarint() + i.pos) : a === 2 ? e.clip_path_idx = i.readVarint() : a === 3 && e.children.push(t1(i, i.readVarint() + i.pos)); }
            function VV(a, e, i) { a === 1 ? e.left = e.top = i.readFloat() : a === 2 ? e.width = e.height = i.readFloat() : a === 3 ? e.top = i.readFloat() : a === 4 ? e.height = i.readFloat() : a === 5 ? e.mask_type = i.readVarint() : a === 6 ? e.mask_idx = i.readVarint() : a === 7 && e.children.push(t1(i, i.readVarint() + i.pos)); }
            class UV {
                static calculate(e = {}, i = []) { const c = new Map, h = new Map; if (Object.keys(e).length === 0)
                    return c; i.forEach(p => { h.set(p.name, p.rgb_color || new nn(0, 0, 0)); }); for (const [p, m] of Object.entries(e))
                    h.has(p) ? c.set(h.get(p).toStringPremultipliedAlpha(), m) : console.warn(`Ignoring unknown image variable "${p}"`); return c; }
            }
            function nm(a, e = 255, i) { const c = e / 255, h = a.toStringPremultipliedAlpha(), p = i.has(h) ? i.get(h).clone() : a.clone(); return p.a *= c, p.toString(); }
            function py(a, e) { if (!kg()) {
                const i = document.createElement("canvas");
                return i.width = a, i.height = e, i;
            } return new OffscreenCanvas(a, e); }
            function $V(a, e) { const i = UV.calculate(e.params, a.metadata ? a.metadata.variables : []), c = a.usvg_tree, h = c.width, p = c.height, m = e.transform ? e.transform : new DOMMatrix, x = Math.max(1, Math.round(h * m.a)), b = Math.max(1, Math.round(p * m.d)), S = new DOMMatrix([x / h, 0, 0, b / p, 0, 0]), A = py(x, b).getContext("2d"); return RS(A, S, c, c, i), A.getImageData(0, 0, x, b); }
            function RS(a, e, i, c, h) { for (const p of c.children)
                kR(a, e, i, p, h); }
            function kR(a, e, i, c, h) { c.group ? (a.save(), function (p, m, x, b, S) { const A = b.mask_idx != null ? x.masks[b.mask_idx] : null, I = b.clip_path_idx != null ? x.clip_paths[b.clip_path_idx] : null; if (b.transform && (m = i1(b.transform).preMultiplySelf(m)), !function (F, U, X) { return F.opacity !== 255 || U || X; }(b, I != null, A != null))
                return void RS(p, m, x, b, S); const M = py(p.canvas.width, p.canvas.height), z = M.getContext("2d"); RS(z, m, x, b, S), I && BR(z, m, x, I), A && jR(z, m, x, A, S), p.globalAlpha = b.opacity / 255, p.drawImage(M, 0, 0); }(a, e, i, c.group, h), a.restore()) : c.path && (a.save(), function (p, m, x, b, S) { const A = VR(b); p.setTransform(m), b.paint_order === SV.PAINT_ORDER_FILL_AND_STROKE ? (DR(p, x, b, A, S), OR(p, x, b, A, S)) : (OR(p, x, b, A, S), DR(p, x, b, A, S)); }(a, e, i, c.path, h), a.restore()); }
            function DR(a, e, i, c, h) { const p = i.fill; if (!p)
                return; const m = p.opacity / 255; switch (p.paint) {
                case "rgb_color":
                    a.fillStyle = nm(p.rgb_color, p.opacity, h);
                    break;
                case "linear_gradient_idx":
                    a.fillStyle = zR(a, e.linear_gradients[p.linear_gradient_idx], m, h);
                    break;
                case "radial_gradient_idx": a.fillStyle = FR(a, e.radial_gradients[p.radial_gradient_idx], m, h);
            } a.fill(c, LR(i)); }
            function LR(a) { return a.rule === PS.PATH_RULE_NON_ZERO ? "nonzero" : a.rule === PS.PATH_RULE_EVEN_ODD ? "evenodd" : void 0; }
            function OR(a, e, i, c, h) { const p = i.stroke; if (!p)
                return; a.lineWidth = p.width, a.miterLimit = p.miterlimit, a.setLineDash(p.dasharray), a.lineDashOffset = p.dashoffset; const m = p.opacity / 255; switch (p.paint) {
                case "rgb_color":
                    a.strokeStyle = nm(p.rgb_color, p.opacity, h);
                    break;
                case "linear_gradient_idx":
                    a.strokeStyle = zR(a, e.linear_gradients[p.linear_gradient_idx], m, h);
                    break;
                case "radial_gradient_idx": a.strokeStyle = FR(a, e.radial_gradients[p.radial_gradient_idx], m, h);
            } switch (p.linejoin) {
                case e1.LINE_JOIN_MITER_CLIP:
                case e1.LINE_JOIN_MITER:
                    a.lineJoin = "miter";
                    break;
                case e1.LINE_JOIN_ROUND:
                    a.lineJoin = "round";
                    break;
                case e1.LINE_JOIN_BEVEL: a.lineJoin = "bevel";
            } switch (p.linecap) {
                case MS.LINE_CAP_BUTT:
                    a.lineCap = "butt";
                    break;
                case MS.LINE_CAP_ROUND:
                    a.lineCap = "round";
                    break;
                case MS.LINE_CAP_SQUARE: a.lineCap = "square";
            } a.stroke(c); }
            function zR(a, e, i, c) { if (e.stops.length === 1) {
                const M = e.stops[0];
                return nm(M.rgb_color, M.opacity * i, c);
            } const h = i1(e.transform), { x1: p, y1: m, x2: x, y2: b } = e, S = h.transformPoint(new DOMPoint(p, m)), A = h.transformPoint(new DOMPoint(x, b)), I = a.createLinearGradient(S.x, S.y, A.x, A.y); for (const M of e.stops)
                I.addColorStop(M.offset, nm(M.rgb_color, M.opacity * i, c)); return I; }
            function FR(a, e, i, c) { if (e.stops.length === 1) {
                const M = e.stops[0];
                return nm(M.rgb_color, M.opacity * i, c);
            } const h = i1(e.transform), { fx: p, fy: m, cx: x, cy: b } = e, S = h.transformPoint(new DOMPoint(p, m)), A = h.transformPoint(new DOMPoint(x, b)), I = a.createRadialGradient(S.x, S.y, 0, A.x, A.y, e.r * ((h.a + h.d) / 2)); for (const M of e.stops)
                I.addColorStop(M.offset, nm(M.rgb_color, M.opacity * i, c)); return I; }
            function NR(a, e, i, c) { const h = c.transform ? i1(c.transform).preMultiplySelf(e) : e, p = py(a.canvas.width, a.canvas.height), m = p.getContext("2d"); for (const b of c.children)
                if (b.group)
                    NR(m, h, i, b.group);
                else if (b.path) {
                    const S = b.path, A = new Path2D;
                    A.addPath(VR(S), h), m.fill(A, LR(S));
                } const x = c.clip_path_idx != null ? i.clip_paths[c.clip_path_idx] : null; x && BR(m, h, i, x), a.globalCompositeOperation = "source-over", a.drawImage(p, 0, 0); }
            function BR(a, e, i, c) { const h = py(a.canvas.width, a.canvas.height); NR(h.getContext("2d"), e, i, c), a.globalCompositeOperation = "destination-in", a.drawImage(h, 0, 0); }
            function jR(a, e, i, c, h) { if (c.children.length === 0)
                return; const p = c.mask_idx != null ? i.masks[c.mask_idx] : null; p && jR(a, e, i, p, h); const m = a.canvas.width, x = a.canvas.height, b = py(m, x), S = b.getContext("2d"), A = c.width, I = c.height, M = c.left, z = c.top, F = new Path2D, U = new Path2D; U.rect(M, z, A, I), F.addPath(U, e), S.clip(F); for (const le of c.children)
                kR(S, e, i, le, h); const X = S.getImageData(0, 0, m, x), Y = X.data; if (c.mask_type === PR.MASK_TYPE_LUMINANCE)
                for (let le = 0; le < Y.length; le += 4)
                    Y[le + 3] = Y[le + 3] / 255 * (.2126 * Y[le] + .7152 * Y[le + 1] + .0722 * Y[le + 2]); S.putImageData(X, 0, 0), a.globalCompositeOperation = "destination-in", a.drawImage(b, 0, 0); }
            function i1(a) { return a ? new DOMMatrix([a.sx, a.ky, a.kx, a.sy, a.tx, a.ty]) : new DOMMatrix; }
            function VR(a) { const e = new Path2D, i = a.step; let c = a.diffs[0] * i, h = a.diffs[1] * i; e.moveTo(c, h); for (let p = 0, m = 2; p < a.commands.length; p++)
                switch (a.commands[p]) {
                    case fy.PATH_COMMAND_MOVE:
                        c += a.diffs[m++] * i, h += a.diffs[m++] * i, e.moveTo(c, h);
                        break;
                    case fy.PATH_COMMAND_LINE:
                        c += a.diffs[m++] * i, h += a.diffs[m++] * i, e.lineTo(c, h);
                        break;
                    case fy.PATH_COMMAND_QUAD: {
                        const x = c + a.diffs[m++] * i, b = h + a.diffs[m++] * i;
                        c = x + a.diffs[m++] * i, h = b + a.diffs[m++] * i, e.quadraticCurveTo(x, b, c, h);
                        break;
                    }
                    case fy.PATH_COMMAND_CUBIC: {
                        const x = c + a.diffs[m++] * i, b = h + a.diffs[m++] * i, S = x + a.diffs[m++] * i, A = b + a.diffs[m++] * i;
                        c = S + a.diffs[m++] * i, h = A + a.diffs[m++] * i, e.bezierCurveTo(x, b, S, A, c, h);
                        break;
                    }
                    case fy.PATH_COMMAND_CLOSE: e.closePath();
                } return e; }
            class s1 {
                constructor(e) { this.capacity = e, this.cache = new Map; }
                get(e) { if (!this.cache.has(e))
                    return; const i = this.cache.get(e); return this.cache.delete(e), this.cache.set(e, i), i; }
                put(e, i) { this.cache.has(e) ? this.cache.delete(e) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(e, i); }
                delete(e) { this.cache.delete(e); }
            }
            Nt(s1, "LRUCache");
            class kS {
                constructor() { this.cacheMap = new Map, this.cacheDependenciesMap = new Map; }
                static _getImage(e) { return new ds(e, e.data); }
                getFromCache(e, i, c) { return this.cacheMap.has(c) || this.cacheMap.set(c, new s1(150)), this.cacheMap.get(c).get(Nc(e.toString(), i)); }
                setInCache(e, i, c, h) { this.cacheDependenciesMap.has(h) || this.cacheDependenciesMap.set(h, new Map), this.cacheMap.has(h) || this.cacheMap.set(h, new s1(150)); const p = this.cacheDependenciesMap.get(h), m = Nc(e.id.toString(), c); p.get(m) || p.set(m, new Set); const x = this.cacheMap.get(h), b = e.toString(); p.get(m).add(b), x.put(Nc(e.toString(), c), i); }
                removeImagesFromCacheByIds(e, i, c = 0) { if (!this.cacheMap.has(c) || !this.cacheDependenciesMap.has(c))
                    return; const h = this.cacheMap.get(c), p = this.cacheDependenciesMap.get(c); for (const m of e) {
                    const x = Nc(m.toString(), i);
                    if (p.has(x)) {
                        for (const b of p.get(x))
                            h.delete(b);
                        p.delete(x);
                    }
                } }
                rasterize(e, i, c, h, p = $V) { const m = this.getFromCache(e, c, h); if (m)
                    return m.clone(); const x = p(i.icon, e.options), b = kS._getImage(x); return this.setInCache(e, b, c, h), b.clone(); }
            }
            class UR {
                constructor(e) { this.size = e, this.minimums = [], this.maximums = [], this.leaves = []; }
                getElevation(e, i) { const c = this.toIdx(e, i); return { min: this.minimums[c], max: this.maximums[c] }; }
                isLeaf(e, i) { return this.leaves[this.toIdx(e, i)]; }
                toIdx(e, i) { return i * this.size + e; }
            }
            function $R(a, e, i, c) { let h = 0, p = Number.MAX_VALUE; for (let m = 0; m < 3; m++)
                if (Math.abs(c[m]) < 1e-15) {
                    if (i[m] < a[m] || i[m] > e[m])
                        return null;
                }
                else {
                    const x = 1 / c[m];
                    let b = (a[m] - i[m]) * x, S = (e[m] - i[m]) * x;
                    if (b > S) {
                        const A = b;
                        b = S, S = A;
                    }
                    if (b > h && (h = b), S < p && (p = S), h > p)
                        return null;
                } return h; }
            function GR(a, e, i, c, h, p, m, x, b, S, A) { const I = c - a, M = h - e, z = p - i, F = m - a, U = x - e, X = b - i, Y = A[1] * X - A[2] * U, le = A[2] * F - A[0] * X, se = A[0] * U - A[1] * F, $ = I * Y + M * le + z * se; if (Math.abs($) < 1e-15)
                return null; const te = 1 / $, ae = S[0] - a, fe = S[1] - e, Te = S[2] - i, Pe = (ae * Y + fe * le + Te * se) * te; if (Pe < 0 || Pe > 1)
                return null; const Me = fe * z - Te * M, Oe = Te * I - ae * z, Ye = ae * M - fe * I, ut = (A[0] * Me + A[1] * Oe + A[2] * Ye) * te; return ut < 0 || Pe + ut > 1 ? null : (F * Me + U * Oe + X * Ye) * te; }
            function qR(a, e, i) { return (a - e) / (i - e); }
            function HR(a, e, i, c, h, p, m, x, b) { const S = 1 << i, A = p - c, I = m - h, M = (a + 1) / S * A + c, z = (e + 0) / S * I + h, F = (e + 1) / S * I + h; x[0] = (a + 0) / S * A + c, x[1] = z, b[0] = M, b[1] = F; }
            class WR {
                constructor(e) { if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = e, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
                    return; const i = function (p) { const m = Math.ceil(Math.log2(p.dim / 8)), x = []; let b = Math.ceil(Math.pow(2, m)); const S = 1 / b, A = (z, F, U, X, Y) => { const le = X ? 1 : 0, se = (z + 1) * U - le, $ = F * U, te = (F + 1) * U - le; Y[0] = z * U, Y[1] = $, Y[2] = se, Y[3] = te; }; let I = new UR(b); const M = []; for (let z = 0; z < b * b; z++) {
                    A(z % b, Math.floor(z / b), S, !1, M);
                    const F = ih(M[0], M[1], p), U = ih(M[2], M[1], p), X = ih(M[2], M[3], p), Y = ih(M[0], M[3], p);
                    I.minimums.push(Math.min(F, U, X, Y)), I.maximums.push(Math.max(F, U, X, Y)), I.leaves.push(1);
                } for (x.push(I), b /= 2; b >= 1; b /= 2) {
                    const z = x[x.length - 1];
                    I = new UR(b);
                    for (let F = 0; F < b * b; F++) {
                        A(F % b, Math.floor(F / b), 2, !0, M);
                        const U = z.getElevation(M[0], M[1]), X = z.getElevation(M[2], M[1]), Y = z.getElevation(M[2], M[3]), le = z.getElevation(M[0], M[3]), se = z.isLeaf(M[0], M[1]), $ = z.isLeaf(M[2], M[1]), te = z.isLeaf(M[2], M[3]), ae = z.isLeaf(M[0], M[3]), fe = Math.min(U.min, X.min, Y.min, le.min), Te = Math.max(U.max, X.max, Y.max, le.max), Pe = se && $ && te && ae;
                        I.maximums.push(Te), I.minimums.push(fe), I.leaves.push(Te - fe <= 5 && Pe ? 1 : 0);
                    }
                    x.push(I);
                } return x; }(this.dem), c = i.length - 1, h = i[c]; this._addNode(h.minimums[0], h.maximums[0], h.leaves[0]), this._construct(i, 0, 0, c, 0); }
                raycastRoot(e, i, c, h, p, m, x = 1) { return $R([e, i, -100], [c, h, this.maximums[0] * x], p, m); }
                raycast(e, i, c, h, p, m, x = 1) { if (!this.nodeCount)
                    return null; const b = this.raycastRoot(e, i, c, h, p, m, x); if (b == null)
                    return null; const S = [], A = [], I = [], M = [], z = [{ idx: 0, t: b, nodex: 0, nodey: 0, depth: 0 }]; for (; z.length > 0;) {
                    const { idx: F, t: U, nodex: X, nodey: Y, depth: le } = z.pop();
                    if (this.leaves[F]) {
                        HR(X, Y, le, e, i, c, h, I, M);
                        const $ = 1 << le, te = (X + 0) / $, ae = (X + 1) / $, fe = (Y + 0) / $, Te = (Y + 1) / $, Pe = ih(te, fe, this.dem) * x, Me = ih(ae, fe, this.dem) * x, Oe = ih(ae, Te, this.dem) * x, Ye = ih(te, Te, this.dem) * x, ut = GR(I[0], I[1], Pe, M[0], I[1], Me, M[0], M[1], Oe, p, m), it = GR(M[0], M[1], Oe, I[0], M[1], Ye, I[0], I[1], Pe, p, m), lt = Math.min(ut !== null ? ut : Number.MAX_VALUE, it !== null ? it : Number.MAX_VALUE);
                        if (lt !== Number.MAX_VALUE)
                            return lt;
                        {
                            const pt = gr([], p, m, U);
                            if (ZR(Pe, Me, Ye, Oe, qR(pt[0], I[0], M[0]), qR(pt[1], I[1], M[1])) >= pt[2])
                                return U;
                        }
                        continue;
                    }
                    let se = 0;
                    for (let $ = 0; $ < this._siblingOffset.length; $++) {
                        HR((X << 1) + this._siblingOffset[$][0], (Y << 1) + this._siblingOffset[$][1], le + 1, e, i, c, h, I, M), I[2] = -100, M[2] = this.maximums[this.childOffsets[F] + $] * x;
                        const te = $R(I, M, p, m);
                        if (te != null) {
                            const ae = te;
                            S[$] = ae;
                            let fe = !1;
                            for (let Te = 0; Te < se && !fe; Te++)
                                ae >= S[A[Te]] && (A.splice(Te, 0, $), fe = !0);
                            fe || (A[se] = $), se++;
                        }
                    }
                    for (let $ = 0; $ < se; $++) {
                        const te = A[$];
                        z.push({ idx: this.childOffsets[F] + te, t: S[te], nodex: (X << 1) + this._siblingOffset[te][0], nodey: (Y << 1) + this._siblingOffset[te][1], depth: le + 1 });
                    }
                } return null; }
                _addNode(e, i, c) { return this.minimums.push(e), this.maximums.push(i), this.leaves.push(c), this.childOffsets.push(0), this.nodeCount++; }
                _construct(e, i, c, h, p) { if (e[h].isLeaf(i, c) === 1)
                    return; this.childOffsets[p] || (this.childOffsets[p] = this.nodeCount); const m = h - 1, x = e[m]; let b = 0, S = 0; for (let A = 0; A < this._siblingOffset.length; A++) {
                    const I = 2 * i + this._siblingOffset[A][0], M = 2 * c + this._siblingOffset[A][1], z = x.getElevation(I, M), F = x.isLeaf(I, M), U = this._addNode(z.min, z.max, F);
                    F && (b |= 1 << A), S || (S = U);
                } for (let A = 0; A < this._siblingOffset.length; A++)
                    b & 1 << A || this._construct(e, 2 * i + this._siblingOffset[A][0], 2 * c + this._siblingOffset[A][1], m, S + A); }
            }
            function ZR(a, e, i, c, h, p) { return nr(nr(a, i, p), nr(e, c, p), h); }
            function ih(a, e, i) { const c = i.dim, h = ke(a * c - .5, 0, c - 1), p = ke(e * c - .5, 0, c - 1), m = Math.floor(h), x = Math.floor(p), b = Math.min(m + 1, c - 1), S = Math.min(x + 1, c - 1); return ZR(i.get(m, x), i.get(b, x), i.get(m, S), i.get(b, S), h - m, p - x); }
            const GV = { mapbox: [6553.6, 25.6, .1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
            function qV(a, e, i) { return (256 * a * 256 + 256 * e + i) / 10 - 1e4; }
            function HV(a, e, i) { return 256 * a + e + i / 256 - 32768; }
            class o1 {
                get tree() { return this._tree || this._buildQuadTree(), this._tree; }
                constructor(e, i, c, h = !1) { if (this.uid = e, i.height !== i.width)
                    throw new RangeError("DEM tiles must be square"); if (c && c !== "mapbox" && c !== "terrarium")
                    return void Br(`"${c}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`); this.stride = i.height; const p = this.dim = i.height - 2, m = new Uint32Array(i.data.buffer); if (this.pixels = new Uint8Array(i.data.buffer), this.floatView = new Float32Array(i.data.buffer), this.borderReady = h, this._modifiedForSources = {}, !h) {
                    for (let b = 0; b < p; b++)
                        m[this._idx(-1, b)] = m[this._idx(0, b)], m[this._idx(p, b)] = m[this._idx(p - 1, b)], m[this._idx(b, -1)] = m[this._idx(b, 0)], m[this._idx(b, p)] = m[this._idx(b, p - 1)];
                    m[this._idx(-1, -1)] = m[this._idx(0, 0)], m[this._idx(p, -1)] = m[this._idx(p - 1, 0)], m[this._idx(-1, p)] = m[this._idx(0, p - 1)], m[this._idx(p, p)] = m[this._idx(p - 1, p - 1)];
                } const x = c === "terrarium" ? HV : qV; for (let b = 0; b < m.length; ++b) {
                    const S = 4 * b;
                    this.floatView[b] = x(this.pixels[S], this.pixels[S + 1], this.pixels[S + 2]);
                } this._timestamp = Yo.now(); }
                _buildQuadTree() { this._tree = new WR(this); }
                get(e, i, c = !1) { c && (e = ke(e, -1, this.dim), i = ke(i, -1, this.dim)); const h = this._idx(e, i); return this.floatView[h]; }
                set(e, i, c) { const h = this._idx(e, i), p = this.floatView[h]; return this.floatView[h] = c, c - p; }
                static getUnpackVector(e) { return GV[e]; }
                _idx(e, i) { if (e < -1 || e >= this.dim + 1 || i < -1 || i >= this.dim + 1)
                    throw new RangeError("out of range source coordinates for DEM data"); return (i + 1) * this.stride + (e + 1); }
                static pack(e, i) { const c = [0, 0, 0, 0], h = o1.getUnpackVector(i); let p = Math.floor((e + h[3]) / h[2]); return c[2] = p % 256, p = Math.floor(p / 256), c[1] = p % 256, p = Math.floor(p / 256), c[0] = p, c; }
                getPixels() { return new XI({ width: this.stride, height: this.stride }, this.pixels); }
                backfillBorder(e, i, c) { if (this.dim !== e.dim)
                    throw new Error("dem dimension mismatch"); let h = i * this.dim, p = i * this.dim + this.dim, m = c * this.dim, x = c * this.dim + this.dim; switch (i) {
                    case -1:
                        h = p - 1;
                        break;
                    case 1: p = h + 1;
                } switch (c) {
                    case -1:
                        m = x - 1;
                        break;
                    case 1: x = m + 1;
                } const b = -i * this.dim, S = -c * this.dim; for (let A = m; A < x; A++)
                    for (let I = h; I < p; I++) {
                        const M = 4 * this._idx(I, A), z = 4 * this._idx(I + b, A + S);
                        this.pixels[M + 0] = e.pixels[z + 0], this.pixels[M + 1] = e.pixels[z + 1], this.pixels[M + 2] = e.pixels[z + 2], this.pixels[M + 3] = e.pixels[z + 3];
                    } }
                onDeserialize() { this._tree && (this._tree.dem = this); }
            }
            function WV(a, e, i) { a === 1 ? e.headerLength = i.readFixed32() : a === 2 ? e.x = i.readVarint() : a === 3 ? e.y = i.readVarint() : a === 4 ? e.z = i.readVarint() : a === 5 && e.layers.push(function (c, h) { return c.readFields(QV, { version: 0, name: "", units: "", tileSize: 0, buffer: 0, pixelFormat: 0, dataIndex: [] }, h); }(i, i.readVarint() + i.pos)); }
            function ZV(a, e, i) { a === 1 ? (e.delta_filter = function (c, h) { return c.readFields(XV, { blockSize: 0 }, h); }(i, i.readVarint() + i.pos), e.filter = "delta_filter") : a === 2 ? (i.readVarint(), e.filter = "zigzag_filter") : a === 3 ? (i.readVarint(), e.filter = "bitshuffle_filter") : a === 4 && (i.readVarint(), e.filter = "byteshuffle_filter"); }
            function XV(a, e, i) { a === 1 && (e.blockSize = i.readVarint()); }
            function KV(a, e, i) { a === 1 ? (i.readVarint(), e.codec = "gzip_data") : a === 2 ? (i.readVarint(), e.codec = "jpeg_image") : a === 3 ? (i.readVarint(), e.codec = "webp_image") : a === 4 && (i.readVarint(), e.codec = "png_image"); }
            function YV(a, e, i) { let c = 0, h = 0; a === 1 ? e.firstByte = i.readFixed64() : a === 2 ? e.lastByte = i.readFixed64() : a === 3 ? e.filters.push(function (p, m) { return p.readFields(ZV, {}, m); }(i, i.readVarint() + i.pos)) : a === 4 ? e.codec = function (p, m) { return p.readFields(KV, {}, m); }(i, i.readVarint() + i.pos) : a === 5 ? h = i.readFloat() : a === 6 ? c = i.readFloat() : a === 7 ? e.bands.push(i.readString()) : a === 8 ? e.offset = i.readDouble() : a === 9 && (e.scale = i.readDouble()), e.offset === 0 && (e.offset = h), e.scale === 0 && (e.scale = c); }
            function QV(a, e, i) { a === 1 ? e.version = i.readVarint() : a === 2 ? e.name = i.readString() : a === 3 ? e.units = i.readString() : a === 4 ? e.tileSize = i.readVarint() : a === 5 ? e.buffer = i.readVarint() : a === 6 ? e.pixelFormat = i.readVarint() : a === 7 && e.dataIndex.push(function (c, h) { return c.readFields(YV, { firstByte: 0, lastByte: 0, filters: [], codec: null, offset: 0, scale: 0, bands: [] }, h); }(i, i.readVarint() + i.pos)); }
            function JV(a, e, i) { if (a === 2)
                (function (c, h, p) { c.readFields(eU, p, h); })(i, i.readVarint() + i.pos, e);
            else if (a === 3)
                throw new Error("Not implemented"); }
            function eU(a, e, i) { if (a === 1) {
                let c = 0;
                const h = i.readVarint() + i.pos;
                for (; i.pos < h;)
                    e[c++] = i.readVarint();
            } }
            function tU(a, e) { if (e.length !== 4)
                throw new Error(`Expected data of dimension 4 but got ${e.length}.`); let i = e[3]; for (let c = 2; c >= 1; c--) {
                const h = c === 1 ? 1 : 0, p = c === 2 ? 1 : 0;
                for (let m = 0; m < e[0]; m++) {
                    const x = e[1] * m;
                    for (let b = h; b < e[1]; b++) {
                        const S = e[2] * (b + x);
                        for (let A = p; A < e[2]; A++) {
                            const I = e[3] * (A + S);
                            for (let M = 0; M < e[3]; M++) {
                                const z = I + M;
                                a[z] += a[z - i];
                            }
                        }
                    }
                }
                i *= e[c];
            } return a; }
            function rU(a) { for (let e = 0, i = a.length; e < i; e++)
                a[e] = a[e] >>> 1 ^ -(1 & a[e]); return a; }
            function nU(a, e) { switch (e) {
                case "uint32": return a;
                case "uint16":
                    for (let i = 0; i < a.length; i += 2) {
                        const c = a[i], h = a[i + 1];
                        a[i] = (240 & c) >> 4 | (61440 & c) >> 8 | (240 & h) << 4 | 61440 & h, a[i + 1] = 15 & c | (3840 & c) >> 4 | (15 & h) << 8 | (3840 & h) << 4;
                    }
                    return a;
                case "uint8":
                    for (let i = 0; i < a.length; i += 4) {
                        const c = a[i], h = a[i + 1], p = a[i + 2], m = a[i + 3];
                        a[i + 0] = (192 & c) >> 6 | (192 & h) >> 4 | (192 & p) >> 2 | 192 & m, a[i + 1] = (48 & c) >> 4 | (48 & h) >> 2 | 48 & p | (48 & m) << 2, a[i + 2] = (12 & c) >> 2 | 12 & h | (12 & p) << 2 | (12 & m) << 4, a[i + 3] = 3 & c | (3 & h) << 2 | (3 & p) << 4 | (3 & m) << 6;
                    }
                    return a;
                default: throw new Error(`Invalid pixel format, "${e}"`);
            } }
            Nt(o1, "DEMData"), Nt(WR, "DemMinMaxQuadTree", { omit: ["dem"] });
            var la = Uint8Array, my = Uint16Array, iU = Int32Array, XR = new la([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), KR = new la([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), sU = new la([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), YR = function (a, e) { for (var i = new my(31), c = 0; c < 31; ++c)
                i[c] = e += 1 << a[c - 1]; var h = new iU(i[30]); for (c = 1; c < 30; ++c)
                for (var p = i[c]; p < i[c + 1]; ++p)
                    h[p] = p - i[c] << 5 | c; return { b: i, r: h }; }, QR = YR(XR, 2), JR = QR.b, oU = QR.r;
            JR[28] = 258, oU[258] = 28;
            for (var aU = YR(KR, 0).b, ek = new my(32768), zi = 0; zi < 32768; ++zi) {
                var im = (43690 & zi) >> 1 | (21845 & zi) << 1;
                ek[zi] = ((65280 & (im = (61680 & (im = (52428 & im) >> 2 | (13107 & im) << 2)) >> 4 | (3855 & im) << 4)) >> 8 | (255 & im) << 8) >> 1;
            }
            var gy = function (a, e, i) { for (var c = a.length, h = 0, p = new my(e); h < c; ++h)
                a[h] && ++p[a[h] - 1]; var m, x = new my(e); for (h = 1; h < e; ++h)
                x[h] = x[h - 1] + p[h - 1] << 1; m = new my(1 << e); var b = 15 - e; for (h = 0; h < c; ++h)
                if (a[h])
                    for (var S = h << 4 | a[h], A = e - a[h], I = x[a[h] - 1]++ << A, M = I | (1 << A) - 1; I <= M; ++I)
                        m[ek[I] >> b] = S; return m; }, _y = new la(288);
            for (zi = 0; zi < 144; ++zi)
                _y[zi] = 8;
            for (zi = 144; zi < 256; ++zi)
                _y[zi] = 9;
            for (zi = 256; zi < 280; ++zi)
                _y[zi] = 7;
            for (zi = 280; zi < 288; ++zi)
                _y[zi] = 8;
            var tk = new la(32);
            for (zi = 0; zi < 32; ++zi)
                tk[zi] = 5;
            var lU = gy(_y, 9), cU = gy(tk, 5), DS = function (a) { for (var e = a[0], i = 1; i < a.length; ++i)
                a[i] > e && (e = a[i]); return e; }, il = function (a, e, i) { var c = e / 8 | 0; return (a[c] | a[c + 1] << 8) >> (7 & e) & i; }, LS = function (a, e) { var i = e / 8 | 0; return (a[i] | a[i + 1] << 8 | a[i + 2] << 16) >> (7 & e); }, uU = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], sl = function (a, e, i) { var c = new Error(e || uU[a]); if (c.code = a, Error.captureStackTrace && Error.captureStackTrace(c, sl), !i)
                throw c; return c; }, hU = new la(0), dU = typeof TextDecoder < "u" && new TextDecoder;
            try {
                dU.decode(hU, { stream: !0 });
            }
            catch { }
            const fU = { gzip_data: "gzip" };
            class Ma extends Error {
                constructor(e) { super(e), this.name = "MRTError"; }
            }
            const pU = { 0: "uint32", 1: "uint32", 2: "uint16", 3: "uint8" }, rk = { uint32: 1, uint16: 2, uint8: 4 }, mU = { uint32: Uint32Array, uint16: Uint16Array, uint8: Uint8Array };
            let OS;
            class a1 {
                constructor(e = 5) { this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = e; }
                getLayer(e) { const i = this.layers[e]; if (!i)
                    throw new Ma(`Layer '${e}' not found`); return i; }
                getHeaderLength(e) { const i = new Uint8Array(e), c = new DataView(e); if (i[0] !== 13)
                    throw new Ma("File is not a valid MRT."); return c.getUint32(1, !0); }
                parseHeader(e) { const i = new Uint8Array(e), c = this.getHeaderLength(e); if (i.length < c)
                    throw new Ma(`Expected header with length >= ${c} but got buffer of length ${i.length}`); const h = function (p, m) { return p.readFields(WV, { headerLength: 0, x: 0, y: 0, z: 0, layers: [] }, void 0); }(new OS(i.subarray(0, c))); if (!isNaN(this.x) && (this.x !== h.x || this.y !== h.y || this.z !== h.z))
                    throw new Ma(`Invalid attempt to parse header ${h.z}/${h.x}/${h.y} for tile ${this.z}/${this.x}/${this.y}`); this.x = h.x, this.y = h.y, this.z = h.z; for (const p of h.layers)
                    this.layers[p.name] = new nk(p, { cacheSize: this._cacheSize }); return this; }
                createDecodingTask(e) { const i = [], c = this.getLayer(e.layerName); for (let h of e.blockIndices) {
                    const p = c.dataIndex[h], m = p.firstByte - e.firstByte, x = p.lastByte - e.firstByte;
                    if (c._blocksInProgress.has(h))
                        continue;
                    const b = { layerName: c.name, firstByte: m, lastByte: x, pixelFormat: c.pixelFormat, blockIndex: h, blockShape: [p.bands.length].concat(c.bandShape), buffer: c.buffer, codec: p.codec.codec, filters: p.filters.map(S => S.filter) };
                    c._blocksInProgress.add(h), i.push(b);
                } return new ik(i, () => { i.forEach(h => c._blocksInProgress.delete(h.blockIndex)); }, (h, p) => { if (i.forEach(m => c._blocksInProgress.delete(m.blockIndex)), h)
                    throw h; p.forEach(m => { this.getLayer(m.layerName).processDecodedData(m); }); }); }
            }
            class nk {
                constructor({ version: e, name: i, units: c, tileSize: h, pixelFormat: p, buffer: m, dataIndex: x }, b) { if (this.version = e, this.version !== 1)
                    throw new Ma(`Cannot parse raster layer encoded with MRT version ${e}`); this.name = i, this.units = c, this.tileSize = h, this.buffer = m, this.pixelFormat = pU[p], this.dataIndex = x, this.bandShape = [h + 2 * m, h + 2 * m, rk[this.pixelFormat]], this._decodedBlocks = new s1(b ? b.cacheSize : 5), this._blocksInProgress = new Set; }
                get dimension() { return rk[this.pixelFormat]; }
                get cacheSize() { return this._decodedBlocks.capacity; }
                getBandList() { return this.dataIndex.map(({ bands: e }) => e).flat(); }
                processDecodedData(e) { const i = e.blockIndex.toString(); this._decodedBlocks.get(i) || this._decodedBlocks.put(i, e.data); }
                getBlockForBand(e) { let i = 0; switch (typeof e) {
                    case "string":
                        for (const [c, h] of this.dataIndex.entries()) {
                            for (const [p, m] of h.bands.entries())
                                if (m === e)
                                    return { bandIndex: i + p, blockIndex: c, blockBandIndex: p };
                            i += h.bands.length;
                        }
                        break;
                    case "number":
                        for (const [c, h] of this.dataIndex.entries()) {
                            if (e >= i && e < i + h.bands.length)
                                return { bandIndex: e, blockIndex: c, blockBandIndex: e - i };
                            i += h.bands.length;
                        }
                        break;
                    default: throw new Ma(`Invalid band \`${JSON.stringify(e)}\`. Expected string or integer.`);
                } return { blockIndex: -1, blockBandIndex: -1 }; }
                getDataRange(e) { let i = 1 / 0, c = -1 / 0; const h = [], p = new Set; for (const m of e) {
                    const { blockIndex: x } = this.getBlockForBand(m);
                    if (x < 0)
                        throw new Ma(`Invalid band: ${JSON.stringify(m)}`);
                    const b = this.dataIndex[x];
                    h.includes(x) || h.push(x), p.add(x), i = Math.min(i, b.firstByte), c = Math.max(c, b.lastByte);
                } if (p.size > this.cacheSize)
                    throw new Ma(`Number of blocks to decode (${p.size}) exceeds cache size (${this.cacheSize}).`); return { layerName: this.name, firstByte: i, lastByte: c, blockIndices: h }; }
                hasBand(e) { const { blockIndex: i } = this.getBlockForBand(e); return i >= 0; }
                hasDataForBand(e) { const { blockIndex: i } = this.getBlockForBand(e); return i >= 0 && !!this._decodedBlocks.get(i.toString()); }
                getBandView(e) { const { blockIndex: i, blockBandIndex: c } = this.getBlockForBand(e); if (i < 0)
                    throw new Ma(`Band not found: ${JSON.stringify(e)}`); const h = this._decodedBlocks.get(i.toString()); if (!h)
                    throw new Ma(`Data for band ${JSON.stringify(e)} of layer "${this.name}" not decoded.`); const p = this.dataIndex[i], m = this.bandShape.reduce((S, A) => S * A, 1), x = c * m, b = h.subarray(x, x + m); return { data: b, bytes: new Uint8Array(b.buffer).subarray(b.byteOffset, b.byteOffset + b.byteLength), tileSize: this.tileSize, buffer: this.buffer, pixelFormat: this.pixelFormat, dimension: this.dimension, offset: p.offset, scale: p.scale }; }
            }
            a1.setPbf = function (a) { OS = a; };
            class ik {
                constructor(e, i, c) { this.tasks = e, this._onCancel = i, this._onComplete = c, this._finalized = !1; }
                cancel() { this._finalized || (this._onCancel(), this._finalized = !0); }
                complete(e, i) { this._finalized || (this._onComplete(e, i), this._finalized = !0); }
            }
            a1.performDecoding = function (a, e) { const i = new Uint8Array(a); return Promise.all(e.tasks.map(c => { const { layerName: h, firstByte: p, lastByte: m, pixelFormat: x, blockShape: b, blockIndex: S, filters: A, codec: I } = c, M = i.subarray(p, m + 1), z = new Uint32Array(b[0] * b[1] * b[2]); let F; if (I !== "gzip_data")
                throw new Ma(`Unhandled codec: ${I}`); return F = function (U, X) { if (!globalThis.DecompressionStream && X === "gzip_data")
                return Promise.resolve((($ = function (fe) { fe[0] == 31 && fe[1] == 139 && fe[2] == 8 || sl(6, "invalid gzip data"); var Te = fe[3], Pe = 10; 4 & Te && (Pe += 2 + (fe[10] | fe[11] << 8)); for (var Me = (Te >> 3 & 1) + (Te >> 4 & 1); Me > 0; Me -= !fe[Pe++])
                    ; return Pe + (2 & Te); }(se = U)) + 8 > se.length && sl(6, "invalid gzip data"), function (fe, Te, Pe, Me) { var Oe = fe.length; if (!Oe || Te.f && !Te.l)
                    return Pe || new la(0); var Ye = !Pe, ut = Ye || Te.i != 2, it = Te.i; Ye && (Pe = new la(3 * Oe)); var lt, pt, We = function (yi) { var Vn = Pe.length; if (yi > Vn) {
                    var Mn = new la(Math.max(2 * Vn, yi));
                    Mn.set(Pe), Pe = Mn;
                } }, at = Te.f || 0, Ge = Te.p || 0, Xe = Te.b || 0, gt = Te.l, yt = Te.d, Zt = Te.m, jt = Te.n, Rt = 8 * Oe; do {
                    if (!gt) {
                        at = il(fe, Ge, 1);
                        var mt = il(fe, Ge + 1, 3);
                        if (Ge += 3, !mt) {
                            var pr = fe[(he = 4 + ((Ge + 7) / 8 | 0)) - 4] | fe[he - 3] << 8, Gt = he + pr;
                            if (Gt > Oe) {
                                it && sl(0);
                                break;
                            }
                            ut && We(Xe + pr), Pe.set(fe.subarray(he, Gt), Xe), Te.b = Xe += pr, Te.p = Ge = 8 * Gt, Te.f = at;
                            continue;
                        }
                        if (mt == 1)
                            gt = lU, yt = cU, Zt = 9, jt = 5;
                        else if (mt == 2) {
                            var qt = il(fe, Ge, 31) + 257, hr = il(fe, Ge + 10, 15) + 4, wr = qt + il(fe, Ge + 5, 31) + 1;
                            Ge += 14;
                            for (var Tr = new la(wr), Lr = new la(19), Pr = 0; Pr < hr; ++Pr)
                                Lr[sU[Pr]] = il(fe, Ge + 3 * Pr, 7);
                            Ge += 3 * hr;
                            var Ar = DS(Lr), Tn = (1 << Ar) - 1, On = gy(Lr, Ar);
                            for (Pr = 0; Pr < wr;) {
                                var he, pe = On[il(fe, Ge, Tn)];
                                if (Ge += 15 & pe, (he = pe >> 4) < 16)
                                    Tr[Pr++] = he;
                                else {
                                    var Je = 0, Tt = 0;
                                    for (he == 16 ? (Tt = 3 + il(fe, Ge, 3), Ge += 2, Je = Tr[Pr - 1]) : he == 17 ? (Tt = 3 + il(fe, Ge, 7), Ge += 3) : he == 18 && (Tt = 11 + il(fe, Ge, 127), Ge += 7); Tt--;)
                                        Tr[Pr++] = Je;
                                }
                            }
                            var Lt = Tr.subarray(0, qt), Dt = Tr.subarray(qt);
                            Zt = DS(Lt), jt = DS(Dt), gt = gy(Lt, Zt), yt = gy(Dt, jt);
                        }
                        else
                            sl(1);
                        if (Ge > Rt) {
                            it && sl(0);
                            break;
                        }
                    }
                    ut && We(Xe + 131072);
                    for (var Ht = (1 << Zt) - 1, lr = (1 << jt) - 1, Vr = Ge;; Vr = Ge) {
                        var Ur = (Je = gt[LS(fe, Ge) & Ht]) >> 4;
                        if ((Ge += 15 & Je) > Rt) {
                            it && sl(0);
                            break;
                        }
                        if (Je || sl(2), Ur < 256)
                            Pe[Xe++] = Ur;
                        else {
                            if (Ur == 256) {
                                Vr = Ge, gt = null;
                                break;
                            }
                            var Ir = Ur - 254;
                            Ur > 264 && (Ir = il(fe, Ge, (1 << ($r = XR[Pr = Ur - 257])) - 1) + JR[Pr], Ge += $r);
                            var pn = yt[LS(fe, Ge) & lr], Pn = pn >> 4;
                            if (pn || sl(3), Ge += 15 & pn, Dt = aU[Pn], Pn > 3) {
                                var $r = KR[Pn];
                                Dt += LS(fe, Ge) & (1 << $r) - 1, Ge += $r;
                            }
                            if (Ge > Rt) {
                                it && sl(0);
                                break;
                            }
                            ut && We(Xe + 131072);
                            var ri = Xe + Ir;
                            if (Xe < Dt) {
                                var zn = 0 - Dt, hn = Math.min(Dt, ri);
                                for (zn + Xe < 0 && sl(3); Xe < hn; ++Xe)
                                    Pe[Xe] = (void 0)[zn + Xe];
                            }
                            for (; Xe < ri; ++Xe)
                                Pe[Xe] = Pe[Xe - Dt];
                        }
                    }
                    Te.l = gt, Te.p = Vr, Te.b = Xe, Te.f = at, gt && (at = 1, Te.m = Zt, Te.d = yt, Te.n = jt);
                } while (!at); return Xe != Pe.length && Ye ? (lt = Pe, ((pt = Xe) == null || pt > lt.length) && (pt = lt.length), new la(lt.subarray(0, pt))) : Pe.subarray(0, Xe); }(se.subarray($, -8), { i: 2 }, new la(((Y = se)[(le = Y.length) - 4] | Y[le - 3] << 8 | Y[le - 2] << 16 | Y[le - 1] << 24) >>> 0)))); var Y, le, se, $; const te = fU[X]; if (!te)
                throw new Error(`Unhandled codec: ${X}`); const ae = new globalThis.DecompressionStream(te); return new Response(new Blob([U]).stream().pipeThrough(ae)).arrayBuffer().then(fe => new Uint8Array(fe)); }(M, I).then(U => (function (X, Y) { X.readFields(JV, Y); }(new OS(U), z), new mU[x](z.buffer))), F.then(U => { for (let X = A.length - 1; X >= 0; X--)
                switch (A[X]) {
                    case "delta_filter":
                        tU(U, b);
                        break;
                    case "zigzag_filter":
                        rU(U);
                        break;
                    case "bitshuffle_filter":
                        nU(U, x);
                        break;
                    default: throw new Ma(`Unhandled filter "${A[X]}"`);
                } return { layerName: h, blockIndex: S, data: U }; }).catch(U => { throw U; }); })); }, Nt(ik, "MRTDecodingBatch", { omit: ["_onCancel", "_onComplete"] }), Nt(a1, "MapboxRasterTile"), Nt(nk, "MapboxRasterLayer", { omit: ["_blocksInProgress"] });
            let yy, zS, ol, sm, FS, om = null;
            function sk() { return Dn(self) && self.worker.dracoUrl ? self.worker.dracoUrl : zS || hs.DRACO_URL; }
            function ok() { if (Dn(self) && self.worker.meshoptUrl)
                return self.worker.meshoptUrl; if (sm)
                return sm; const a = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]); if (typeof WebAssembly != "object")
                throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer"); return sm = WebAssembly.validate(a) ? hs.MESHOPT_SIMD_URL : hs.MESHOPT_URL, sm; }
            const l1 = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, gU = { 5120: "DT_INT8", 5121: "DT_UINT8", 5122: "DT_INT16", 5123: "DT_UINT16", 5125: "DT_UINT32", 5126: "DT_FLOAT32" }, vy = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
            function ak(a, e, i) { const c = i.json.bufferViews.length, h = i.buffers.length; e.bufferView = c, i.json.bufferViews[c] = { buffer: h, byteLength: a.byteLength }, i.buffers[h] = a; }
            const NS = "KHR_draco_mesh_compression";
            function _U(a, e) { const i = a.extensions && a.extensions[NS]; if (!i)
                return; const c = new ol.Decoder, h = hk(e, i.bufferView), p = new ol.Mesh; if (!c.DecodeArrayToMesh(h, h.byteLength, p))
                throw new Error("Failed to decode Draco mesh"); const m = e.json.accessors[a.indices], x = l1[m.componentType], b = m.count * x.BYTES_PER_ELEMENT, S = ol._malloc(b); x === Uint16Array ? c.GetTrianglesUInt16Array(p, b, S) : c.GetTrianglesUInt32Array(p, b, S), ak(ol.memory.buffer.slice(S, S + b), m, e), ol._free(S); for (const A of Object.keys(i.attributes)) {
                const I = c.GetAttributeByUniqueId(p, i.attributes[A]), M = e.json.accessors[a.attributes[A]], z = gU[M.componentType], F = M.count * vy[M.type] * l1[M.componentType].BYTES_PER_ELEMENT, U = ol._malloc(F);
                c.GetAttributeDataArrayForAllPoints(p, I, ol[z], F, U), ak(ol.memory.buffer.slice(U, U + F), M, e), ol._free(U);
            } c.destroy(), p.destroy(), delete a.extensions[NS]; }
            const c1 = "EXT_meshopt_compression";
            function yU(a, e) { if (!a.extensions || !a.extensions[c1])
                return; const i = a.extensions[c1], c = new Uint8Array(e.buffers[i.buffer], i.byteOffset || 0, i.byteLength || 0), h = new Uint8Array(i.count * i.byteStride); FS.decodeGltfBuffer(h, i.count, i.byteStride, c, i.mode, i.filter), a.buffer = e.buffers.length, a.byteOffset = 0, e.buffers[a.buffer] = h.buffer, delete a.extensions[c1]; }
            const lk = 1179937895, ck = new TextDecoder("utf8");
            function uk(a, e) { return new URL(a, e).href; }
            function vU(a, e, i, c) { return fetch(uk(a.uri, c)).then(h => h.arrayBuffer()).then(h => { e.buffers[i] = h; }); }
            function hk(a, e) { const i = a.json.bufferViews[e]; return new Uint8Array(a.buffers[i.buffer], i.byteOffset || 0, i.byteLength); }
            function xU(a, e, i, c) { if (a.uri) {
                const h = uk(a.uri, c);
                return fetch(h).then(p => p.blob()).then(p => createImageBitmap(p)).then(p => { e.images[i] = p; });
            } if (a.bufferView !== void 0) {
                const h = hk(e, a.bufferView), p = new Blob([h], { type: a.mimeType });
                return createImageBitmap(p).then(m => { e.images[i] = m; });
            } }
            function dk(a, e = 0, i) { const c = { json: null, images: [], buffers: [] }; if (new Uint32Array(a, e, 1)[0] === lk) {
                const A = new Uint32Array(a, e);
                let I = 2;
                const M = (A[I++] >> 2) - 3, z = A[I++] >> 2;
                if (I++, c.json = JSON.parse(ck.decode(A.subarray(I, I + z))), I += z, I < M) {
                    const F = A[I++];
                    I++;
                    const U = e + (I << 2);
                    c.buffers[0] = a.slice(U, U + F);
                }
            }
            else
                c.json = JSON.parse(ck.decode(new Uint8Array(a, e))); const { buffers: h, images: p, meshes: m, extensionsUsed: x, bufferViews: b } = c.json; let S = Promise.resolve(); if (h) {
                const A = [];
                for (let I = 0; I < h.length; I++) {
                    const M = h[I];
                    M.uri ? A.push(vU(M, c, I, i)) : c.buffers[I] || (c.buffers[I] = null);
                }
                S = Promise.all(A);
            } return S.then(() => { const A = [], I = x && x.includes(NS), M = x && x.includes(c1); if (I && A.push(function () { if (!ol)
                return yy ?? (yy = function (z) { let F, U = null; function X() { F = new Uint8Array(U.buffer); } function Y() { throw new Error("Unexpected Draco error."); } const le = { a: { a: Y, d: function (se, $, te) { return F.copyWithin(se, $, $ + te); }, c: function (se) { const $ = F.length, te = Math.max(se >>> 0, Math.ceil(1.2 * $)), ae = Math.ceil((te - $) / 65536); try {
                            return U.grow(ae), X(), !0;
                        }
                        catch {
                            return !1;
                        } }, b: Y } }; return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(z, le) : z.then(se => se.arrayBuffer()).then(se => WebAssembly.instantiate(se, le))).then(se => { const { Rb: $, Qb: te, P: ae, T: fe, X: Te, Ja: Pe, La: Me, Qa: Oe, Va: Ye, Wa: ut, eb: it, jb: lt, f: pt, e: We, yb: at, zb: Ge, Ab: Xe, Bb: gt, Db: yt, Gb: Zt } = se.instance.exports; U = We; const jt = (() => { let Rt = 0, mt = 0, pr = 0, Gt = 0; return qt => { pr && ($(Gt), $(Rt), mt += pr, pr = Rt = 0), Rt || (mt += 128, Rt = te(mt)); const hr = qt.length + 7 & -8; let wr = Rt; hr >= mt && (pr = hr, wr = Gt = te(hr)); for (let Tr = 0; Tr < qt.length; Tr++)
                    F[wr + Tr] = qt[Tr]; return wr; }; })(); return X(), pt(), { memory: We, _free: $, _malloc: te, Mesh: class {
                        constructor() { this.ptr = ae(); }
                        destroy() { fe(this.ptr); }
                    }, Decoder: class {
                        constructor() { this.ptr = Pe(); }
                        destroy() { lt(this.ptr); }
                        DecodeArrayToMesh(Rt, mt, pr) { const Gt = jt(Rt), qt = Me(this.ptr, Gt, mt, pr.ptr); return !!Te(qt); }
                        GetAttributeByUniqueId(Rt, mt) { return { ptr: Oe(this.ptr, Rt.ptr, mt) }; }
                        GetTrianglesUInt16Array(Rt, mt, pr) { Ye(this.ptr, Rt.ptr, mt, pr); }
                        GetTrianglesUInt32Array(Rt, mt, pr) { ut(this.ptr, Rt.ptr, mt, pr); }
                        GetAttributeDataArrayForAllPoints(Rt, mt, pr, Gt, qt) { it(this.ptr, Rt.ptr, mt.ptr, pr, Gt, qt); }
                    }, DT_INT8: at(), DT_UINT8: Ge(), DT_INT16: Xe(), DT_UINT16: gt(), DT_UINT32: yt(), DT_FLOAT32: Zt() }; }); }(fetch(sk())), yy.then(z => { ol = z, yy = void 0; })); }()), M && A.push(function () { if (FS)
                return; const z = function (F) { let U; const X = WebAssembly.instantiateStreaming(F, {}).then(se => { U = se.instance, U.exports.__wasm_call_ctors(); }), Y = { NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, le = { ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" }; return { ready: X, supported: !0, decodeGltfBuffer(se, $, te, ae, fe, Te) { (function (Pe, Me, Oe, Ye, ut, it, lt) { const pt = Pe.exports.sbrk, We = Ye + 3 & -4, at = pt(We * ut), Ge = pt(it.length), Xe = new Uint8Array(Pe.exports.memory.buffer); Xe.set(it, Ge); const gt = Me(at, Ye, ut, Ge, it.length); if (gt === 0 && lt && lt(at, We, ut), Oe.set(Xe.subarray(at, at + Ye * ut)), pt(at - pt(0)), gt !== 0)
                    throw new Error(`Malformed buffer data: ${gt}`); })(U, U.exports[le[fe]], se, $, te, ae, U.exports[Y[Te]]); } }; }(fetch(ok())); return z.ready.then(() => { FS = z; }); }()), p)
                for (let z = 0; z < p.length; z++)
                    A.push(xU(p[z], c, z, i)); return (A.length ? Promise.all(A) : Promise.resolve()).then(() => { if (I && m)
                for (const { primitives: z } of m)
                    for (const F of z)
                        _U(F, c); if (M && m && b)
                for (const z of b)
                    yU(z, c); return c; }); }); }
            function rf(a, e) { const i = a.json.bufferViews[e.bufferView], c = l1[e.componentType]; return new c(a.buffers[i.buffer], (e.byteOffset || 0) + (i.byteOffset || 0), e.count * (i.byteStride && i.byteStride !== vy[e.type] * c.BYTES_PER_ELEMENT ? i.byteStride / c.BYTES_PER_ELEMENT : vy[e.type])); }
            function BS(a, e, i, c) { const h = l1[e.componentType], p = function (A) { switch (A) {
                case Int8Array: return 1 / 127;
                case Uint8Array: return 1 / 255;
                case Int16Array: return 1 / 32767;
                case Uint16Array: return 1 / 65535;
                default: return 1;
            } }(h), m = a.json.bufferViews[e.bufferView], x = m.byteStride ? m.byteStride / h.BYTES_PER_ELEMENT : vy[e.type], b = i.float32, S = b.length / i.capacity; for (let A = 0, I = 0; A < e.count * x; A += x, I += S)
                for (let M = 0; M < S; M++)
                    b[I + M] = c[A + M] * p; i._trim(); }
            function wU(a, e, i) { const c = a.indices, h = a.attributes, p = {}; p.indexArray = new Hi; const m = e.json.accessors[c], x = m.count / 3; p.indexArray.reserve(x); const b = rf(e, m); for (let M = 0; M < x; M++)
                p.indexArray.emplaceBack(b[3 * M], b[3 * M + 1], b[3 * M + 2]); p.indexArray._trim(), p.vertexArray = new Ea; const S = e.json.accessors[h.POSITION]; p.vertexArray.reserve(S.count); const A = rf(e, S); for (let M = 0; M < S.count; M++)
                p.vertexArray.emplaceBack(A[3 * M], A[3 * M + 1], A[3 * M + 2]); if (p.vertexArray._trim(), p.aabb = new Wn(S.min, S.max), p.centroid = function (M, z) { const F = [0, 0, 0], U = M.length; if (U > 0) {
                for (let X = 0; X < U; X++) {
                    const Y = 3 * M[X];
                    F[0] += z[Y], F[1] += z[Y + 1], F[2] += z[Y + 2];
                }
                F[0] /= U, F[1] /= U, F[2] /= U;
            } return F; }(b, A), h.COLOR_0 !== void 0) {
                const M = e.json.accessors[h.COLOR_0], z = vy[M.type], F = rf(e, M);
                p.colorArray = z === 3 ? new Ea : new Ca, p.colorArray.resize(M.count), BS(e, M, p.colorArray, F);
            } if (h.NORMAL !== void 0) {
                p.normalArray = new Ea;
                const M = e.json.accessors[h.NORMAL];
                p.normalArray.resize(M.count);
                const z = rf(e, M);
                BS(e, M, p.normalArray, z);
            } if (h.TEXCOORD_0 !== void 0 && i.length > 0) {
                p.texcoordArray = new Vc;
                const M = e.json.accessors[h.TEXCOORD_0];
                p.texcoordArray.resize(M.count);
                const z = rf(e, M);
                BS(e, M, p.texcoordArray, z);
            } if (h._FEATURE_ID_RGBA4444 !== void 0) {
                const M = e.json.accessors[h._FEATURE_ID_RGBA4444];
                e.json.extensionsUsed && e.json.extensionsUsed.includes("EXT_meshopt_compression") && (p.featureData = rf(e, M));
            } h._FEATURE_RGBA4444 !== void 0 && (p.featureData = new Uint32Array(rf(e, e.json.accessors[h._FEATURE_RGBA4444]).buffer)); const I = a.material; return p.material = function (M, z) { const { emissiveFactor: F = [0, 0, 0], alphaMode: U = "OPAQUE", alphaCutoff: X = .5, normalTexture: Y, occlusionTexture: le, emissiveTexture: se, doubleSided: $ } = M, { baseColorFactor: te = [1, 1, 1, 1], metallicFactor: ae = 1, roughnessFactor: fe = 1, baseColorTexture: Te, metallicRoughnessTexture: Pe } = M.pbrMetallicRoughness || {}, Me = le ? z[le.index] : void 0; if (le && le.extensions && le.extensions.KHR_texture_transform && Me) {
                const Oe = le.extensions.KHR_texture_transform;
                Me.offsetScale = [Oe.offset[0], Oe.offset[1], Oe.scale[0], Oe.scale[1]];
            } return { pbrMetallicRoughness: { baseColorFactor: new nn(...te), metallicFactor: ae, roughnessFactor: fe, baseColorTexture: Te ? z[Te.index] : void 0, metallicRoughnessTexture: Pe ? z[Pe.index] : void 0 }, doubleSided: $, emissiveFactor: F, alphaMode: U, alphaCutoff: X, normalTexture: Y ? z[Y.index] : void 0, occlusionTexture: Me, emissionTexture: se ? z[se.index] : void 0, defined: M.defined === void 0 }; }(I !== void 0 ? e.json.materials[I] : { defined: !1 }, i), p; }
            function fk(a, e, i) { const { matrix: c, rotation: h, translation: p, scale: m, mesh: x, extras: b, children: S } = a, A = {}; if (A.matrix = c || function (I, M, z, F) { var U = M[0], X = M[1], Y = M[2], le = M[3], se = U + U, $ = X + X, te = Y + Y, ae = U * se, fe = U * $, Te = U * te, Pe = X * $, Me = X * te, Oe = Y * te, Ye = le * se, ut = le * $, it = le * te, lt = F[0], pt = F[1], We = F[2]; return I[0] = (1 - (Pe + Oe)) * lt, I[1] = (fe + it) * lt, I[2] = (Te - ut) * lt, I[3] = 0, I[4] = (fe - it) * pt, I[5] = (1 - (ae + Oe)) * pt, I[6] = (Me + Ye) * pt, I[7] = 0, I[8] = (Te + ut) * We, I[9] = (Me - Ye) * We, I[10] = (1 - (ae + Pe)) * We, I[11] = 0, I[12] = z[0], I[13] = z[1], I[14] = z[2], I[15] = 1, I; }([], h || [0, 0, 0, 1], p || [0, 0, 0], m || [1, 1, 1]), x !== void 0) {
                A.meshes = i[x];
                const I = A.anchor = [0, 0];
                for (const M of A.meshes) {
                    const { min: z, max: F } = M.aabb;
                    I[0] += z[0] + F[0], I[1] += z[1] + F[1];
                }
                I[0] = Math.floor(I[0] / A.meshes.length / 2), I[1] = Math.floor(I[1] / A.meshes.length / 2);
            } if (b && (b.id && (A.id = b.id), b.lights && (A.lights = function (I) { if (!I.length)
                return []; const M = function (Y) { const le = atob(Y), se = new Uint8Array(le.length); for (let $ = 0; $ < le.length; $++)
                se[$] = le.codePointAt($); return se; }(I), z = [], F = M.length / 24, U = new Uint16Array(M.buffer), X = new Float32Array(M.buffer); for (let Y = 0; Y < F; Y++) {
                const le = U[2 * Y * 6] / 30, se = U[2 * Y * 6 + 1] / 30, $ = U[2 * Y * 6 + 10] / 100, te = X[6 * Y + 1], ae = X[6 * Y + 2], fe = X[6 * Y + 3], Te = X[6 * Y + 4], Pe = fe - te, Me = Te - ae, Oe = Math.hypot(Pe, Me);
                z.push({ pos: [te + .5 * Pe, ae + .5 * Me, se], normal: [Me / Oe, -Pe / Oe, 0], width: Oe, height: le, depth: $, points: [te, ae, fe, Te] });
            } return z; }(b.lights))), S) {
                const I = [];
                for (const M of S)
                    I.push(fk(e.json.nodes[M], e, i));
                A.children = I;
            } return A; }
            function bU(a) { if (a.vertices.length === 0 || a.indices.length === 0)
                return null; const e = new $T(a.vertices, a.indices, 8, 256), [i, c] = [e.min.clone(), e.max.clone()]; return { vertices: a.vertices, indices: a.indices, grid: e, min: i, max: c }; }
            function TU(a) { if (!a.extras || !a.extras.ground)
                return null; const e = a.extras.ground; if (!e || !Array.isArray(e) || e.length === 0)
                return null; const i = e[0]; if (!i || !Array.isArray(i) || i.length === 0)
                return null; const c = []; for (const m of i) {
                if (!Array.isArray(m) || m.length !== 2)
                    continue;
                const x = m[0], b = m[1];
                typeof x == "number" && typeof b == "number" && c.push(new Et(x, b));
            } if (c.length < 3)
                return null; c.length > 1 && c[c.length - 1].equals(c[0]) && c.pop(); let h = 0; for (let m = 0; m < c.length; m++) {
                const x = c[m], b = c[(m + 1) % c.length], S = c[(m + 2) % c.length];
                h += (x.x - b.x) * (S.y - b.y) - (S.x - b.x) * (x.y - b.y);
            } h > 0 && c.reverse(); const p = U_(c.flatMap(m => [m.x, m.y]), []); return p.length === 0 ? null : { vertices: c, indices: p }; }
            function SU(a, e) { const i = [], c = []; let h = 0; const p = []; for (const m of a) {
                h = i.length;
                const x = m.vertexArray.float32, b = m.indexArray.uint16;
                for (let S = 0; S < m.vertexArray.length; S++)
                    p[0] = x[3 * S + 0], p[1] = x[3 * S + 1], p[2] = x[3 * S + 2], ln(p, p, e), i.push(new Et(p[0], p[1]));
                for (let S = 0; S < 3 * m.indexArray.length; S++)
                    c.push(b[S] + h);
            } if (c.length % 3 != 0)
                return null; for (let m = 0; m < c.length; m += 3) {
                const x = i[c[m + 0]], b = i[c[m + 1]], S = i[c[m + 2]];
                (x.x - b.x) * (S.y - b.y) - (S.x - b.x) * (x.y - b.y) > 0 && ([c[m + 1], c[m + 2]] = [c[m + 2], c[m + 1]]);
            } return { vertices: i, indices: c }; }
            function pk(a) { const e = function (b, S) { const A = [], I = WebGL2RenderingContext; if (b.json.textures)
                for (const M of b.json.textures) {
                    const z = { magFilter: I.LINEAR, minFilter: I.NEAREST, wrapS: I.REPEAT, wrapT: I.REPEAT };
                    M.sampler !== void 0 && Object.assign(z, b.json.samplers[M.sampler]), A.push({ image: S[M.source], sampler: z, uploaded: !1 });
                } return A; }(a, a.images), i = function (b, S) { const A = []; for (const I of b.json.meshes) {
                const M = [];
                for (const z of I.primitives)
                    M.push(wU(z, b, S));
                A.push(M);
            } return A; }(a, e), { scenes: c, scene: h, nodes: p } = a.json, m = c ? c[h || 0].nodes : p, x = []; for (const b of m)
                x.push(fk(p[b], a, i)); return function (b, S, A) { const I = {}, M = new Set; for (let z = 0; z < b.length; z++) {
                const F = A[S[z]];
                if (!F.extras)
                    continue;
                const U = F.extras["mapbox:footprint:version"], X = F.extras["mapbox:footprint:id"];
                (U || X) && M.add(z), U === "1.0.0" && X && (I[X] = z);
            } for (let z = 0; z < b.length; z++) {
                if (M.has(z))
                    continue;
                const F = b[z], U = A[S[z]];
                if (!U.extras)
                    continue;
                let X = null;
                F.id in I && (X = SU(b[I[F.id]].meshes, F.matrix)), X || (X = TU(U)), X && (F.footprint = bU(X));
            } if (M.size > 0) {
                const z = Array.from(M.values()).sort((F, U) => F - U);
                for (let F = z.length - 1; F >= 0; F--)
                    b.splice(z[F], 1);
            } }(x, m, a.json.nodes), x; }
            function EU(a) { a.heightmap = new Float32Array(4096), a.heightmap.fill(-1); const e = a.vertexArray.float32, i = a.aabb.min[0] - 1, c = a.aabb.min[1] - 1, h = Jd / (a.aabb.max[0] - i + 2), p = Jd / (a.aabb.max[1] - c + 2); for (let m = 0; m < e.length; m += 3) {
                const x = e[m + 2], b = (e[m + 0] - i) * h | 0, S = (e[m + 1] - c) * p | 0;
                x > a.heightmap[S * Jd + b] && (a.heightmap[S * Jd + b] = x);
            } }
            function CU(a, e) { const i = {}; i.indexArray = new Hi, i.indexArray.reserve(4 * a.length), i.vertexArray = new Ea, i.vertexArray.reserve(10 * a.length), i.colorArray = new Ca, i.vertexArray.reserve(10 * a.length); let c = 0; for (const m of a) {
                const x = Math.min(10, Math.max(4, 1.3 * m.height)) * e, b = [-m.normal[1], m.normal[0], 0], S = Math.min(.29, .1 * m.width / m.depth), A = m.width - 2 * m.depth * e * (S + .01), I = gr([], m.pos, b, A / 2), M = gr([], m.pos, b, -A / 2), z = [I[0], I[1], I[2] + m.height], F = [M[0], M[1], M[2] + m.height], U = gr([], m.normal, b, S);
                Ft(U, U, x);
                const X = gr([], m.normal, b, -S);
                Ft(X, X, x), ir(U, I, U), ir(X, M, X), I[2] += .1, M[2] += .1, i.vertexArray.emplaceBack(U[0], U[1], U[2]), i.vertexArray.emplaceBack(X[0], X[1], X[2]), i.vertexArray.emplaceBack(I[0], I[1], I[2]), i.vertexArray.emplaceBack(M[0], M[1], M[2]), i.vertexArray.emplaceBack(z[0], z[1], z[2]), i.vertexArray.emplaceBack(F[0], F[1], F[2]), i.vertexArray.emplaceBack(I[0], I[1], I[2]), i.vertexArray.emplaceBack(M[0], M[1], M[2]), i.vertexArray.emplaceBack(U[0], U[1], U[2]), i.vertexArray.emplaceBack(X[0], X[1], X[2]);
                const Y = A / x / 2;
                i.colorArray.emplaceBack(-Y - S, -1, Y, .8), i.colorArray.emplaceBack(Y + S, -1, Y, .8), i.colorArray.emplaceBack(-Y, 0, Y, 1.3), i.colorArray.emplaceBack(Y, 0, Y, 1.3), i.colorArray.emplaceBack(Y + S, -.8, Y, .7), i.colorArray.emplaceBack(Y + S, -.8, Y, .7), i.colorArray.emplaceBack(0, 0, Y, 1.3), i.colorArray.emplaceBack(0, 0, Y, 1.3), i.colorArray.emplaceBack(Y + S, -1.2, Y, .8), i.colorArray.emplaceBack(Y + S, -1.2, Y, .8), i.indexArray.emplaceBack(6 + c, 4 + c, 8 + c), i.indexArray.emplaceBack(7 + c, 9 + c, 5 + c), i.indexArray.emplaceBack(0 + c, 1 + c, 2 + c), i.indexArray.emplaceBack(1 + c, 3 + c, 2 + c), c += 10;
            } const h = { defined: !0, emissiveFactor: [0, 0, 0] }, p = {}; return p.baseColorFactor = nn.white, h.pbrMetallicRoughness = p, i.material = h, i.aabb = new Wn([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), i; }
            class mk {
                constructor(e) { this._stringToNumber = {}, this._numberToString = []; for (let i = 0; i < e.length; i++) {
                    const c = e[i];
                    this._stringToNumber[c] = i, this._numberToString[i] = c;
                } }
                encode(e) { return this._stringToNumber[e]; }
                decode(e) { return this._numberToString[e]; }
            }
            const AU = ["id", "tile", "layer", "source", "sourceLayer", "state"];
            class am {
                constructor(e, i, c, h, p) { this.type = "Feature", this._vectorTileFeature = e, this._z = i, this._x = c, this._y = h, this.properties = e.properties, this.id = p; }
                clone() { const e = new am(this._vectorTileFeature, this._z, this._x, this._y, this.id); return this.state && (e.state = Object.assign({}, this.state)), this.layer && (e.layer = Object.assign({}, this.layer)), this.source && (e.source = this.source), this.sourceLayer && (e.sourceLayer = this.sourceLayer), e; }
                get geometry() { return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry; }
                set geometry(e) { this._geometry = e; }
                toJSON() { const e = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties }; for (const i of AU)
                    this[i] !== void 0 && (e[i] = this[i]); return e; }
            }
            class gk {
                constructor(e, i) { this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new Fu(It, 16, 0), this.featureIndexArray = new cx, this.promoteId = i, this.is3DTile = !1, this.serializedLayersCache = new Map; }
                insert(e, i, c, h, p, m = 0, x = 0) { const b = this.featureIndexArray.length; this.featureIndexArray.emplaceBack(c, h, p, m); const S = this.grid; for (let A = 0; A < i.length; A++) {
                    const I = i[A], M = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    for (let z = 0; z < I.length; z++) {
                        const F = I[z];
                        M[0] = Math.min(M[0], F.x), M[1] = Math.min(M[1], F.y), M[2] = Math.max(M[2], F.x), M[3] = Math.max(M[3], F.y);
                    }
                    x !== 0 && (M[0] -= x, M[1] -= x, M[2] += x, M[3] += x), M[0] < It && M[1] < It && M[2] >= 0 && M[3] >= 0 && S.insert(b, M[0], M[1], M[2], M[3]);
                } }
                loadVTLayers() { if (!this.vtLayers) {
                    this.vtLayers = new Qu.VectorTile(new Mx(this.rawTileData)).layers, this.sourceLayerCoder = new mk(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
                    for (const e in this.vtLayers)
                        this.vtFeatures[e] = [];
                } return this.vtLayers; }
                query(e, i) { const { tilespaceGeometry: c, transform: h, tileTransform: p, pixelPosMatrix: m, availableImages: x } = i; this.loadVTLayers(), this.serializedLayersCache.clear(); const b = c.bufferedTilespaceBounds, S = this.grid.query(b.min.x, b.min.y, b.max.x, b.max.y, (z, F, U, X) => Ii(c.bufferedTilespaceGeometry, z, F, U, X)); S.sort(IU); let A = null; h.elevation && S.length > 0 && (A = tm.create(h.elevation, this.tileID)); const I = {}; let M; for (let z = 0; z < S.length; z++) {
                    const F = S[z];
                    if (F === M)
                        continue;
                    M = F;
                    const U = this.featureIndexArray.get(F);
                    let X = null;
                    this.is3DTile ? this.loadMatchingModelFeature(I, U, e, c, h) : this.loadMatchingFeature(I, U, e, x, (Y, le, se, $ = 0) => (X || (X = Vt(Y, this.tileID.canonical, p)), le.queryIntersectsFeature(c, Y, se, X, this.z, h, m, A, $)));
                } return I; }
                loadMatchingFeature(e, i, c, h, p) { const { featureIndex: m, bucketIndex: x, sourceLayerIndex: b, layoutVertexArrayOffset: S } = i, A = this.bucketLayerIDs[x], I = c.layers, M = Object.keys(I); if (M.length && !function (Y, le) { for (let se = 0; se < Y.length; se++)
                    if (le.indexOf(Y[se]) >= 0)
                        return !0; return !1; }(M, A))
                    return; const z = c.sourceCache, F = this.sourceLayerCoder.decode(b), U = this.vtLayers[F].feature(m), X = this.getId(U, F); for (let Y = 0; Y < A.length; Y++) {
                    const le = A[Y];
                    if (!I[le])
                        continue;
                    const { styleLayer: se, targets: $ } = I[le];
                    let te = {};
                    X !== void 0 && (te = z.getFeatureState(se.sourceLayer, X));
                    const ae = !p || p(U, se, te, S);
                    if (!ae)
                        continue;
                    const fe = new am(U, this.z, this.x, this.y, X);
                    fe.tile = this.tileID.canonical, fe.state = te;
                    let Te = this.serializedLayersCache.get(le);
                    Te || (Te = se.serialize(), Te.id = le, this.serializedLayersCache.set(le, Te)), fe.source = Te.source, fe.sourceLayer = Te["source-layer"], fe.layer = $e({}, Te), fe.layer.paint = _k(Te.paint, se.paint, U, te, h), fe.layer.layout = _k(Te.layout, se.layout, U, te, h);
                    let Pe = !1;
                    for (const Me of $) {
                        this.updateFeatureProperties(fe, Me);
                        const { filter: Oe } = Me;
                        if (Oe) {
                            if (U.properties = fe.properties, Oe.needGeometry) {
                                const Ye = Xt(U, !0);
                                if (!Oe.filter(new yn(this.tileID.overscaledZ), Ye, this.tileID.canonical))
                                    continue;
                            }
                            else if (!Oe.filter(new yn(this.tileID.overscaledZ), U))
                                continue;
                        }
                        Pe = !0, Me.targetId && this.addFeatureVariant(fe, Me);
                    }
                    Pe && this.appendToResult(e, le, m, fe, ae);
                } }
                loadMatchingModelFeature(e, i, c, h, p) { const m = this.bucketLayerIDs[0][0], x = c.layers; if (!x[m])
                    return; const { styleLayer: b, targets: S } = x[m]; if (b.type !== "model")
                    return; const A = h.tile, I = i.featureIndex, M = A.getBucket(b); if (!(M && M instanceof Qx))
                    return; const z = function (Te, Pe, Me, Oe) { const Ye = Te.getNodesInfo()[Pe]; if (Ye.hiddenByReplacement || !Ye.node.meshes)
                    return; let ut = Number.MAX_VALUE; const it = Ye.node, lt = Me.tile, pt = Oe.calculatePosMatrix(lt.tileID.toUnwrapped(), Oe.worldSize), We = Ye.evaluatedScale; let at = 0; Oe.elevation && it.elevation && (at = it.elevation * Oe.elevation.exaggeration()), Q(pt, pt, [(it.anchor ? it.anchor[0] : 0) * (We[0] - 1), (it.anchor ? it.anchor[1] : 0) * (We[1] - 1), at]), ue(pt, pt, We); const Ge = Me.queryGeometry, Xe = Ge.isPointQuery() ? Ge.screenBounds : Ge.screenGeometry, gt = function (Zt) { const jt = ie([], pt, Zt.matrix); ie(jt, Oe.expandedFarZProjMatrix, jt); for (let Rt = 0; Rt < Zt.meshes.length; ++Rt) {
                    const mt = Zt.meshes[Rt];
                    if (Rt === Zt.lightMeshIndex)
                        continue;
                    const pr = gR(Xe, Oe, jt, mt.aabb);
                    pr != null && (ut = Math.min(pr, ut));
                } if (Zt.children)
                    for (const Rt of Zt.children)
                        gt(Rt); }; if (gt(it), ut === Number.MAX_VALUE)
                    return; const yt = new W(0, 0); return AR(lt.tileID.canonical, yt, Ye.node.anchor[0], Ye.node.anchor[1]), { intersectionZ: ut, position: yt, feature: Ye.feature }; }(M, I, h, p); if (!z)
                    return; const { z: F, x: U, y: X } = A.tileID.canonical, { feature: Y, intersectionZ: le, position: se } = z; let $ = {}; Y.id !== void 0 && ($ = c.sourceCache.getFeatureState(b.sourceLayer, Y.id)); const te = new am({}, F, U, X, Y.id); te.tile = this.tileID.canonical, te.state = $, te.properties = Y.properties, te.geometry = { type: "Point", coordinates: [se.lng, se.lat] }; let ae = this.serializedLayersCache.get(m); ae || (ae = b.serialize(), ae.id = m, this.serializedLayersCache.set(m, ae)), te.source = ae.source, te.sourceLayer = ae["source-layer"], te.layer = $e({}, ae); let fe = !1; for (const Te of S) {
                    this.updateFeatureProperties(te, Te);
                    const { filter: Pe } = Te;
                    if (Pe) {
                        if (Y.properties = te.properties, Pe.needGeometry) {
                            if (!Pe.filter(new yn(this.tileID.overscaledZ), Y, this.tileID.canonical))
                                continue;
                        }
                        else if (!Pe.filter(new yn(this.tileID.overscaledZ), Y))
                            continue;
                    }
                    fe = !0, Te.targetId && this.addFeatureVariant(te, Te);
                } fe && this.appendToResult(e, m, I, te, le); }
                updateFeatureProperties(e, i, c) { if (i.properties) {
                    const h = {};
                    for (const p in i.properties) {
                        const m = i.properties[p].evaluate({ zoom: this.z }, e._vectorTileFeature, e.state, e.tile, c);
                        m != null && (h[p] = m);
                    }
                    e.properties = h;
                } }
                addFeatureVariant(e, i, c) { const h = { target: i.target, namespace: i.namespace, uniqueFeatureID: i.uniqueFeatureID }; i.properties && (h.properties = e.properties), e.variants = e.variants || {}, e.variants[i.targetId] = e.variants[i.targetId] || [], e.variants[i.targetId].push(h); }
                appendToResult(e, i, c, h, p) { let m = e[i]; m === void 0 && (m = e[i] = []), m.push({ featureIndex: c, feature: h, intersectionZ: p }); }
                lookupSymbolFeatures(e, i, c, h, p) { const m = {}; this.loadVTLayers(); for (const x of e)
                    this.loadMatchingFeature(m, { bucketIndex: i, sourceLayerIndex: c, featureIndex: x, layoutVertexArrayOffset: 0 }, h, p); return m; }
                loadFeature(e) { const { featureIndex: i, sourceLayerIndex: c } = e; this.loadVTLayers(); const h = this.sourceLayerCoder.decode(c), p = this.vtFeatures[h]; if (p[i])
                    return p[i]; const m = this.vtLayers[h].feature(i); return p[i] = m, m; }
                hasLayer(e) { for (const i of this.bucketLayerIDs)
                    for (const c of i)
                        if (e === c)
                            return !0; return !1; }
                getId(e, i) { let c = e.id; if (this.promoteId) {
                    const h = Array.isArray(this.promoteId) || typeof this.promoteId != "object" ? this.promoteId : this.promoteId[i];
                    if (h != null)
                        if (Array.isArray(h)) {
                            if (!this.promoteIdExpression) {
                                const p = Ou(h);
                                if (p.result !== "success") {
                                    const m = p.value.map(x => `${x.key}: ${x.message}`).join(", ");
                                    return void Br(`Failed to create expression for promoteId: ${m}`);
                                }
                                this.promoteIdExpression = p.value;
                            }
                            this.promoteIdExpression._evaluator || (this.promoteIdExpression._evaluator = new np), c = this.promoteIdExpression.evaluate({ zoom: 0 }, e);
                        }
                        else
                            c = e.properties[h];
                    typeof c == "boolean" && (c = Number(c));
                } return c; }
            }
            function _k(a, e, i, c, h) { return br(a, (p, m) => { const x = e instanceof zc ? e.get(m) : null; return x && x.evaluate ? x.evaluate(i, c, void 0, h) : x; }); }
            function IU(a, e) { return e - a; }
            Nt(gk, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
            const yk = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            class jS {
                static from(e) { if (!(e instanceof ArrayBuffer))
                    throw new Error("Data must be an instance of ArrayBuffer."); const [i, c] = new Uint8Array(e, 0, 2); if (i !== 219)
                    throw new Error("Data does not appear to be in a KDBush format."); const h = c >> 4; if (h !== 1)
                    throw new Error(`Got v${h} data when expected v1.`); const p = yk[15 & c]; if (!p)
                    throw new Error("Unrecognized array type."); const [m] = new Uint16Array(e, 2, 1), [x] = new Uint32Array(e, 4, 1); return new jS(x, m, p, e); }
                constructor(e, i = 64, c = Float64Array, h) { if (isNaN(e) || e < 0)
                    throw new Error(`Unpexpected numItems value: ${e}.`); this.numItems = +e, this.nodeSize = Math.min(Math.max(+i, 2), 65535), this.ArrayType = c, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array; const p = yk.indexOf(this.ArrayType), m = 2 * e * this.ArrayType.BYTES_PER_ELEMENT, x = e * this.IndexArrayType.BYTES_PER_ELEMENT, b = (8 - x % 8) % 8; if (p < 0)
                    throw new Error(`Unexpected typed array class: ${c}.`); h && h instanceof ArrayBuffer ? (this.data = h, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + x + b, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + m + x + b), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + x + b, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + p]), new Uint16Array(this.data, 2, 1)[0] = i, new Uint32Array(this.data, 4, 1)[0] = e); }
                add(e, i) { const c = this._pos >> 1; return this.ids[c] = c, this.coords[this._pos++] = e, this.coords[this._pos++] = i, c; }
                finish() { const e = this._pos >> 1; if (e !== this.numItems)
                    throw new Error(`Added ${e} items when expected ${this.numItems}.`); return VS(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this; }
                range(e, i, c, h) { if (!this._finished)
                    throw new Error("Data not yet indexed - call index.finish()."); const { ids: p, coords: m, nodeSize: x } = this, b = [0, p.length - 1, 0], S = []; for (; b.length;) {
                    const A = b.pop() || 0, I = b.pop() || 0, M = b.pop() || 0;
                    if (I - M <= x) {
                        for (let X = M; X <= I; X++) {
                            const Y = m[2 * X], le = m[2 * X + 1];
                            Y >= e && Y <= c && le >= i && le <= h && S.push(p[X]);
                        }
                        continue;
                    }
                    const z = M + I >> 1, F = m[2 * z], U = m[2 * z + 1];
                    F >= e && F <= c && U >= i && U <= h && S.push(p[z]), (A === 0 ? e <= F : i <= U) && (b.push(M), b.push(z - 1), b.push(1 - A)), (A === 0 ? c >= F : h >= U) && (b.push(z + 1), b.push(I), b.push(1 - A));
                } return S; }
                within(e, i, c) { if (!this._finished)
                    throw new Error("Data not yet indexed - call index.finish()."); const { ids: h, coords: p, nodeSize: m } = this, x = [0, h.length - 1, 0], b = [], S = c * c; for (; x.length;) {
                    const A = x.pop() || 0, I = x.pop() || 0, M = x.pop() || 0;
                    if (I - M <= m) {
                        for (let X = M; X <= I; X++)
                            xk(p[2 * X], p[2 * X + 1], e, i) <= S && b.push(h[X]);
                        continue;
                    }
                    const z = M + I >> 1, F = p[2 * z], U = p[2 * z + 1];
                    xk(F, U, e, i) <= S && b.push(h[z]), (A === 0 ? e - c <= F : i - c <= U) && (x.push(M), x.push(z - 1), x.push(1 - A)), (A === 0 ? e + c >= F : i + c >= U) && (x.push(z + 1), x.push(I), x.push(1 - A));
                } return b; }
            }
            function VS(a, e, i, c, h, p) { if (h - c <= i)
                return; const m = c + h >> 1; vk(a, e, m, c, h, p), VS(a, e, i, c, m - 1, 1 - p), VS(a, e, i, m + 1, h, 1 - p); }
            function vk(a, e, i, c, h, p) { for (; h > c;) {
                if (h - c > 600) {
                    const S = h - c + 1, A = i - c + 1, I = Math.log(S), M = .5 * Math.exp(2 * I / 3), z = .5 * Math.sqrt(I * M * (S - M) / S) * (A - S / 2 < 0 ? -1 : 1);
                    vk(a, e, i, Math.max(c, Math.floor(i - A * M / S + z)), Math.min(h, Math.floor(i + (S - A) * M / S + z)), p);
                }
                const m = e[2 * i + p];
                let x = c, b = h;
                for (xy(a, e, c, i), e[2 * h + p] > m && xy(a, e, c, h); x < b;) {
                    for (xy(a, e, x, b), x++, b--; e[2 * x + p] < m;)
                        x++;
                    for (; e[2 * b + p] > m;)
                        b--;
                }
                e[2 * c + p] === m ? xy(a, e, c, b) : (b++, xy(a, e, b, h)), b <= i && (c = b + 1), i <= b && (h = b - 1);
            } }
            function xy(a, e, i, c) { US(a, i, c), US(e, 2 * i, 2 * c), US(e, 2 * i + 1, 2 * c + 1); }
            function US(a, e, i) { const c = a[e]; a[e] = a[i], a[i] = c; }
            function xk(a, e, i, c) { const h = a - i, p = e - c; return h * h + p * p; }
            s.$ = vs, s.A = Al, s.B = ea, s.C = Nc, s.D = rm, s.E = wc, s.F = 2, s.G = ty, s.H = MM, s.I = eo, s.J = class extends Kx {
            }, s.K = fr, s.L = pd, s.M = ra, s.N = Sp, s.O = Tp, s.P = Et, s.Q = f_, s.R = Xf, s.S = Ap, s.T = _S, s.U = kp, s.V = Kx, s.W = Pd, s.X = Ou, s.Y = hp, s.Z = Mu, s._ = Td, s.a = function (a) { return hs.API_CDN_URL_REGEX.test(a); }, s.a$ = Ot, s.a0 = fd, s.a1 = Dp, s.a2 = Ep, s.a3 = U0, s.a4 = function (a) { const e = a.value; let i = []; if (!e)
                return i; const c = fr(e); return c !== "string" ? (i = i.concat([new Kx(a.key, e, `string expected, "${c}" found`)]), i) : (wS(e, !0) || (i = i.concat([new Kx(a.key, e, `invalid url "${e}"`)])), i); }, s.a5 = Ne, s.a6 = X0, s.a7 = gi, s.a8 = wt, s.a9 = class {
                constructor(a) { this.specification = a; }
                possiblyEvaluate(a, e) { return In(a.expression.evaluate(e)); }
                interpolate(a, e, i) { return { x: nr(a.x, e.x, i), y: nr(a.y, e.y, i), z: nr(a.z, e.z, i), azimuthal: nr(a.azimuthal, e.azimuthal, i), polar: nr(a.polar, e.polar, i) }; }
            }, s.aA = Gi, s.aB = xn, s.aC = st, s.aD = ke, s.aE = v, s.aF = function (a, e) { const i = {}; for (let c = 0; c < e.length; c++) {
                const h = e[c];
                h in a && (i[h] = a[h]);
            } return i; }, s.aG = oe, s.aH = xe, s.aI = class {
                constructor(a) { this.entries = {}, this.scheduler = a; }
                request(a, e, i, c) { const h = this.entries[a] = this.entries[a] || { callbacks: [] }; if (h.result) {
                    const [p, m] = h.result;
                    return this.scheduler ? this.scheduler.add(() => { c(p, m); }, e) : c(p, m), () => { };
                } return h.callbacks.push(c), h.cancel || (h.cancel = i((p, m) => { h.result = [p, m]; for (const x of h.callbacks)
                    this.scheduler ? this.scheduler.add(() => { x(p, m); }, e) : x(p, m); setTimeout(() => delete this.entries[a], 3e3); })), () => { h.result || (h.callbacks = h.callbacks.filter(p => p !== c), h.callbacks.length || (h.cancel(), delete this.entries[a])); }; }
            }, s.aJ = function (a, e, i) { const c = JSON.stringify(a.request); return a.data && (this.deduped.entries[c] = { result: [null, a.data] }), this.deduped.request(c, { type: "parseTile", isSymbolTile: a.isSymbolTile, zoom: a.tileZoom }, h => { const p = yu(a.request, (m, x, b, S) => { m ? h(m) : x && h(null, { vectorTile: i ? void 0 : new Qu.VectorTile(new Mx(x)), rawData: x, cacheControl: b, expires: S }); }); return () => { p.cancel(), h(); }; }, e); }, s.aK = function (a) { ud++, ud > Jo && (a.getActor().send("enforceCacheSizeLimit", Wa), ud = 0); }, s.aL = function (a) { return a <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(a) / Math.LN2)); }, s.aM = wi, s.aN = sR, s.aO = hR, s.aP = iR, s.aQ = function (a, e) { const i = document.createElement("video"); i.muted = !0, i.onloadstart = function () { e(null, i); }; for (let c = 0; c < a.length; c++) {
                const h = document.createElement("source");
                Hb(a[c]) || (i.crossOrigin = "Anonymous"), h.src = a[c], i.appendChild(h);
            } return { cancel: () => { } }; }, s.aR = qx, s.aS = function (a) { return fetch(a).then(e => e.arrayBuffer()).then(e => dk(e, 0, a)); }, s.aT = pk, s.aU = class {
                constructor(a, e, i, c) { this.id = a, this.position = e != null ? new W(e[0], e[1]) : new W(0, 0), this.orientation = i ?? [0, 0, 0], this.nodes = c, this.uploaded = !1, this.aabb = new Wn([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = []; }
                _applyTransformations(a, e) { if (ie(a.matrix, e, a.matrix), a.meshes)
                    for (const i of a.meshes) {
                        const c = Wn.applyTransformFast(i.aabb, a.matrix);
                        this.aabb.encapsulate(c);
                    } if (a.children)
                    for (const i of a.children)
                        this._applyTransformations(i, a.matrix); }
                computeBoundsAndApplyParent() { const a = J([]); for (const e of this.nodes)
                    this._applyTransformations(e, a); }
                computeModelMatrix(a, e, i, c, h, p, m = !1) { bR(this.matrix, this, a.transform, this.position, e, i, c, h, p, m); }
                upload(a) { if (!this.uploaded) {
                    for (const e of this.nodes)
                        TS(e, a);
                    for (const e of this.nodes)
                        Yx(e);
                    this.uploaded = !0;
                } }
                destroy() { for (const a of this.nodes)
                    SS(a); }
            }, s.aV = _r, s.aW = iy, s.aX = Se, s.aY = Ce, s.aZ = Bc, s.a_ = Hi, s.aa = yn, s.ab = zu, s.ac = Ve, s.ad = ln, s.ae = Kt, s.af = De, s.ag = zc, s.ah = Ku, s.ai = nr, s.aj = It, s.ak = g0, s.al = Z, s.am = nn, s.an = class {
                constructor(a) { this.specification = a; }
                possiblyEvaluate(a, e) { return function ([i, c]) { const h = In([1, i, c]); return { x: h.x, y: h.y, z: h.z }; }(a.expression.evaluate(e)); }
                interpolate(a, e, i) { return { x: nr(a.x, e.x, i), y: nr(a.y, e.y, i), z: nr(a.z, e.z, i) }; }
            }, s.ao = function (a, e, i = 0, c = !0) { const h = new Et(i, i), p = a.sub(h), m = e.add(h), x = [p, new Et(m.x, p.y), m, new Et(p.x, m.y)]; return c && x.push(p.clone()), x; }, s.ap = function (a, e) { const i = []; for (let c = 0; c < a.length; c++) {
                const h = qe(c - 1, -1, a.length - 1), p = qe(c + 1, -1, a.length - 1), m = a[c], x = a[p], b = a[h].sub(m).unit(), S = x.sub(m).unit(), A = S.angleWithSep(b.x, b.y), I = b.add(S).unit().mult(-1 * e / Math.sin(A / 2));
                i.push(m.add(I));
            } return i; }, s.aq = GM, s.ar = Ii, s.as = function (a, e, i = 0) { return bt(((e.x - i) * a.scale - a.x) * It, (e.y * a.scale - a.y) * It, je(e.z, e.y)); }, s.at = Gn, s.au = an, s.av = aa, s.aw = tM, s.ax = function (a) { let e = 1 / 0, i = 1 / 0, c = -1 / 0, h = -1 / 0; for (const p of a)
                e = Math.min(e, p.x), i = Math.min(i, p.y), c = Math.max(c, p.x), h = Math.max(h, p.y); return { min: new Et(e, i), max: new Et(c, h) }; }, s.ay = ve, s.az = ie, s.b = function (a) { return hs.API_FONTS_REGEX.test(a); }, s.b$ = Ft, s.b0 = Up, s.b1 = $x, s.b2 = function () { zo.isLoading() || zo.isLoaded() || Nu() !== "deferred" || Z0(); }, s.b3 = b_, s.b4 = Xt, s.b5 = am, s.b6 = vi, s.b7 = XT, s.b8 = UT, s.b9 = Vt, s.bA = function (a, e) { const { x: i, y: c } = a.point, h = zI(i, c, a.worldSize / a._pixelsPerMercatorPixel, 0, 0); return ie(h, h, AT(Gl(e))); }, s.bB = N, s.bC = function (a) { return a[0] = 0, a[1] = 0, a[2] = 0, a; }, s.bD = function (a, e) { return Math.hypot(e[0] - a[0], e[1] - a[1], e[2] - a[2]); }, s.bE = Kr, s.bF = gr, s.bG = mn, s.bH = ey, s.bI = go, s.bJ = nS, s.bK = function (a, e, i, c, h) { const p = 5 * e + 2; a.float32[p + 0] = i, a.float32[p + 1] = c, a.float32[p + 2] = h; }, s.bL = Ux, s.bM = Px, s.bN = or, s.bO = ts, s.bP = TP, s.bQ = _R, s.bR = IP, s.bS = PP, s.bT = aS, s.bU = FM, s.bV = rS, s.bW = jS, s.bX = qe, s.bY = Ko, s.bZ = function (a, e, i) { i *= .5; var c = e[0], h = e[1], p = e[2], m = e[3], x = Math.sin(i), b = Math.cos(i); return a[0] = c * b + h * x, a[1] = h * b - c * x, a[2] = p * b + m * x, a[3] = m * b - p * x, a; }, s.b_ = Ue, s.ba = Ja, s.bb = Bd, s.bc = Ia, s.bd = ti, s.be = U_, s.bf = pS, s.bg = function (a, e) { const i = Ku(e.zoom); if (i === 0)
                return Gl(a); const c = _x(a), h = CT(c), p = ve(c.getWest()) * e.worldSize, m = ve(c.getEast()) * e.worldSize, x = xe(c.getNorth()) * e.worldSize, b = xe(c.getSouth()) * e.worldSize, S = [p, x, 0], A = [m, x, 0], I = [p, b, 0], M = [m, b, 0], z = ye([], e.globeMatrix); return ln(S, S, z), ln(A, A, z), ln(I, I, z), ln(M, M, z), h[0] = Gc(h[0], I, i), h[1] = Gc(h[1], M, i), h[2] = Gc(h[2], A, i), h[3] = Gc(h[3], S, i), Wn.fromPoints(h); }, s.bh = vx, s.bi = ye, s.bj = j_, s.bk = Gc, s.bl = zp, s.bm = No, s.bn = Ze, s.bo = Q, s.bp = a1, s.bq = Mx, s.br = yu, s.bs = function (a, e) { const i = []; for (const c in a)
                c in e || i.push(c); return i; }, s.bt = tt, s.bu = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], s.bv = qa, s.bw = function (a) { var e = new L(16); return e[0] = a[0], e[1] = a[1], e[2] = a[2], e[3] = a[3], e[4] = a[4], e[5] = a[5], e[6] = a[6], e[7] = a[7], e[8] = a[8], e[9] = a[9], e[10] = a[10], e[11] = a[11], e[12] = a[12], e[13] = a[13], e[14] = a[14], e[15] = a[15], e; }, s.bx = J, s.by = Be, s.bz = ce, s.c = _c, s.c$ = function (a) { return a({ pluginStatus: to, pluginURL: Nl }), Rp.on("pluginStateChange", a), a; }, s.c0 = Xo, s.c1 = qi, s.c2 = function (a, e) { return a[0] = -e[0], a[1] = -e[1], a[2] = -e[2], a[3] = e[3], a; }, s.c3 = At, s.c4 = function (a, e, i, c, h) { var p, m = 1 / Math.tan(e / 2); return a[0] = m / i, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = m, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[11] = -1, a[12] = 0, a[13] = 0, a[15] = 0, h != null && h !== 1 / 0 ? (a[10] = (h + c) * (p = 1 / (c - h)), a[14] = 2 * h * c * p) : (a[10] = -1, a[14] = -2 * c), a; }, s.c5 = function (a, e, i, c, h, p, m) { var x = 1 / (e - i), b = 1 / (c - h), S = 1 / (p - m); return a[0] = -2 * x, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = -2 * b, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 2 * S, a[11] = 0, a[12] = (e + i) * x, a[13] = (h + c) * b, a[14] = (m + p) * S, a[15] = 1, a; }, s.c6 = ge, s.c7 = function (a, e, i) { a[4 * e + 0] = i[0], a[4 * e + 1] = i[1], a[4 * e + 2] = i[2], a[4 * e + 3] = i[3]; }, s.c8 = $d, s.c9 = na, s.cA = Zx, s.cB = kt, s.cC = dR, s.cD = function (a) { const e = dR(a, !0); return N([], [e[0], e[1], e[4], e[5]]); }, s.cE = ue, s.cF = Zu, s.cG = be, s.cH = function (a) { const { x: e, y: i } = a.point, { lng: c, lat: h } = a._center; return zI(e, i, a.worldSize, c, h); }, s.cI = Or, s.cJ = re, s.cK = as, s.cL = w, s.cM = function (a, e, i) { let c = 0; for (let h = 0; h < 2; ++h)
                a[h] > 0 && (c += (a[h] - 0) * (a[h] - 0)), e[h] < 0 && (c += (0 - e[h]) * (0 - e[h])); return c; }, s.cN = 45, s.cO = ep, s.cP = we, s.cQ = qp, s.cR = function (a, e, i) { const c = Math.sqrt(a * a + e * e + i * i), h = c > 0 ? Math.acos(i / c) * Qe : 0; let p = a !== 0 || e !== 0 ? Math.atan2(-e, -a) * Qe + 90 : 0; return p < 0 && (p += 360), [c, p, h]; }, s.cS = bt, s.cT = Fe, s.cU = ir, s.cV = Wn, s.cW = In, s.cX = function (a) { return [Math.pow(a[0], 1 / 2.2), Math.pow(a[1], 1 / 2.2), Math.pow(a[2], 1 / 2.2)]; }, s.cY = tr, s.cZ = wS, s.c_ = function (a, e) { return a.readFields(EV, { icons: [] }, e); }, s.ca = Ud, s.cb = Ei, s.cc = Gp, s.cd = W, s.ce = XM, s.cf = function () { var a = new L(4); return L != Float32Array && (a[1] = 0, a[2] = 0), a[0] = 1, a[3] = 1, a; }, s.cg = function (a, e, i) { var c = e[0], h = e[1], p = e[2], m = e[3], x = Math.sin(i), b = Math.cos(i); return a[0] = c * b + p * x, a[1] = h * b + m * x, a[2] = c * -x + p * b, a[3] = h * -x + m * b, a; }, s.ch = function (a, e) { return a[0] === e[0] && a[1] === e[1] && a[2] === e[2] && a[3] === e[3]; }, s.ci = ss, s.cj = function (a) { return Math.hypot(a[0], a[1], a[2], a[3]); }, s.ck = gn, s.cl = js, s.cm = es, s.cn = Hd, s.co = fR, s.cp = Ln, s.cq = DI, s.cr = function (a, e, i, c, h, p, m, x, b) { if (b.name === "globe")
                return DI(a, e, new Ln(i, c, h), !1); const S = iy({ z: i, x: c, y: h }, b); return new Wn([(p + S.x / S.scale) * e, e * (S.y / S.scale), m], [(p + S.x2 / S.scale) * e, e * (S.y2 / S.scale), x]); }, s.cs = function (a, e, i) { return a[0] = Math.min(e[0], i[0]), a[1] = Math.min(e[1], i[1]), a[2] = Math.min(e[2], i[2]), a[3] = Math.min(e[3], i[3]), a; }, s.ct = function (a, e, i) { return a[0] = Math.max(e[0], i[0]), a[1] = Math.max(e[1], i[1]), a[2] = Math.max(e[2], i[2]), a[3] = Math.max(e[3], i[3]), a; }, s.cu = function (a) { const e = Math.round((a + 45 + 360) % 360 / 90) % 4; return _e[e]; }, s.cv = ze, s.cw = Ks, s.cx = T, s.cy = function (a) { const e = J(new Float64Array(16)); ie(e, a.pixelMatrix, a.globeMatrix); const i = [0, O, 0], c = [0, D, 0]; return ln(i, i, e), ln(c, c, e), [i[0] > 0 && i[0] <= a.width && i[1] > 0 && i[1] <= a.height && !PT(a, new W(a.center.lat, 90)), c[0] > 0 && c[0] <= a.width && c[1] > 0 && c[1] <= a.height && !PT(a, new W(a.center.lat, -90))]; }, s.cz = function (a, e) { const { scale: i } = a.tileTransform, c = i * It / (a.tileSize * Math.pow(2, e.zoom - a.tileID.overscaledZ + a.tileID.canonical.z)); return function (h, p, m) { var x = p[1], b = p[2], S = p[3], A = m[0], I = m[1]; return h[0] = p[0] * A, h[1] = x * A, h[2] = b * I, h[3] = S * I, h; }(new Float32Array(4), e.inverseAdjustmentMatrix, [c, c]); }, s.d = function (a) { return hs.API_TILEJSON_REGEX.test(a); }, s.d$ = z_, s.d0 = Jx, s.d1 = Yp, s.d2 = sS, s.d3 = Yr, s.d4 = Oc, s.d5 = Qs, s.d6 = Js, s.d7 = Fr, s.d8 = function (a) { const e = a.indexOf(Od); return e >= 0 ? a.slice(0, e) : a; }, s.d9 = function (a) { return a.indexOf(Od) >= 0; }, s.dA = OI, s.dB = ys, s.dC = _s, s.dD = 256, s.dE = function (a, e) { const i = [0, 0, 0]; return ln(i, i, vx(Gl(e.canonical))), ln(i, i, a), i; }, s.dF = a => ({ u_camera_to_center_distance: new Ei(a), u_extrude_scale: new Fo(a), u_device_pixel_ratio: new Ei(a), u_matrix: new $d(a), u_inv_rot_matrix: new $d(a), u_merc_center: new na(a), u_tile_id: new Ud(a), u_zoom_transition: new Ei(a), u_up_dir: new Ud(a), u_emissive_strength: new Ei(a) }), s.dG = a => ({ u_matrix: new $d(a), u_pixels_to_tile_units: new Fo(a), u_device_pixel_ratio: new Ei(a), u_width_scale: new Ei(a), u_floor_width_scale: new Ei(a), u_units_to_pixels: new na(a), u_dash_image: new Gp(a), u_gradient_image: new Gp(a), u_image_height: new Ei(a), u_texsize: new na(a), u_tile_units_to_pixels: new Ei(a), u_alpha_discard_threshold: new Ei(a), u_trim_offset: new na(a), u_trim_fade_range: new na(a), u_trim_color: new qp(a), u_emissive_strength: new Ei(a), u_zbias_factor: new Ei(a), u_tile_to_meter: new Ei(a), u_ground_shadow_factor: new Ud(a) }), s.dH = a => ({ u_matrix: new $d(a), u_texsize: new na(a), u_pixels_to_tile_units: new Fo(a), u_device_pixel_ratio: new Ei(a), u_width_scale: new Ei(a), u_floor_width_scale: new Ei(a), u_image: new Gp(a), u_units_to_pixels: new na(a), u_tile_units_to_pixels: new Ei(a), u_alpha_discard_threshold: new Ei(a), u_trim_offset: new na(a), u_trim_fade_range: new na(a), u_trim_color: new qp(a), u_emissive_strength: new Ei(a), u_zbias_factor: new Ei(a), u_tile_to_meter: new Ei(a), u_ground_shadow_factor: new Ud(a), u_pattern_transition: new Ei(a) }), s.dI = Fd, s.dJ = M5, s.dK = BI, s.dL = (a, e, i, c, h, p) => { const m = a.transform, x = m.projection.name === "globe"; let b; if (p.paint.get("circle-pitch-alignment") === "map")
                if (x) {
                    const A = OI(m.zoom, e.canonical) * m._pixelsPerMercatorPixel;
                    b = Float32Array.from([A, 0, 0, A]);
                }
                else
                    b = m.calculatePixelsToTileUnitsMatrix(i);
            else
                b = new Float32Array([m.pixelsToGLUnits[0], 0, 0, m.pixelsToGLUnits[1]]); const S = { u_camera_to_center_distance: a.transform.getCameraToCenterDistance(m.projection), u_matrix: a.translatePosMatrix(e.projMatrix, i, p.paint.get("circle-translate"), p.paint.get("circle-translate-anchor")), u_device_pixel_ratio: Yo.devicePixelRatio, u_extrude_scale: b, u_inv_rot_matrix: E4, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: p.paint.get("circle-emissive-strength") }; if (x) {
                S.u_inv_rot_matrix = c, S.u_merc_center = h, S.u_tile_id = [e.canonical.x, e.canonical.y, 1 << e.canonical.z], S.u_zoom_transition = Ku(m.zoom);
                const A = h[0] * It, I = h[1] * It;
                S.u_up_dir = m.projection.upVector(new Ln(0, 0, 0), A, I);
            } return S; }, s.dM = sM, s.dN = Us, s.dO = (a, e, i, c, h, p, m, x, b, S) => { const A = a.transform, I = A.pitch < 15 ? rM(.07, .7, ke((14 - A.zoom) / 5, 0, 1)) : .07, M = i.paint.get("line-trim-color-use-theme").constantOr("default") === "none"; return { u_matrix: iM(a, e, i, c), u_texsize: e.imageAtlasTexture ? e.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: A.calculatePixelsToTileUnitsMatrix(e), u_device_pixel_ratio: h, u_width_scale: p, u_floor_width_scale: m, u_image: 0, u_tile_units_to_pixels: nM(e, A), u_units_to_pixels: [1 / A.pixelsToGLUnits[0], 1 / A.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0, u_trim_offset: x, u_trim_fade_range: i.paint.get("line-trim-fade-range"), u_trim_color: i.paint.get("line-trim-color").toRenderColor(M ? null : i.lut).toArray01(), u_emissive_strength: i.paint.get("line-emissive-strength"), u_zbias_factor: I, u_tile_to_meter: Fe(e.tileID.canonical, 0), u_ground_shadow_factor: b, u_pattern_transition: S }; }, s.dP = (a, e, i, c, h, p, m, x, b, S) => { const A = a.transform, I = A.calculatePixelsToTileUnitsMatrix(e), M = i.paint.get("line-trim-color-use-theme").constantOr("default") === "none", z = A.pitch < 15 ? rM(.07, .7, ke((14 - A.zoom) / 5, 0, 1)) : .07; return { u_matrix: iM(a, e, i, c), u_pixels_to_tile_units: I, u_device_pixel_ratio: p, u_width_scale: m, u_floor_width_scale: x, u_units_to_pixels: [1 / A.pixelsToGLUnits[0], 1 / A.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: h, u_texsize: oM(i) && e.lineAtlasTexture ? e.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: nM(e, a.transform), u_alpha_discard_threshold: 0, u_trim_offset: b, u_trim_fade_range: i.paint.get("line-trim-fade-range"), u_trim_color: i.paint.get("line-trim-color").toRenderColor(M ? null : i.lut).toArray01(), u_emissive_strength: i.paint.get("line-emissive-strength"), u_zbias_factor: z, u_tile_to_meter: Fe(e.tileID.canonical, 0), u_ground_shadow_factor: S }; }, s.dQ = Wt, s.dR = V_, s.dS = je, s.dT = UP, s.dU = oa, s.dV = Ix, s.dW = Ju, s.dX = 450, s.dY = 7, s.dZ = cV, s.d_ = tn, s.da = function (a) { const e = a.lastIndexOf(Od); return e >= 0 ? a.slice(e + 1) : ""; }, s.db = function (a) { const e = [], i = a.id; return i === void 0 && e.push({ message: `layers.${i}: missing required property "id"` }), a.render === void 0 && e.push({ message: `layers.${i}: missing required method "render"` }), a.renderingMode && a.renderingMode !== "2d" && a.renderingMode !== "3d" && e.push({ message: `layers.${i}: property "renderingMode" must be either "2d" or "3d"` }), e; }, s.dc = function (a, e, i, c) { return a.type === "custom" ? new uV(a, e) : new wV[a.type](a, e, i, c); }, s.dd = Mr, s.de = function (a) { const e = a.indexOf(Od); return e >= 0 ? a.slice(e + 1) : ""; }, s.df = class extends am {
                constructor(a, e) { super(a._vectorTileFeature, a._z, a._x, a._y, a.id), a.state && (this.state = Object.assign({}, a.state)), this.target = e.target, this.namespace = e.namespace, e.properties && (this.properties = e.properties), this.target && ("featuresetId" in this.target && !this.target.importId || "layerId" in this.target) && (this.source = a.source, this.sourceLayer = a.sourceLayer, this.layer = a.layer); }
                toJSON() { const a = super.toJSON(); return a.target = this.target, a.namespace = this.namespace, a; }
            }, s.dg = Rp, s.dh = _u, s.di = mx, s.dj = class extends Aa {
                constructor(a) { super(a), this.current = gx; }
                set(a, e, i) { if (this.fetchUniformLocation(a, e)) {
                    for (let c = 0; c < 9; c++)
                        if (i[c] !== this.current[c]) {
                            this.current = i, this.gl.uniformMatrix3fv(this.location, !1, i);
                            break;
                        }
                } }
            }, s.dk = Ae, s.dl = function (a, e, i) { const c = Ku(i.zoom), h = a.style.map._antialias, p = a.terrain && a.terrain.exaggeration() > 0; return c === 0 && !h && !p; }, s.dm = function (a) { const e = a.pixelsPerMeter, i = e / ge(1, a.center.lat), c = J(new Float64Array(16)); return Q(c, c, [a.point.x, a.point.y, 0]), ue(c, c, [i, i, e]), Float32Array.from(c); }, s.dn = _x, s.dp = function (a) { const e = ze - 5; a = ke(a, -e, e) / e * 90; const i = Math.pow(Math.abs(Math.sin(Z(a))), 3); return Math.round(i * (R.length - 1)); }, s.dq = function (a, e, i, c) { const h = e.getNorth(), p = e.getSouth(), m = e.getWest(), x = e.getEast(), b = 1 << a.z, S = x - m, A = h - p, I = S / P, M = -A / R[i], z = [0, I, 0, M, 0, 0, h, m, 0]; if (a.z > 0) {
                const F = 180 / c;
                ee(z, z, [F / S + 1, 0, 0, 0, F / A + 1, 0, -.5 * F / I, .5 * F / M, 1]);
            } return z[2] = b, z[5] = a.x, z[8] = a.y, z; }, s.dr = Gl, s.ds = function (a, e, i) { const c = J(new Float64Array(16)), h = (e / (1 << a) - .5) * Math.PI * 2; return Ie(c, i.globeMatrix, h), Float32Array.from(c); }, s.dt = class {
                isDataAvailableAtPoint(a) { const e = this._source(); if (this.isUsingMockSource() || !e || a.y < 0 || a.y > 1)
                    return !1; const i = e.getSource().maxzoom, c = 1 << i, h = Math.floor(a.x), p = Math.floor((a.x - h) * c), m = Math.floor(a.y * c), x = this.findDEMTileFor(new wi(i, h, i, p, m)); return !(!x || !x.dem); }
                getAtPointOrZero(a, e = 0) { return this.getAtPoint(a, e) || 0; }
                getAtPoint(a, e, i = !0) { if (this.isUsingMockSource())
                    return null; e == null && (e = null); const c = this._source(); if (!c || a.y < 0 || a.y > 1)
                    return e; const h = c.getSource().maxzoom, p = 1 << h, m = Math.floor(a.x), x = a.x - m, b = new wi(h, m, h, Math.floor(x * p), Math.floor(a.y * p)), S = this.findDEMTileFor(b); if (!S || !S.dem)
                    return e; const A = S.dem, I = 1 << S.tileID.canonical.z, M = (x * I - S.tileID.canonical.x) * A.dim, z = (a.y * I - S.tileID.canonical.y) * A.dim, F = Math.floor(M), U = Math.floor(z); return (i ? this.exaggeration() : 1) * nr(nr(A.get(F, U), A.get(F, U + 1), z - U), nr(A.get(F + 1, U), A.get(F + 1, U + 1), z - U), M - F); }
                getAtTileOffset(a, e, i) { const c = 1 << a.canonical.z; return this.getAtPointOrZero(new Ve(a.wrap + (a.canonical.x + e / It) / c, (a.canonical.y + i / It) / c)); }
                getAtTileOffsetFunc(a, e, i, c) { return h => { const p = this.getAtTileOffset(a, h.x, h.y), m = c.upVector(a.canonical, h.x, h.y); return Ft(m, m, p * c.upVectorScale(a.canonical, e, i).metersToTile), m; }; }
                getForTilePoints(a, e, i, c) { if (this.isUsingMockSource())
                    return !1; const h = tm.create(this, a, c); return !!h && (e.forEach(p => { p[2] = this.exaggeration() * h.getElevationAt(p[0], p[1], i); }), !0); }
                getMinMaxForTile(a) { if (this.isUsingMockSource())
                    return null; const e = this.findDEMTileFor(a); if (!e || !e.dem)
                    return null; const i = e.dem.tree, c = e.tileID, h = 1 << a.canonical.z - c.canonical.z; let p = a.canonical.x / h - c.canonical.x, m = a.canonical.y / h - c.canonical.y, x = 0; for (let b = 0; b < a.canonical.z - c.canonical.z && !i.leaves[x]; b++) {
                    p *= 2, m *= 2;
                    const S = 2 * Math.floor(m) + Math.floor(p);
                    x = i.childOffsets[x] + S, p %= 1, m %= 1;
                } return { min: this.exaggeration() * i.minimums[x], max: this.exaggeration() * i.maximums[x] }; }
                getMinElevationBelowMSL() { throw new Error("Pure virtual method called."); }
                raycast(a, e, i) { throw new Error("Pure virtual method called."); }
                pointCoordinate(a) { throw new Error("Pure virtual method called."); }
                _source() { throw new Error("Pure virtual method called."); }
                isUsingMockSource() { throw new Error("Pure virtual method called."); }
                exaggeration() { throw new Error("Pure virtual method called."); }
                findDEMTileFor(a) { throw new Error("Pure virtual method called."); }
                get visibleDemTiles() { throw new Error("Getter must be implemented in subclass."); }
                getMinMaxForVisibleTiles() { const a = this.visibleDemTiles; if (a.length === 0)
                    return null; let e = !1, i = Number.MAX_VALUE, c = Number.MIN_VALUE; for (const h of a) {
                    const p = this.getMinMaxForTile(h.tileID);
                    p && (i = Math.min(i, p.min), c = Math.max(c, p.max), e = !0);
                } return e ? { min: i, max: c } : null; }
            }, s.du = XI, s.dv = Xu, s.dw = function (a, e) { return [Math.pow(a[0], 2.2) * e, Math.pow(a[1], 2.2) * e, Math.pow(a[2], 2.2) * e]; }, s.dx = V, s.dy = function (a, e) { var i = Math.sin(e), c = Math.cos(e); return a[0] = c, a[1] = i, a[2] = 0, a[3] = -i, a[4] = c, a[5] = 0, a[6] = 0, a[7] = 0, a[8] = 1, a; }, s.dz = Bs, s.e = hs, s.e$ = mk, s.e0 = 256, s.e1 = AT, s.e2 = Ea, s.e3 = Ie, s.e4 = function (a, e) { return a[0] = e[0], a[1] = e[1], a[2] = e[2], a[3] = e[4], a[4] = e[5], a[5] = e[6], a[6] = e[8], a[7] = e[9], a[8] = e[10], a; }, s.e5 = Ul, s.e6 = Nd, s.e7 = function (a, e, i, c, h) { return ke((a - e) / (i - e) * (h - c) + c, c, h); }, s.e8 = _t, s.e9 = function (a, e) { var i = e[0], c = e[1], h = e[2], p = e[3], m = e[4], x = e[5], b = e[6], S = e[7], A = e[8], I = A * m - x * S, M = -A * p + x * b, z = S * p - m * b, F = i * I + c * M + h * z; return F ? (a[0] = I * (F = 1 / F), a[1] = (-A * c + h * S) * F, a[2] = (x * c - h * m) * F, a[3] = M * F, a[4] = (A * i - h * b) * F, a[5] = (-x * i + h * p) * F, a[6] = z * F, a[7] = (-S * i + c * b) * F, a[8] = (m * i - c * p) * F, a) : null; }, s.eA = function (a, e, i) { return a[0] = e[0] / i[0], a[1] = e[1] / i[1], a[2] = e[2] / i[2], a; }, s.eB = Ua, s.eC = q, s.eD = pi, s.eE = function (a, e, i, c) { return a[0] = e, a[1] = i, a[2] = c, a; }, s.eF = function ([a, e, i]) { const c = Math.hypot(a, e, i), h = Math.atan2(a, i), p = .5 * Math.PI - Math.acos(-e / c); return new W(re(h), re(p)); }, s.eG = Io, s.eH = vS, s.eI = function (a) { const e = a.navigator ? a.navigator.userAgent : null; return !!function (i) { if (Mi == null) {
                const c = i.navigator ? i.navigator.userAgent : null;
                Mi = !!i.safari || !(!c || !(/\b(iPad|iPhone|iPod)\b/.test(c) || c.match("Safari") && !c.match("Chrome")));
            } return Mi; }(a) && !(!e || !(e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/))); }, s.eJ = function (a, e) { Wa = a, Jo = e; }, s.eK = PT, s.eL = FI, s.eM = function (a) { const e = [0, 0, 0], i = J(new Float64Array(16)); return ie(i, a.pixelMatrix, a.globeMatrix), ln(e, e, i), new Et(e[0], e[1]); }, s.eN = function (a, e, i = !1) { if (to === y_ || to === v_ || to === x_)
                throw new Error("setRTLTextPlugin cannot be called multiple times."); Nl = Yo.resolveURL(a), to = y_, w_ = e, Mp(), i || Z0(); }, s.eO = Nu, s.eP = function () { Jx().acquire(CS); }, s.eQ = function () { const a = dy; a && (a.isPreloaded() && a.numActive() === 1 ? (a.release(CS), dy = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()")); }, s.eR = tf, s.eS = function (a) { const e = Lg(); if (!e)
                return; const i = e.delete(Qo); a && i.then(() => a()).catch(a); }, s.eT = hy, s.eU = sk, s.eV = function (a) { zS = Yo.resolveURL(a), om || (om = new rm(Jx(), new wc)), om.broadcast("setDracoUrl", zS); }, s.eW = ok, s.eX = function (a) { sm = Yo.resolveURL(a), om || (om = new rm(Jx(), new wc)), om.broadcast("setMeshoptUrl", sm); }, s.eY = Nt, s.eZ = Yu, s.e_ = nl, s.ea = N0, s.eb = Si, s.ec = et, s.ed = class {
                constructor(a, e, i, c) { this.context = a, this.format = c, this.size = i, this.texture = a.gl.createTexture(); const [h, p, m] = this.size, { gl: x } = a; x.bindTexture(x.TEXTURE_3D, this.texture), a.pixelStoreUnpackFlipY.set(!1), a.pixelStoreUnpack.set(1), a.pixelStoreUnpackPremultiplyAlpha.set(!1), x.texImage3D(x.TEXTURE_3D, 0, this.format, h, p, m, 0, mS(this.format), gS(this.format), e.data); }
                bind(a, e) { const { context: i } = this, { gl: c } = i; c.bindTexture(c.TEXTURE_3D, this.texture), a !== this.minFilter && (c.texParameteri(c.TEXTURE_3D, c.TEXTURE_MAG_FILTER, a), c.texParameteri(c.TEXTURE_3D, c.TEXTURE_MIN_FILTER, a), this.minFilter = a), e !== this.wrapS && (c.texParameteri(c.TEXTURE_3D, c.TEXTURE_WRAP_S, e), c.texParameteri(c.TEXTURE_3D, c.TEXTURE_WRAP_T, e), this.wrapS = e); }
                destroy() { const { gl: a } = this.context; a.deleteTexture(this.texture), this.texture = null; }
            }, s.ee = function (a, e) { if (a === e) {
                var i = e[1], c = e[2], h = e[3], p = e[6], m = e[7], x = e[11];
                a[1] = e[4], a[2] = e[8], a[3] = e[12], a[4] = i, a[6] = e[9], a[7] = e[13], a[8] = c, a[9] = p, a[11] = e[14], a[12] = h, a[13] = m, a[14] = x;
            }
            else
                a[0] = e[0], a[1] = e[4], a[2] = e[8], a[3] = e[12], a[4] = e[1], a[5] = e[5], a[6] = e[9], a[7] = e[13], a[8] = e[2], a[9] = e[6], a[10] = e[10], a[11] = e[14], a[12] = e[3], a[13] = e[7], a[14] = e[11], a[15] = e[15]; return a; }, s.ef = xS, s.eg = ct, s.eh = [1, 1, 1], s.ei = function (a, e, i, c) { var h = new L(4); return h[0] = a, h[1] = e, h[2] = i, h[3] = c, h; }, s.ej = $i, s.ek = function (a, e, i, c) { var h = e[0], p = e[1], m = e[2], x = e[3]; return a[0] = h + c * (i[0] - h), a[1] = p + c * (i[1] - p), a[2] = m + c * (i[2] - m), a[3] = x + c * (i[3] - x), a; }, s.el = tm, s.em = em, s.en = Vl, s.eo = Vc, s.ep = function (a, e, i, c, h, p, m, x, b, S, A, I, M, z, F, U) { var X = new L(16); return X[0] = a, X[1] = e, X[2] = i, X[3] = c, X[4] = h, X[5] = p, X[6] = m, X[7] = x, X[8] = b, X[9] = S, X[10] = A, X[11] = I, X[12] = M, X[13] = z, X[14] = F, X[15] = U, X; }, s.eq = G, s.er = jp, s.es = L_, s.et = class {
                constructor() { this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = { min: new Et(1 / 0, 1 / 0), max: new Et(-1 / 0, -1 / 0) }; }
                clear() { this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = []; }
                get updateTime() { return this._updateTime; }
                getReplacementRegionsForTile(a, e = !1) { const i = EP(new Et(0, 0), new Et(It, It), a), c = []; if (e && !GT(i, this._globalClipBounds))
                    return c; for (const h of this._activeRegions) {
                    if (h.hiddenByOverlap || !GT(i, h))
                        continue;
                    const p = r5(h.min, h.max, a);
                    c.push({ min: p.min, max: p.max, sourceId: this._sourceIds[h.priority], footprint: h.footprint, footprintTileId: h.tileId, order: h.order, clipMask: h.clipMask, clipScope: h.clipScope });
                } return c; }
                setSources(a) { this._setSources(a.map(e => ({ getSourceId: () => e.cache.id, getFootprints: () => { const i = []; for (const c of e.cache.getVisibleCoordinates()) {
                        const h = e.cache.getTile(c).buckets[e.layer];
                        h && h.updateFootprints(c.toUnwrapped(), i);
                    } return i; }, getOrder: () => e.order, getClipMask: () => e.clipMask, getClipScope: () => e.clipScope }))); }
                _addSource(a) { const e = a.getFootprints(); if (e.length === 0)
                    return; const i = a.getOrder(), c = a.getClipMask(), h = a.getClipScope(); for (const p of e) {
                    if (!p.footprint)
                        continue;
                    const m = EP(p.footprint.min, p.footprint.max, p.id);
                    this._activeRegions.push({ min: m.min, max: m.max, hiddenByOverlap: !1, priority: this._sourceIds.length, tileId: p.id, footprint: p.footprint, order: i, clipMask: c, clipScope: h });
                } this._sourceIds.push(a.getSourceId()); }
                _computeReplacement() { this._activeRegions.sort((e, i) => e.priority - i.priority || Cx(e.min, i.min) || Cx(e.max, i.max) || e.order - i.order || e.clipMask - i.clipMask || function (c, h) { const p = (m, x) => m + x; return c.length - h.length || c.reduce(p, "").localeCompare(h.reduce(p, "")); }(e.clipScope, i.clipScope)); let a = this._activeRegions.length !== this._prevRegions.length; if (!a) {
                    let e = 0;
                    for (; !a && e !== this._activeRegions.length;) {
                        const i = this._activeRegions[e], c = this._prevRegions[e];
                        a = i.priority !== c.priority || !SP(i, c) || i.order !== c.order || i.clipMask !== c.clipMask || !qa(i.clipScope, c.clipScope), ++e;
                    }
                } if (a) {
                    ++this._updateTime;
                    for (const i of this._activeRegions)
                        i.order !== Ex && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, i.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, i.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, i.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, i.max.y));
                    const e = i => { const c = this._activeRegions; if (i >= c.length)
                        return i; const h = c[i].priority; for (; i < c.length && c[i].priority === h;)
                        ++i; return i; };
                    if (this._sourceIds.length > 1) {
                        let i = 0, c = e(i);
                        for (; i !== c;) {
                            let h = i;
                            const p = i;
                            for (; h !== c;) {
                                const m = this._activeRegions[h];
                                m.hiddenByOverlap = !1;
                                for (let x = 0; x < p; x++) {
                                    const b = this._activeRegions[x];
                                    if (!b.hiddenByOverlap && m.order === Ex && GT(m, b) && (m.hiddenByOverlap = AP(m.footprint, m.tileId, b.footprint, b.tileId), m.hiddenByOverlap))
                                        break;
                                }
                                ++h;
                            }
                            i = c, c = e(i);
                        }
                    }
                } }
                _setSources(a) { [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = []; for (let e = a.length - 1; e >= 0; e--)
                    this._addSource(a[e]); this._computeReplacement(); }
            }, s.eu = class {
                constructor(a) { this._createGrid(a), this._createPoles(a); }
                destroy() { this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy(); for (const a of this._poleSegments)
                    a.destroy(); for (const a of this._gridSegments)
                    a.withSkirts.destroy(), a.withoutSkirts.destroy(); }
                _fillGridMeshWithLods(a, e) { const i = new Ja, c = new Hi, h = [], p = a + 1 + 2, m = e[0] + 1, x = e[0] + 1 + (1 + e.length), b = (S, A, I) => { let M = S === p - 1 ? S - 2 : S === 0 ? S : S - 1; return M += I ? 24575 : 0, [M, A]; }; for (let S = 0; S < p; ++S)
                    i.emplaceBack(...b(S, 0, !0)); for (let S = 0; S < m; ++S)
                    for (let A = 0; A < p; ++A)
                        i.emplaceBack(...b(A, S, (A === 0 || A === p - 1) && !0)); for (let S = 0; S < e.length; ++S) {
                    const A = e[S];
                    for (let I = 0; I < p; ++I)
                        i.emplaceBack(...b(I, A, !0));
                } for (let S = 0; S < e.length; ++S) {
                    const A = c.length, I = e[S] + 1 + 2, M = new Hi;
                    for (let U = 0; U < I - 1; U++) {
                        const X = U === I - 2, Y = X ? p * (x - e.length + S - U) : p;
                        for (let le = 0; le < p - 1; le++) {
                            const se = U * p + le;
                            U === 0 || X || le === 0 || le === p - 2 ? (M.emplaceBack(se + 1, se, se + Y), M.emplaceBack(se + Y, se + Y + 1, se + 1)) : (c.emplaceBack(se + 1, se, se + Y), c.emplaceBack(se + Y, se + Y + 1, se + 1));
                        }
                    }
                    const z = ti.simpleSegment(0, A, i.length, c.length - A);
                    for (let U = 0; U < M.uint16.length; U += 3)
                        c.emplaceBack(M.uint16[U], M.uint16[U + 1], M.uint16[U + 2]);
                    const F = ti.simpleSegment(0, A, i.length, c.length - A);
                    h.push({ withoutSkirts: z, withSkirts: F });
                } return { vertices: i, indices: c, segments: h }; }
                _createGrid(a) { const e = this._fillGridMeshWithLods(P, R); this._gridSegments = e.segments, this._gridBuffer = a.createVertexBuffer(e.vertices, Ia.members), this._gridIndexBuffer = a.createIndexBuffer(e.indices, !0); }
                _createPoles(a) { const e = new Hi; for (let m = 0; m <= P; m++)
                    e.emplaceBack(0, m + 1, m + 2); this._poleIndexBuffer = a.createIndexBuffer(e, !0); const i = new Ul, c = new Ul, h = new Ul, p = new Ul; this._poleSegments = []; for (let m = 0, x = 0; m < w; m++) {
                    const b = 360 / (1 << m);
                    i.emplaceBack(0, -v, 0, .5, 0), c.emplaceBack(0, -v, 0, .5, 1), h.emplaceBack(0, -v, 0, .5, .5), p.emplaceBack(0, -v, 0, .5, .5);
                    for (let S = 0; S <= P; S++) {
                        let A = S / P, I = 0;
                        const M = nr(0, b, A), [z, F, U] = B(T4, S4, M, v);
                        i.emplaceBack(z, F, U, A, I), c.emplaceBack(z, F, U, A, 1 - I);
                        const X = Z(M);
                        A = .5 + .5 * Math.sin(X), I = .5 + .5 * Math.cos(X), h.emplaceBack(z, F, U, A, I), p.emplaceBack(z, F, U, A, 1 - I);
                    }
                    this._poleSegments.push(ti.simpleSegment(x, 0, 66, 64)), x += 66;
                } this._poleNorthVertexBuffer = a.createVertexBuffer(i, ro, !1), this._poleSouthVertexBuffer = a.createVertexBuffer(c, ro, !1), this._texturedPoleNorthVertexBuffer = a.createVertexBuffer(h, ro, !1), this._texturedPoleSouthVertexBuffer = a.createVertexBuffer(p, ro, !1); }
                getGridBuffers(a, e) { return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[a].withSkirts : this._gridSegments[a].withoutSkirts]; }
                getPoleBuffers(a, e) { return [e ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[a]]; }
            }, s.ev = Ex, s.ew = Ee, s.ex = function () { return !!document.fullscreenElement || !!document.webkitFullscreenElement; }, s.ey = Re, s.ez = vt, s.f = function (a) { return a.indexOf("mapbox:") === 0; }, s.f0 = gk, s.f1 = QP, s.f2 = Zd, s.f3 = "hd_road_elevation", s.f4 = BT, s.f5 = br, s.f6 = Kd, s.f7 = iS, s.f8 = Qd, s.f9 = function (a, e, i, c, h, p, m, x = 1, b, S) { a.createArrays(), a.tilePixelRatio = It / (512 * a.overscaling), a.compareText = {}, a.iconsNeedLinear = !1; const A = a.layers[0].layout, I = a.layers[0]._unevaluatedLayout._values, M = {}; M.scaleFactor = x, M.textSizeScaleRange = A.get("text-size-scale-range"), M.iconSizeScaleRange = A.get("icon-size-scale-range"); const [z, F] = M.textSizeScaleRange, [U, X] = M.iconSizeScaleRange; M.textScaleFactor = ke(M.scaleFactor, z, F), M.iconScaleFactor = ke(M.scaleFactor, U, X); const Y = I["text-size"], le = I["icon-size"]; if (a.textSizeData.kind === "composite") {
                const { minZoom: Te, maxZoom: Pe } = a.textSizeData;
                M.compositeTextSizes = [Y.possiblyEvaluate(new yn(Te), p), Y.possiblyEvaluate(new yn(Pe), p)];
            } if (a.iconSizeData.kind === "composite") {
                const { minZoom: Te, maxZoom: Pe } = a.iconSizeData;
                M.compositeIconSizes = [le.possiblyEvaluate(new yn(Te), p), le.possiblyEvaluate(new yn(Pe), p)];
            } M.layoutTextSize = Y.possiblyEvaluate(new yn(m + 1), p), M.layoutIconSize = le.possiblyEvaluate(new yn(m + 1), p), M.textMaxSize = Y.possiblyEvaluate(new yn(18), p); const se = A.get("symbol-placement"), $ = A.get("text-rotation-alignment") === "map" && se !== "point", te = A.get("text-size"); let ae = !1; const fe = []; for (const Te of a.features) {
                const Pe = A.get("text-font").evaluate(Te, {}, p).join(","), Me = te.evaluate(Te, {}, p) * M.textScaleFactor, Oe = M.layoutTextSize.evaluate(Te, {}, p) * M.textScaleFactor, Ye = M.layoutIconSize.evaluate(Te, {}, p) * M.iconScaleFactor, ut = { horizontal: {}, vertical: void 0 }, it = Te.text;
                let lt, pt = [0, 0];
                if (it) {
                    const qt = it.toString(), hr = A.get("text-letter-spacing").evaluate(Te, {}, p) * ts, wr = A.get("text-line-height").evaluate(Te, {}, p) * ts, Tr = dT(qt) ? hr : 0, Lr = A.get("text-anchor").evaluate(Te, {}, p), Pr = A.get("text-variable-anchor");
                    if (!Pr) {
                        const pe = A.get("text-radial-offset").evaluate(Te, {}, p);
                        if (pe)
                            pt = FM(Lr, [pe * ts, oS]);
                        else {
                            const Je = A.get("text-offset").evaluate(Te, {}, p);
                            pt = [Je[0] * ts, Je[1] * ts];
                        }
                    }
                    let Ar = $ ? "center" : A.get("text-justify").evaluate(Te, {}, p);
                    const Tn = se === "point", On = Tn ? A.get("text-max-width").evaluate(Te, {}, p) * ts : 1 / 0, he = pe => { a.allowVerticalPlacement && __(qt) && (ut.vertical = tS(it, e, i, h, Pe, On, wr, Lr, pe, Tr, pt, go.vertical, !0, Oe, Me, b)); };
                    if (!$ && Pr) {
                        const pe = Ar === "auto" ? Pr.map(Tt => aS(Tt)) : [Ar];
                        let Je = !1;
                        for (let Tt = 0; Tt < pe.length; Tt++) {
                            const Lt = pe[Tt];
                            if (!ut.horizontal[Lt])
                                if (Je)
                                    ut.horizontal[Lt] = ut.horizontal[0];
                                else {
                                    const Dt = tS(it, e, i, h, Pe, On, wr, "center", Lt, Tr, pt, go.horizontal, !1, Oe, Me, b);
                                    Dt && (ut.horizontal[Lt] = Dt, Je = Dt.positionedLines.length === 1);
                                }
                        }
                        he("left");
                    }
                    else {
                        if (Ar === "auto" && (Ar = aS(Lr)), Tn || A.get("text-writing-mode").indexOf("horizontal") >= 0 || !__(qt)) {
                            const pe = tS(it, e, i, h, Pe, On, wr, Lr, Ar, Tr, pt, go.horizontal, !1, Oe, Me, b);
                            pe && (ut.horizontal[Ar] = pe);
                        }
                        he(Tn ? "left" : Ar);
                    }
                }
                let We, at, Ge, Xe, gt, yt, Zt, jt = !1;
                if (Te.icon && Te.icon.hasPrimary()) {
                    const qt = BM(Te.icon, a.iconSizeData, I["icon-size"], p, a.zoom, Te, b, M.iconScaleFactor);
                    We = qt.iconPrimary, Ge = qt.iconSecondary;
                    const hr = We.toString();
                    if (at = c.get(hr), at && (gt = A.get("icon-offset").evaluate(Te, {}, p), yt = A.get("icon-anchor").evaluate(Te, {}, p), Zt = A.get("icon-text-fit").evaluate(Te, {}, p), lt = j5(h.get(hr), Ge ? h.get(Ge.toString()) : void 0, gt, yt), jt = at.sdf, a.sdfIcons === void 0 ? a.sdfIcons = at.sdf : a.sdfIcons !== at.sdf && Br("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (at.pixelRatio !== a.pixelRatio || A.get("icon-rotate").constantOr(1) !== 0) && (a.iconsNeedLinear = !0)), Ge) {
                        const wr = Ge.toString();
                        Xe = c.get(wr);
                    }
                }
                ae = ae || !(!Te.icon || !Te.icon.hasSecondary());
                const Rt = lS(ut.horizontal) || ut.vertical;
                a.iconsInText || (a.iconsInText = !!Rt && Rt.iconsInText);
                const mt = Oe * M.textScaleFactor / ts, { defaultShapedIcon: pr, verticallyShapedIcon: Gt } = X5(a, lt, A, Te, p, ut, mt, gt, Zt);
                Zt !== "none" && lt && (wM(lt) || bM(lt)) && (Ox(0, at, We, lt, pr, Zt, S, c, h), Ox(0, Xe, Ge, lt, pr, Zt, S, c, h), Gt && (Ox(0, at, We, lt, Gt, Zt, S, c, h), Ox(0, Xe, Ge, lt, Gt, Zt, S, c, h))), lt = pr, fe.push({ feature: Te, shapedTextOrientations: ut, shapedText: Rt, shapedIcon: lt, iconPrimary: We, iconSecondary: Ge, iconOffset: gt, iconAnchor: yt, verticallyShapedIcon: Gt, layoutTextSize: Oe, layoutIconSize: Ye, textOffset: pt, isSDFIcon: jt, iconTextFit: Zt });
            } return { featureData: fe, sizes: M, hasAnySecondaryIcon: ae, textAlongLine: $, symbolPlacement: se }; }, s.fa = RM, s.fb = function (a, e, i, c, h, p, m, x, b, S) { const { featureData: A, hasAnySecondaryIcon: I, sizes: M, textAlongLine: z, symbolPlacement: F } = e; for (const U of A) {
                const { shapedIcon: X, verticallyShapedIcon: Y, feature: le, shapedTextOrientations: se, shapedText: $, layoutTextSize: te, textOffset: ae, isSDFIcon: fe, iconPrimary: Te, iconSecondary: Pe, iconTextFit: Me, iconOffset: Oe } = U;
                jM(X, S.iconPositions, Te, Pe), jM(Y, S.iconPositions, Te, Pe), Z5(se, S.iconPositions), ($ || X) && K5(a, le, se, X, Y, b, M, te, 0, ae, fe, c, h, m, x, I, Me, Oe, z, F);
            } i && a.generateCollisionDebugBuffers(p, a.collisionBoxArray, M.textScaleFactor); }, s.fc = Qu, s.fd = o1, s.fe = sd, s.ff = lP, s.fg = dM, s.fh = ba, s.fi = function (a) { let e = 0; if (new Uint32Array(a, 0, 1)[0] !== lk) {
                const i = new Uint32Array(a, 0, 7), [, , c, h, p, m] = i;
                e = i.byteLength + h + p + m + p, (c !== a.byteLength || e >= a.byteLength) && Br("Invalid b3dm header information.");
            } return dk(a, e); }, s.fj = function (a, e) { const i = pk(a); for (const c of i) {
                for (const h of c.meshes)
                    EU(h);
                c.lights && (c.lightMeshIndex = c.meshes.length, c.meshes.push(CU(c.lights, e)));
            } return i; }, s.fk = Qx, s.fl = Dn, s.fm = IR, s.fn = zo, s.fo = function (a) { Xa(), ko != null && ko.then(e => { e.keys().then(i => { for (let c = 0; c < i.length - a; c++)
                e.delete(i[c]).catch(h => Br(h.message)); }).catch(i => Br(i.message)); }).catch(e => Br(e.message)); }, s.g = function (a, e) { return _u($e(a, { method: "GET" }), e); }, s.h = Ta, s.i = function (a) { return hs.API_STYLE_REGEX.test(a) && !_c(a); }, s.j = function (a) { return decodeURIComponent(atob(a).split("").map(e => "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2)).join("")); }, s.k = function (a) { return btoa(encodeURIComponent(a).replace(/%([0-9A-F]{2})/g, (e, i) => String.fromCharCode(+("0x" + i)))); }, s.l = $e, s.m = Og, s.n = function (a, e) { return _u($e(a, { type: "json" }), e); }, s.o = vu, s.p = function (a, e) { return _u($e(a, { method: "POST" }), e); }, s.q = Yo, s.r = ds, s.s = function (a) { try {
                const e = self[a];
                return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0;
            }
            catch {
                return !1;
            } }, s.t = kg, s.u = function () { return function a(e) { return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, a); }(); }, s.v = function (a) { return !!a && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(a); }, s.w = Br, s.x = function () { return AS || (AS = new tf), AS; }, s.y = kS, s.z = Ng;
        }), y(["./shared"], function (s) { function k(Qe) { const Z = Qe ? Qe.url.toString() : void 0; return Z ? performance.getEntriesByName(Z) : []; } function L(Qe) { if (typeof Qe == "number" || typeof Qe == "boolean" || typeof Qe == "string" || Qe == null)
            return JSON.stringify(Qe); if (Array.isArray(Qe)) {
            let re = "[";
            for (const _e of Qe)
                re += `${L(_e)},`;
            return `${re}]`;
        } let Z = "{"; for (const re of Object.keys(Qe).sort())
            Z += `${re}:${L(Qe[re])},`; return `${Z}}`; } function N(Qe) { let Z = ""; for (const re of s.bu)
            (Qe.type !== "model" || re !== "minzoom" && re !== "maxzoom") && (Z += `/${L(Qe[re])}`); return Z; } class V {
            constructor(Z) { this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, Z && this.replace(Z); }
            replace(Z, re) { this._layerConfigs = {}, this._layers = {}, this.update(Z, [], re); }
            update(Z, re, _e) { this._options = _e; for (const Ee of Z)
                this._layerConfigs[Ee.id] = Ee, (this._layers[Ee.id] = s.dc(Ee, this.scope, null, this._options)).compileFilter(_e), this.keyCache[Ee.id] && delete this.keyCache[Ee.id]; for (const Ee of re)
                delete this.keyCache[Ee], delete this._layerConfigs[Ee], delete this._layers[Ee]; this.familiesBySource = {}; const Ae = function (Ee, Re) { const ke = {}; for (let qe = 0; qe < Ee.length; qe++) {
                const tt = Ee[qe];
                let $e = Re && Re[tt.id];
                $e || (tt.type === "symbol" ? $e = tt.id : ($e = N(tt), tt.type === "line" && tt.paint && function Ot(Wt) { return typeof Wt == "string" && Wt === "line-progress" || (Array.isArray(Wt) ? Wt.some(Ot) : !(!Wt || typeof Wt != "object") && Object.values(Wt).some(Ot)); }(tt.paint["line-width"]) && ($e += `/${L(tt.paint["line-width"])}`))), Re && (Re[tt.id] = $e);
                let Ct = ke[$e];
                Ct || (Ct = ke[$e] = []), Ct.push(tt);
            } const De = []; for (const qe in ke)
                De.push(ke[qe]); return De; }(Object.values(this._layerConfigs), this.keyCache); for (const Ee of Ae) {
                const Re = Ee.map(Ct => this._layers[Ct.id]), ke = Re[0];
                if (ke.visibility === "none")
                    continue;
                const De = ke.source || "";
                let qe = this.familiesBySource[De];
                qe || (qe = this.familiesBySource[De] = {});
                const tt = ke.sourceLayer || "_geojsonTileLayer";
                let $e = qe[tt];
                $e || ($e = qe[tt] = []), $e.push(Re);
            } }
        } const H = 1 * s.e_; class ee {
            constructor(Z) { const re = {}, _e = []; for (const ke in Z) {
                const De = Z[ke], qe = re[ke] = {};
                for (const tt in De.glyphs) {
                    const $e = De.glyphs[+tt];
                    if (!$e || $e.bitmap.width === 0 || $e.bitmap.height === 0)
                        continue;
                    const Ct = $e.metrics.localGlyph ? H : 1, Ot = { x: 0, y: 0, w: $e.bitmap.width + 2 * Ct, h: $e.bitmap.height + 2 * Ct };
                    _e.push(Ot), qe[tt] = Ot;
                }
            } const { w: Ae, h: Ee } = s.H(_e), Re = new s.eZ({ width: Ae || 1, height: Ee || 1 }); for (const ke in Z) {
                const De = Z[ke];
                for (const qe in De.glyphs) {
                    const tt = De.glyphs[+qe];
                    if (!tt || tt.bitmap.width === 0 || tt.bitmap.height === 0)
                        continue;
                    const $e = re[ke][qe], Ct = tt.metrics.localGlyph ? H : 1;
                    s.eZ.copy(tt.bitmap, Re, { x: 0, y: 0 }, { x: $e.x + Ct, y: $e.y + Ct }, tt.bitmap);
                }
            } this.image = Re, this.positions = re; }
        } s.eY(ee, "GlyphAtlas"); class ce {
            constructor(Z) { this.tileID = new s.aM(Z.tileID.overscaledZ, Z.tileID.wrap, Z.tileID.canonical.z, Z.tileID.canonical.x, Z.tileID.canonical.y), this.tileZoom = Z.tileZoom, this.uid = Z.uid, this.zoom = Z.zoom, this.lut = Z.lut, this.canonical = Z.tileID.canonical, this.pixelRatio = Z.pixelRatio, this.tileSize = Z.tileSize, this.source = Z.source, this.scope = Z.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = Z.showCollisionBoxes, this.collectResourceTiming = !!Z.request && Z.request.collectResourceTiming, this.promoteId = Z.promoteId, this.isSymbolTile = Z.isSymbolTile, this.tileTransform = s.aW(Z.tileID.canonical, Z.projection), this.projection = Z.projection, this.worldview = Z.worldview, this.localizableLayerIds = Z.localizableLayerIds, this.brightness = Z.brightness, this.extraShadowCaster = !!Z.extraShadowCaster, this.tessellationStep = Z.tessellationStep, this.scaleFactor = Z.scaleFactor; }
            parse(Z, re, _e, Ae, Ee, Re) { this.status = "parsing", this.data = Z, this.collisionBoxArray = new s.b0; const ke = new s.e$(Object.keys(Z.layers).sort()), De = new s.f0(this.tileID, this.promoteId); De.bucketLayerIDs = []; const qe = {}, tt = new s.f1(256, 256), $e = { featureIndex: De, iconDependencies: new Map, patternDependencies: new Map, glyphDependencies: {}, lineAtlas: tt, availableImages: _e, brightness: this.brightness, scaleFactor: this.scaleFactor, elevationFeatures: void 0 }, Ct = re.familiesBySource[this.source]; for (const en in Ct) {
                const In = Z.layers[en];
                if (!In)
                    continue;
                let Dn = !1, vi = !1, Mi = !1;
                for (const _s of Ct[en])
                    _s[0].type === "symbol" ? Dn = !0 : vi = !0, _s[0].is3D() && _s[0].type !== "model" && (Mi = !0);
                if (this.extraShadowCaster && !Mi || this.isSymbolTile === !0 && !Dn || this.isSymbolTile === !1 && !vi)
                    continue;
                In.version === 1 && s.w(`Vector tile source "${this.source}" layer "${en}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const qi = ke.encode(en), os = [];
                let Ha = !1;
                for (let _s = 0, ys = 0; _s < In.length; _s++) {
                    const Ji = In.feature(_s), hs = De.getId(Ji, en);
                    if (this.localizableLayerIds && this.localizableLayerIds.has(en)) {
                        const Ta = Ji.properties ? Ji.properties.worldview : null;
                        if (this.worldview && typeof Ta == "string")
                            if (Ta === "all")
                                Ji.properties.$localized = !0;
                            else {
                                if (!Ta.split(",").includes(this.worldview))
                                    continue;
                                Ji.properties.$localized = !0, Ji.properties.worldview = this.worldview;
                            }
                    }
                    !Ha && Ji.properties && Ji.properties.hasOwnProperty(s.f2) && (Ha = !0), os.push({ feature: Ji, id: hs, index: ys, sourceLayerIndex: qi }), ys++;
                }
                Ha && !$e.elevationFeatures && Z.layers.hasOwnProperty(s.f3) && ($e.elevationFeatures = s.f4.parseFrom(Z.layers[s.f3], this.canonical));
                for (const _s of Ct[en]) {
                    const ys = _s[0];
                    (!this.extraShadowCaster || ys.is3D() && ys.type !== "model") && (this.isSymbolTile !== void 0 && ys.type === "symbol" !== this.isSymbolTile || ys.minzoom && this.zoom < Math.floor(ys.minzoom) || ys.maxzoom && this.zoom >= ys.maxzoom || ys.visibility !== "none" && (J(_s, this.zoom, $e.brightness, _e), (qe[ys.id] = ys.createBucket({ index: De.bucketLayerIDs.length, layers: _s, zoom: this.zoom, lut: this.lut, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: qi, sourceID: this.source, projection: this.projection.spec, tessellationStep: this.tessellationStep, styleDefinedModelURLs: Ae })).populate(os, $e, this.tileID.canonical, this.tileTransform), De.bucketLayerIDs.push(_s.map(Ji => s.C(Ji.id, Ji.scope)))));
                }
            } let Ot, Wt, _r, br, Mr, Fr; tt.trim(); const ai = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, Br = () => { if (Ot)
                return this.status = "done", Re(Ot); if (this.extraShadowCaster)
                this.status = "done", Re(null, { buckets: Object.values(qe).filter(en => !en.isEmpty()), featureIndex: De, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: $e.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
            else if (Wt && _r && br) {
                const en = new ee(Wt), In = new Map;
                for (const [Mi, qi] of _r.entries()) {
                    const { imagePosition: os } = s.f7(Mi, qi, s.f8);
                    In.set(Mi, os);
                }
                const Dn = {};
                for (const Mi in qe) {
                    const qi = qe[Mi];
                    qi instanceof s.b1 && (J(qi.layers, this.zoom, $e.brightness, _e), Dn[Mi] = s.f9(qi, Wt, en.positions, _r, In, this.tileID.canonical, this.tileZoom, this.scaleFactor, this.pixelRatio, Mr));
                }
                const vi = { iconsPending: !0, patternsPending: !0 };
                this.rasterizeIfNeeded(Ee, _r, Mr, () => { vi.iconsPending = !1, An(Dn, en, vi); }), this.rasterizeIfNeeded(Ee, br, Fr, () => { vi.patternsPending = !1, An(Dn, en, vi); });
            } }, An = (en, In, Dn, vi) => { if (Dn.iconsPending || Dn.patternsPending)
                return; const Mi = new s.fa(_r, br, this.lut); for (const qi in qe) {
                const os = qe[qi];
                if (qi in en)
                    s.fb(os, en[qi], this.showCollisionBoxes, _e, this.tileID.canonical, this.tileZoom, this.projection, this.brightness, _r, Mi);
                else if (os.hasPattern && (os instanceof s.b7 || os instanceof s.b8 || os instanceof s.dV)) {
                    J(os.layers, this.zoom, $e.brightness, _e);
                    const Ha = Object.fromEntries(Mi.patternPositions);
                    os.addFeatures($e, this.tileID.canonical, Ha, _e, this.tileTransform, this.brightness);
                }
            } this.status = "done", Re(null, { buckets: Object.values(qe).filter(qi => !qi.isEmpty()), featureIndex: De, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: In.image, lineAtlas: tt, imageAtlas: Mi, brightness: $e.brightness }); }; if (!this.extraShadowCaster) {
                const en = s.f5($e.glyphDependencies, vi => Object.keys(vi).map(Number));
                Object.keys(en).length ? Ee.send("getGlyphs", { uid: this.uid, stacks: en, scope: this.scope }, (vi, Mi) => { Ot || (Ot = vi, Wt = Mi, Br()); }, void 0, !1, ai) : Wt = {};
                const In = Array.from($e.iconDependencies.keys()).map(vi => s.I.parse(vi));
                In.length ? Ee.send("getImages", { images: In, source: this.source, scope: this.scope, tileID: this.tileID, type: "icons" }, (vi, Mi) => { Ot || (Ot = vi, _r = new Map, Mr = this.updateImageMapAndGetImageTaskQueue(_r, Mi, $e.iconDependencies), Br()); }, void 0, !1, ai) : (_r = new Map, Mr = new Map);
                const Dn = Array.from($e.patternDependencies.keys()).map(vi => s.I.parse(vi));
                Dn.length ? Ee.send("getImages", { images: Dn, source: this.source, scope: this.scope, tileID: this.tileID, type: "patterns" }, (vi, Mi) => { Ot || (Ot = vi, br = new Map, Fr = this.updateImageMapAndGetImageTaskQueue(br, Mi, $e.patternDependencies), Br()); }, void 0, !1, ai) : (br = new Map, Fr = new Map);
            } if ($e.elevationFeatures && $e.elevationFeatures.length > 0) {
                const en = [];
                for (const Dn of Object.values(qe))
                    if (Dn instanceof s.b8) {
                        const vi = Dn.getUnevaluatedPortalGraph();
                        vi && en.push(vi);
                    }
                const In = s.f6.evaluate(en);
                for (const Dn of Object.values(qe))
                    Dn instanceof s.b8 && Dn.setEvaluatedPortalGraph(In);
            } Br(); }
            rasterizeIfNeeded(Z, re, _e, Ae) { Array.from(re.values()).some(Ee => Ee.usvg) ? this.rasterize(Z, re, _e, Ae) : Ae(); }
            updateImageMapAndGetImageTaskQueue(Z, re, _e) { const Ae = new Map; for (const Ee of re.keys()) {
                const Re = _e.get(Ee) || [];
                for (const ke of Re) {
                    const De = ke.toString(), qe = re.get(ke.id.toString());
                    qe.usvg ? Ae.has(De) || (Ae.set(De, ke), Z.set(De, Object.assign({}, qe))) : Z.set(De, qe);
                }
            } return Ae; }
            rasterize(Z, re, _e, Ae) { this.rasterizeTask = Z.send("rasterizeImages", { scope: this.scope, tasks: _e }, (Ee, Re) => { if (!Ee)
                for (const [ke, De] of Re.entries()) {
                    const qe = Object.assign(re.get(ke), { data: De });
                    re.set(ke, qe);
                } Ae(); }); }
            cancelRasterize() { this.rasterizeTask && this.rasterizeTask.cancel(); }
        } function J(Qe, Z, re, _e) { const Ae = new s.aa(Z, { brightness: re }); for (const Ee of Qe)
            Ee.recalculate(Ae, _e); } class ye extends s.E {
            constructor(Z, re, _e, Ae, Ee, Re, ke) { super(), this.actor = Z, this.layerIndex = re, this.availableImages = _e, this.availableModels = Ae, this.loadVectorData = Re || s.aJ, this.loading = {}, this.loaded = {}, this.deduped = new s.aI(Z.scheduler), this.isSpriteLoaded = Ee, this.scheduler = Z.scheduler, this.brightness = ke; }
            loadTile(Z, re) { const _e = Z.uid, Ae = Z && Z.request, Ee = Ae && Ae.collectResourceTiming, Re = this.loading[_e] = new ce(Z); Re.abort = this.loadVectorData(Z, (ke, De) => { const qe = !this.loading[_e]; if (delete this.loading[_e], Re.cancelRasterize(), qe || ke || !De)
                return Re.status = "done", qe || (this.loaded[_e] = Re), re(ke); const tt = De.rawData, $e = {}; De.expires && ($e.expires = De.expires), De.cacheControl && ($e.cacheControl = De.cacheControl), Re.vectorTile = De.vectorTile || new s.fc.VectorTile(new s.bq(tt)); const Ct = () => { Re.parse(Re.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, (Ot, Wt) => { if (Ot || !Wt)
                return re(Ot); const _r = {}; if (Ee) {
                const br = k(Ae);
                br.length > 0 && (_r.resourceTiming = JSON.parse(JSON.stringify(br)));
            } re(null, s.l({ rawTileData: tt.slice(0) }, Wt, $e, _r)); }); }; this.isSpriteLoaded ? Ct() : this.once("isSpriteLoaded", () => { this.scheduler ? this.scheduler.add(Ct, { type: "parseTile", isSymbolTile: Z.isSymbolTile, zoom: Z.tileZoom }) : Ct(); }), this.loaded = this.loaded || {}, this.loaded[_e] = Re; }); }
            reloadTile(Z, re) { const _e = this.loaded, Ae = Z.uid; if (_e && _e[Ae]) {
                const Ee = _e[Ae];
                Ee.scaleFactor = Z.scaleFactor, Ee.showCollisionBoxes = Z.showCollisionBoxes, Ee.projection = Z.projection, Ee.brightness = Z.brightness, Ee.tileTransform = s.aW(Z.tileID.canonical, Z.projection), Ee.extraShadowCaster = Z.extraShadowCaster, Ee.lut = Z.lut;
                const Re = (ke, De) => { const qe = Ee.reloadCallback; qe && (delete Ee.reloadCallback, Ee.parse(Ee.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, qe)), re(ke, De); };
                Ee.status === "parsing" ? Ee.reloadCallback = Re : Ee.status === "done" && (Ee.vectorTile ? Ee.parse(Ee.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, Re) : Re());
            }
            else
                re(null, void 0); }
            abortTile(Z, re) { const _e = Z.uid, Ae = this.loading[_e]; Ae && (Ae.abort && Ae.abort(), delete this.loading[_e]), re(); }
            removeTile(Z, re) { const _e = this.loaded, Ae = Z.uid; _e && _e[Ae] && delete _e[Ae], re(); }
        } class ie {
            loadTile(Z, re) { const { uid: _e, encoding: Ae, rawImageData: Ee, padding: Re } = Z, ke = ImageBitmap && Ee instanceof ImageBitmap ? this.getImageData(Ee, Re) : Ee; re(null, new s.fd(_e, ke, Ae, Re < 1)); }
            reloadTile(Z, re) { re(null, null); }
            abortTile(Z, re) { re(); }
            removeTile(Z, re) { re(); }
            getImageData(Z, re) { this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(Z.width, Z.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: !0 })), this.offscreenCanvas.width = Z.width, this.offscreenCanvas.height = Z.height, this.offscreenCanvasContext.drawImage(Z, 0, 0, Z.width, Z.height); const _e = this.offscreenCanvasContext.getImageData(-re, -re, Z.width + 2 * re, Z.height + 2 * re); return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), _e; }
        } s.bp.setPbf(s.bq); class Q {
            constructor(Z) { this._mrt = new s.bp(Z.partial ? 30 : 1 / 0), this._isHeaderLoaded = !1, this.uid = Z.uid, this.tileID = Z.tileID, this.source = Z.source; }
            parse(Z, re) { const _e = this._mrt; this.status = "parsing", this._entireBuffer = Z; try {
                _e.parseHeader(Z), this._isHeaderLoaded = !0;
                const Ae = [];
                for (const Ee in _e.layers) {
                    const Re = _e.getLayer(Ee), ke = Re.getDataRange(Re.getBandList()), De = _e.createDecodingTask(ke), qe = Z.slice(ke.firstByte, ke.lastByte + 1), tt = s.bp.performDecoding(qe, De).then($e => De.complete(null, $e)).catch($e => De.complete($e, null));
                    Ae.push(tt);
                }
                Promise.allSettled(Ae).then(() => re(null, _e)).catch(Ee => re(Ee));
            }
            catch (Ae) {
                re(Ae);
            } }
        } class ue {
            constructor(Z) { this.actor = Z, this.loading = {}, this.loaded = {}; }
            loadTile(Z, re) { const _e = Z.uid, Ae = Z.request, Ee = this.loading[_e] = new Q(Z), { cancel: Re } = s.br(Ae, (ke, De, qe, tt) => { const $e = !this.loading[_e]; if (delete this.loading[_e], $e || ke || !De)
                return Ee.status = "done", $e || (this.loaded[_e] = Ee), re(ke); Ee.parse(De, (Ct, Ot) => { if (Ct || !Ot)
                return re(Ct); re(null, Ot, qe, tt); }), this.loaded[_e] = Ee; }); Ee.abort = Re; }
            reloadTile(Z, re) { re(null, void 0); }
            abortTile(Z, re) { const _e = Z.uid, Ae = this.loading[_e]; Ae && (Ae.abort && Ae.abort(), delete this.loading[_e]), re(); }
            removeTile(Z, re) { const _e = Z.uid; this.loaded[_e] && delete this.loaded[_e], re(); }
            decodeRasterArray(Z, re) { s.bp.performDecoding(Z.buffer, Z.task).then(_e => re(null, _e)).catch(_e => re(_e)); }
        } const be = s.fc.VectorTileFeature.prototype.toGeoJSON; class Ie {
            constructor(Z) { this._feature = Z, this.extent = s.aj, this.type = Z.type, this.properties = Z.tags, "id" in Z && !isNaN(Z.id) && (this.id = parseInt(Z.id, 10)); }
            loadGeometry() { if (this._feature.type === 1) {
                const Z = [];
                for (const re of this._feature.geometry)
                    Z.push([new s.P(re[0], re[1])]);
                return Z;
            } {
                const Z = [];
                for (const re of this._feature.geometry) {
                    const _e = [];
                    for (const Ae of re)
                        _e.push(new s.P(Ae[0], Ae[1]));
                    Z.push(_e);
                }
                return Z;
            } }
            toGeoJSON(Z, re, _e) { return be.call(this, Z, re, _e); }
        } class Be {
            constructor(Z) { this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = s.aj, this.length = Z.length, this._features = Z; }
            feature(Z) { return new Ie(this._features[Z]); }
        } const Ze = 64 / 4096, ot = 128; class At {
            constructor() { this.features = new Map; }
            clear() { this.features.clear(); }
            load(Z = [], re) { for (const _e of Z) {
                const Ae = _e.id;
                if (Ae == null)
                    continue;
                let Ee = this.features.get(Ae);
                Ee && this.updateCache(Ee, re), _e.geometry ? (Ee = ct(_e), this.updateCache(Ee, re), this.features.set(Ae, Ee)) : this.features.delete(Ae), this.updateCache(Ee, re);
            } }
            updateCache(Z, re) { for (const { canonical: _e, uid: Ae } of Object.values(re)) {
                const { z: Ee, x: Re, y: ke } = _e;
                kt(Z, Math.pow(2, Ee), Re, ke) && delete re[Ae];
            } }
            getTile(Z, re, _e) { const Ae = Math.pow(2, Z), Ee = []; for (const Re of this.features.values())
                kt(Re, Ae, re, _e) && Ee.push(ir(Re, Ae, re, _e)); return { features: Ee }; }
            getFeatures() { return [...this.features.values()]; }
        } function kt({ minX: Qe, minY: Z, maxX: re, maxY: _e }, Ae, Ee, Re) { return Qe < (Ee + 1 + Ze) / Ae && Z < (Re + 1 + Ze) / Ae && re > (Ee - Ze) / Ae && _e > (Re - Ze) / Ae; } function ct(Qe) { const { id: Z, geometry: re, properties: _e } = Qe; if (!re)
            return; if (re.type === "GeometryCollection")
            throw new Error("GeometryCollection not supported in dynamic mode."); const { type: Ae, coordinates: Ee } = re, Re = { id: Z, type: 1, geometry: [], tags: _e, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }, ke = Re.geometry; if (Ae === "Point")
            St(Ee, ke, Re);
        else if (Ae === "MultiPoint")
            for (const De of Ee)
                St(De, ke, Re);
        else if (Ae === "LineString")
            Re.type = 2, Kt(Ee, ke, Re);
        else if (Ae === "MultiLineString")
            Re.type = 2, bt(Ee, ke, Re);
        else if (Ae === "Polygon")
            Re.type = 3, bt(Ee, ke, Re, !0);
        else {
            if (Ae !== "MultiPolygon")
                throw new Error("Input data is not a valid GeoJSON object.");
            Re.type = 3;
            for (const De of Ee)
                bt(De, ke, Re, !0);
        } return Re; } function St([Qe, Z], re, _e) { const Ae = s.ay(Qe); let Ee = s.aH(Z); Ee = Ee < 0 ? 0 : Ee > 1 ? 1 : Ee, re.push(Ae, Ee), _e.minX = Math.min(_e.minX, Ae), _e.minY = Math.min(_e.minY, Ee), _e.maxX = Math.max(_e.maxX, Ae), _e.maxY = Math.max(_e.maxY, Ee); } function Kt(Qe, Z, re, _e = !1, Ae = !1) { const Ee = []; for (const Re of Qe)
            St(Re, Ee, re); Z.push(Ee), _e && function (Re, ke) { let De = 0; for (let qe = 0, tt = Re.length, $e = tt - 2; qe < tt; $e = qe, qe += 2)
            De += (Re[qe] - Re[$e]) * (Re[qe + 1] + Re[$e + 1]); if (De > 0 === ke)
            for (let qe = 0, tt = Re.length; qe < tt / 2; qe += 2) {
                const $e = Re[qe], Ct = Re[qe + 1];
                Re[qe] = Re[tt - 2 - qe], Re[qe + 1] = Re[tt - 1 - qe], Re[tt - 2 - qe] = $e, Re[tt - 1 - qe] = Ct;
            } }(Ee, Ae); } function bt(Qe, Z, re, _e = !1) { for (let Ae = 0; Ae < Qe.length; Ae++)
            Kt(Qe[Ae], Z, re, _e, Ae === 0); } function ir(Qe, Z, re, _e) { const { id: Ae, type: Ee, geometry: Re, tags: ke } = Qe, De = []; if (Ee === 1)
            (function (qe, tt, $e, Ct, Ot) { for (let Wt = 0; Wt < qe.length; Wt += 2) {
                const _r = Math.round(s.aj * (qe[Wt + 0] * tt - $e)), br = Math.round(s.aj * (qe[Wt + 1] * tt - Ct));
                Ot.push([_r, br]);
            } })(Re, Z, re, _e, De);
        else
            for (const qe of Re)
                tr(qe, Z, re, _e, De); return { id: Ae, type: Ee, geometry: De, tags: ke }; } function tr(Qe, Z, re, _e, Ae) { const Ee = -ot, Re = s.aj + ot; let ke; for (let De = 0; De < Qe.length - 2; De += 2) {
            let qe = Math.round(s.aj * (Qe[De + 0] * Z - re)), tt = Math.round(s.aj * (Qe[De + 1] * Z - _e)), $e = Math.round(s.aj * (Qe[De + 2] * Z - re)), Ct = Math.round(s.aj * (Qe[De + 3] * Z - _e));
            const Ot = $e - qe, Wt = Ct - tt;
            qe < Ee && $e < Ee || (qe < Ee ? (tt += Math.round(Wt * ((Ee - qe) / Ot)), qe = Ee) : $e < Ee && (Ct = tt + Math.round(Wt * ((Ee - qe) / Ot)), $e = Ee), tt < Ee && Ct < Ee || (tt < Ee ? (qe += Math.round(Ot * ((Ee - tt) / Wt)), tt = Ee) : Ct < Ee && ($e = qe + Math.round(Ot * ((Ee - tt) / Wt)), Ct = Ee), qe >= Re && $e >= Re || (qe >= Re ? (tt += Math.round(Wt * ((Re - qe) / Ot)), qe = Re) : $e >= Re && (Ct = tt + Math.round(Wt * ((Re - qe) / Ot)), $e = Re), tt >= Re && Ct >= Re || (tt >= Re ? (qe += Math.round(Ot * ((Re - tt) / Wt)), tt = Re) : Ct >= Re && ($e = qe + Math.round(Ot * ((Re - tt) / Wt)), Ct = Re), ke && qe === ke[ke.length - 1][0] && tt === ke[ke.length - 1][1] || (ke = [[qe, tt]], Ae.push(ke)), ke.push([$e, Ct])))));
        } } var Or, xt, Pt, Ft = { exports: {} }, gr = function () { if (Pt)
            return Ft.exports; Pt = 1; var Qe = s.fg(), Z = function () { if (xt)
            return Or; xt = 1; var tt = s.fe(), $e = s.ff().VectorTileFeature; function Ct(Wt, _r) { this.options = _r || {}, this.features = Wt, this.length = Wt.length; } function Ot(Wt, _r) { this.id = typeof Wt.id == "number" ? Wt.id : void 0, this.type = Wt.type, this.rawGeometry = Wt.type === 1 ? [Wt.geometry] : Wt.geometry, this.properties = Wt.tags, this.extent = _r || 4096; } return Or = Ct, Ct.prototype.feature = function (Wt) { return new Ot(this.features[Wt], this.options.extent); }, Ot.prototype.loadGeometry = function () { var Wt = this.rawGeometry; this.geometry = []; for (var _r = 0; _r < Wt.length; _r++) {
            for (var br = Wt[_r], Mr = [], Fr = 0; Fr < br.length; Fr++)
                Mr.push(new tt(br[Fr][0], br[Fr][1]));
            this.geometry.push(Mr);
        } return this.geometry; }, Ot.prototype.bbox = function () { this.geometry || this.loadGeometry(); for (var Wt = this.geometry, _r = 1 / 0, br = -1 / 0, Mr = 1 / 0, Fr = -1 / 0, ai = 0; ai < Wt.length; ai++)
            for (var Br = Wt[ai], An = 0; An < Br.length; An++) {
                var en = Br[An];
                _r = Math.min(_r, en.x), br = Math.max(br, en.x), Mr = Math.min(Mr, en.y), Fr = Math.max(Fr, en.y);
            } return [_r, Mr, br, Fr]; }, Ot.prototype.toGeoJSON = $e.prototype.toGeoJSON, Or; }(); function re(tt) { var $e = new Qe; return function (Ct, Ot) { for (var Wt in Ct.layers)
            Ot.writeMessage(3, _e, Ct.layers[Wt]); }(tt, $e), $e.finish(); } function _e(tt, $e) { var Ct; $e.writeVarintField(15, tt.version || 1), $e.writeStringField(1, tt.name || ""), $e.writeVarintField(5, tt.extent || 4096); var Ot = { keys: [], values: [], keycache: {}, valuecache: {} }; for (Ct = 0; Ct < tt.length; Ct++)
            Ot.feature = tt.feature(Ct), $e.writeMessage(2, Ae, Ot); var Wt = Ot.keys; for (Ct = 0; Ct < Wt.length; Ct++)
            $e.writeStringField(3, Wt[Ct]); var _r = Ot.values; for (Ct = 0; Ct < _r.length; Ct++)
            $e.writeMessage(4, qe, _r[Ct]); } function Ae(tt, $e) { var Ct = tt.feature; Ct.id !== void 0 && $e.writeVarintField(1, Ct.id), $e.writeMessage(2, Ee, tt), $e.writeVarintField(3, Ct.type), $e.writeMessage(4, De, Ct); } function Ee(tt, $e) { var Ct = tt.feature, Ot = tt.keys, Wt = tt.values, _r = tt.keycache, br = tt.valuecache; for (var Mr in Ct.properties) {
            var Fr = Ct.properties[Mr], ai = _r[Mr];
            if (Fr !== null) {
                ai === void 0 && (Ot.push(Mr), _r[Mr] = ai = Ot.length - 1), $e.writeVarint(ai);
                var Br = typeof Fr;
                Br !== "string" && Br !== "boolean" && Br !== "number" && (Fr = JSON.stringify(Fr));
                var An = Br + ":" + Fr, en = br[An];
                en === void 0 && (Wt.push(Fr), br[An] = en = Wt.length - 1), $e.writeVarint(en);
            }
        } } function Re(tt, $e) { return ($e << 3) + (7 & tt); } function ke(tt) { return tt << 1 ^ tt >> 31; } function De(tt, $e) { for (var Ct = tt.loadGeometry(), Ot = tt.type, Wt = 0, _r = 0, br = Ct.length, Mr = 0; Mr < br; Mr++) {
            var Fr = Ct[Mr], ai = 1;
            Ot === 1 && (ai = Fr.length), $e.writeVarint(Re(1, ai));
            for (var Br = Ot === 3 ? Fr.length - 1 : Fr.length, An = 0; An < Br; An++) {
                An === 1 && Ot !== 1 && $e.writeVarint(Re(2, Br - 1));
                var en = Fr[An].x - Wt, In = Fr[An].y - _r;
                $e.writeVarint(ke(en)), $e.writeVarint(ke(In)), Wt += en, _r += In;
            }
            Ot === 3 && $e.writeVarint(Re(7, 1));
        } } function qe(tt, $e) { var Ct = typeof tt; Ct === "string" ? $e.writeStringField(1, tt) : Ct === "boolean" ? $e.writeBooleanField(7, tt) : Ct === "number" && (tt % 1 != 0 ? $e.writeDoubleField(3, tt) : tt < 0 ? $e.writeSVarintField(6, tt) : $e.writeVarintField(5, tt)); } return Ft.exports = re, Ft.exports.fromVectorTileJs = re, Ft.exports.fromGeojsonVt = function (tt, $e) { $e = $e || {}; var Ct = {}; for (var Ot in tt)
            Ct[Ot] = new Z(tt[Ot].features, $e), Ct[Ot].name = Ot, Ct[Ot].version = $e.version, Ct[Ot].extent = $e.extent; return re({ layers: Ct }); }, Ft.exports.GeoJSONWrapper = Z, Ft.exports; }(), Jr = s.fh(gr); const pi = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: Qe => Qe }, Si = Math.fround || (an = new Float32Array(1), Qe => (an[0] = +Qe, an[0])); var an; const Kr = 3, mn = 5, Xs = 6; class ln {
            constructor(Z) { this.options = Object.assign(Object.create(pi), Z), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []; }
            load(Z) { const { log: re, minZoom: _e, maxZoom: Ae } = this.options; re && console.time("total time"); const Ee = `prepare ${Z.length} points`; re && console.time(Ee), this.points = Z; const Re = []; for (let De = 0; De < Z.length; De++) {
                const qe = Z[De];
                if (!qe.geometry)
                    continue;
                const [tt, $e] = qe.geometry.coordinates, Ct = Si(ss(tt)), Ot = Si(Gn($e));
                Re.push(Ct, Ot, 1 / 0, De, -1, 1), this.options.reduce && Re.push(0);
            } let ke = this.trees[Ae + 1] = this._createTree(Re); re && console.timeEnd(Ee); for (let De = Ae; De >= _e; De--) {
                const qe = +Date.now();
                ke = this.trees[De] = this._createTree(this._cluster(ke, De)), re && console.log("z%d: %d clusters in %dms", De, ke.numItems, +Date.now() - qe);
            } return re && console.timeEnd("total time"), this; }
            getClusters(Z, re) { let _e = ((Z[0] + 180) % 360 + 360) % 360 - 180; const Ae = Math.max(-90, Math.min(90, Z[1])); let Ee = Z[2] === 180 ? 180 : ((Z[2] + 180) % 360 + 360) % 360 - 180; const Re = Math.max(-90, Math.min(90, Z[3])); if (Z[2] - Z[0] >= 360)
                _e = -180, Ee = 180;
            else if (_e > Ee) {
                const $e = this.getClusters([_e, Ae, 180, Re], re), Ct = this.getClusters([-180, Ae, Ee, Re], re);
                return $e.concat(Ct);
            } const ke = this.trees[this._limitZoom(re)], De = ke.range(ss(_e), Gn(Re), ss(Ee), Gn(Ae)), qe = ke.data, tt = []; for (const $e of De) {
                const Ct = this.stride * $e;
                tt.push(qe[Ct + mn] > 1 ? Bs(qe, Ct, this.clusterProps) : this.points[qe[Ct + Kr]]);
            } return tt; }
            getChildren(Z) { const re = this._getOriginId(Z), _e = this._getOriginZoom(Z), Ae = "No cluster with the specified id.", Ee = this.trees[_e]; if (!Ee)
                throw new Error(Ae); const Re = Ee.data; if (re * this.stride >= Re.length)
                throw new Error(Ae); const ke = this.options.radius / (this.options.extent * Math.pow(2, _e - 1)), De = Ee.within(Re[re * this.stride], Re[re * this.stride + 1], ke), qe = []; for (const tt of De) {
                const $e = tt * this.stride;
                Re[$e + 4] === Z && qe.push(Re[$e + mn] > 1 ? Bs(Re, $e, this.clusterProps) : this.points[Re[$e + Kr]]);
            } if (qe.length === 0)
                throw new Error(Ae); return qe; }
            getLeaves(Z, re, _e) { const Ae = []; return this._appendLeaves(Ae, Z, re = re || 10, _e = _e || 0, 0), Ae; }
            getTile(Z, re, _e) { const Ae = this.trees[this._limitZoom(Z)], Ee = Math.pow(2, Z), { extent: Re, radius: ke } = this.options, De = ke / Re, qe = (_e - De) / Ee, tt = (_e + 1 + De) / Ee, $e = { features: [] }; return this._addTileFeatures(Ae.range((re - De) / Ee, qe, (re + 1 + De) / Ee, tt), Ae.data, re, _e, Ee, $e), re === 0 && this._addTileFeatures(Ae.range(1 - De / Ee, qe, 1, tt), Ae.data, Ee, _e, Ee, $e), re === Ee - 1 && this._addTileFeatures(Ae.range(0, qe, De / Ee, tt), Ae.data, -1, _e, Ee, $e), $e.features.length ? $e : null; }
            getClusterExpansionZoom(Z) { let re = this._getOriginZoom(Z) - 1; for (; re <= this.options.maxZoom;) {
                const _e = this.getChildren(Z);
                if (re++, _e.length !== 1)
                    break;
                Z = _e[0].properties.cluster_id;
            } return re; }
            _appendLeaves(Z, re, _e, Ae, Ee) { const Re = this.getChildren(re); for (const ke of Re) {
                const De = ke.properties;
                if (De && De.cluster ? Ee + De.point_count <= Ae ? Ee += De.point_count : Ee = this._appendLeaves(Z, De.cluster_id, _e, Ae, Ee) : Ee < Ae ? Ee++ : Z.push(ke), Z.length === _e)
                    break;
            } return Ee; }
            _createTree(Z) { const re = new s.bW(Z.length / this.stride | 0, this.options.nodeSize, Float32Array); for (let _e = 0; _e < Z.length; _e += this.stride)
                re.add(Z[_e], Z[_e + 1]); return re.finish(), re.data = Z, re; }
            _addTileFeatures(Z, re, _e, Ae, Ee, Re) { for (const ke of Z) {
                const De = ke * this.stride, qe = re[De + mn] > 1;
                let tt, $e, Ct;
                if (qe)
                    tt = js(re, De, this.clusterProps), $e = re[De], Ct = re[De + 1];
                else {
                    const _r = this.points[re[De + Kr]];
                    tt = _r.properties;
                    const [br, Mr] = _r.geometry.coordinates;
                    $e = ss(br), Ct = Gn(Mr);
                }
                const Ot = { type: 1, geometry: [[Math.round(this.options.extent * ($e * Ee - _e)), Math.round(this.options.extent * (Ct * Ee - Ae))]], tags: tt };
                let Wt;
                Wt = qe || this.options.generateId ? re[De + Kr] : this.points[re[De + Kr]].id, Wt !== void 0 && (Ot.id = Wt), Re.features.push(Ot);
            } }
            _limitZoom(Z) { return Math.max(this.options.minZoom, Math.min(Math.floor(+Z), this.options.maxZoom + 1)); }
            _cluster(Z, re) { const { radius: _e, extent: Ae, reduce: Ee, minPoints: Re } = this.options, ke = _e / (Ae * Math.pow(2, re)), De = Z.data, qe = [], tt = this.stride; for (let $e = 0; $e < De.length; $e += tt) {
                if (De[$e + 2] <= re)
                    continue;
                De[$e + 2] = re;
                const Ct = De[$e], Ot = De[$e + 1], Wt = Z.within(De[$e], De[$e + 1], ke), _r = De[$e + mn];
                let br = _r;
                for (const Mr of Wt) {
                    const Fr = Mr * tt;
                    De[Fr + 2] > re && (br += De[Fr + mn]);
                }
                if (br > _r && br >= Re) {
                    let Mr, Fr = Ct * _r, ai = Ot * _r, Br = -1;
                    const An = ($e / tt << 5) + (re + 1) + this.points.length;
                    for (const en of Wt) {
                        const In = en * tt;
                        if (De[In + 2] <= re)
                            continue;
                        De[In + 2] = re;
                        const Dn = De[In + mn];
                        Fr += De[In] * Dn, ai += De[In + 1] * Dn, De[In + 4] = An, Ee && (Mr || (Mr = this._map(De, $e, !0), Br = this.clusterProps.length, this.clusterProps.push(Mr)), Ee(Mr, this._map(De, In)));
                    }
                    De[$e + 4] = An, qe.push(Fr / br, ai / br, 1 / 0, An, -1, br), Ee && qe.push(Br);
                }
                else {
                    for (let Mr = 0; Mr < tt; Mr++)
                        qe.push(De[$e + Mr]);
                    if (br > 1)
                        for (const Mr of Wt) {
                            const Fr = Mr * tt;
                            if (!(De[Fr + 2] <= re)) {
                                De[Fr + 2] = re;
                                for (let ai = 0; ai < tt; ai++)
                                    qe.push(De[Fr + ai]);
                            }
                        }
                }
            } return qe; }
            _getOriginId(Z) { return Z - this.points.length >> 5; }
            _getOriginZoom(Z) { return (Z - this.points.length) % 32; }
            _map(Z, re, _e) { if (Z[re + mn] > 1) {
                const Re = this.clusterProps[Z[re + Xs]];
                return _e ? Object.assign({}, Re) : Re;
            } const Ae = this.points[Z[re + Kr]].properties, Ee = this.options.map(Ae); return _e && Ee === Ae ? Object.assign({}, Ee) : Ee; }
        } function Bs(Qe, Z, re) { return { type: "Feature", id: Qe[Z + Kr], properties: js(Qe, Z, re), geometry: { type: "Point", coordinates: [(_e = Qe[Z], 360 * (_e - .5)), Ua(Qe[Z + 1])] } }; var _e; } function js(Qe, Z, re) { const _e = Qe[Z + mn], Ae = _e >= 1e4 ? `${Math.round(_e / 1e3)}k` : _e >= 1e3 ? Math.round(_e / 100) / 10 + "k" : _e, Ee = Qe[Z + Xs], Re = Ee === -1 ? {} : Object.assign({}, re[Ee]); return Object.assign(Re, { cluster: !0, cluster_id: Qe[Z + Kr], point_count: _e, point_count_abbreviated: Ae }); } function ss(Qe) { return Qe / 360 + .5; } function Gn(Qe) { const Z = Math.sin(Qe * Math.PI / 180), re = .5 - .25 * Math.log((1 + Z) / (1 - Z)) / Math.PI; return re < 0 ? 0 : re > 1 ? 1 : re; } function Ua(Qe) { const Z = (180 - 360 * Qe) * Math.PI / 180; return 360 * Math.atan(Math.exp(Z)) / Math.PI - 90; } function Xo(Qe, Z, re, _e) { let Ae = _e; const Ee = Z + (re - Z >> 1); let Re, ke = re - Z; const De = Qe[Z], qe = Qe[Z + 1], tt = Qe[re], $e = Qe[re + 1]; for (let Ct = Z + 3; Ct < re; Ct += 3) {
            const Ot = $i(Qe[Ct], Qe[Ct + 1], De, qe, tt, $e);
            if (Ot > Ae)
                Re = Ct, Ae = Ot;
            else if (Ot === Ae) {
                const Wt = Math.abs(Ct - Ee);
                Wt < ke && (Re = Ct, ke = Wt);
            }
        } Ae > _e && (Re - Z > 3 && Xo(Qe, Z, Re, _e), Qe[Re + 2] = Ae, re - Re > 3 && Xo(Qe, Re, re, _e)); } function $i(Qe, Z, re, _e, Ae, Ee) { let Re = Ae - re, ke = Ee - _e; if (Re !== 0 || ke !== 0) {
            const De = ((Qe - re) * Re + (Z - _e) * ke) / (Re * Re + ke * ke);
            De > 1 ? (re = Ae, _e = Ee) : De > 0 && (re += Re * De, _e += ke * De);
        } return Re = Qe - re, ke = Z - _e, Re * Re + ke * ke; } function Ks(Qe, Z, re, _e) { const Ae = { id: Qe ?? null, type: Z, geometry: re, tags: _e, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }; if (Z === "Point" || Z === "MultiPoint" || Z === "LineString")
            Io(Ae, re);
        else if (Z === "Polygon")
            Io(Ae, re[0]);
        else if (Z === "MultiLineString")
            for (const Ee of re)
                Io(Ae, Ee);
        else if (Z === "MultiPolygon")
            for (const Ee of re)
                Io(Ae, Ee[0]); return Ae; } function Io(Qe, Z) { for (let re = 0; re < Z.length; re += 3)
            Qe.minX = Math.min(Qe.minX, Z[re]), Qe.minY = Math.min(Qe.minY, Z[re + 1]), Qe.maxX = Math.max(Qe.maxX, Z[re]), Qe.maxY = Math.max(Qe.maxY, Z[re + 1]); } function Gi(Qe, Z, re, _e) { if (!Z.geometry)
            return; const Ae = Z.geometry.coordinates; if (Ae && Ae.length === 0)
            return; const Ee = Z.geometry.type, Re = Math.pow(re.tolerance / ((1 << re.maxZoom) * re.extent), 2); let ke = [], De = Z.id; if (re.promoteId ? De = Z.properties[re.promoteId] : re.generateId && (De = _e || 0), Ee === "Point")
            Po(Ae, ke);
        else if (Ee === "MultiPoint")
            for (const qe of Ae)
                Po(qe, ke);
        else if (Ee === "LineString")
            Ko(Ae, ke, Re, !1);
        else if (Ee === "MultiLineString") {
            if (re.lineMetrics) {
                for (const qe of Ae)
                    ke = [], Ko(qe, ke, Re, !1), Qe.push(Ks(De, "LineString", ke, Z.properties));
                return;
            }
            Ue(Ae, ke, Re, !1);
        }
        else if (Ee === "Polygon")
            Ue(Ae, ke, Re, !0);
        else {
            if (Ee !== "MultiPolygon") {
                if (Ee === "GeometryCollection") {
                    for (const qe of Z.geometry.geometries)
                        Gi(Qe, { id: De, geometry: qe, properties: Z.properties }, re, _e);
                    return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const qe of Ae) {
                const tt = [];
                Ue(qe, tt, Re, !0), ke.push(tt);
            }
        } Qe.push(Ks(De, Ee, ke, Z.properties)); } function Po(Qe, Z) { Z.push(_t(Qe[0]), Mt(Qe[1]), 0); } function Ko(Qe, Z, re, _e) { let Ae, Ee, Re = 0; for (let De = 0; De < Qe.length; De++) {
            const qe = _t(Qe[De][0]), tt = Mt(Qe[De][1]);
            Z.push(qe, tt, 0), De > 0 && (Re += _e ? (Ae * tt - qe * Ee) / 2 : Math.sqrt(Math.pow(qe - Ae, 2) + Math.pow(tt - Ee, 2))), Ae = qe, Ee = tt;
        } const ke = Z.length - 3; Z[2] = 1, Xo(Z, 0, ke, re), Z[ke + 2] = 1, Z.size = Math.abs(Re), Z.start = 0, Z.end = Z.size; } function Ue(Qe, Z, re, _e) { for (let Ae = 0; Ae < Qe.length; Ae++) {
            const Ee = [];
            Ko(Qe[Ae], Ee, re, _e), Z.push(Ee);
        } } function _t(Qe) { return Qe / 360 + .5; } function Mt(Qe) { const Z = Math.sin(Qe * Math.PI / 180), re = .5 - .25 * Math.log((1 + Z) / (1 - Z)) / Math.PI; return re < 0 ? 0 : re > 1 ? 1 : re; } function cr(Qe, Z, re, _e, Ae, Ee, Re, ke) { if (_e /= Z, Ee >= (re /= Z) && Re < _e)
            return Qe; if (Re < re || Ee >= _e)
            return null; const De = []; for (const qe of Qe) {
            const tt = qe.geometry;
            let $e = qe.type;
            const Ct = Ae === 0 ? qe.minX : qe.minY, Ot = Ae === 0 ? qe.maxX : qe.maxY;
            if (Ct >= re && Ot < _e) {
                De.push(qe);
                continue;
            }
            if (Ot < re || Ct >= _e)
                continue;
            let Wt = [];
            if ($e === "Point" || $e === "MultiPoint")
                ur(tt, Wt, re, _e, Ae);
            else if ($e === "LineString")
                Jt(tt, Wt, re, _e, Ae, !1, ke.lineMetrics);
            else if ($e === "MultiLineString")
                gn(tt, Wt, re, _e, Ae, !1);
            else if ($e === "Polygon")
                gn(tt, Wt, re, _e, Ae, !0);
            else if ($e === "MultiPolygon")
                for (const _r of tt) {
                    const br = [];
                    gn(_r, br, re, _e, Ae, !0), br.length && Wt.push(br);
                }
            if (Wt.length) {
                if (ke.lineMetrics && $e === "LineString") {
                    for (const _r of Wt)
                        De.push(Ks(qe.id, $e, _r, qe.tags));
                    continue;
                }
                $e !== "LineString" && $e !== "MultiLineString" || (Wt.length === 1 ? ($e = "LineString", Wt = Wt[0]) : $e = "MultiLineString"), $e !== "Point" && $e !== "MultiPoint" || ($e = Wt.length === 3 ? "Point" : "MultiPoint"), De.push(Ks(qe.id, $e, Wt, qe.tags));
            }
        } return De.length ? De : null; } function ur(Qe, Z, re, _e, Ae) { for (let Ee = 0; Ee < Qe.length; Ee += 3) {
            const Re = Qe[Ee + Ae];
            Re >= re && Re <= _e && mi(Z, Qe[Ee], Qe[Ee + 1], Qe[Ee + 2]);
        } } function Jt(Qe, Z, re, _e, Ae, Ee, Re) { let ke = vr(Qe); const De = Ae === 0 ? oi : $a; let qe, tt, $e = Qe.start; for (let br = 0; br < Qe.length - 3; br += 3) {
            const Mr = Qe[br], Fr = Qe[br + 1], ai = Qe[br + 2], Br = Qe[br + 3], An = Qe[br + 4], en = Ae === 0 ? Mr : Fr, In = Ae === 0 ? Br : An;
            let Dn = !1;
            Re && (qe = Math.sqrt(Math.pow(Mr - Br, 2) + Math.pow(Fr - An, 2))), en < re ? In > re && (tt = De(ke, Mr, Fr, Br, An, re), Re && (ke.start = $e + qe * tt)) : en > _e ? In < _e && (tt = De(ke, Mr, Fr, Br, An, _e), Re && (ke.start = $e + qe * tt)) : mi(ke, Mr, Fr, ai), In < re && en >= re && (tt = De(ke, Mr, Fr, Br, An, re), Dn = !0), In > _e && en <= _e && (tt = De(ke, Mr, Fr, Br, An, _e), Dn = !0), !Ee && Dn && (Re && (ke.end = $e + qe * tt), Z.push(ke), ke = vr(Qe)), Re && ($e += qe);
        } let Ct = Qe.length - 3; const Ot = Qe[Ct], Wt = Qe[Ct + 1], _r = Ae === 0 ? Ot : Wt; _r >= re && _r <= _e && mi(ke, Ot, Wt, Qe[Ct + 2]), Ct = ke.length - 3, Ee && Ct >= 3 && (ke[Ct] !== ke[0] || ke[Ct + 1] !== ke[1]) && mi(ke, ke[0], ke[1], ke[2]), ke.length && Z.push(ke); } function vr(Qe) { const Z = []; return Z.size = Qe.size, Z.start = Qe.start, Z.end = Qe.end, Z; } function gn(Qe, Z, re, _e, Ae, Ee) { for (const Re of Qe)
            Jt(Re, Z, re, _e, Ae, Ee, !1); } function mi(Qe, Z, re, _e) { Qe.push(Z, re, _e); } function oi(Qe, Z, re, _e, Ae, Ee) { const Re = (Ee - Z) / (_e - Z); return mi(Qe, Ee, re + (Ae - re) * Re, 1), Re; } function $a(Qe, Z, re, _e, Ae, Ee) { const Re = (Ee - re) / (Ae - re); return mi(Qe, Z + (_e - Z) * Re, Ee, 1), Re; } function Mo(Qe, Z) { const re = []; for (let _e = 0; _e < Qe.length; _e++) {
            const Ae = Qe[_e], Ee = Ae.type;
            let Re;
            if (Ee === "Point" || Ee === "MultiPoint" || Ee === "LineString")
                Re = Ys(Ae.geometry, Z);
            else if (Ee === "MultiLineString" || Ee === "Polygon") {
                Re = [];
                for (const ke of Ae.geometry)
                    Re.push(Ys(ke, Z));
            }
            else if (Ee === "MultiPolygon") {
                Re = [];
                for (const ke of Ae.geometry) {
                    const De = [];
                    for (const qe of ke)
                        De.push(Ys(qe, Z));
                    Re.push(De);
                }
            }
            re.push(Ks(Ae.id, Ee, Re, Ae.tags));
        } return re; } function Ys(Qe, Z) { const re = []; re.size = Qe.size, Qe.start !== void 0 && (re.start = Qe.start, re.end = Qe.end); for (let _e = 0; _e < Qe.length; _e += 3)
            re.push(Qe[_e] + Z, Qe[_e + 1], Qe[_e + 2]); return re; } function Ga(Qe, Z) { if (Qe.transformed)
            return Qe; const re = 1 << Qe.z, _e = Qe.x, Ae = Qe.y; for (const Ee of Qe.features) {
            const Re = Ee.geometry, ke = Ee.type;
            if (Ee.geometry = [], ke === 1)
                for (let De = 0; De < Re.length; De += 2)
                    Ee.geometry.push(wa(Re[De], Re[De + 1], Z, re, _e, Ae));
            else
                for (let De = 0; De < Re.length; De++) {
                    const qe = [];
                    for (let tt = 0; tt < Re[De].length; tt += 2)
                        qe.push(wa(Re[De][tt], Re[De][tt + 1], Z, re, _e, Ae));
                    Ee.geometry.push(qe);
                }
        } return Qe.transformed = !0, Qe; } function wa(Qe, Z, re, _e, Ae, Ee) { return [Math.round(re * (Qe * _e - Ae)), Math.round(re * (Z * _e - Ee))]; } function gc(Qe, Z, re, _e, Ae) { const Ee = Z === Ae.maxZoom ? 0 : Ae.tolerance / ((1 << Z) * Ae.extent), Re = { features: [], numPoints: 0, numSimplified: 0, numFeatures: Qe.length, source: null, x: re, y: _e, z: Z, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }; for (const ke of Qe)
            jn(Re, ke, Ee, Ae); return Re; } function jn(Qe, Z, re, _e) { const Ae = Z.geometry, Ee = Z.type, Re = []; if (Qe.minX = Math.min(Qe.minX, Z.minX), Qe.minY = Math.min(Qe.minY, Z.minY), Qe.maxX = Math.max(Qe.maxX, Z.maxX), Qe.maxY = Math.max(Qe.maxY, Z.maxY), Ee === "Point" || Ee === "MultiPoint")
            for (let ke = 0; ke < Ae.length; ke += 3)
                Re.push(Ae[ke], Ae[ke + 1]), Qe.numPoints++, Qe.numSimplified++;
        else if (Ee === "LineString")
            ba(Re, Ae, Qe, re, !1, !1);
        else if (Ee === "MultiLineString" || Ee === "Polygon")
            for (let ke = 0; ke < Ae.length; ke++)
                ba(Re, Ae[ke], Qe, re, Ee === "Polygon", ke === 0);
        else if (Ee === "MultiPolygon")
            for (let ke = 0; ke < Ae.length; ke++) {
                const De = Ae[ke];
                for (let qe = 0; qe < De.length; qe++)
                    ba(Re, De[qe], Qe, re, !0, qe === 0);
            } if (Re.length) {
            let ke = Z.tags || null;
            if (Ee === "LineString" && _e.lineMetrics) {
                ke = {};
                for (const qe in Z.tags)
                    ke[qe] = Z.tags[qe];
                ke.mapbox_clip_start = Ae.start / Ae.size, ke.mapbox_clip_end = Ae.end / Ae.size;
            }
            const De = { geometry: Re, type: Ee === "Polygon" || Ee === "MultiPolygon" ? 3 : Ee === "LineString" || Ee === "MultiLineString" ? 2 : 1, tags: ke };
            Z.id !== null && (De.id = Z.id), Qe.features.push(De);
        } } function ba(Qe, Z, re, _e, Ae, Ee) { const Re = _e * _e; if (_e > 0 && Z.size < (Ae ? Re : _e))
            return void (re.numPoints += Z.length / 3); const ke = []; for (let De = 0; De < Z.length; De += 3)
            (_e === 0 || Z[De + 2] > Re) && (re.numSimplified++, ke.push(Z[De], Z[De + 1])), re.numPoints++; Ae && function (De, qe) { let tt = 0; for (let $e = 0, Ct = De.length, Ot = Ct - 2; $e < Ct; Ot = $e, $e += 2)
            tt += (De[$e] - De[Ot]) * (De[$e + 1] + De[Ot + 1]); if (tt > 0 === qe)
            for (let $e = 0, Ct = De.length; $e < Ct / 2; $e += 2) {
                const Ot = De[$e], Wt = De[$e + 1];
                De[$e] = De[Ct - 2 - $e], De[$e + 1] = De[Ct - 1 - $e], De[Ct - 2 - $e] = Ot, De[Ct - 1 - $e] = Wt;
            } }(ke, Ee), Qe.push(ke); } const pu = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }; class Ro {
            constructor(Z, re) { const _e = (re = this.options = function (Ee, Re) { for (const ke in Re)
                Ee[ke] = Re[ke]; return Ee; }(Object.create(pu), re)).debug; if (_e && console.time("preprocess data"), re.maxZoom < 0 || re.maxZoom > 24)
                throw new Error("maxZoom should be in the 0-24 range"); if (re.promoteId && re.generateId)
                throw new Error("promoteId and generateId cannot be used together."); let Ae = function (Ee, Re) { const ke = []; if (Ee.type === "FeatureCollection")
                for (let De = 0; De < Ee.features.length; De++)
                    Gi(ke, Ee.features[De], Re, De);
            else
                Gi(ke, Ee.type === "Feature" ? Ee : { geometry: Ee }, Re); return ke; }(Z, re); this.tiles = {}, this.tileCoords = [], _e && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", re.indexMaxZoom, re.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), Ae = function (Ee, Re) { const ke = Re.buffer / Re.extent; let De = Ee; const qe = cr(Ee, 1, -1 - ke, ke, 0, -1, 2, Re), tt = cr(Ee, 1, 1 - ke, 2 + ke, 0, -1, 2, Re); return (qe || tt) && (De = cr(Ee, 1, -ke, 1 + ke, 0, -1, 2, Re) || [], qe && (De = Mo(qe, 1).concat(De)), tt && (De = De.concat(Mo(tt, -1)))), De; }(Ae, re), Ae.length && this.splitTile(Ae, 0, 0, 0), _e && (Ae.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats))); }
            splitTile(Z, re, _e, Ae, Ee, Re, ke) { const De = [Z, re, _e, Ae], qe = this.options, tt = qe.debug; for (; De.length;) {
                Ae = De.pop(), _e = De.pop(), re = De.pop(), Z = De.pop();
                const $e = 1 << re, Ct = id(re, _e, Ae);
                let Ot = this.tiles[Ct];
                if (!Ot && (tt > 1 && console.time("creation"), Ot = this.tiles[Ct] = gc(Z, re, _e, Ae, qe), this.tileCoords.push({ z: re, x: _e, y: Ae }), tt)) {
                    tt > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", re, _e, Ae, Ot.numFeatures, Ot.numPoints, Ot.numSimplified), console.timeEnd("creation"));
                    const Dn = `z${re}`;
                    this.stats[Dn] = (this.stats[Dn] || 0) + 1, this.total++;
                }
                if (Ot.source = Z, Ee == null) {
                    if (re === qe.indexMaxZoom || Ot.numPoints <= qe.indexMaxPoints)
                        continue;
                }
                else {
                    if (re === qe.maxZoom || re === Ee)
                        continue;
                    if (Ee != null) {
                        const Dn = Ee - re;
                        if (_e !== Re >> Dn || Ae !== ke >> Dn)
                            continue;
                    }
                }
                if (Ot.source = null, Z.length === 0)
                    continue;
                tt > 1 && console.time("clipping");
                const Wt = .5 * qe.buffer / qe.extent, _r = .5 - Wt, br = .5 + Wt, Mr = 1 + Wt;
                let Fr = null, ai = null, Br = null, An = null, en = cr(Z, $e, _e - Wt, _e + br, 0, Ot.minX, Ot.maxX, qe), In = cr(Z, $e, _e + _r, _e + Mr, 0, Ot.minX, Ot.maxX, qe);
                Z = null, en && (Fr = cr(en, $e, Ae - Wt, Ae + br, 1, Ot.minY, Ot.maxY, qe), ai = cr(en, $e, Ae + _r, Ae + Mr, 1, Ot.minY, Ot.maxY, qe), en = null), In && (Br = cr(In, $e, Ae - Wt, Ae + br, 1, Ot.minY, Ot.maxY, qe), An = cr(In, $e, Ae + _r, Ae + Mr, 1, Ot.minY, Ot.maxY, qe), In = null), tt > 1 && console.timeEnd("clipping"), De.push(Fr || [], re + 1, 2 * _e, 2 * Ae), De.push(ai || [], re + 1, 2 * _e, 2 * Ae + 1), De.push(Br || [], re + 1, 2 * _e + 1, 2 * Ae), De.push(An || [], re + 1, 2 * _e + 1, 2 * Ae + 1);
            } }
            getTile(Z, re, _e) { Z = +Z, re = +re, _e = +_e; const Ae = this.options, { extent: Ee, debug: Re } = Ae; if (Z < 0 || Z > 24)
                return null; const ke = 1 << Z, De = id(Z, re = re + ke & ke - 1, _e); if (this.tiles[De])
                return Ga(this.tiles[De], Ee); Re > 1 && console.log("drilling down to z%d-%d-%d", Z, re, _e); let qe, tt = Z, $e = re, Ct = _e; for (; !qe && tt > 0;)
                tt--, $e >>= 1, Ct >>= 1, qe = this.tiles[id(tt, $e, Ct)]; return qe && qe.source ? (Re > 1 && (console.log("found parent tile z%d-%d-%d", tt, $e, Ct), console.time("drilling down")), this.splitTile(qe.source, tt, $e, Ct, Z, re, _e), Re > 1 && console.timeEnd("drilling down"), this.tiles[De] ? Ga(this.tiles[De], Ee) : null) : null; }
        } function id(Qe, Z, re) { return 32 * ((1 << Qe) * re + Z) + Qe; } function Gf(Qe, Z) { const re = Qe.tileID.canonical; if (!this._geoJSONIndex)
            return void Z(null, null); const _e = this._geoJSONIndex.getTile(re.z, re.x, re.y); if (!_e)
            return void Z(null, null); const Ae = new Be(_e.features); let Ee = Jr(Ae); Ee.byteOffset === 0 && Ee.byteLength === Ee.buffer.byteLength || (Ee = new Uint8Array(Ee)), Z(null, { vectorTile: Ae, rawData: Ee.buffer }); } class sd extends ye {
            constructor(Z, re, _e, Ae, Ee, Re, ke) { super(Z, re, _e, Ae, Ee, Gf, ke), Re && (this.loadGeoJSON = Re), this._dynamicIndex = new At; }
            loadData(Z, re) { const _e = Z && Z.request, Ae = _e && _e.collectResourceTiming; this.loadGeoJSON(Z, (Ee, Re) => { if (Ee || !Re)
                return re(Ee); if (typeof Re != "object")
                return re(new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`)); {
                try {
                    if (Z.filter) {
                        const De = s.X(Z.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                        if (De.result === "error")
                            throw new Error(De.value.map(qe => `${qe.key}: ${qe.message}`).join(", "));
                        Re.features = Re.features.filter(qe => De.value.evaluate({ zoom: 0 }, qe));
                    }
                    Z.dynamic ? (Re.type === "Feature" && (Re = { type: "FeatureCollection", features: [Re] }), Z.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(Re.features, this.loaded), Z.cluster && (Re.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = Z.cluster ? new ln(function ({ superclusterOptions: De, clusterProperties: qe }) { if (!qe || !De)
                        return De; const tt = {}, $e = {}, Ct = { accumulated: null, zoom: 0 }, Ot = { properties: null }, Wt = Object.keys(qe); for (const _r of Wt) {
                        const [br, Mr] = qe[_r], Fr = s.X(Mr), ai = s.X(typeof br == "string" ? [br, ["accumulated"], ["get", _r]] : br);
                        tt[_r] = Fr.value, $e[_r] = ai.value;
                    } return De.map = _r => { Ot.properties = _r; const br = {}; for (const Mr of Wt)
                        br[Mr] = tt[Mr].evaluate(Ct, Ot); return br; }, De.reduce = (_r, br) => { Ot.properties = br; for (const Mr of Wt)
                        Ct.accumulated = _r[Mr], _r[Mr] = $e[Mr].evaluate(Ct, Ot); }, De; }(Z)).load(Re.features) : Z.dynamic ? this._dynamicIndex : function (De, qe) { return new Ro(De, qe); }(Re, Z.geojsonVtOptions);
                }
                catch (De) {
                    return re(De);
                }
                const ke = {};
                if (Ae) {
                    const De = k(_e);
                    De && (ke.resourceTiming = {}, ke.resourceTiming[Z.source] = JSON.parse(JSON.stringify(De)));
                }
                re(null, ke);
            } }); }
            reloadTile(Z, re) { const _e = this.loaded; return _e && _e[Z.uid] ? Z.partial ? re(null, void 0) : super.reloadTile(Z, re) : this.loadTile(Z, re); }
            loadGeoJSON(Z, re) { if (Z.request)
                s.n(Z.request, re);
            else {
                if (typeof Z.data != "string")
                    return re(new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`));
                try {
                    return re(null, JSON.parse(Z.data));
                }
                catch {
                    return re(new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`));
                }
            } }
            getClusterExpansionZoom(Z, re) { try {
                re(null, this._geoJSONIndex.getClusterExpansionZoom(Z.clusterId));
            }
            catch (_e) {
                re(_e);
            } }
            getClusterChildren(Z, re) { try {
                re(null, this._geoJSONIndex.getChildren(Z.clusterId));
            }
            catch (_e) {
                re(_e);
            } }
            getClusterLeaves(Z, re) { try {
                re(null, this._geoJSONIndex.getLeaves(Z.clusterId, Z.limit, Z.offset));
            }
            catch (_e) {
                re(_e);
            } }
        } class Et {
            constructor(Z, re) { this.tileID = new s.aM(Z.tileID.overscaledZ, Z.tileID.wrap, Z.tileID.canonical.z, Z.tileID.canonical.x, Z.tileID.canonical.y), this.tileZoom = Z.tileZoom, this.uid = Z.uid, this.zoom = Z.zoom, this.canonical = Z.tileID.canonical, this.pixelRatio = Z.pixelRatio, this.tileSize = Z.tileSize, this.source = Z.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = Z.projection, this.brightness = re; }
            parse(Z, re, _e, Ae) { this.status = "parsing"; const Ee = new s.aM(_e.tileID.overscaledZ, _e.tileID.wrap, _e.tileID.canonical.z, _e.tileID.canonical.x, _e.tileID.canonical.y), Re = [], ke = re.familiesBySource[_e.source], De = new s.f0(Ee, _e.promoteId); De.bucketLayerIDs = [], De.is3DTile = !0, s.fi(Z).then(qe => { if (!qe)
                return Ae(new Error("Could not parse tile")); const tt = s.fj(qe, 1 / s.cT(_e.tileID.canonical)), $e = qe.json.extensionsUsed && qe.json.extensionsUsed.includes("MAPBOX_mesh_features") || qe.json.asset.extras && qe.json.asset.extras.MAPBOX_mesh_features, Ct = qe.json.extensionsUsed && qe.json.extensionsUsed.includes("EXT_meshopt_compression"), Ot = new s.aa(this.zoom, { brightness: this.brightness }); for (const Wt in ke)
                for (const _r of ke[Wt]) {
                    const br = _r[0];
                    De.bucketLayerIDs.push(_r.map(Fr => s.C(Fr.id, Fr.scope))), br.recalculate(Ot, []);
                    const Mr = new s.fk(_r, tt, Ee, $e, Ct, this.brightness, De);
                    $e || (Mr.needsUpload = !0), Re.push(Mr), Mr.evaluate(br);
                } this.status = "done", Ae(null, { buckets: Re, featureIndex: De, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: null }); }).catch(qe => Ae(new Error(qe.message))); }
        } class qa {
            constructor(Z, re, _e, Ae, Ee, Re, ke) { this.actor = Z, this.layerIndex = re, this.availableImages = _e, this.availableModels = Ae, this.brightness = ke, this.loading = {}, this.loaded = {}; }
            loadTile(Z, re) { const _e = Z.uid, Ae = this.loading[_e] = new Et(Z, this.brightness); s.br(Z.request, (Ee, Re) => { const ke = !this.loading[_e]; return delete this.loading[_e], ke || Ee ? (Ae.status = "done", ke || (this.loaded[_e] = Ae), re(Ee)) : Re && Re.byteLength !== 0 ? void Ae.parse(Re, this.layerIndex, Z, (De, qe) => { Ae.status = "done", this.loaded = this.loaded || {}, this.loaded[_e] = Ae, De || !qe ? re(De) : re(null, qe); }) : (Ae.status = "done", this.loaded[_e] = Ae, re()); }); }
            reloadTile(Z, re) { const _e = this.loaded, Ae = Z.uid; if (_e && _e[Ae]) {
                const Ee = _e[Ae];
                Ee.projection = Z.projection, Ee.brightness = Z.brightness;
                const Re = (ke, De) => { Ee.reloadCallback && (delete Ee.reloadCallback, this.loadTile(Z, re)), re(ke, De); };
                Ee.status === "parsing" ? Ee.reloadCallback = Re : Ee.status === "done" && this.loadTile(Z, re);
            } }
            abortTile(Z, re) { const _e = Z.uid; this.loading[_e] && delete this.loading[_e], re(); }
            removeTile(Z, re) { const _e = this.loaded, Ae = Z.uid; _e && _e[Ae] && delete _e[Ae], re(); }
        } class qf {
            constructor(Z) { this.self = Z, this.actor = new s.fm(Z, this), this.layerIndexes = {}, this.availableImages = {}, this.availableModels = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new s.y, this.projections = {}, this.defaultProjection = s.ce({ name: "mercator" }), this.workerSourceTypes = { vector: ye, geojson: sd, "raster-dem": ie, "raster-array": ue, "batched-model": qa }, this.workerSources = {}, this.self.registerWorkerSource = (re, _e) => { if (this.workerSourceTypes[re])
                throw new Error(`Worker source with name "${re}" already registered.`); this.workerSourceTypes[re] = _e; }, this.self.registerRTLTextPlugin = re => { if (s.fn.isParsed())
                throw new Error("RTL text plugin already registered."); s.fn.applyArabicShaping = re.applyArabicShaping, s.fn.processBidirectionalText = re.processBidirectionalText, s.fn.processStyledBidirectionalText = re.processStyledBidirectionalText; }; }
            clearCaches(Z, re, _e) { delete this.layerIndexes[Z], delete this.availableImages[Z], delete this.availableModels[Z], delete this.workerSources[Z], _e(); }
            checkIfReady(Z, re, _e) { _e(); }
            setReferrer(Z, re) { this.referrer = re; }
            spriteLoaded(Z, re) { this.isSpriteLoaded[Z] || (this.isSpriteLoaded[Z] = {}); const { scope: _e, isLoaded: Ae } = re; if (this.isSpriteLoaded[Z][_e] = Ae, this.workerSources[Z] && this.workerSources[Z][_e])
                for (const Ee in this.workerSources[Z][_e]) {
                    const Re = this.workerSources[Z][_e][Ee];
                    for (const ke in Re) {
                        const De = Re[ke];
                        De instanceof ye && (De.isSpriteLoaded = Ae, De.fire(new s.A("isSpriteLoaded")));
                    }
                } }
            setImages(Z, re, _e) { this.availableImages[Z] || (this.availableImages[Z] = {}); const { scope: Ae, images: Ee } = re; if (this.availableImages[Z][Ae] = Ee, this.workerSources[Z] && this.workerSources[Z][Ae]) {
                for (const Re in this.workerSources[Z][Ae]) {
                    const ke = this.workerSources[Z][Ae][Re];
                    for (const De in ke)
                        ke[De].availableImages = Ee;
                }
                _e();
            }
            else
                _e(); }
            setModels(Z, { scope: re, models: _e }, Ae) { if (this.availableModels[Z] || (this.availableModels[Z] = {}), this.availableModels[Z][re] = _e, this.workerSources[Z] && this.workerSources[Z][re]) {
                for (const Ee in this.workerSources[Z][re]) {
                    const Re = this.workerSources[Z][re][Ee];
                    for (const ke in Re)
                        Re[ke].availableModels = _e;
                }
                Ae();
            }
            else
                Ae(); }
            setProjection(Z, re) { this.projections[Z] = s.ce(re); }
            setBrightness(Z, re, _e) { this.brightness = re, _e(); }
            setLayers(Z, re, _e) { this.getLayerIndex(Z, re.scope).replace(re.layers, re.options), _e(); }
            updateLayers(Z, re, _e) { this.getLayerIndex(Z, re.scope).update(re.layers, re.removedIds, re.options), _e(); }
            loadTile(Z, re, _e) { re.projection = this.projections[Z] || this.defaultProjection, this.getWorkerSource(Z, re.type, re.source, re.scope).loadTile(re, _e); }
            decodeRasterArray(Z, re, _e) { this.getWorkerSource(Z, re.type, re.source, re.scope).decodeRasterArray(re, _e); }
            reloadTile(Z, re, _e) { re.projection = this.projections[Z] || this.defaultProjection, this.getWorkerSource(Z, re.type, re.source, re.scope).reloadTile(re, _e); }
            abortTile(Z, re, _e) { this.getWorkerSource(Z, re.type, re.source, re.scope).abortTile(re, _e); }
            removeTile(Z, re, _e) { this.getWorkerSource(Z, re.type, re.source, re.scope).removeTile(re, _e); }
            removeSource(Z, re, _e) { if (!(this.workerSources[Z] && this.workerSources[Z][re.scope] && this.workerSources[Z][re.scope][re.type] && this.workerSources[Z][re.scope][re.type][re.source]))
                return; const Ae = this.workerSources[Z][re.scope][re.type][re.source]; delete this.workerSources[Z][re.scope][re.type][re.source], Ae.removeSource !== void 0 ? Ae.removeSource(re, _e) : _e(); }
            loadWorkerSource(Z, re, _e) { try {
                this.self.importScripts(re.url), _e();
            }
            catch (Ae) {
                _e(Ae.toString());
            } }
            syncRTLPluginState(Z, re, _e) { try {
                s.fn.setState(re);
                const Ae = s.fn.getPluginURL();
                if (s.fn.isLoaded() && !s.fn.isParsed() && Ae != null) {
                    this.self.importScripts(Ae);
                    const Ee = s.fn.isParsed();
                    _e(Ee ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${Ae}`), Ee);
                }
            }
            catch (Ae) {
                _e(Ae.toString());
            } }
            setDracoUrl(Z, re) { this.dracoUrl = re; }
            getAvailableImages(Z, re) { this.availableImages[Z] || (this.availableImages[Z] = {}); let _e = this.availableImages[Z][re]; return _e || (_e = []), _e; }
            getAvailableModels(Z, re) { this.availableModels[Z] || (this.availableModels[Z] = {}); let _e = this.availableModels[Z][re]; return _e || (_e = {}), _e; }
            getLayerIndex(Z, re) { this.layerIndexes[Z] || (this.layerIndexes[Z] = {}); let _e = this.layerIndexes[Z][re]; return _e || (_e = this.layerIndexes[Z][re] = new V, _e.scope = re), _e; }
            getWorkerSource(Z, re, _e, Ae) { const Ee = this.workerSources; return Ee[Z] || (Ee[Z] = {}), Ee[Z][Ae] || (Ee[Z][Ae] = {}), Ee[Z][Ae][re] || (Ee[Z][Ae][re] = {}), this.isSpriteLoaded[Z] || (this.isSpriteLoaded[Z] = {}), Ee[Z][Ae][re][_e] || (Ee[Z][Ae][re][_e] = new this.workerSourceTypes[re]({ send: (Re, ke, De, qe, tt, $e) => this.actor.send(Re, ke, De, Z, tt, $e), scheduler: this.actor.scheduler }, this.getLayerIndex(Z, Ae), this.getAvailableImages(Z, Ae), this.getAvailableModels(Z, Ae), this.isSpriteLoaded[Z][Ae], void 0, this.brightness)), Ee[Z][Ae][re][_e]; }
            rasterizeImagesWorker(Z, re, _e) { const Ae = new Map; for (const [Ee, { image: Re, imageVariant: ke }] of re.tasks.entries()) {
                const De = this.imageRasterizer.rasterize(ke, Re, re.scope, Z);
                Ae.set(Ee, De);
            } _e(void 0, Ae); }
            removeRasterizedImages(Z, re, _e) { this.imageRasterizer.removeImagesFromCacheByIds(re.imageIds, re.scope, Z), _e(); }
            enforceCacheSizeLimit(Z, re) { s.fo(re); }
            getWorkerPerformanceMetrics(Z, re, _e) { _e(void 0, void 0); }
        } return s.fl(self) && (self.worker = new qf(self)), qf; }), y(["./shared"], function (s) {
            var k = "3.12.0";
            const L = { create: "create", load: "load", fullLoad: "fullLoad" }, N = { mark(d) { performance.mark(d); }, measure(d, n, l) { performance.measure(d, n, l); } };
            function V(d) { const n = d.name.split("?")[0]; return s.a(n) && n.includes("mapbox-gl.js") ? "javascript" : s.a(n) && n.includes("mapbox-gl.css") ? "css" : s.b(n) ? "fontRange" : s.c(n) ? "sprite" : s.i(n) ? "style" : s.d(n) ? "tilejson" : "other"; }
            var H, ee = {}, ce = function () { if (H)
                return ee; function d(f) { return !n(f); } function n(f) { return typeof window > "u" || typeof document > "u" ? "not a browser" : function () { if (!("Worker" in window && "Blob" in window && "URL" in window))
                return !1; var v, w, T = new Blob([""], { type: "text/javascript" }), C = URL.createObjectURL(T); try {
                w = new Worker(C), v = !0;
            }
            catch {
                v = !1;
            } return w && w.terminate(), URL.revokeObjectURL(C), v; }() ? function () { var v = document.createElement("canvas"); v.width = v.height = 1; var w = v.getContext("2d"); if (!w)
                return !1; var T = w.getImageData(0, 0, 1, 1); return T && T.width === v.width; }() ? (l[_ = f && f.failIfMajorPerformanceCaveat] === void 0 && (l[_] = function (v) { var w, T = function (C) { var P = document.createElement("canvas"), R = Object.create(d.webGLContextAttributes); return R.failIfMajorPerformanceCaveat = C, P.getContext("webgl2", R); }(v); if (!T)
                return !1; try {
                w = T.createShader(T.VERTEX_SHADER);
            }
            catch {
                return !1;
            } return !(!w || T.isContextLost()) && (T.shaderSource(w, "void main() {}"), T.compileShader(w), T.getShaderParameter(w, T.COMPILE_STATUS) === !0); }(_)), l[_] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support"; var _; } H = 1, ee.supported = d, ee.notSupportedReason = n; var l = {}; return d.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 }, ee; }();
            function J(d, n, l) { const f = document.createElement(d); return n != null && (f.className = n), l && l.appendChild(f), f; }
            function ye(d, n, l) { const f = document.createElementNS("http://www.w3.org/2000/svg", d); for (const _ of Object.keys(n))
                f.setAttributeNS(null, _, String(n[_])); return l && l.appendChild(f), f; }
            const ie = typeof document < "u" ? document.documentElement && document.documentElement.style : null, Q = ie && ie.userSelect !== void 0 ? "userSelect" : "WebkitUserSelect";
            let ue;
            function be() { ie && Q && (ue = ie[Q], ie[Q] = "none"); }
            function Ie() { ie && Q && (ie[Q] = ue); }
            function Be(d) { d.preventDefault(), d.stopPropagation(), window.removeEventListener("click", Be, !0); }
            function Ze() { window.addEventListener("click", Be, !0), window.setTimeout(() => { window.removeEventListener("click", Be, !0); }, 0); }
            function ot(d, n) { const l = d.getBoundingClientRect(); return ct(d, l, n); }
            function At(d, n) { const l = d.getBoundingClientRect(), f = []; for (let _ = 0; _ < n.length; _++)
                f.push(ct(d, l, n[_])); return f; }
            function kt(d) { return /firefox/i.test(navigator.userAgent) && /macintosh/i.test(navigator.userAgent) && d.button === 2 && d.ctrlKey ? 0 : d.button; }
            function ct(d, n, l) { const f = d.offsetWidth === n.width ? 1 : d.offsetWidth / n.width; return new s.P((l.clientX - n.left) * f, (l.clientY - n.top) * f); }
            const St = "01", Kt = "NO_ACCESS_TOKEN";
            class bt {
                constructor(n, l, f) { this._transformRequestFn = n, this._customAccessToken = l, this._silenceAuthErrors = !!f, this._createSkuToken(); }
                _createSkuToken() { const n = function () { let l = ""; for (let f = 0; f < 10; f++)
                    l += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())]; return { token: ["1", St, l].join(""), tokenExpiresAt: Date.now() + 432e5 }; }(); this._skuToken = n.token, this._skuTokenExpiresAt = n.tokenExpiresAt; }
                _isSkuTokenExpired() { return Date.now() > this._skuTokenExpiresAt; }
                transformRequest(n, l) { return this._transformRequestFn && this._transformRequestFn(n, l) || { url: n }; }
                normalizeStyleURL(n, l) { if (!s.f(n))
                    return n; const f = tr(n); return f.params.push(`sdk=js-${k}`), f.path = `/styles/v1${f.path}`, this._makeAPIURL(f, this._customAccessToken || l); }
                normalizeGlyphsURL(n, l) { if (!s.f(n))
                    return n; const f = tr(n); return f.path = `/fonts/v1${f.path}`, this._makeAPIURL(f, this._customAccessToken || l); }
                normalizeModelURL(n, l) { if (!s.f(n))
                    return n; const f = tr(n); return f.path = `/models/v1${f.path}`, this._makeAPIURL(f, this._customAccessToken || l); }
                normalizeSourceURL(n, l, f, _) { if (!s.f(n))
                    return n; const v = tr(n); return v.path = `/v4/${v.authority}.json`, v.params.push("secure"), f && v.params.push(`language=${f}`), _ && v.params.push(`worldview=${_}`), this._makeAPIURL(v, this._customAccessToken || l); }
                normalizeIconsetURL(n, l) { const f = tr(n); return s.f(n) ? (f.path = `/styles/v1${f.path}/iconset.pbf`, this._makeAPIURL(f, this._customAccessToken || l)) : Or(f); }
                normalizeSpriteURL(n, l, f, _) { const v = tr(n); return s.f(n) ? (v.path = `/styles/v1${v.path}/sprite${l}${f}`, this._makeAPIURL(v, this._customAccessToken || _)) : (v.path += `${l}${f}`, Or(v)); }
                normalizeTileURL(n, l, f) { if (this._isSkuTokenExpired() && this._createSkuToken(), n && !s.f(n))
                    return n; const _ = tr(n); _.path = _.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${l || f && _.authority !== "raster" && f === 512 ? "@2x" : ""}${s.m.supported ? ".webp" : "$1"}`), _.authority === "raster" ? _.path = `/${s.e.RASTER_URL_PREFIX}${_.path}` : _.authority === "rasterarrays" ? _.path = `/${s.e.RASTERARRAYS_URL_PREFIX}${_.path}` : _.authority === "3dtiles" ? _.path = `/${s.e.TILES3D_URL_PREFIX}${_.path}` : (_.path = _.path.replace(/^.+\/v4\//, "/"), _.path = `/${s.e.TILE_URL_VERSION}${_.path}`); const v = this._customAccessToken || function (w) { for (const T of w) {
                    const C = T.match(/^access_token=(.*)$/);
                    if (C)
                        return C[1];
                } return null; }(_.params) || s.e.ACCESS_TOKEN; return s.e.REQUIRE_ACCESS_TOKEN && v && this._skuToken && _.params.push(`sku=${this._skuToken}`), this._makeAPIURL(_, v); }
                canonicalizeTileURL(n, l) { const f = tr(n); if (!f.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !f.path.match(/\.[\w]+$/))
                    return n; let _ = "mapbox://"; f.path.match(/^\/raster\/v1\//) ? _ += `raster/${f.path.replace(`/${s.e.RASTER_URL_PREFIX}/`, "")}` : f.path.match(/^\/rasterarrays\/v1\//) ? _ += `rasterarrays/${f.path.replace(`/${s.e.RASTERARRAYS_URL_PREFIX}/`, "")}` : _ += `tiles/${f.path.replace(`/${s.e.TILE_URL_VERSION}/`, "")}`; let v = f.params; return l && (v = v.filter(w => !w.match(/^access_token=/))), v.length && (_ += `?${v.join("&")}`), _; }
                canonicalizeTileset(n, l) { const f = !!l && s.f(l), _ = []; for (const v of n.tiles || [])
                    s.h(v) ? _.push(this.canonicalizeTileURL(v, f)) : _.push(v); return _; }
                _makeAPIURL(n, l) { const f = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", _ = tr(s.e.API_URL); if (n.protocol = _.protocol, n.authority = _.authority, n.protocol === "http") {
                    const v = n.params.indexOf("secure");
                    v >= 0 && n.params.splice(v, 1);
                } if (_.path !== "/" && (n.path = `${_.path}${n.path}`), !s.e.REQUIRE_ACCESS_TOKEN)
                    return Or(n); if (l = l || s.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
                    if (!l)
                        throw new Error(`An API access token is required to use Mapbox GL. ${f}`);
                    if (l[0] === "s")
                        throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${f}`);
                } return n.params = n.params.filter(v => v.indexOf("access_token") === -1), n.params.push(`access_token=${l || ""}`), Or(n); }
            }
            const ir = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
            function tr(d) { const n = d.match(ir); if (!n)
                throw new Error("Unable to parse URL object"); return { protocol: n[1], authority: n[2], path: n[3] || "/", params: n[4] ? n[4].split("&") : [] }; }
            function Or(d) { const n = d.params.length ? `?${d.params.join("&")}` : ""; return `${d.protocol}://${d.authority}${d.path}${n}`; }
            const xt = "mapbox.eventData";
            function Pt(d) { if (!d)
                return null; const n = d.split("."); if (!n || n.length !== 3)
                return null; try {
                return JSON.parse(s.j(n[1]));
            }
            catch {
                return null;
            } }
            class Ft {
                constructor(n) { this.type = n, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null; }
                getStorageKey(n) { const l = Pt(s.e.ACCESS_TOKEN); let f = ""; return f = l && l.u ? s.k(l.u) : s.e.ACCESS_TOKEN || "", n ? `${xt}.${n}:${f}` : `${xt}:${f}`; }
                fetchEventData() { const n = s.s("localStorage"), l = this.getStorageKey(), f = this.getStorageKey("uuid"); if (n)
                    try {
                        const _ = localStorage.getItem(l);
                        _ && (this.eventData = JSON.parse(_));
                        const v = localStorage.getItem(f);
                        v && (this.anonId = v);
                    }
                    catch {
                        s.w("Unable to read from LocalStorage");
                    } }
                saveEventData() { const n = s.s("localStorage"), l = this.getStorageKey(), f = this.getStorageKey("uuid"), _ = this.anonId; if (n && _)
                    try {
                        localStorage.setItem(f, _), Object.keys(this.eventData).length >= 1 && localStorage.setItem(l, JSON.stringify(this.eventData));
                    }
                    catch {
                        s.w("Unable to write to LocalStorage");
                    } }
                processRequests(n) { }
                postEvent(n, l, f, _) { if (!s.e.EVENTS_URL)
                    return; const v = tr(s.e.EVENTS_URL); v.params.push(`access_token=${_ || s.e.ACCESS_TOKEN || ""}`); const w = { event: this.type, created: new Date(n).toISOString() }, T = l ? s.l(w, l) : w, C = { url: Or(v), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([T]) }; this.pendingRequest = s.p(C, P => { this.pendingRequest = null, f(P), this.saveEventData(), this.processRequests(_); }); }
                queueRequest(n, l) { this.queue.push(n), this.processRequests(l); }
            }
            const gr = new class extends Ft {
                constructor(d) { super("appUserTurnstile"), this._customAccessToken = d; }
                postTurnstileEvent(d, n) { s.e.EVENTS_URL && s.e.ACCESS_TOKEN && Array.isArray(d) && d.some(l => s.f(l) || s.h(l)) && this.queueRequest(Date.now(), n); }
                processRequests(d) { if (this.pendingRequest || this.queue.length === 0)
                    return; this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData(); const n = Pt(s.e.ACCESS_TOKEN), l = n ? n.u : s.e.ACCESS_TOKEN; let f = l !== this.eventData.tokenU; s.v(this.anonId) || (this.anonId = s.u(), f = !0); const _ = this.queue.shift(); if (this.eventData.lastSuccess) {
                    const v = new Date(this.eventData.lastSuccess), w = new Date(_), T = (_ - this.eventData.lastSuccess) / 864e5;
                    f = f || T >= 1 || T < -1 || v.getDate() !== w.getDate();
                }
                else
                    f = !0; f ? this.postEvent(_, { sdkIdentifier: "mapbox-gl-js", sdkVersion: k, skuId: St, "enabled.telemetry": !1, userId: this.anonId }, v => { v || (this.eventData.lastSuccess = _, this.eventData.tokenU = l); }, d) : this.processRequests(); }
            }, Jr = gr.postTurnstileEvent.bind(gr), pi = new class extends Ft {
                constructor() { super("map.load"), this.success = {}, this.skuToken = ""; }
                postMapLoadEvent(d, n, l, f) { this.skuToken = n, this.errorCb = f, s.e.EVENTS_URL && (l || s.e.ACCESS_TOKEN ? this.queueRequest({ id: d, timestamp: Date.now() }, l) : this.errorCb(new Error(Kt))); }
                processRequests(d) { if (this.pendingRequest || this.queue.length === 0)
                    return; const { id: n, timestamp: l } = this.queue.shift(); n && this.success[n] || (this.anonId || this.fetchEventData(), s.v(this.anonId) || (this.anonId = s.u()), this.postEvent(l, { sdkIdentifier: "mapbox-gl-js", sdkVersion: k, skuId: St, skuToken: this.skuToken, userId: this.anonId }, f => { f ? this.errorCb(f) : n && (this.success[n] = !0); }, d)); }
                remove() { this.errorCb = null; }
            }, Si = pi.postMapLoadEvent.bind(pi), an = new class extends Ft {
                constructor() { super("style.load"), this.eventIdPerMapInstanceMap = new Map, this.mapInstanceIdMap = new WeakMap; }
                getMapInstanceId(d) { let n = this.mapInstanceIdMap.get(d); return n || (n = s.u(), this.mapInstanceIdMap.set(d, n)), n; }
                getEventId(d) { const n = this.eventIdPerMapInstanceMap.get(d) || 0; return this.eventIdPerMapInstanceMap.set(d, n + 1), n; }
                postStyleLoadEvent(d, n) { const { map: l, style: f, importedStyles: _ } = n; if (!s.e.EVENTS_URL || !d && !s.e.ACCESS_TOKEN)
                    return; const v = this.getMapInstanceId(l), w = { mapInstanceId: v, eventId: this.getEventId(v), style: f }; _.length && (w.importedStyles = _), this.queueRequest({ timestamp: Date.now(), payload: w }, d); }
                processRequests(d) { if (this.pendingRequest || this.queue.length === 0)
                    return; const { timestamp: n, payload: l } = this.queue.shift(); this.postEvent(n, l, () => { }, d); }
            }, Kr = an.postStyleLoadEvent.bind(an), mn = new class extends Ft {
                constructor() { super("gljs.performance"); }
                postPerformanceEvent(d, n) { s.e.EVENTS_URL && (d || s.e.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: n }, d); }
                processRequests(d) { if (this.pendingRequest || this.queue.length === 0)
                    return; const { timestamp: n, performanceData: l } = this.queue.shift(), f = function (_) { const v = performance.getEntriesByType("resource"), w = performance.getEntriesByType("mark"), T = function (B) { const q = {}; if (B) {
                    for (const G in B)
                        if (G !== "other")
                            for (const K of B[G]) {
                                const W = `${G}ResolveRangeMin`, oe = `${G}ResolveRangeMax`, de = `${G}RequestCount`, me = `${G}RequestCachedCount`;
                                q[W] = Math.min(q[W] || 1 / 0, K.startTime), q[oe] = Math.max(q[oe] || -1 / 0, K.responseEnd);
                                const we = ve => { q[ve] === void 0 && (q[ve] = 0), ++q[ve]; };
                                K.transferSize !== void 0 && K.transferSize === 0 && we(me), we(de);
                            }
                } return q; }(function (B, q) { const G = {}; if (B)
                    for (const K of B) {
                        const W = q(K);
                        G[W] === void 0 && (G[W] = []), G[W].push(K);
                    } return G; }(v, V)), C = window.devicePixelRatio, P = navigator.connection || navigator.mozConnection || navigator.webkitConnection, R = P ? P.effectiveType : void 0, O = { counters: [], metadata: [], attributes: [] }, D = (B, q, G) => { G != null && B.push({ name: q, value: G.toString() }); }; for (const B in T)
                    D(O.counters, B, T[B]); if (_.interactionRange[0] !== 1 / 0 && _.interactionRange[1] !== -1 / 0 && (D(O.counters, "interactionRangeMin", _.interactionRange[0]), D(O.counters, "interactionRangeMax", _.interactionRange[1])), w)
                    for (const B of Object.keys(L)) {
                        const q = L[B], G = w.find(K => K.name === q);
                        G && D(O.counters, q, G.startTime);
                    } return D(O.counters, "visibilityHidden", _.visibilityHidden), D(O.attributes, "style", function (B) { if (B)
                    for (const q of B) {
                        const G = q.name.split("?")[0];
                        if (s.i(G)) {
                            const K = G.split("/").slice(-2);
                            if (K.length === 2)
                                return `mapbox://styles/${K[0]}/${K[1]}`;
                        }
                    } }(v)), D(O.attributes, "terrainEnabled", _.terrainEnabled ? "true" : "false"), D(O.attributes, "fogEnabled", _.fogEnabled ? "true" : "false"), D(O.attributes, "projection", _.projection), D(O.attributes, "zoom", _.zoom), D(O.metadata, "devicePixelRatio", C), D(O.metadata, "connectionEffectiveType", R), D(O.metadata, "navigatorUserAgent", navigator.userAgent), D(O.metadata, "screenWidth", window.screen.width), D(O.metadata, "screenHeight", window.screen.height), D(O.metadata, "windowWidth", window.innerWidth), D(O.metadata, "windowHeight", window.innerHeight), D(O.metadata, "mapWidth", _.width / C), D(O.metadata, "mapHeight", _.height / C), D(O.metadata, "webglRenderer", _.renderer), D(O.metadata, "webglVendor", _.vendor), D(O.metadata, "sdkVersion", k), D(O.metadata, "sdkIdentifier", "mapbox-gl-js"), O; }(l); for (const _ of f.metadata)
                    ; for (const _ of f.counters)
                    ; for (const _ of f.attributes)
                    ; this.postEvent(n, f, () => { }, d); }
            }, Xs = mn.postPerformanceEvent.bind(mn), ln = new class extends Ft {
                constructor() { super("map.auth"), this.success = {}, this.skuToken = ""; }
                getSession(d, n, l, f) { if (!s.e.API_URL || !s.e.SESSION_PATH)
                    return; const _ = tr(s.e.API_URL + s.e.SESSION_PATH); _.params.push(`sku=${n || ""}`), _.params.push(`access_token=${f || s.e.ACCESS_TOKEN || ""}`); const v = { url: Or(_), headers: { "Content-Type": "text/plain" } }; this.pendingRequest = s.g(v, w => { this.pendingRequest = null, l(w), this.saveEventData(), this.processRequests(f); }); }
                getSessionAPI(d, n, l, f) { this.skuToken = n, this.errorCb = f, s.e.SESSION_PATH && s.e.API_URL && (l || s.e.ACCESS_TOKEN ? this.queueRequest({ id: d, timestamp: Date.now() }, l) : this.errorCb(new Error(Kt))); }
                processRequests(d) { if (this.pendingRequest || this.queue.length === 0)
                    return; const { id: n, timestamp: l } = this.queue.shift(); n && this.success[n] || this.getSession(l, this.skuToken, f => { f ? this.errorCb(f) : n && (this.success[n] = !0); }, d); }
                remove() { this.errorCb = null; }
            }, Bs = ln.getSessionAPI.bind(ln), js = new Set;
            function ss(d, n) { n ? js.add(d) : js.delete(d); }
            class Gn {
                constructor() { this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = new Set, this._updatedImages = {}; }
                isDirty() { return this._changed; }
                setDirty() { this._changed = !0; }
                getUpdatedSourceCaches() { return this._updatedSourceCaches; }
                updateSourceCache(n, l) { this._updatedSourceCaches[n] = l, this.setDirty(); }
                discardSourceCacheUpdate(n) { delete this._updatedSourceCaches[n]; }
                updateLayer(n) { const l = n.scope; this._updatedLayers[l] = this._updatedLayers[l] || new Set, this._updatedLayers[l].add(n.id), this.setDirty(); }
                removeLayer(n) { const l = n.scope; this._removedLayers[l] = this._removedLayers[l] || {}, this._updatedLayers[l] = this._updatedLayers[l] || new Set, this._removedLayers[l][n.id] = n, this._updatedLayers[l].delete(n.id), this._updatedPaintProps.delete(n.fqid), this.setDirty(); }
                getRemovedLayer(n) { return this._removedLayers[n.scope] ? this._removedLayers[n.scope][n.id] : null; }
                discardLayerRemoval(n) { this._removedLayers[n.scope] && delete this._removedLayers[n.scope][n.id]; }
                getLayerUpdatesByScope() { const n = {}; for (const l in this._updatedLayers)
                    n[l] = n[l] || {}, n[l].updatedIds = Array.from(this._updatedLayers[l].values()); for (const l in this._removedLayers)
                    n[l] = n[l] || {}, n[l].removedIds = Object.keys(this._removedLayers[l]); return n; }
                getUpdatedPaintProperties() { return this._updatedPaintProps; }
                updatePaintProperties(n) { this._updatedPaintProps.add(n.fqid), this.setDirty(); }
                getUpdatedImages(n) { return this._updatedImages[n] ? Array.from(this._updatedImages[n].values()) : []; }
                updateImage(n, l) { this._updatedImages[l] = this._updatedImages[l] || new Set, this._updatedImages[l].add(s.I.toString(n)), this.setDirty(); }
                resetUpdatedImages(n) { this._updatedImages[n] && this._updatedImages[n].clear(); }
                reset() { this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages = {}; }
            }
            function Ua(d) { const { userImage: n } = d; return !!(n && n.render && n.render()) && (d.data.replace(new Uint8Array(n.data.buffer)), !0); }
            class Xo extends s.E {
                constructor(n) { super(), this.imageProviders = new Map, this.images = new Map, this.updatedImages = new Map, this.callbackDispatchedThisFrame = new Map, this.loaded = new Map, this.requestors = [], this.patterns = new Map, this.patternsInFlight = new Set, this.atlasImage = new Map, this.atlasTexture = new Map, this.dirty = !0, this.spriteFormat = n, n !== "raster" && s.t() && (this.imageRasterizerDispatcher = new s.D(s.x(), this, "Image Rasterizer Worker", 1)); }
                addScope(n) { this.loaded.set(n, !1), this.imageProviders.set(n, new Map), this.images.set(n, new Map), this.updatedImages.set(n, new Set), this.callbackDispatchedThisFrame.set(n, new Set), this.patterns.set(n, new Map), this.atlasImage.set(n, new s.r({ width: 1, height: 1 })); }
                removeScope(n) { this.loaded.delete(n), this.imageProviders.delete(n), this.images.delete(n), this.updatedImages.delete(n), this.callbackDispatchedThisFrame.delete(n), this.patterns.delete(n), this.atlasImage.delete(n); const l = this.atlasTexture.get(n); l && (l.destroy(), this.atlasTexture.delete(n)); }
                addImageProvider(n, l) { this.imageProviders.has(l) || this.imageProviders.set(l, new Map), this.imageProviders.get(l).set(n.id, n); }
                removeImageProvider(n, l) { this.imageProviders.has(l) && this.imageProviders.get(l).delete(n); }
                getPendingImageProviders() { const n = []; for (const l of this.imageProviders.values())
                    for (const f of l.values())
                        f.hasPendingRequests() && n.push(f); return n; }
                get imageRasterizer() { return this._imageRasterizer || (this._imageRasterizer = new s.y), this._imageRasterizer; }
                isLoaded() { for (const n of this.loaded.keys())
                    if (!this.loaded.get(n))
                        return !1; return !0; }
                setLoaded(n, l) { if (this.loaded.get(l) !== n && (this.loaded.set(l, n), n)) {
                    for (const { ids: f, callback: _ } of this.requestors)
                        this._notify(f, l, _);
                    this.requestors = [];
                } }
                hasImage(n, l) { return !!this.getImage(n, l); }
                getImage(n, l) { return this.images.get(l).get(n.toString()); }
                addImage(n, l, f) { this._validate(n, f) && this.images.get(l).set(n.toString(), f); }
                _validate(n, l) { let f = !0; return this._validateStretch(l.stretchX, l.data && l.data.width) || (this.fire(new s.z(new Error(`Image "${n.name}" has invalid "stretchX" value`))), f = !1), this._validateStretch(l.stretchY, l.data && l.data.height) || (this.fire(new s.z(new Error(`Image "${n.name}" has invalid "stretchY" value`))), f = !1), this._validateContent(l.content, l) || (this.fire(new s.z(new Error(`Image "${n.name}" has invalid "content" value`))), f = !1), f; }
                _validateStretch(n, l) { if (!n)
                    return !0; let f = 0; for (const _ of n) {
                    if (_[0] < f || _[1] < _[0] || l < _[1])
                        return !1;
                    f = _[1];
                } return !0; }
                _validateContent(n, l) { return n ? n.length !== 4 || !l.usvg && (n[0] < 0 || l.data.width < n[0] || n[1] < 0 || l.data.height < n[1] || n[2] < 0 || l.data.width < n[2] || n[3] < 0 || l.data.height < n[3]) ? !1 : !(n[2] < n[0] || n[3] < n[1]) : !0; }
                updateImage(n, l, f) { const _ = this.images.get(l).get(n.toString()); f.version = _.version + 1, this.images.get(l).set(n.toString(), f), this.updatedImages.get(l).add(n), this.removeFromImageRasterizerCache(n, l); }
                clearUpdatedImages(n) { this.updatedImages.get(n).clear(); }
                removeFromImageRasterizerCache(n, l) { this.spriteFormat !== "raster" && (s.t() ? this.imageRasterizerDispatcher.getActor().send("removeRasterizedImages", { imageIds: [n], scope: l }) : this.imageRasterizer.removeImagesFromCacheByIds([n], l)); }
                removeImage(n, l) { const f = this.images.get(l), _ = f.get(n.toString()); f.delete(n.toString()), this.patterns.get(l).delete(n.toString()), this.removeFromImageRasterizerCache(n, l), _.userImage && _.userImage.onRemove && _.userImage.onRemove(); }
                listImages(n) { return Array.from(this.images.get(n).keys()).map(l => s.I.from(l)); }
                getImages(n, l, f) { const _ = [], v = [], w = this.imageProviders.get(l); for (const R of n) {
                    if (!R.iconsetId) {
                        _.push(R);
                        continue;
                    }
                    const O = w.get(R.iconsetId);
                    O && (this.getImage(R, l) ? v.push(R) : O.addPendingRequest(R));
                } if (_.length === 0)
                    return void this._notify(v, l, f); let T = !0; const C = !!this.loaded.get(l), P = this.images.get(l); if (!C)
                    for (const R of _)
                        P.has(R.toString()) || (T = !1); C || T ? this._notify(_, l, f) : this.requestors.push({ ids: _, scope: l, callback: f }); }
                rasterizeImages(n, l) { const f = new Map, { tasks: _, scope: v } = n; for (const [w, T] of _.entries()) {
                    const C = this.getImage(T.id, v);
                    C && f.set(w, { image: C, imageVariant: T });
                } this._rasterizeImages(v, f, l); }
                _rasterizeImages(n, l, f) { if (s.t())
                    this.imageRasterizerDispatcher.getActor().send("rasterizeImagesWorker", { tasks: l, scope: n }, f);
                else {
                    const _ = new Map;
                    for (const [v, { image: w, imageVariant: T }] of l.entries())
                        _.set(v, this.imageRasterizer.rasterize(T, w, n, 0));
                    f(void 0, _);
                } }
                getUpdatedImages(n) { return this.updatedImages.get(n) || new Set; }
                _notify(n, l, f) { const _ = this.images.get(l), v = new Map; for (const w of n) {
                    if (!_.get(w.toString())) {
                        if (w.iconsetId)
                            continue;
                        this.fire(new s.A("styleimagemissing", { id: w.name }));
                    }
                    const T = _.get(w.toString());
                    if (!T) {
                        s.w(`Image "${w.name}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                        continue;
                    }
                    const C = { data: T.usvg ? null : T.data.clone(), pixelRatio: T.pixelRatio, sdf: T.sdf, usvg: T.usvg, version: T.version, stretchX: T.stretchX, stretchY: T.stretchY, content: T.content, hasRenderCallback: !!(T.userImage && T.userImage.render) };
                    T.usvg && Object.assign(C, { width: T.icon.usvg_tree.width, height: T.icon.usvg_tree.height }), v.set(s.I.toString(w), C);
                } f(null, v); }
                getPixelSize(n) { const { width: l, height: f } = this.atlasImage.get(n); return { width: l, height: f }; }
                getPattern(n, l, f) { const _ = n.toString(), v = this.patterns.get(l), w = v.get(_), T = this.getImage(n, l); if (!T)
                    return null; if (w) {
                    if (w.position.version === T.version)
                        return w.position;
                    w.position.version = T.version;
                }
                else {
                    if (T.usvg && !T.data) {
                        const C = this.getPatternInFlightId(_, l);
                        if (this.patternsInFlight.has(C))
                            return null;
                        this.patternsInFlight.add(C);
                        const P = new s.B(n).scaleSelf(s.q.devicePixelRatio), R = new Map([[P.toString(), { image: T, imageVariant: P }]]);
                        return this._rasterizeImages(l, R, (O, D) => this.storePatternImage(P, l, T, f, D)), null;
                    }
                    this.storePattern(n, l, T);
                } return this._updatePatternAtlas(l, f), v.get(_).position; }
                getPatternInFlightId(n, l) { return s.C(n, l); }
                hasPatternsInFlight() { return this.patternsInFlight.size !== 0; }
                storePatternImage(n, l, f, _, v) { const w = n.toString(), T = v ? v.get(w) : void 0; T && (f.data = T, this.storePattern(n.id, l, f), this._updatePatternAtlas(l, _), this.patternsInFlight.delete(this.getPatternInFlightId(n.id.toString(), l))); }
                storePattern(n, l, f) { const _ = { w: f.data.width + 2 * s.F, h: f.data.height + 2 * s.F, x: 0, y: 0 }, v = new s.G(_, f, s.F); this.patterns.get(l).set(n.toString(), { bin: _, position: v }); }
                bind(n, l) { const f = n.gl; let _ = this.atlasTexture.get(l); _ ? this.dirty && (_.update(this.atlasImage.get(l)), this.dirty = !1) : (_ = new s.T(n, this.atlasImage.get(l), f.RGBA8), this.atlasTexture.set(l, _)), _.bind(f.LINEAR, f.CLAMP_TO_EDGE); }
                _updatePatternAtlas(n, l) { const f = this.patterns.get(n), _ = Array.from(f.values()).map(({ bin: P }) => P), { w: v, h: w } = s.H(_), T = this.atlasImage.get(n); T.resize({ width: v || 1, height: w || 1 }); const C = this.images.get(n); for (const [P, { bin: R, position: O }] of f.entries()) {
                    let D = O.padding;
                    const B = R.x + D, q = R.y + D, G = C.get(P).data, K = G.width, W = G.height;
                    D = D > 1 ? D - 1 : D, s.r.copy(G, T, { x: 0, y: 0 }, { x: B, y: q }, { width: K, height: W }, l), s.r.copy(G, T, { x: 0, y: W - D }, { x: B, y: q - D }, { width: K, height: D }, l), s.r.copy(G, T, { x: 0, y: 0 }, { x: B, y: q + W }, { width: K, height: D }, l), s.r.copy(G, T, { x: K - D, y: 0 }, { x: B - D, y: q }, { width: D, height: W }, l), s.r.copy(G, T, { x: 0, y: 0 }, { x: B + K, y: q }, { width: D, height: W }, l), s.r.copy(G, T, { x: K - D, y: W - D }, { x: B - D, y: q - D }, { width: D, height: D }, l), s.r.copy(G, T, { x: 0, y: W - D }, { x: B + K, y: q - D }, { width: D, height: D }, l), s.r.copy(G, T, { x: 0, y: 0 }, { x: B + K, y: q + W }, { width: D, height: D }, l), s.r.copy(G, T, { x: K - D, y: 0 }, { x: B - D, y: q + W }, { width: D, height: D }, l);
                } this.dirty = !0; }
                beginFrame() { for (const n of this.images.keys())
                    this.callbackDispatchedThisFrame.set(n, new Set); }
                dispatchRenderCallbacks(n, l) { const f = this.images.get(l); for (const _ of n) {
                    if (this.callbackDispatchedThisFrame.get(l).has(_.toString()))
                        continue;
                    this.callbackDispatchedThisFrame.get(l).add(_.toString());
                    const v = f.get(_.toString());
                    Ua(v) && this.updateImage(_, l, v);
                } }
            }
            function $i(d) { const n = d.key, l = d.value, f = d.valueSpec || {}, _ = d.objectElementValidators || {}, v = d.style, w = d.styleSpec; let T = []; const C = s.K(l); if (C !== "object")
                return [new s.V(n, l, `object expected, ${C} found`)]; for (const P in l) {
                const R = P.split(".")[0];
                let O;
                _[R] ? O = _[R] : f[R] ? O = jn : _["*"] ? O = _["*"] : f["*"] && (O = jn), O ? T = T.concat(O({ key: (n && `${n}.`) + P, value: l[P], valueSpec: f[R] || f["*"], style: v, styleSpec: w, object: l, objectKey: P }, l)) : T.push(new s.J(n, l[P], `unknown property "${P}"`));
            } for (const P in f)
                _[P] || f[P].required && f[P].default === void 0 && l[P] === void 0 && T.push(new s.V(n, l, `missing required property "${P}"`)); return T; }
            function Ks(d) { const n = d.value, l = d.valueSpec, f = d.style, _ = d.styleSpec, v = d.key, w = d.arrayElementValidator || jn; if (s.K(n) !== "array")
                return [new s.V(v, n, `array expected, ${s.K(n)} found`)]; if (l.length && n.length !== l.length)
                return [new s.V(v, n, `array length ${l.length} expected, length ${n.length} found`)]; if (l["min-length"] && n.length < l["min-length"])
                return [new s.V(v, n, `array length at least ${l["min-length"]} expected, length ${n.length} found`)]; let T = { type: l.value, values: l.values, minimum: l.minimum, maximum: l.maximum, function: void 0 }; _.$version < 7 && (T.function = l.function), s.K(l.value) === "object" && (T = l.value); let C = []; for (let P = 0; P < n.length; P++)
                C = C.concat(w({ array: n, arrayIndex: P, value: n[P], valueSpec: T, style: f, styleSpec: _, key: `${v}[${P}]` }, !0)); return C; }
            function Io(d) { const n = d.key, l = d.value, f = d.valueSpec; let _ = s.K(l); if (_ === "number" && l != l && (_ = "NaN"), _ !== "number")
                return [new s.V(n, l, `number expected, ${_} found`)]; if ("minimum" in f) {
                let v = f.minimum;
                if (s.K(f.minimum) === "array" && (v = f.minimum[d.arrayIndex]), l < v)
                    return [new s.V(n, l, `${l} is less than the minimum value ${v}`)];
            } if ("maximum" in f) {
                let v = f.maximum;
                if (s.K(f.maximum) === "array" && (v = f.maximum[d.arrayIndex]), l > v)
                    return [new s.V(n, l, `${l} is greater than the maximum value ${v}`)];
            } return []; }
            function Gi(d) { const n = d.valueSpec, l = s.M(d.value.type); let f, _, v, w = {}; const T = l !== "categorical" && d.value.property === void 0, C = !T, P = s.K(d.value.stops) === "array" && s.K(d.value.stops[0]) === "array" && s.K(d.value.stops[0][0]) === "object", R = $i({ key: d.key, value: d.value, valueSpec: d.styleSpec.function, style: d.style, styleSpec: d.styleSpec, objectElementValidators: { stops: function (B) { if (l === "identity")
                        return [new s.V(B.key, B.value, "identity function may not have a \"stops\" property")]; let q = []; const G = B.value; return q = q.concat(Ks({ key: B.key, value: G, valueSpec: B.valueSpec, style: B.style, styleSpec: B.styleSpec, arrayElementValidator: O })), s.K(G) === "array" && G.length === 0 && q.push(new s.V(B.key, G, "array must have at least one stop")), q; }, default: function (B) { return jn({ key: B.key, value: B.value, valueSpec: n, style: B.style, styleSpec: B.styleSpec }); } } }); return l === "identity" && T && R.push(new s.V(d.key, d.value, "missing required property \"property\"")), l === "identity" || d.value.stops || R.push(new s.V(d.key, d.value, "missing required property \"stops\"")), l === "exponential" && d.valueSpec.expression && !s.N(d.valueSpec) && R.push(new s.V(d.key, d.value, "exponential functions not supported")), d.styleSpec.$version >= 8 && (C && !s.O(d.valueSpec) ? R.push(new s.V(d.key, d.value, "property functions not supported")) : T && !s.Q(d.valueSpec) && R.push(new s.V(d.key, d.value, "zoom functions not supported"))), l !== "categorical" && !P || d.value.property !== void 0 || R.push(new s.V(d.key, d.value, "\"property\" property is required")), R; function O(B) { let q = []; const G = B.value, K = B.key; if (s.K(G) !== "array")
                return [new s.V(K, G, `array expected, ${s.K(G)} found`)]; if (G.length !== 2)
                return [new s.V(K, G, `array length 2 expected, length ${G.length} found`)]; if (P) {
                if (s.K(G[0]) !== "object")
                    return [new s.V(K, G, `object expected, ${s.K(G[0])} found`)];
                if (G[0].zoom === void 0)
                    return [new s.V(K, G, "object stop key must have zoom")];
                if (G[0].value === void 0)
                    return [new s.V(K, G, "object stop key must have value")];
                const W = s.M(G[0].zoom);
                if (typeof W != "number")
                    return [new s.V(K, G[0].zoom, "stop zoom values must be numbers")];
                if (v && v > W)
                    return [new s.V(K, G[0].zoom, "stop zoom values must appear in ascending order")];
                W !== v && (v = W, _ = void 0, w = {}), q = q.concat($i({ key: `${K}[0]`, value: G[0], valueSpec: { zoom: {} }, style: B.style, styleSpec: B.styleSpec, objectElementValidators: { zoom: Io, value: D } }));
            }
            else
                q = q.concat(D({ key: `${K}[0]`, value: G[0], valueSpec: {}, style: B.style, styleSpec: B.styleSpec }, G)); return s.S(s.U(G[1])) ? q.concat([new s.V(`${K}[1]`, G[1], "expressions are not allowed in function stops.")]) : q.concat(jn({ key: `${K}[1]`, value: G[1], valueSpec: n, style: B.style, styleSpec: B.styleSpec })); } function D(B, q) { const G = s.K(B.value), K = s.M(B.value), W = B.value !== null ? B.value : q; if (f) {
                if (G !== f)
                    return [new s.V(B.key, W, `${G} stop domain type must match previous stop domain type ${f}`)];
            }
            else
                f = G; if (G !== "number" && G !== "string" && G !== "boolean" && typeof K != "number" && typeof K != "string" && typeof K != "boolean")
                return [new s.V(B.key, W, "stop domain value must be a number, string, or boolean")]; if (G !== "number" && l !== "categorical") {
                let oe = `number expected, ${G} found`;
                return s.O(n) && l === void 0 && (oe += "\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`."), [new s.V(B.key, W, oe)];
            } return l !== "categorical" || G !== "number" || typeof K == "number" && isFinite(K) && Math.floor(K) === K ? l !== "categorical" && G === "number" && typeof K == "number" && typeof _ == "number" && _ !== void 0 && K < _ ? [new s.V(B.key, W, "stop domain values must appear in ascending order")] : (_ = K, l === "categorical" && K in w ? [new s.V(B.key, W, "stop domain values must be unique")] : (w[K] = !0, [])) : [new s.V(B.key, W, `integer expected, found ${String(K)}`)]; } }
            function Po(d) { const n = (d.expressionContext === "property" ? s.W : s.X)(s.U(d.value), d.valueSpec); if (n.result === "error")
                return n.value.map(f => new s.V(`${d.key}${f.key}`, d.value, f.message)); const l = n.value.expression || n.value._styleExpression.expression; if (d.expressionContext === "property" && d.propertyKey === "text-font" && !l.outputDefined())
                return [new s.V(d.key, d.value, `Invalid data expression for "${d.propertyKey}". Output values must be contained as literals within the expression.`)]; if (d.expressionContext === "property" && d.propertyType === "layout" && !s.Y(l))
                return [new s.V(d.key, d.value, "\"feature-state\" data expressions are not supported with layout properties.")]; if (d.expressionContext === "filter")
                return Ko(l, d); if (d.expressionContext && d.expressionContext.indexOf("cluster") === 0) {
                if (!s.Z(l, ["zoom", "feature-state"]))
                    return [new s.V(d.key, d.value, "\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.")];
                if (d.expressionContext === "cluster-initial" && !s._(l))
                    return [new s.V(d.key, d.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
            } return []; }
            function Ko(d, n) { const l = new Set(["zoom", "feature-state", "pitch", "distance-from-center"]); if (n.valueSpec && n.valueSpec.expression)
                for (const _ of n.valueSpec.expression.parameters)
                    l.delete(_); if (l.size === 0)
                return []; const f = []; return d instanceof s.$ && l.has(d.name) ? [new s.V(n.key, n.value, `["${d.name}"] expression is not supported in a filter for a ${n.object.type} layer with id: ${n.object.id}`)] : (d.eachChild(_ => { f.push(...Ko(_, n)); }), f); }
            function Ue(d) { const n = d.key, l = d.value, f = d.valueSpec, _ = []; return Array.isArray(f.values) ? f.values.indexOf(s.M(l)) === -1 && _.push(new s.V(n, l, `expected one of [${f.values.join(", ")}], ${JSON.stringify(l)} found`)) : Object.keys(f.values).indexOf(s.M(l)) === -1 && _.push(new s.V(n, l, `expected one of [${Object.keys(f.values).join(", ")}], ${JSON.stringify(l)} found`)), _; }
            function _t(d) { return s.a1(s.U(d.value)) ? Po(s.L({}, d, { expressionContext: "filter", valueSpec: d.styleSpec[`filter_${d.layerType || "fill"}`] })) : Mt(d); }
            function Mt(d) { const n = d.value, l = d.key; if (s.K(n) !== "array")
                return [new s.V(l, n, `array expected, ${s.K(n)} found`)]; const f = d.styleSpec; let _, v = []; if (n.length < 1)
                return [new s.V(l, n, "filter array must have at least 1 element")]; switch (v = v.concat(Ue({ key: `${l}[0]`, value: n[0], valueSpec: f.filter_operator, style: d.style, styleSpec: d.styleSpec })), s.M(n[0])) {
                case "<":
                case "<=":
                case ">":
                case ">=": n.length >= 2 && s.M(n[1]) === "$type" && v.push(new s.V(l, n, `"$type" cannot be use with operator "${n[0]}"`));
                case "==":
                case "!=": n.length !== 3 && v.push(new s.V(l, n, `filter array for operator "${n[0]}" must have 3 elements`));
                case "in":
                case "!in":
                    n.length >= 2 && (_ = s.K(n[1]), _ !== "string" && v.push(new s.V(`${l}[1]`, n[1], `string expected, ${_} found`)));
                    for (let w = 2; w < n.length; w++)
                        _ = s.K(n[w]), s.M(n[1]) === "$type" ? v = v.concat(Ue({ key: `${l}[${w}]`, value: n[w], valueSpec: f.geometry_type, style: d.style, styleSpec: d.styleSpec })) : _ !== "string" && _ !== "number" && _ !== "boolean" && v.push(new s.V(`${l}[${w}]`, n[w], `string, number, or boolean expected, ${_} found`));
                    break;
                case "any":
                case "all":
                case "none":
                    for (let w = 1; w < n.length; w++)
                        v = v.concat(Mt({ key: `${l}[${w}]`, value: n[w], style: d.style, styleSpec: d.styleSpec }));
                    break;
                case "has":
                case "!has": _ = s.K(n[1]), n.length !== 2 ? v.push(new s.V(l, n, `filter array for "${n[0]}" operator must have 2 elements`)) : _ !== "string" && v.push(new s.V(`${l}[1]`, n[1], `string expected, ${_} found`));
            } return v; }
            function cr(d, n) {
                const l = d.key, f = d.style, _ = d.layer, v = d.styleSpec, w = d.value, T = d.objectKey, C = v[`${n}_${d.layerType}`];
                if (!C)
                    return [];
                const P = T.match(/^(.*)-use-theme$/);
                if (n === "paint" && P && C[P[1]])
                    return s.S(w) ? [].concat(jn({ key: d.key, value: w, valueSpec: { type: "string", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, style: f, styleSpec: v, expressionContext: "property", propertyType: n, propertyKey: T })) : jn({ key: l, value: w, valueSpec: { type: "string" }, style: f, styleSpec: v });
                const R = T.match(/^(.*)-transition$/);
                if (n === "paint" && R && C[R[1]] && C[R[1]].transition)
                    return jn({ key: l, value: w, valueSpec: v.transition, style: f, styleSpec: v });
                const O = d.valueSpec || C[T];
                if (!O)
                    return [new s.J(l, w, `unknown property "${T}"`)];
                let D;
                if (s.K(w) === "string" && s.O(O) && !O.tokens && (D = /^{([^}]+)}$/.exec(w))) {
                    const q = `\`{ "type": "identity", "property": ${D ? JSON.stringify(D[1]) : "\"_\""} }\``;
                    return [new s.V(l, w, `"${T}" does not support interpolation syntax
Use an identity property function instead: ${q}.`)];
                }
                const B = [];
                if (d.layerType === "symbol")
                    T !== "text-field" || !f || f.glyphs || f.imports || B.push(new s.V(l, w, "use of \"text-field\" requires a style \"glyphs\" property")), T === "text-font" && s.a2(s.U(w)) && s.M(w.type) === "identity" && B.push(new s.V(l, w, "\"text-font\" does not support identity functions"));
                else if (d.layerType === "model" && n === "paint" && _ && _.layout && _.layout.hasOwnProperty("model-id") && s.O(O) && (s.a3(O) || s.Q(O))) {
                    const q = s.W(s.U(w), O), G = q.value.expression || q.value._styleExpression.expression;
                    G && !s.Z(G, ["measure-light"]) && (T === "model-emissive-strength" && s._(G) && s.Y(G) || B.push(new s.V(l, w, `${T} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
                }
                return B.concat(jn({ key: d.key, value: w, valueSpec: O, style: f, styleSpec: v, expressionContext: "property", propertyType: n, propertyKey: T }));
            }
            function ur(d) { return cr(d, "paint"); }
            function Jt(d) { return cr(d, "layout"); }
            function vr(d) { let n = []; const l = d.value, f = d.key, _ = d.style, v = d.styleSpec; l.type || l.ref || n.push(new s.V(f, l, "either \"type\" or \"ref\" is required")); let w = s.M(l.type); const T = s.M(l.ref); if (l.id) {
                const C = s.M(l.id);
                for (let P = 0; P < d.arrayIndex; P++) {
                    const R = _.layers[P];
                    s.M(R.id) === C && n.push(new s.V(f, l.id, `duplicate layer id "${l.id}", previously used at line ${R.id.__line__}`));
                }
            } if ("ref" in l) {
                let C;
                ["type", "source", "source-layer", "filter", "layout"].forEach(P => { P in l && n.push(new s.V(f, l[P], `"${P}" is prohibited for ref layers`)); }), _.layers.forEach(P => { s.M(P.id) === T && (C = P); }), C ? C.ref ? n.push(new s.V(f, l.ref, "ref cannot reference another ref layer")) : w = s.M(C.type) : typeof T == "string" && n.push(new s.V(f, l.ref, `ref layer "${T}" not found`));
            }
            else if (w !== "background" && w !== "sky" && w !== "slot")
                if (l.source) {
                    const C = _.sources && _.sources[l.source], P = C && s.M(C.type);
                    C ? P === "vector" && w === "raster" ? n.push(new s.V(f, l.source, `layer "${l.id}" requires a raster source`)) : P === "raster" && w !== "raster" ? n.push(new s.V(f, l.source, `layer "${l.id}" requires a vector source`)) : P !== "vector" || l["source-layer"] ? P === "raster-dem" && w !== "hillshade" ? n.push(new s.V(f, l.source, "raster-dem source can only be used with layer type 'hillshade'.")) : P !== "raster-array" || ["raster", "raster-particle"].includes(w) ? w === "line" && l.paint && (l.paint["line-gradient"] || l.paint["line-trim-offset"]) && P === "geojson" && !C.lineMetrics ? n.push(new s.V(f, l, `layer "${l.id}" specifies a line-gradient, which requires the GeoJSON source to have \`lineMetrics\` enabled.`)) : w === "raster-particle" && P !== "raster-array" && n.push(new s.V(f, l.source, `layer "${l.id}" requires a 'raster-array' source.`)) : n.push(new s.V(f, l.source, "raster-array source can only be used with layer type 'raster'.")) : n.push(new s.V(f, l, `layer "${l.id}" must specify a "source-layer"`)) : n.push(new s.V(f, l.source, `source "${l.source}" not found`));
                }
                else
                    n.push(new s.V(f, l, "missing required property \"source\"")); return n = n.concat($i({ key: f, value: l, valueSpec: v.layer, style: d.style, styleSpec: d.styleSpec, objectElementValidators: { "*": () => [], type: () => jn({ key: `${f}.type`, value: l.type, valueSpec: v.layer.type, style: d.style, styleSpec: d.styleSpec, object: l, objectKey: "type" }), filter: C => _t(s.L({ layerType: w }, C)), layout: C => $i({ layer: l, key: C.key, value: C.value, valueSpec: {}, style: C.style, styleSpec: C.styleSpec, objectElementValidators: { "*": P => Jt(s.L({ layerType: w }, P)) } }), paint: C => $i({ layer: l, key: C.key, value: C.value, valueSpec: {}, style: C.style, styleSpec: C.styleSpec, objectElementValidators: { "*": P => ur(s.L({ layerType: w, layer: l }, P)) } }) } })), n; }
            function gn(d) { const n = d.value, l = d.key, f = s.K(n); return f !== "string" ? [new s.V(l, n, `string expected, ${f} found`)] : []; }
            const mi = { promoteId: function d({ key: n, value: l }) { if (s.K(l) === "string")
                    return gn({ key: n, value: l }); if (Array.isArray(l)) {
                    const f = [], _ = s.U(l), v = s.X(_);
                    return v.result === "error" && v.value.forEach(w => { f.push(new s.V(`${n}${w.key}`, null, `${w.message}`)); }), s.Z(v.value.expression, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]) || f.push(new s.V(`${n}`, null, "promoteId expression should be only feature dependent")), f;
                } {
                    const f = [];
                    for (const _ in l)
                        f.push(...d({ key: `${n}.${_}`, value: l[_] }));
                    return f;
                } } };
            function oi(d) { const n = d.value, l = d.key, f = d.styleSpec, _ = d.style; if (!n.type)
                return [new s.V(l, n, "\"type\" is required")]; const v = s.M(n.type); let w = []; switch (["vector", "raster", "raster-dem", "raster-array"].includes(v) && (n.url || n.tiles || w.push(new s.J(l, n, "Either \"url\" or \"tiles\" is required."))), v) {
                case "vector":
                case "raster":
                case "raster-dem":
                case "raster-array": return w = w.concat($i({ key: l, value: n, valueSpec: f[`source_${v.replace("-", "_")}`], style: d.style, styleSpec: f, objectElementValidators: mi })), w;
                case "geojson":
                    if (w = $i({ key: l, value: n, valueSpec: f.source_geojson, style: _, styleSpec: f, objectElementValidators: mi }), n.cluster)
                        for (const T in n.clusterProperties) {
                            const [C, P] = n.clusterProperties[T], R = typeof C == "string" ? [C, ["accumulated"], ["get", T]] : C;
                            w.push(...Po({ key: `${l}.${T}.map`, value: P, expressionContext: "cluster-map" })), w.push(...Po({ key: `${l}.${T}.reduce`, value: R, expressionContext: "cluster-reduce" }));
                        }
                    return w;
                case "video": return $i({ key: l, value: n, valueSpec: f.source_video, style: _, styleSpec: f });
                case "image": return $i({ key: l, value: n, valueSpec: f.source_image, style: _, styleSpec: f });
                case "canvas": return [new s.V(l, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
                default: return Ue({ key: `${l}.type`, value: n.type, valueSpec: { values: $a(f) }, style: _, styleSpec: f });
            } }
            function $a(d) { return d.source.reduce((n, l) => { const f = d[l]; return f.type.type === "enum" && (n = n.concat(Object.keys(f.type.values))), n; }, []); }
            function Mo(d) { const n = d.value, l = d.styleSpec, f = l.light, _ = d.style; let v = []; const w = s.K(n); if (n === void 0)
                return v; if (w !== "object")
                return v = v.concat([new s.V("light", n, `object expected, ${w} found`)]), v; for (const T in n) {
                const C = T.match(/^(.*)-transition$/), P = T.match(/^(.*)-use-theme$/);
                v = v.concat(P && f[P[1]] ? jn({ key: T, value: n[T], valueSpec: { type: "string" }, style: _, styleSpec: l }) : C && f[C[1]] && f[C[1]].transition ? jn({ key: T, value: n[T], valueSpec: l.transition, style: _, styleSpec: l }) : f[T] ? jn({ key: T, value: n[T], valueSpec: f[T], style: _, styleSpec: l }) : [new s.V(T, n[T], `unknown property "${T}"`)]);
            } return v; }
            function Ys(d) { const n = d.value; let l = []; if (!n)
                return l; const f = s.K(n); if (f !== "object")
                return l = l.concat([new s.V("light-3d", n, `object expected, ${f} found`)]), l; const _ = d.styleSpec, v = _["light-3d"], w = d.key, T = d.style, C = d.style.lights; for (const O of ["type", "id"])
                if (!(O in n))
                    return l = l.concat([new s.V("light-3d", n, `missing property ${O} on light`)]), l; if (n.type && C)
                for (let O = 0; O < d.arrayIndex; O++) {
                    const D = s.M(n.type), B = C[O];
                    s.M(B.type) === D && l.push(new s.V(w, n.id, `duplicate light type "${n.type}", previously defined at line ${B.id.__line__}`));
                } const P = `properties_light_${n.type}`; if (!(P in _))
                return l = l.concat([new s.V("light-3d", n, `Invalid light type ${n.type}`)]), l; const R = _[P]; for (const O in n)
                if (O === "properties") {
                    const D = n[O], B = s.K(D);
                    if (B !== "object")
                        return l = l.concat([new s.V("properties", D, `object expected, ${B} found`)]), l;
                    for (const q in D)
                        l = l.concat(R[q] ? jn({ key: q, value: D[q], valueSpec: R[q], style: T, styleSpec: _ }) : [new s.J(d.key, D[q], `unknown property "${q}"`)]);
                }
                else {
                    const D = O.match(/^(.*)-transition$/), B = O.match(/^(.*)-use-theme$/);
                    l = l.concat(B && v[B[1]] ? jn({ key: O, value: n[O], valueSpec: { type: "string" }, style: T, styleSpec: _ }) : D && v[D[1]] && v[D[1]].transition ? jn({ key: O, value: n[O], valueSpec: _.transition, style: T, styleSpec: _ }) : v[O] ? jn({ key: O, value: n[O], valueSpec: v[O], style: T, styleSpec: _ }) : [new s.J(O, n[O], `unknown property "${O}"`)]);
                } return l; }
            function Ga(d) { const n = d.value, l = d.key, f = d.style, _ = d.styleSpec, v = _.terrain; let w = []; const T = s.K(n); if (n === void 0 || T === "null")
                return w; if (T !== "object")
                return w = w.concat([new s.V("terrain", n, `object expected, ${T} found`)]), w; for (const C in n) {
                const P = C.match(/^(.*)-transition$/), R = C.match(/^(.*)-use-theme$/);
                w = w.concat(R && v[R[1]] ? jn({ key: C, value: n[C], valueSpec: { type: "string" }, style: f, styleSpec: _ }) : P && v[P[1]] && v[P[1]].transition ? jn({ key: C, value: n[C], valueSpec: _.transition, style: f, styleSpec: _ }) : v[C] ? jn({ key: C, value: n[C], valueSpec: v[C], style: f, styleSpec: _ }) : [new s.J(C, n[C], `unknown property "${C}"`)]);
            } if (n.source) {
                const C = f.sources && f.sources[n.source], P = C && s.M(C.type);
                C ? P !== "raster-dem" && w.push(new s.V(l, n.source, `terrain cannot be used with a source of type ${String(P)}, it only be used with a "raster-dem" source type`)) : w.push(new s.V(l, n.source, `source "${n.source}" not found`));
            }
            else
                w.push(new s.V(l, n, "terrain is missing required property \"source\"")); return w; }
            function wa(d) { const n = d.value, l = d.style, f = d.styleSpec, _ = f.fog; let v = []; const w = s.K(n); if (n === void 0)
                return v; if (w !== "object")
                return v = v.concat([new s.V("fog", n, `object expected, ${w} found`)]), v; for (const T in n) {
                const C = T.match(/^(.*)-transition$/), P = T.match(/^(.*)-use-theme$/);
                v = v.concat(P && _[P[1]] ? jn({ key: T, value: n[T], valueSpec: { type: "string" }, style: l, styleSpec: f }) : C && _[C[1]] && _[C[1]].transition ? jn({ key: T, value: n[T], valueSpec: f.transition, style: l, styleSpec: f }) : _[T] ? jn({ key: T, value: n[T], valueSpec: _[T], style: l, styleSpec: f }) : [new s.J(T, n[T], `unknown property "${T}"`)]);
            } return v; }
            const gc = { "*": () => [], array: Ks, boolean: function (d) { const n = d.value, l = d.key, f = s.K(n); return f !== "boolean" ? [new s.V(l, n, `boolean expected, ${f} found`)] : []; }, number: Io, color: function (d) { const n = d.key, l = d.value, f = s.K(l); return f !== "string" ? [new s.V(n, l, `color expected, ${f} found`)] : s.a0.parseCSSColor(l) === null ? [new s.V(n, l, `color expected, "${l}" found`)] : []; }, enum: Ue, filter: _t, function: Gi, layer: vr, object: $i, source: oi, model: s.a4, light: Mo, "light-3d": Ys, terrain: Ga, fog: wa, string: gn, formatted: function (d) { return gn(d).length === 0 ? [] : Po(d); }, resolvedImage: function (d) { return gn(d).length === 0 ? [] : Po(d); }, projection: function (d) { const n = d.value, l = d.styleSpec, f = l.projection, _ = d.style; let v = []; const w = s.K(n); if (w === "object")
                    for (const T in n)
                        v = v.concat(jn({ key: T, value: n[T], valueSpec: f[T], style: _, styleSpec: l }));
                else
                    w !== "string" && (v = v.concat([new s.V("projection", n, `object or string expected, ${w} found`)])); return v; }, import: function (d) { const { value: n, styleSpec: l } = d, { data: f, ..._ } = n; Object.defineProperty(_, "__line__", { value: n.__line__, enumerable: !1 }); let v = $i(s.L({}, d, { value: _, valueSpec: l.import })); return s.M(_.id) === "" && v.push(new s.V(`${d.key}.id`, _, "import id can't be an empty string")), f && (v = v.concat(pu(f, l, { key: `${d.key}.data` }))), v; }, iconset: function (d) { const n = d.value, l = d.key, f = d.styleSpec, _ = d.style; if (!n.type)
                    return [new s.V(l, n, "\"type\" is required")]; const v = s.M(n.type); let w = []; if (w = w.concat($i({ key: l, value: n, valueSpec: f[`iconset_${v}`], style: _, styleSpec: f })), v === "source" && n.source) {
                    const T = _.sources && _.sources[n.source], C = T && s.M(T.type);
                    T ? C !== "raster-array" && w.push(new s.V(l, n.source, `iconset cannot be used with a source of type ${String(C)}, it only be used with a "raster-array" source type`)) : w.push(new s.V(l, n.source, `source "${n.source}" not found`));
                } return w; } };
            function jn(d, n = !1) { const l = d.value, f = d.valueSpec, _ = d.styleSpec; if (f.expression && s.a2(s.M(l)))
                return Gi(d); if (f.expression && s.S(s.U(l)))
                return Po(d); if (f.type && gc[f.type]) {
                const v = gc[f.type](d);
                return n === !0 && v.length > 0 && s.K(d.value) === "array" ? Po(d) : v;
            } return $i(s.L({}, d, { valueSpec: f.type ? _[f.type] : f })); }
            function ba(d) { const n = d.value, l = d.key, f = gn(d); return f.length || (n.indexOf("{fontstack}") === -1 && f.push(new s.V(l, n, "\"glyphs\" url must include a \"{fontstack}\" token")), n.indexOf("{range}") === -1 && f.push(new s.V(l, n, "\"glyphs\" url must include a \"{range}\" token"))), f; }
            function pu(d, n = s.a5, l = {}) { return jn({ key: l.key || "", value: d, valueSpec: n.$root, styleSpec: n, style: d, objectElementValidators: { glyphs: ba, "*": () => [] } }); }
            function Ro(d, n = s.a5) { return Re(pu(d, n)); }
            const id = d => Re(oi(d)), Gf = d => Re(Mo(d)), sd = d => Re(Ys(d)), Et = d => Re(Ga(d)), qa = d => Re(wa(d)), qf = d => Re(function (n) { const l = n.value, f = n.style, _ = n.styleSpec, v = _.snow; let w = []; const T = s.K(l); if (l === void 0)
                return w; if (T !== "object")
                return w = w.concat([new s.V("snow", l, `object expected, ${T} found`)]), w; for (const C in l) {
                const P = C.match(/^(.*)-transition$/);
                w = w.concat(P && v[P[1]] && v[P[1]].transition ? jn({ key: C, value: l[C], valueSpec: _.transition, style: f, styleSpec: _ }) : v[C] ? jn({ key: C, value: l[C], valueSpec: v[C], style: f, styleSpec: _ }) : [new s.J(C, l[C], `unknown property "${C}"`)]);
            } return w; }(d)), Qe = d => Re(function (n) { const l = n.value, f = n.style, _ = n.styleSpec, v = _.rain; let w = []; const T = s.K(l); if (l === void 0)
                return w; if (T !== "object")
                return w = w.concat([new s.V("rain", l, `object expected, ${T} found`)]), w; for (const C in l) {
                const P = C.match(/^(.*)-transition$/);
                w = w.concat(P && v[P[1]] && v[P[1]].transition ? jn({ key: C, value: l[C], valueSpec: _.transition, style: f, styleSpec: _ }) : v[C] ? jn({ key: C, value: l[C], valueSpec: v[C], style: f, styleSpec: _ }) : [new s.J(C, l[C], `unknown property "${C}"`)]);
            } return w; }(d)), Z = d => Re(vr(d)), re = d => Re(_t(d)), _e = d => Re(ur(d)), Ae = d => Re(Jt(d)), Ee = d => Re(s.a4(d));
            function Re(d) { return d.slice().sort((n, l) => n.line && l.line ? n.line - l.line : 0); }
            function ke(d, n) { let l = !1; if (n && n.length)
                for (const f of n)
                    f instanceof s.J ? s.w(f.message) : (d.fire(new s.z(new Error(f.message))), l = !0); return l; }
            let De;
            class qe extends s.E {
                constructor(n, l = "flat") { super(), this._transitionable = new s.a6(De || (De = new s.a7({ anchor: new s.a8(s.a5.light.anchor), position: new s.a9(s.a5.light.position), color: new s.a8(s.a5.light.color), intensity: new s.a8(s.a5.light.intensity) }))), this.setLight(n, l), this._transitioning = this._transitionable.untransitioned(); }
                getLight() { return this._transitionable.serialize(); }
                setLight(n, l, f = {}) { this._validate(Gf, n, f) || (this._transitionable.setTransitionOrValue(n), this.id = l); }
                updateTransitions(n) { this._transitioning = this._transitionable.transitioned(n, this._transitioning); }
                hasTransition() { return this._transitioning.hasTransition(); }
                recalculate(n) { this.properties = this._transitioning.possiblyEvaluate(n); }
                _validate(n, l, f) { return (!f || f.validate !== !1) && ke(this, n.call(Ro, s.l({ value: l, style: { glyphs: !0, sprite: !0 }, styleSpec: s.a5 }))); }
            }
            let tt = class extends s.E {
                constructor(d, n, l, f) { super(), this.scope = l, this._transitionable = new s.a6(new s.a7({ source: new s.a8(s.a5.terrain.source), exaggeration: new s.a8(s.a5.terrain.exaggeration) }), l, f), this._transitionable.setTransitionOrValue(d, f), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = n; }
                get() { return this._transitionable.serialize(); }
                set(d, n) { this._transitionable.setTransitionOrValue(d, n); }
                updateTransitions(d) { this._transitioning = this._transitionable.transitioned(d, this._transitioning); }
                hasTransition() { return this._transitioning.hasTransition(); }
                recalculate(d) { this.properties = this._transitioning.possiblyEvaluate(d); }
                getExaggeration(d) { return this._transitioning.possiblyEvaluate(new s.aa(d)).get("exaggeration"); }
                getAttenuationRange() { if (!this.isZoomDependent())
                    return null; const d = this._transitionable._values.exaggeration; if (!d)
                    return null; const n = d.value.expression; if (!n)
                    return null; let l = -1, f = -1, _ = 1; for (const v of n.zoomStops)
                    _ = n.evaluate(new s.aa(v)), _ > .01 ? (l = v, f = -1) : f = v; return _ < .01 && l > 0 && f > l ? [l, f] : null; }
                isZoomDependent() { const d = this._transitionable._values.exaggeration; return d != null && d.value != null && d.value.expression != null && d.value.expression instanceof s.ab; }
            };
            const $e = 45, Ct = 65, Ot = .05;
            function Wt(d, n, l, f) { const _ = s.af($e, Ct, l), [v, w] = _r(d, f); let T = 1 - Math.min(1, Math.exp((n - v) / (w - v) * -6)); return T *= T * T, T = Math.min(1, 1.00747 * T), T * _ * d.alpha; }
            function _r(d, n) { const l = .5 / Math.tan(.5 * n); return [d.range[0] + l, d.range[1] + l]; }
            function br(d, n, l, f, _) { const v = s.ad([], [n, l, f], _.mercatorFogMatrix); return Wt(d, s.ae(v), _.pitch, _._fov); }
            function Mr(d, n, l, f, _, v, w) { const T = [[l, f, 0], [_, f, 0], [_, v, 0], [l, v, 0]]; let C = Number.MAX_VALUE, P = -Number.MAX_VALUE; for (const R of T) {
                const O = s.ad([], R, n), D = s.ae(O);
                C = Math.min(C, D), P = Math.max(P, D);
            } return [Wt(d, C, w.pitch, w._fov), Wt(d, P, w.pitch, w._fov)]; }
            class Fr extends s.E {
                constructor(n, l, f, _) { super(); const v = new s.a7({ range: new s.a8(s.a5.fog.range), color: new s.a8(s.a5.fog.color), "color-use-theme": new s.a8({ type: "string", "property-type": "data-constant", default: "default" }), "high-color": new s.a8(s.a5.fog["high-color"]), "high-color-use-theme": new s.a8({ type: "string", "property-type": "data-constant", default: "default" }), "space-color": new s.a8(s.a5.fog["space-color"]), "space-color-use-theme": new s.a8({ type: "string", "property-type": "data-constant", default: "default" }), "horizon-blend": new s.a8(s.a5.fog["horizon-blend"]), "star-intensity": new s.a8(s.a5.fog["star-intensity"]), "vertical-range": new s.a8(s.a5.fog["vertical-range"]) }); this._transitionable = new s.a6(v, f, new Map(_)), this.set(n, _), this._transitioning = this._transitionable.untransitioned(), this._transform = l, this.properties = new s.ag(v), this.scope = f; }
                get state() { const n = this._transform, l = n.projection.name === "globe", f = s.ah(n.zoom), _ = this.properties.get("range"), v = [.5, 3]; return { range: l ? [s.ai(v[0], _[0], f), s.ai(v[1], _[1], f)] : _, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a }; }
                get() { return this._transitionable.serialize(); }
                set(n, l, f = {}) { if (this._validate(qa, n, f))
                    return; const _ = s.l({}, n); for (const v of Object.keys(s.a5.fog))
                    _[v] === void 0 && (_[v] = s.a5.fog[v].default); this._options = _, this._transitionable.setTransitionOrValue(this._options, l); }
                getOpacity(n) { if (!this._transform.projection.supportsFog)
                    return 0; const l = this.properties && this.properties.get("color") || 1; return (this._transform.projection.name === "globe" ? 1 : s.af($e, Ct, n)) * l.a; }
                getOpacityAtLatLng(n, l) { return this._transform.projection.supportsFog ? function (f, _, v) { const w = s.ac.fromLngLat(_), T = v.elevation ? v.elevation.getAtPointOrZero(w) : 0; return br(f, w.x, w.y, T, v); }(this.state, n, l) : 0; }
                getOpacityForTile(n) { if (!this._transform.projection.supportsFog)
                    return [1, 1]; const l = this._transform.calculateFogTileMatrix(n.toUnwrapped()); return Mr(this.state, l, 0, 0, s.aj, s.aj, this._transform); }
                getOpacityForBounds(n, l, f, _, v) { return this._transform.projection.supportsFog ? Mr(this.state, n, l, f, _, v, this._transform) : [1, 1]; }
                getFovAdjustedRange(n) { return this._transform.projection.supportsFog ? _r(this.state, n) : [0, 1]; }
                isVisibleOnFrustum(n) { if (!this._transform.projection.supportsFog)
                    return !1; const l = [4, 5, 6, 7]; for (const f of l) {
                    const _ = n.points[f];
                    let v;
                    if (_[2] >= 0)
                        v = _;
                    else {
                        const w = n.points[f - 4];
                        v = s.ak(w, _, w[2] / (w[2] - _[2]));
                    }
                    if (br(this.state, v[0], v[1], 0, this._transform) >= Ot)
                        return !0;
                } return !1; }
                updateConfig(n) { this._transitionable.setTransitionOrValue(this._options, new Map(n)); }
                updateTransitions(n) { this._transitioning = this._transitionable.transitioned(n, this._transitioning); }
                hasTransition() { return this._transitioning.hasTransition(); }
                recalculate(n) { this.properties = this._transitioning.possiblyEvaluate(n); }
                _validate(n, l, f) { return (!f || f.validate !== !1) && ke(this, n.call(Ro, s.l({ value: l, style: { glyphs: !0, sprite: !0 }, styleSpec: s.a5 }))); }
            }
            let ai, Br, An, en, In = class extends s.E {
                constructor(d, n, l, f) { super(); const _ = ai || (ai = new s.a7({ density: new s.a8(s.a5.snow.density), intensity: new s.a8(s.a5.snow.intensity), color: new s.a8(s.a5.snow.color), opacity: new s.a8(s.a5.snow.opacity), vignette: new s.a8(s.a5.snow.vignette), "vignette-color": new s.a8(s.a5.snow["vignette-color"]), "center-thinning": new s.a8(s.a5.snow["center-thinning"]), direction: new s.a8(s.a5.snow.direction), "flake-size": new s.a8(s.a5.snow["flake-size"]) })); this._transitionable = new s.a6(_, l, new Map(f)), this.set(d, f), this._transitioning = this._transitionable.untransitioned(), this.properties = new s.ag(_), this.scope = l; }
                get state() { const d = this.properties.get("opacity"), n = this.properties.get("color"), l = this.properties.get("direction"), f = s.al(l[0]), _ = -Math.max(s.al(l[1]), .01), v = [Math.cos(f) * Math.cos(_), Math.sin(f) * Math.cos(_), Math.sin(_)], w = this.properties.get("vignette"), T = this.properties.get("vignette-color"); return T.a = w, { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new s.am(n.r, n.g, n.b, n.a * d), direction: v, centerThinning: this.properties.get("center-thinning"), flakeSize: this.properties.get("flake-size"), vignetteColor: T }; }
                get() { return this._transitionable.serialize(); }
                set(d, n, l = {}) { if (this._validate(qf, d, l))
                    return; const f = s.l({}, d); for (const _ of Object.keys(s.a5.snow))
                    f[_] === void 0 && (f[_] = s.a5.snow[_].default); this._options = f, this._transitionable.setTransitionOrValue(this._options, n); }
                updateConfig(d) { this._transitionable.setTransitionOrValue(this._options, new Map(d)); }
                updateTransitions(d) { this._transitioning = this._transitionable.transitioned(d, this._transitioning); }
                hasTransition() { return this._transitioning.hasTransition(); }
                recalculate(d) { this.properties = this._transitioning.possiblyEvaluate(d); }
                _validate(d, n, l) { return (!l || l.validate !== !1) && ke(this, d.call(Ro, s.l({ value: n, style: { glyphs: !0, sprite: !0 }, styleSpec: s.a5 }))); }
            }, Dn = class extends s.E {
                constructor(d, n, l, f) { super(); const _ = Br || (Br = new s.a7({ density: new s.a8(s.a5.rain.density), intensity: new s.a8(s.a5.rain.intensity), color: new s.a8(s.a5.rain.color), opacity: new s.a8(s.a5.rain.opacity), vignette: new s.a8(s.a5.rain.vignette), "vignette-color": new s.a8(s.a5.rain["vignette-color"]), "center-thinning": new s.a8(s.a5.rain["center-thinning"]), direction: new s.a8(s.a5.rain.direction), "droplet-size": new s.a8(s.a5.rain["droplet-size"]), "distortion-strength": new s.a8(s.a5.rain["distortion-strength"]) })); this._transitionable = new s.a6(_, l, new Map(f)), this.set(d, f), this._transitioning = this._transitionable.untransitioned(), this.properties = new s.ag(_), this.scope = l; }
                get state() { const d = this.properties.get("opacity"), n = this.properties.get("color"), l = this.properties.get("direction"), f = s.al(l[0]), _ = -Math.max(s.al(l[1]), .01), v = [Math.cos(f) * Math.cos(_), Math.sin(f) * Math.cos(_), Math.sin(_)], w = this.properties.get("vignette-color"); return w.a = this.properties.get("vignette"), { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new s.am(n.r, n.g, n.b, n.a * d), direction: v, centerThinning: this.properties.get("center-thinning"), dropletSize: this.properties.get("droplet-size"), distortionStrength: this.properties.get("distortion-strength"), vignetteColor: w }; }
                get() { return this._transitionable.serialize(); }
                set(d, n, l = {}) { if (this._validate(Qe, d, l))
                    return; const f = s.l({}, d); for (const _ of Object.keys(s.a5.rain))
                    f[_] === void 0 && (f[_] = s.a5.rain[_].default); this._options = f, this._transitionable.setTransitionOrValue(this._options, n); }
                updateConfig(d) { this._transitionable.setTransitionOrValue(this._options, new Map(d)); }
                updateTransitions(d) { this._transitioning = this._transitionable.transitioned(d, this._transitioning); }
                hasTransition() { return this._transitioning.hasTransition(); }
                recalculate(d) { this.properties = this._transitioning.possiblyEvaluate(d); }
                _validate(d, n, l) { return (!l || l.validate !== !1) && ke(this, d.call(Ro, s.l({ value: n, style: { glyphs: !0, sprite: !0 }, styleSpec: s.a5 }))); }
            };
            class vi extends s.E {
                constructor(n, l, f, _) { super(), this.scope = f, this._options = n, this.properties = new s.ag(l), this._transitionable = new s.a6(l, f, new Map(_)), this._transitionable.setTransitionOrValue(n.properties), this._transitioning = this._transitionable.untransitioned(); }
                updateConfig(n) { this._transitionable.setTransitionOrValue(this._options.properties, new Map(n)); }
                updateTransitions(n) { this._transitioning = this._transitionable.transitioned(n, this._transitioning); }
                hasTransition() { return this._transitioning.hasTransition(); }
                recalculate(n) { this.properties = this._transitioning.possiblyEvaluate(n); }
                get() { return this._options.properties = this._transitionable.serialize(), this._options; }
                set(n, l) { this._options = n, this._transitionable.setTransitionOrValue(n.properties, l); }
                shadowsEnabled() { return !!this.properties && this.properties.get("cast-shadows") === !0; }
            }
            class Mi {
                constructor(n, l, f, _) { this.screenBounds = n, this.cameraPoint = l, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = f, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, _); }
                static createFromScreenPoints(n, l) { let f, _; if (n instanceof s.P || typeof n[0] == "number") {
                    const v = s.P.convert(n);
                    f = [v], _ = l.isPointAboveHorizon(v);
                }
                else {
                    const v = s.P.convert(n[0]), w = s.P.convert(n[1]), T = v.add(w)._div(2);
                    f = [v, w], _ = s.ao(v, w).every(C => l.isPointAboveHorizon(C)) && l.isPointAboveHorizon(T);
                } return new Mi(f, l.getCameraPoint(), _, l); }
                isPointQuery() { return this.screenBounds.length === 1; }
                bufferedScreenGeometry(n) { return s.ao(this.screenBounds[0], this.screenBounds.length === 1 ? this.screenBounds[0] : this.screenBounds[1], n); }
                bufferedCameraGeometry(n) { const l = this.screenBounds[0], f = this.screenBounds.length === 1 ? this.screenBounds[0].add(new s.P(1, 1)) : this.screenBounds[1], _ = s.ao(l, f, 0, !1); return this.cameraPoint.y > f.y && (this.cameraPoint.x > l.x && this.cameraPoint.x < f.x ? _.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= f.x ? _[2] = this.cameraPoint : this.cameraPoint.x <= l.x && (_[3] = this.cameraPoint)), s.ap(_, n); }
                bufferedCameraGeometryGlobe(n) { const l = this.screenBounds[0], f = this.screenBounds.length === 1 ? this.screenBounds[0].add(new s.P(1, 1)) : this.screenBounds[1], _ = s.ao(l, f, n), v = this.cameraPoint.clone(); switch (3 * ((v.y > l.y) + (v.y > f.y)) + ((v.x > l.x) + (v.x > f.x))) {
                    case 0:
                        _[0] = v, _[4] = v.clone();
                        break;
                    case 1:
                        _.splice(1, 0, v);
                        break;
                    case 2:
                        _[1] = v;
                        break;
                    case 3:
                        _.splice(4, 0, v);
                        break;
                    case 5:
                        _.splice(2, 0, v);
                        break;
                    case 6:
                        _[3] = v;
                        break;
                    case 7:
                        _.splice(3, 0, v);
                        break;
                    case 8: _[2] = v;
                } return _; }
                containsTile(n, l, f, _ = 0) { const v = n.queryPadding / l._pixelsPerMercatorPixel + 1, w = f ? this._bufferedCameraMercator(v, l) : this._bufferedScreenMercator(v, l); let T = n.tileID.wrap + (w.unwrapped ? _ : 0); const C = w.polygon.map(K => s.aq(n.tileTransform, K, T)); if (!s.ar(C, 0, 0, s.aj, s.aj))
                    return; T = n.tileID.wrap + (this.screenGeometryMercator.unwrapped ? _ : 0); const P = this.screenGeometryMercator.polygon.map(K => s.as(n.tileTransform, K, T)), R = P.map(K => new s.P(K[0], K[1])), O = l.getFreeCameraOptions().position || new s.ac(0, 0, 0), D = s.as(n.tileTransform, O, T), B = P.map(K => { const W = s.at(K, K, D); return s.au(W, W), new s.av(D, W); }), q = s.aw(n, 1, l.zoom) * l._pixelsPerMercatorPixel; return { queryGeometry: this, tilespaceGeometry: R, tilespaceRays: B, bufferedTilespaceGeometry: C, bufferedTilespaceBounds: (G = s.ax(C), G.min.x = s.aD(G.min.x, 0, s.aj), G.min.y = s.aD(G.min.y, 0, s.aj), G.max.x = s.aD(G.max.x, 0, s.aj), G.max.y = s.aD(G.max.y, 0, s.aj), G), tile: n, tileID: n.tileID, pixelToTileUnitsFactor: q }; var G; }
                _bufferedScreenMercator(n, l) { const f = Ha(n); if (this._screenRaycastCache[f])
                    return this._screenRaycastCache[f]; {
                    let _;
                    return _ = l.projection.name === "globe" ? this._projectAndResample(this.bufferedScreenGeometry(n), l) : { polygon: this.bufferedScreenGeometry(n).map(v => l.pointCoordinate3D(v)), unwrapped: !0 }, this._screenRaycastCache[f] = _, _;
                } }
                _bufferedCameraMercator(n, l) { const f = Ha(n); if (this._cameraRaycastCache[f])
                    return this._cameraRaycastCache[f]; {
                    let _;
                    return _ = l.projection.name === "globe" ? this._projectAndResample(this.bufferedCameraGeometryGlobe(n), l) : { polygon: this.bufferedCameraGeometry(n).map(v => l.pointCoordinate3D(v)), unwrapped: !0 }, this._cameraRaycastCache[f] = _, _;
                } }
                _projectAndResample(n, l) { const f = function (v, w) { const T = s.az([], w.pixelMatrix, w.globeMatrix), C = [0, -s.aE, 0, 1], P = [0, s.aE, 0, 1], R = [0, 0, 0, 1]; s.aA(C, C, T), s.aA(P, P, T), s.aA(R, R, T); const O = new s.P(C[0] / C[3], C[1] / C[3]), D = new s.P(P[0] / P[3], P[1] / P[3]), B = s.aB(v, O) && C[3] < R[3], q = s.aB(v, D) && P[3] < R[3]; if (!B && !q)
                    return null; const G = function (xe, ge, Se) { for (let Ce = 1; Ce < xe.length; Ce++) {
                    const je = os(ge.pointCoordinate3D(xe[Ce - 1]).x), ze = os(ge.pointCoordinate3D(xe[Ce]).x);
                    if (Se < 0) {
                        if (je < ze)
                            return { idx: Ce, t: -je / (ze - 1 - je) };
                    }
                    else if (ze < je)
                        return { idx: Ce, t: (1 - je) / (ze + 1 - je) };
                } return null; }(v, w, B ? -1 : 1); if (!G)
                    return null; const { idx: K, t: W } = G; let oe = K > 1 ? qi(v.slice(0, K), w) : [], de = K < v.length ? qi(v.slice(K), w) : []; oe = oe.map(xe => new s.P(os(xe.x), xe.y)), de = de.map(xe => new s.P(os(xe.x), xe.y)); const me = [...oe]; me.length === 0 && me.push(de[de.length - 1]); const we = s.ai(me[me.length - 1].y, (de.length === 0 ? oe[0] : de[0]).y, W); let ve; return ve = B ? [new s.P(0, we), new s.P(0, 0), new s.P(1, 0), new s.P(1, we)] : [new s.P(1, we), new s.P(1, 1), new s.P(0, 1), new s.P(0, we)], me.push(...ve), de.length === 0 ? me.push(oe[0]) : me.push(...de), { polygon: me.map(xe => new s.ac(xe.x, xe.y)), unwrapped: !1 }; }(n, l); if (f)
                    return f; const _ = function (v, w) { let T = !1, C = -1 / 0, P = 0; for (let O = 0; O < v.length - 1; O++)
                    v[O].x > C && (C = v[O].x, P = O); for (let O = 0; O < v.length - 1; O++) {
                    const D = (P + O) % (v.length - 1), B = v[D], q = v[D + 1];
                    Math.abs(B.x - q.x) > .5 && (B.x < q.x ? (B.x += 1, D === 0 && (v[v.length - 1].x += 1)) : (q.x += 1, D + 1 === v.length - 1 && (v[0].x += 1)), T = !0);
                } const R = s.ay(w.center.lng); return T && R < Math.abs(R - 1) && v.forEach(O => { O.x -= 1; }), { polygon: v, unwrapped: T }; }(qi(n, l).map(v => new s.P(os(v.x), v.y)), l); return { polygon: _.polygon.map(v => new s.ac(v.x, v.y)), unwrapped: _.unwrapped }; }
            }
            function qi(d, n) { return s.aC(d, l => { const f = n.pointCoordinate3D(l); l.x = f.x, l.y = f.y; }, 1 / 256); }
            function os(d) { return d < 0 ? 1 + d % 1 : d % 1; }
            function Ha(d) { return 100 * d | 0; }
            function _s(d, n, l, f, _) { const v = function (T, C) { if (T)
                return _(T); if (C) {
                if (d.url && C.tiles && d.tiles && delete d.tiles, C.variants) {
                    if (!Array.isArray(C.variants))
                        return _(new Error("variants must be an array"));
                    for (const R of C.variants) {
                        if (R == null || typeof R != "object" || R.constructor !== Object)
                            return _(new Error("variant must be an object"));
                        if (!Array.isArray(R.capabilities))
                            return _(new Error("capabilities must be an array"));
                        if (R.capabilities.length === 1 && R.capabilities[0] === "meshopt") {
                            C = s.l(C, R);
                            break;
                        }
                    }
                }
                const P = s.aF(s.l({}, C, d), ["tilejson", "tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "extra_bounds", "scheme", "tileSize", "encoding", "vector_layers", "raster_layers", "worldview_options", "worldview_default", "worldview"]);
                P.tiles = n.canonicalizeTileset(P, d.url), _(null, P);
            } }, w = function (T, C, P) { if (!T)
                return null; if (!C && !P)
                return T; P = P || T.worldview_default; const R = Object.values(T.language || {}); if (R.length === 0)
                return null; const O = Object.values(T.worldview || {}); if (O.length === 0)
                return null; const D = R.every(q => q === C), B = O.every(q => q === P); return D && B ? T : C in (T.language_options || {}) || P in (T.worldview_options || {}) ? null : T.language_options && T.worldview_options ? T : null; }(d.data, l, f); return w ? s.q.frame(() => v(null, w)) : d.url ? s.n(n.transformRequest(n.normalizeSourceURL(d.url, null, l, f), s.R.Source), v) : s.q.frame(() => { const { data: T, ...C } = d; v(null, C); }); }
            function ys(d, n) { const l = Math.pow(2, n.z), f = Math.floor(s.ay(d.getWest()) * l), _ = Math.floor(s.aH(d.getNorth()) * l), v = Math.ceil(s.ay(d.getEast()) * l), w = Math.ceil(s.aH(d.getSouth()) * l); return n.x >= f && n.x < v && n.y >= _ && n.y < w; }
            class Ji {
                constructor(n, l, f) { this.bounds = n ? s.aG.convert(this.validateBounds(n)) : null, this.minzoom = l || 0, this.maxzoom = f || 24; }
                validateBounds(n) { return Array.isArray(n) && n.length === 4 ? [Math.max(-180, n[0]), Math.max(-90, n[1]), Math.min(180, n[2]), Math.min(90, n[3])] : [-180, -90, 180, 90]; }
                addExtraBounds(n) { if (n) {
                    this.extraBounds || (this.extraBounds = []);
                    for (const l of n)
                        this.extraBounds.push(s.aG.convert(this.validateBounds(l)));
                } }
                contains(n) { if (n.z > this.maxzoom || n.z < this.minzoom || this.bounds && !ys(this.bounds, n))
                    return !1; if (!this.extraBounds)
                    return !0; for (const l of this.extraBounds)
                    if (ys(l, n))
                        return !0; return !1; }
                static fromTileJSON(n) { if (!n.bounds && !n.extra_bounds)
                    return null; const l = new Ji(n.bounds, n.minzoom, n.maxzoom); return l.addExtraBounds(n.extra_bounds), l; }
            }
            class hs extends s.E {
                constructor(n, l, f, _) { if (super(), this.id = n, this.dispatcher = f, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, s.l(this, s.aF(l, ["url", "scheme", "tileSize", "promoteId"])), this._options = s.l({ type: "vector" }, l), this._collectResourceTiming = !!l.collectResourceTiming, this.tileSize !== 512)
                    throw new Error("vector tile sources must have a tileSize of 512"); this.setEventedParent(_), this._tileWorkers = {}, this._deduped = new s.aI; }
                load(n) { this._loaded = !1, this.fire(new s.A("dataloading", { dataType: "source" })); const l = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, f = this.map.getWorldview(); this._tileJSONRequest = _s(this._options, this.map._requestManager, l, f, (_, v) => { if (this._tileJSONRequest = null, this._loaded = !0, _)
                    l && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${l}`), f && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${f}`), this.fire(new s.z(_));
                else if (v) {
                    if (s.l(this, v), this.hasWorldviews = !!v.worldview_options, v.worldview_default && (this.worldviewDefault = v.worldview_default), v.vector_layers) {
                        this.vectorLayers = v.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = new Set;
                        for (const w of v.vector_layers)
                            this.vectorLayerIds.push(w.id), v.worldview && v.worldview[w.source] && this.localizableLayerIds.add(w.id);
                    }
                    this.tileBounds = Ji.fromTileJSON(v), Jr(v.tiles, this.map._requestManager._customAccessToken), this.fire(new s.A("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.A("data", { dataType: "source", sourceDataType: "content" }));
                } n && n(_); }); }
                loaded() { return this._loaded; }
                hasTile(n) { return !this.tileBounds || this.tileBounds.contains(n.canonical); }
                onAdd(n) { this.map = n, this.load(); }
                reload() { this.cancelTileJSONRequest(); const n = s.C(this.id, this.scope); this.load(() => this.map.style.clearSource(n)); }
                setTiles(n) { return this._options.tiles = n, this.reload(), this; }
                setUrl(n) { return this.url = n, this._options.url = n, this.reload(), this; }
                onRemove(n) { this.cancelTileJSONRequest(); }
                serialize() { return s.l({}, this._options); }
                loadTile(n, l) { const f = n.tileID.canonical.url(this.tiles, this.scheme), _ = this.map._requestManager.normalizeTileURL(f), v = this.map._requestManager.transformRequest(_, s.R.Tile), w = this.map.style ? this.map.style.getLut(this.scope) : null, T = w ? { image: w.image.clone() } : null, C = { request: v, data: void 0, uid: n.uid, tileID: n.tileID, tileZoom: n.tileZoom, zoom: n.tileID.overscaledZ, maxZoom: this.maxzoom, lut: T, tileSize: this.tileSize * n.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: s.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: n.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: n.isExtraShadowCaster, tessellationStep: this.map._tessellationStep, scaleFactor: this.map.getScaleFactor() }; if (this.hasWorldviews && s.f(f) && (C.worldview = this.map.getWorldview() || this.worldviewDefault, C.localizableLayerIds = this.localizableLayerIds), C.request.collectResourceTiming = this._collectResourceTiming, n.actor && n.state !== "expired")
                    n.state === "loading" ? n.reloadCallback = l : n.request = n.actor.send("reloadTile", C, P.bind(this));
                else if (n.actor = this._tileWorkers[_] = this._tileWorkers[_] || this.dispatcher.getActor(), this.dispatcher.ready)
                    n.request = n.actor.send("loadTile", C, P.bind(this), void 0, !0);
                else {
                    const R = s.aJ.call({ deduped: this._deduped }, C, (O, D) => { O || !D ? P.call(this, O) : (C.data = { cacheControl: D.cacheControl, expires: D.expires, rawData: D.rawData.slice(0) }, n.actor && n.actor.send("loadTile", C, P.bind(this), void 0, !0)); }, !0);
                    n.request = { cancel: R };
                } function P(R, O) { return delete n.request, n.aborted ? l(null) : R && R.status !== 404 ? l(R) : (O && O.resourceTiming && (n.resourceTiming = O.resourceTiming), this.map._refreshExpiredTiles && O && n.setExpiryData(O), n.loadVectorData(O, this.map.painter), s.aK(this.dispatcher), l(null), void (n.reloadCallback && (this.loadTile(n, n.reloadCallback), n.reloadCallback = null))); } }
                abortTile(n) { n.request && (n.request.cancel(), delete n.request), n.actor && n.actor.send("abortTile", { uid: n.uid, type: this.type, source: this.id, scope: this.scope }); }
                unloadTile(n, l) { n.actor && n.actor.send("removeTile", { uid: n.uid, type: this.type, source: this.id, scope: this.scope }), n.destroy(); }
                hasTransition() { return !1; }
                afterUpdate() { this._tileWorkers = {}; }
                cancelTileJSONRequest() { this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null); }
            }
            class Ta extends s.E {
                constructor(n, l, f, _) { super(), this.id = n, this.dispatcher = f, this.setEventedParent(_), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = s.l({ type: "raster" }, l), s.l(this, s.aF(l, ["url", "scheme", "tileSize"])); }
                load(n) { this._loaded = !1, this.fire(new s.A("dataloading", { dataType: "source" })), this._tileJSONRequest = _s(this._options, this.map._requestManager, null, null, (l, f) => { this._tileJSONRequest = null, this._loaded = !0, l ? this.fire(new s.z(l)) : f && (s.l(this, f), f.raster_layers && (this.rasterLayers = f.raster_layers, this.rasterLayerIds = this.rasterLayers.map(_ => _.id)), this.tileBounds = Ji.fromTileJSON(f), Jr(f.tiles), this.fire(new s.A("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.A("data", { dataType: "source", sourceDataType: "content" }))), n && n(l); }); }
                loaded() { return this._loaded; }
                onAdd(n) { this.map = n, this.load(); }
                reload() { this.cancelTileJSONRequest(); const n = s.C(this.id, this.scope); this.load(() => this.map.style.clearSource(n)); }
                setTiles(n) { return this._options.tiles = n, this.reload(), this; }
                setUrl(n) { return this.url = n, this._options.url = n, this.reload(), this; }
                onRemove(n) { this.cancelTileJSONRequest(); }
                serialize() { return s.l({}, this._options); }
                hasTile(n) { return !this.tileBounds || this.tileBounds.contains(n.canonical); }
                loadTile(n, l) { const f = s.q.devicePixelRatio >= 2, _ = this.map._requestManager.normalizeTileURL(n.tileID.canonical.url(this.tiles, this.scheme), f, this.tileSize); n.request = s.o(this.map._requestManager.transformRequest(_, s.R.Tile), (v, w, T, C) => (delete n.request, n.aborted ? (n.state = "unloaded", l(null)) : v ? (n.state = "errored", l(v)) : w ? (this.map._refreshExpiredTiles && n.setExpiryData({ cacheControl: T, expires: C }), n.setTexture(w, this.map.painter), n.state = "loaded", s.aK(this.dispatcher), void l(null)) : l(null))); }
                abortTile(n, l) { n.request && (n.request.cancel(), delete n.request), l && l(); }
                unloadTile(n, l) { n.texture && n.texture instanceof s.T ? (n.destroy(!0), n.texture && n.texture instanceof s.T && this.map.painter.saveTileTexture(n.texture)) : n.destroy(), l && l(); }
                hasTransition() { return !1; }
                cancelTileJSONRequest() { this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null); }
            }
            class _c extends Ta {
                constructor(n, l, f, _) { super(n, l, f, _), this.type = "raster-array", this.maxzoom = 22, this.partial = !0, this._options = s.l({ type: "raster-array" }, l); }
                triggerRepaint(n) { const l = this.map.painter._terrain, f = this.map.style.getSourceCache(this.id); l && l.enabled && f && l._clearRenderCacheForTile(f.id, n.tileID), this.map.triggerRepaint(); }
                loadTile(n, l) { const f = this.map._requestManager.normalizeTileURL(n.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize), _ = this.map._requestManager.transformRequest(f, s.R.Tile), v = { request: _, uid: n.uid, tileID: n.tileID, type: this.type, source: this.id, scope: this.scope, partial: this.partial }; n.source = this.id, n.scope = this.scope, n.requestParams = _, n.actor || (n.actor = this.dispatcher.getActor()); const w = (T, C, P, R) => { if (delete n.request, n.aborted)
                    return n.state = "unloaded", l(null); if (T)
                    return T.name === "AbortError" ? void 0 : (n.state = "errored", l(T)); if (this.map._refreshExpiredTiles && C && n.setExpiryData({ cacheControl: P, expires: R }), this.partial)
                    n.state = "empty";
                else {
                    if (!C)
                        return l(null);
                    n.state = "loaded", n._isHeaderLoaded = !0, n._mrt = C;
                } l(null); }; n.request = this.partial ? n.fetchHeader(void 0, w.bind(this)) : n.actor.send("loadTile", v, w.bind(this), void 0, !0); }
                abortTile(n) { n.request && (n.request.cancel(), delete n.request), n.actor && n.actor.send("abortTile", { uid: n.uid, type: this.type, source: this.id, scope: this.scope }); }
                unloadTile(n, l) { const f = n.texture; f && f instanceof s.T ? (n.destroy(!0), this.map.painter.saveTileTexture(f)) : (n.destroy(), n.flushQueues(), n._isHeaderLoaded = !1, delete n._mrt, delete n.textureDescriptor), n.fbo && (n.fbo.destroy(), delete n.fbo), delete n.request, delete n.requestParams, delete n.neighboringTiles, n.state = "unloaded"; }
                prepareTile(n, l, f) { n._isHeaderLoaded && (n.state !== "empty" && (n.state = "reloading"), n.fetchBand(l, f, (_, v) => { if (_)
                    return n.state = "errored", this.fire(new s.z(_)), void this.triggerRepaint(n); v && (n._isHeaderLoaded = !0, n.setTexture(v, this.map.painter), n.state = "loaded", this.triggerRepaint(n)); })); }
                getInitialBand(n) { if (!this.rasterLayers)
                    return 0; const l = this.rasterLayers.find(({ id: v }) => v === n), f = l && l.fields, _ = f && f.bands && f.bands; return _ ? _[0] : 0; }
                getTextureDescriptor(n, l, f) { if (!n)
                    return; const _ = l.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0]; if (!_)
                    return; let v = null; l instanceof s.aN ? v = l.paint.get("raster-array-band") : l instanceof s.aO && (v = l.paint.get("raster-particle-array-band")); const w = v || this.getInitialBand(_); if (w != null)
                    if (n.textureDescriptor) {
                        if (!n.updateNeeded(_, w) || f)
                            return Object.assign({}, n.textureDescriptor, { texture: n.texture });
                    }
                    else
                        this.prepareTile(n, _, w); }
                getImages(n, l) { const f = new Map; for (const _ of n)
                    for (const v of l) {
                        const [w, T] = v.split("/"), C = _.getLayer(w);
                        if (!C || !C.hasBand(T) || !C.hasDataForBand(T))
                            continue;
                        const { bytes: P, tileSize: R, buffer: O } = C.getBandView(T), D = R + 2 * O, B = { data: new s.r({ width: D, height: D }, P), pixelRatio: 2, sdf: !1, usvg: !1, version: 0 };
                        f.set(v, B);
                    } return f; }
            }
            const od = { vector: hs, raster: Ta, "raster-dem": class extends Ta {
                    constructor(d, n, l, f) { super(d, n, l, f), this.type = "raster-dem", this.maxzoom = 22, this._options = s.l({ type: "raster-dem" }, n), this.encoding = n.encoding || "mapbox"; }
                    loadTile(d, n) { const l = this.map._requestManager.normalizeTileURL(d.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize); function f(_, v) { _ && (d.state = "errored", n(_)), v && (d.dem = v, d.dem.onDeserialize(), d.needsHillshadePrepare = !0, d.needsDEMTextureUpload = !0, d.state = "loaded", n(null)); } d.request = s.o(this.map._requestManager.transformRequest(l, s.R.Tile), (function (_, v, w, T) { if (delete d.request, d.aborted)
                        d.state = "unloaded", n(null);
                    else if (_)
                        d.state = "errored", n(_);
                    else if (v) {
                        this.map._refreshExpiredTiles && d.setExpiryData({ cacheControl: w, expires: T });
                        const C = ImageBitmap && v instanceof ImageBitmap && s.t(), P = 1 - (v.width - s.aL(v.width)) / 2;
                        P < 1 || d.neighboringTiles || (d.neighboringTiles = this._getNeighboringTiles(d.tileID));
                        const R = C ? v : s.q.getImageData(v, P), O = { uid: d.uid, tileID: d.tileID, source: this.id, type: this.type, scope: this.scope, rawImageData: R, encoding: this.encoding, padding: P };
                        d.actor && d.state !== "expired" || (d.actor = this.dispatcher.getActor(), d.actor.send("loadTile", O, f.bind(this), void 0, !0));
                    } }).bind(this)); }
                    _getNeighboringTiles(d) { const n = d.canonical, l = Math.pow(2, n.z), f = (n.x - 1 + l) % l, _ = n.x === 0 ? d.wrap - 1 : d.wrap, v = (n.x + 1 + l) % l, w = n.x + 1 === l ? d.wrap + 1 : d.wrap, T = {}; return T[new s.aM(d.overscaledZ, _, n.z, f, n.y).key] = { backfilled: !1 }, T[new s.aM(d.overscaledZ, w, n.z, v, n.y).key] = { backfilled: !1 }, n.y > 0 && (T[new s.aM(d.overscaledZ, _, n.z, f, n.y - 1).key] = { backfilled: !1 }, T[new s.aM(d.overscaledZ, d.wrap, n.z, n.x, n.y - 1).key] = { backfilled: !1 }, T[new s.aM(d.overscaledZ, w, n.z, v, n.y - 1).key] = { backfilled: !1 }), n.y + 1 < l && (T[new s.aM(d.overscaledZ, _, n.z, f, n.y + 1).key] = { backfilled: !1 }, T[new s.aM(d.overscaledZ, d.wrap, n.z, n.x, n.y + 1).key] = { backfilled: !1 }, T[new s.aM(d.overscaledZ, w, n.z, v, n.y + 1).key] = { backfilled: !1 }), T; }
                }, "raster-array": _c, geojson: class extends s.E {
                    constructor(d, n, l, f) { super(), this.id = d, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = l.getActor(), this.setEventedParent(f), this._data = n.data, this._options = s.l({}, n), this._collectResourceTiming = n.collectResourceTiming, n.maxzoom !== void 0 && (this.maxzoom = n.maxzoom), n.minzoom !== void 0 && (this.minzoom = n.minzoom), n.type && (this.type = n.type), n.attribution && (this.attribution = n.attribution), this.promoteId = n.promoteId; const _ = s.aj / this.tileSize; this.workerOptions = s.l({ source: this.id, scope: this.scope, cluster: n.cluster || !1, geojsonVtOptions: { buffer: (n.buffer !== void 0 ? n.buffer : 128) * _, tolerance: (n.tolerance !== void 0 ? n.tolerance : .375) * _, extent: s.aj, maxZoom: this.maxzoom, lineMetrics: n.lineMetrics || !1, generateId: n.generateId || !1 }, superclusterOptions: { maxZoom: n.clusterMaxZoom !== void 0 ? n.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, n.clusterMinPoints || 2), extent: s.aj, radius: (n.clusterRadius !== void 0 ? n.clusterRadius : 50) * _, log: !1, generateId: n.generateId || !1 }, clusterProperties: n.clusterProperties, filter: n.filter, dynamic: n.dynamic }, n.workerOptions); }
                    onAdd(d) { this.map = d, this.setData(this._data); }
                    setData(d) { return this._data = d, this._updateWorkerData(), this; }
                    updateData(d) { if (!this._options.dynamic)
                        return this.fire(new s.z(new Error("Can't call updateData on a GeoJSON source with dynamic set to false."))); if (typeof d != "string" && (d.type === "Feature" && (d = { type: "FeatureCollection", features: [d] }), d.type !== "FeatureCollection"))
                        return this.fire(new s.z(new Error("Data to update should be a feature or a feature collection."))); if (this._coalesce && typeof d != "string" && typeof this._data != "string" && this._data.type === "FeatureCollection") {
                        const n = new Map;
                        for (const l of this._data.features)
                            n.set(l.id, l);
                        for (const l of d.features)
                            n.set(l.id, l);
                        this._data.features = [...n.values()];
                    }
                    else
                        this._data = d; return this._updateWorkerData(!0), this; }
                    getClusterExpansionZoom(d, n) { return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: d, source: this.id, scope: this.scope }, n), this; }
                    getClusterChildren(d, n) { return this.actor.send("geojson.getClusterChildren", { clusterId: d, source: this.id, scope: this.scope }, n), this; }
                    getClusterLeaves(d, n, l, f) { return this.actor.send("geojson.getClusterLeaves", { source: this.id, scope: this.scope, clusterId: d, limit: n, offset: l }, f), this; }
                    _updateWorkerData(d = !1) { if (this._pendingLoad)
                        return void (this._coalesce = !0); this.fire(new s.A("dataloading", { dataType: "source" })), this._loaded = !1; const n = s.l({ append: d }, this.workerOptions); n.scope = this.scope; const l = this._data; typeof l == "string" ? (n.request = this.map._requestManager.transformRequest(s.q.resolveURL(l), s.R.Source), n.request.collectResourceTiming = this._collectResourceTiming) : n.data = JSON.stringify(l), this._pendingLoad = this.actor.send(`${this.type}.loadData`, n, (f, _) => { if (this._loaded = !0, this._pendingLoad = null, f)
                        this.fire(new s.z(f));
                    else {
                        const v = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
                        this._collectResourceTiming && _ && _.resourceTiming && _.resourceTiming[this.id] && (v.resourceTiming = _.resourceTiming[this.id]), d && (this._partialReload = !0), this.fire(new s.A("data", v)), this._partialReload = !1, this._metadataFired = !0;
                    } this._coalesce && (this._updateWorkerData(d), this._coalesce = !1); }); }
                    loaded() { return this._loaded; }
                    reload() { const d = s.C(this.id, this.scope); this.map.style.clearSource(d), this._updateWorkerData(); }
                    loadTile(d, n) { const l = d.actor ? "reloadTile" : "loadTile"; d.actor = this.actor; const f = this.map.style ? this.map.style.getLut(this.scope) : null, _ = f ? { image: f.image.clone() } : null, v = this._partialReload, w = { type: this.type, uid: d.uid, tileID: d.tileID, tileZoom: d.tileZoom, zoom: d.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, lut: _, scope: this.scope, pixelRatio: s.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: d.isExtraShadowCaster, scaleFactor: this.map.getScaleFactor(), partial: v }; d.request = this.actor.send(l, w, (T, C) => v && !C ? (d.state = "loaded", n(null)) : (delete d.request, d.destroy(), d.aborted ? n(null) : T ? n(T) : (d.loadVectorData(C, this.map.painter, l === "reloadTile"), n(null))), void 0, l === "loadTile"); }
                    abortTile(d) { d.request && (d.request.cancel(), delete d.request), d.aborted = !0; }
                    unloadTile(d, n) { this.actor.send("removeTile", { uid: d.uid, type: this.type, source: this.id, scope: this.scope }), d.destroy(); }
                    onRemove(d) { this._pendingLoad && this._pendingLoad.cancel(); }
                    serialize() { return s.l({}, this._options, { type: this.type, data: this._data }); }
                    hasTransition() { return !1; }
                }, video: class extends s.aP {
                    constructor(d, n, l, f) { super(d, n, l, f), this.roundZoom = !0, this.type = "video", this.options = n; }
                    load() { this._loaded = !1; const d = this.options; this.urls = []; for (const n of d.urls)
                        this.urls.push(this.map._requestManager.transformRequest(n, s.R.Source).url); s.aQ(this.urls, (n, l) => { this._loaded = !0, n ? this.fire(new s.z(n)) : l && (this.video = l, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => { this.map.triggerRepaint(); }), this.map && this.video.play(), this._finishLoading()); }); }
                    pause() { this.video && this.video.pause(); }
                    play() { this.video && this.video.play(); }
                    seek(d) { if (this.video) {
                        const n = this.video.seekable;
                        d < n.start(0) || d > n.end(0) ? this.fire(new s.z(new s.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${n.start(0)} and ${n.end(0)}-second mark.`))) : this.video.currentTime = d;
                    } }
                    getVideo() { return this.video; }
                    onAdd(d) { this.map || (this.map = d, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates))); }
                    prepare() { if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
                        return; const d = this.map.painter.context, n = d.gl; this.texture ? this.video.paused || (this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, n.RGBA, n.UNSIGNED_BYTE, this.video)) : (this.texture = new s.T(d, this.video, n.RGBA8), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(d); }
                    serialize() { return { type: "video", urls: this.urls, coordinates: this.coordinates }; }
                    hasTransition() { return this.video && !this.video.paused; }
                }, image: s.aP, model: class extends s.E {
                    constructor(d, n, l, f) { super(), this.id = d, this.type = "model", this.models = [], this._loaded = !1, this._options = n; }
                    load() { const d = []; for (const n in this._options.models) {
                        const l = this._options.models[n], f = s.aS(this.map._requestManager.transformRequest(l.uri, s.R.Model).url).then(_ => { if (!_)
                            return; const v = s.aT(_), w = new s.aU(n, l.position, l.orientation, v); w.computeBoundsAndApplyParent(), this.models.push(w); }).catch(_ => { this.fire(new s.z(new Error(`Could not load model ${n} from ${l.uri}: ${_.message}`))); });
                        d.push(f);
                    } Promise.allSettled(d).then(() => { this._loaded = !0, this.fire(new s.A("data", { dataType: "source", sourceDataType: "metadata" })); }).catch(n => { this._loaded = !0, this.fire(new s.z(new Error(`Could not load models: ${n.message}`))); }); }
                    onAdd(d) { this.map = d, this.load(); }
                    hasTransition() { return !1; }
                    loaded() { return this._loaded; }
                    getModels() { return this.models; }
                    loadTile(d, n) { }
                    serialize() { return this._options; }
                }, "batched-model": class extends s.E {
                    constructor(d, n, l, f) { super(), this.type = "batched-model", this.id = d, this.tileSize = 512, this._options = n, this.tiles = this._options.tiles, this.maxzoom = n.maxzoom || 19, this.minzoom = n.minzoom || 0, this.roundZoom = !0, this.usedInConflation = !0, this.dispatcher = l, this.reparseOverscaled = !1, this.scheme = "xyz", this._loaded = !1, this.setEventedParent(f); }
                    onAdd(d) { this.map = d, this.load(); }
                    reload() { this.cancelTileJSONRequest(); const d = s.C(this.id, this.scope); this.load(() => this.map.style.clearSource(d)); }
                    cancelTileJSONRequest() { this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null); }
                    load(d) { this._loaded = !1, this.fire(new s.A("dataloading", { dataType: "source" })); const n = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, l = this.map.getWorldview(); this._tileJSONRequest = _s(this._options, this.map._requestManager, n, l, (f, _) => { this._tileJSONRequest = null, this._loaded = !0, f ? (n && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${n}`), l && l.length !== 2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${l}`), this.fire(new s.z(f))) : _ && (s.l(this, _), _.bounds && (this.tileBounds = new Ji(_.bounds, this.minzoom, this.maxzoom)), Jr(_.tiles, this.map._requestManager._customAccessToken), this.fire(new s.A("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.A("data", { dataType: "source", sourceDataType: "content" }))), d && d(f); }); }
                    hasTransition() { return !1; }
                    hasTile(d) { return !this.tileBounds || this.tileBounds.contains(d.canonical); }
                    loaded() { return this._loaded; }
                    loadTile(d, n) { const l = this.map._requestManager.normalizeTileURL(d.tileID.canonical.url(this.tiles, this.scheme)), f = { request: this.map._requestManager.transformRequest(l, s.R.Tile), data: void 0, uid: d.uid, tileID: d.tileID, tileZoom: d.tileZoom, zoom: d.tileID.overscaledZ, tileSize: this.tileSize * d.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: d.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, pixelRatio: s.q.devicePixelRatio, promoteId: this.promoteId }; if (d.actor && d.state !== "expired")
                        if (d.state === "loading")
                            d.reloadCallback = n;
                        else {
                            if (d.buckets) {
                                const v = Object.values(d.buckets);
                                for (const w of v)
                                    w.dirty = !0;
                                return void (d.state = "loaded");
                            }
                            d.request = d.actor.send("reloadTile", f, _.bind(this));
                        }
                    else
                        d.actor = this.dispatcher.getActor(), d.request = d.actor.send("loadTile", f, _.bind(this), void 0, !0); function _(v, w) { return d.aborted ? n(null) : v && v.status !== 404 ? n(v) : (this.map._refreshExpiredTiles && w && d.setExpiryData(w), d.loadModelData(w, this.map.painter), d.state = "loaded", void n(null)); } }
                    serialize() { return s.l({}, this._options); }
                }, canvas: class extends s.aP {
                    constructor(d, n, l, f) { super(d, n, l, f), n.coordinates ? Array.isArray(n.coordinates) && n.coordinates.length === 4 && !n.coordinates.some(_ => !Array.isArray(_) || _.length !== 2 || _.some(v => typeof v != "number")) || this.fire(new s.z(new s.V(`sources.${d}`, null, "\"coordinates\" property must be an array of 4 longitude/latitude array pairs"))) : this.fire(new s.z(new s.V(`sources.${d}`, null, "missing required property \"coordinates\""))), n.animate && typeof n.animate != "boolean" && this.fire(new s.z(new s.V(`sources.${d}`, null, "optional \"animate\" property must be a boolean value"))), n.canvas ? typeof n.canvas == "string" || n.canvas instanceof HTMLCanvasElement || this.fire(new s.z(new s.V(`sources.${d}`, null, "\"canvas\" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance"))) : this.fire(new s.z(new s.V(`sources.${d}`, null, "missing required property \"canvas\""))), this.options = n, this.animate = n.animate === void 0 || n.animate; }
                    load() { this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new s.z(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () { this._playing = !0, this.map.triggerRepaint(); }, this.pause = function () { this._playing && (this.prepare(), this._playing = !1); }, this._finishLoading()); }
                    getCanvas() { return this.canvas; }
                    onAdd(d) { this.map = d, this.load(), this.canvas && this.animate && this.play(); }
                    onRemove(d) { this.pause(); }
                    prepare() { let d = !1; if (this.canvas.width !== this.width && (this.width = this.canvas.width, d = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, d = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0)
                        return; const n = this.map.painter.context; this.texture ? !d && !this._playing || this.texture instanceof s.aR || this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new s.T(n, this.canvas, n.gl.RGBA8, { premultiply: !0 }), this._prepareData(n); }
                    serialize() { return { type: "canvas", coordinates: this.coordinates }; }
                    hasTransition() { return this._playing; }
                    _hasInvalidDimensions() { for (const d of [this.canvas.width, this.canvas.height])
                        if (isNaN(d) || d <= 0)
                            return !0; return !1; }
                }, custom: class extends s.E {
                    constructor(d, n, l, f) { super(), this.id = d, this.type = "custom", this._dataType = "raster", this._dispatcher = l, this._implementation = n, this.setEventedParent(f), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new s.z(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new s.z(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new Ji(this._implementation.bounds, this.minzoom, this.maxzoom)), n.update = this._update.bind(this), n.clearTiles = this._clearTiles.bind(this), n.coveringTiles = this._coveringTiles.bind(this), s.l(this, s.aF(n, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"])); }
                    serialize() { return s.aF(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]); }
                    load() { this._loaded = !0, this.fire(new s.A("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.A("data", { dataType: "source", sourceDataType: "content" })); }
                    loaded() { return this._loaded; }
                    onAdd(d) { this.map = d, this._loaded = !1, this.fire(new s.A("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(d), this.load(); }
                    onRemove(d) { this._implementation.onRemove && this._implementation.onRemove(d); }
                    hasTile(d) { if (this._implementation.hasTile) {
                        const { x: n, y: l, z: f } = d.canonical;
                        return this._implementation.hasTile({ x: n, y: l, z: f });
                    } return !this.tileBounds || this.tileBounds.contains(d.canonical); }
                    loadTile(d, n) { const { x: l, y: f, z: _ } = d.tileID.canonical, v = new AbortController; d.request = Promise.resolve(this._implementation.loadTile({ x: l, y: f, z: _ }, { signal: v.signal })).then((function (w) { return delete d.request, d.aborted ? (d.state = "unloaded", n(null)) : w === void 0 ? (d.state = "errored", n(null)) : w === null ? (this.loadTileData(d, { width: this.tileSize, height: this.tileSize, data: null }), d.state = "loaded", n(null)) : function (T) { return T instanceof ImageData || T instanceof HTMLCanvasElement || T instanceof ImageBitmap || T instanceof HTMLImageElement; }(w) ? (this.loadTileData(d, w), d.state = "loaded", void n(null)) : (d.state = "errored", n(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`))); }).bind(this)).catch(w => { w.name !== "AbortError" && (d.state = "errored", n(w)); }), d.request.cancel = () => v.abort(); }
                    loadTileData(d, n) { d.setTexture(n, this.map.painter); }
                    unloadTile(d, n) { if (d.texture && d.texture instanceof s.T ? (d.destroy(!0), d.texture && d.texture instanceof s.T && this.map.painter.saveTileTexture(d.texture)) : d.destroy(), this._implementation.unloadTile) {
                        const { x: l, y: f, z: _ } = d.tileID.canonical;
                        this._implementation.unloadTile({ x: l, y: f, z: _ });
                    } n && n(); }
                    abortTile(d, n) { d.request && d.request.cancel && (d.request.cancel(), delete d.request), n && n(); }
                    hasTransition() { return !1; }
                    _coveringTiles() { return this.map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map(d => ({ x: d.canonical.x, y: d.canonical.y, z: d.canonical.z })); }
                    _clearTiles() { const d = s.C(this.id, this.scope); this.map.style.clearSource(d); }
                    _update() { this.fire(new s.A("data", { dataType: "source", sourceDataType: "content" })); }
                } }, mu = function (d, n, l, f) { const _ = new od[n.type](d, n, l, f); if (_.id !== d)
                throw new Error(`Expected Source id to be ${d} instead of ${_.id}`); return s.aV(["load", "abort", "unload", "serialize", "prepare"], _), _; };
            function Hf(d, n, l = "") { return `${l}:${n.id || ""}:${n.layer.id}:${function (f) { if ("layerId" in f)
                return `layer:${f.layerId}`; {
                const { featuresetId: _, importId: v } = f;
                return `featureset:${_}${v ? `:import:${v}` : ""}`;
            } }(d.target)}`; }
            function ad(d, n, l, f = "") { if (d.uniqueFeatureID) {
                const _ = Hf(d, n, f);
                if (l.has(_))
                    return !0;
                l.add(_);
            } return !1; }
            function yc(d, n, l, f, _ = !1) { const v = n.sourceCache.transform, w = n.sourceCache.tilesIn(d, n.has3DLayers, _); w.sort(Yo); const T = []; for (const C of w) {
                const P = C.tile.queryRenderedFeatures(n, C, l, f, v, _);
                Object.keys(P).length && T.push({ wrappedTileID: C.tile.tileID.wrapped().key, queryResults: P });
            } return T.length === 0 ? {} : function (C) { const P = {}, R = {}; for (const O of C) {
                const D = O.queryResults, B = O.wrappedTileID, q = R[B] = R[B] || {};
                for (const G in D) {
                    const K = D[G], W = q[G] = q[G] || {}, oe = P[G] = P[G] || [];
                    for (const de of K)
                        W[de.featureIndex] || (W[de.featureIndex] = !0, oe.push(de));
                }
            } return P; }(T); }
            function ld(d, n, l, f, _) { const v = {}, w = f.queryRenderedSymbols(d), T = []; for (const C of Object.keys(w).map(Number))
                T.push(_[C]); T.sort(Yo); for (const C of T) {
                const P = C.featureIndex.lookupSymbolFeatures(w[C.bucketInstanceId], C.bucketIndex, C.sourceLayerIndex, n, l);
                for (const R in P) {
                    const O = v[R] = v[R] || [], D = P[R];
                    D.sort((B, q) => { const G = C.featureSortOrder; if (G) {
                        const K = G.indexOf(B.featureIndex);
                        return G.indexOf(q.featureIndex) - K;
                    } return q.featureIndex - B.featureIndex; });
                    for (const B of D)
                        O.push(B);
                }
            } return v; }
            function kg(d, n) { const l = d.getRenderableIds().map(v => d.getTileByID(v)), f = [], _ = {}; for (let v = 0; v < l.length; v++) {
                const w = l[v], T = w.tileID.canonical.key;
                _[T] || (_[T] = !0, w.querySourceFeatures(f, n));
            } return f; }
            function Yo(d, n) { const l = d.tileID, f = n.tileID; return l.overscaledZ - f.overscaledZ || l.canonical.y - f.canonical.y || l.wrap - f.wrap || l.canonical.x - f.canonical.x; }
            function Dg(d, n) { const l = {}; if (!n)
                return l; for (const f of d) {
                const _ = f.layerIds.map(v => n.getLayer(v)).filter(Boolean);
                if (_.length !== 0) {
                    f.layers = _, f.stateDependentLayerIds && (f.stateDependentLayers = f.stateDependentLayerIds.map(v => _.filter(w => w.id === v)[0]));
                    for (const v of _)
                        l[v.fqid] = f;
                }
            } return l; }
            const Qs = 32, Qo = 33, Wa = new Uint16Array(8184);
            for (let d = 0; d < 2046; d++) {
                let n = d + 2, l = 0, f = 0, _ = 0, v = 0, w = 0, T = 0;
                for (1 & n ? _ = v = w = Qs : l = f = T = Qs; (n >>= 1) > 1;) {
                    const P = l + _ >> 1, R = f + v >> 1;
                    1 & n ? (_ = l, v = f, l = w, f = T) : (l = _, f = v, _ = w, v = T), w = P, T = R;
                }
                const C = 4 * d;
                Wa[C + 0] = l, Wa[C + 1] = f, Wa[C + 2] = _, Wa[C + 3] = v;
            }
            const Jo = new Uint16Array(2178), Za = new Uint8Array(1089), ko = new Uint16Array(1089);
            function cd(d) { return d === 0 ? -.03125 : d === 32 ? .03125 : 0; }
            const Lg = { type: 2, extent: s.aj, loadGeometry: () => [[new s.P(0, 0), new s.P(s.aj + 1, 0), new s.P(s.aj + 1, s.aj + 1), new s.P(0, s.aj + 1), new s.P(0, 0)]] };
            class Xa {
                constructor(n, l, f, _, v) { this.tileID = n, this.uid = s.a$(), this.uses = 0, this.tileSize = l, this.tileZoom = f, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = v, _ && _.style && (this._lastUpdatedBrightness = _.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", _ && _.transform && (this.projection = _.transform.projection); }
                registerFadeDuration(n) { const l = n + this.timeAdded; l < s.q.now() || this.fadeEndTime && l < this.fadeEndTime || (this.fadeEndTime = l); }
                wasRequested() { return this.state === "errored" || this.state === "loaded" || this.state === "reloading"; }
                get tileTransform() { return this._tileTransform || (this._tileTransform = s.aW(this.tileID.canonical, this.projection)), this._tileTransform; }
                loadVectorData(n, l, f) { if (this.unloadVectorData(), this.state = "loaded", n) {
                    n.featureIndex && (this.latestFeatureIndex = n.featureIndex, n.rawTileData ? (this.latestRawTileData = n.rawTileData, this.latestFeatureIndex.rawTileData = n.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = n.collisionBoxArray, this.buckets = Dg(n.buckets, l.style), this.hasSymbolBuckets = !1;
                    for (const _ in this.buckets) {
                        const v = this.buckets[_];
                        if (v instanceof s.b1) {
                            if (this.hasSymbolBuckets = !0, !f)
                                break;
                            v.justReloaded = !0;
                        }
                    }
                    if (this.hasRTLText = !1, this.hasSymbolBuckets)
                        for (const _ in this.buckets) {
                            const v = this.buckets[_];
                            if (v instanceof s.b1 && v.hasRTLText) {
                                this.hasRTLText = !0, s.b2();
                                break;
                            }
                        }
                    this.queryPadding = 0;
                    for (const _ in this.buckets) {
                        const v = this.buckets[_], w = l.style.getOwnLayer(_);
                        if (!w)
                            continue;
                        const T = w.queryRadius(v);
                        this.queryPadding = Math.max(this.queryPadding, T);
                    }
                    n.imageAtlas && (this.imageAtlas = n.imageAtlas), n.glyphAtlasImage && (this.glyphAtlasImage = n.glyphAtlasImage), n.lineAtlas && (this.lineAtlas = n.lineAtlas), this._lastUpdatedBrightness = n.brightness;
                }
                else
                    this.collisionBoxArray = new s.b0; }
                unloadVectorData() { if (this.hasData()) {
                    for (const n in this.buckets)
                        this.buckets[n].destroy();
                    this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
                } }
                loadModelData(n, l, f) { n && (n.resourceTiming && (this.resourceTiming = n.resourceTiming), this.buckets = Object.assign({}, this.buckets, Dg(n.buckets, l.style)), n.featureIndex && (this.latestFeatureIndex = n.featureIndex)); }
                getBucket(n) { return this.buckets[n.fqid]; }
                upload(n) { for (const _ in this.buckets) {
                    const v = this.buckets[_];
                    v.uploadPending() && v.upload(n);
                } const l = n.gl, f = this.imageAtlas; f && !f.uploaded && (this.imageAtlasTexture = new s.T(n, f.image, l.RGBA8, { useMipmap: !!f.patternPositions.size }), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new s.T(n, this.glyphAtlasImage, l.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new s.T(n, this.lineAtlas.image, l.R8), this.lineAtlas.uploaded = !0); }
                prepare(n, l, f) { if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(n, this.imageAtlasTexture, f), !l || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData)
                    return; const _ = l.style.getBrightness(); (this._lastUpdatedBrightness || _) && (this._lastUpdatedBrightness && _ && Math.abs(this._lastUpdatedBrightness - _) < .001 || (this.updateBuckets(l, this._lastUpdatedBrightness !== _), this._lastUpdatedBrightness = _)); }
                queryRenderedFeatures(n, l, f, _, v, w) { if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile)
                    return {}; const T = function (C, P) { const R = s.bn([], [.5 * C.width, .5 * -C.height, 1]); return s.bo(R, R, [1, -1, 0]), s.az(R, R, C.calculateProjMatrix(P.toUnwrapped())), Float32Array.from(R); }(v, this.tileID); return this.latestFeatureIndex.query(n, { tilespaceGeometry: l, pixelPosMatrix: T, transform: _, availableImages: f, tileTransform: this.tileTransform }); }
                querySourceFeatures(n, l) { const f = this.latestFeatureIndex; if (!f || !f.rawTileData)
                    return; const _ = f.loadVTLayers(), v = l ? l.sourceLayer : "", w = _._geojsonTileLayer || _[v]; if (!w)
                    return; const T = s.b3(l && l.filter), { z: C, x: P, y: R } = this.tileID.canonical, O = { z: C, x: P, y: R }; for (let D = 0; D < w.length; D++) {
                    const B = w.feature(D);
                    if (T.needGeometry) {
                        const K = s.b4(B, !0);
                        if (!T.filter(new s.aa(this.tileID.overscaledZ), K, this.tileID.canonical))
                            continue;
                    }
                    else if (!T.filter(new s.aa(this.tileID.overscaledZ), B))
                        continue;
                    const q = f.getId(B, v), G = new s.b5(B, C, P, R, q);
                    G.tile = O, n.push(G);
                } }
                loaded() { return this.state === "loaded" || this.state === "errored"; }
                hasData() { return this.state === "loaded" || this.state === "reloading" || this.state === "expired"; }
                patternsLoaded() { return !!this.imageAtlas && !!this.imageAtlas.patternPositions.size; }
                setExpiryData(n) { const l = this.expirationTime; if (n.cacheControl) {
                    const f = s.b6(n.cacheControl);
                    f["max-age"] && (this.expirationTime = Date.now() + 1e3 * f["max-age"]);
                }
                else
                    n.expires && (this.expirationTime = new Date(n.expires).getTime()); if (this.expirationTime) {
                    const f = Date.now();
                    let _ = !1;
                    if (this.expirationTime > f)
                        _ = !1;
                    else if (l)
                        if (this.expirationTime < l)
                            _ = !0;
                        else {
                            const v = this.expirationTime - l;
                            v ? this.expirationTime = f + Math.max(v, 3e4) : _ = !0;
                        }
                    else
                        _ = !0;
                    _ ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
                } }
                getExpiryTimeout() { if (this.expirationTime)
                    return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1); }
                refreshFeatureState(n) { this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && n && this.updateBuckets(n); }
                updateBuckets(n, l) { if (!this.latestFeatureIndex || !n.style)
                    return; const f = this.latestFeatureIndex.loadVTLayers(), _ = n.style.listImages(), v = n.style.getBrightness(); for (const w in this.buckets) {
                    if (!n.style.hasLayer(w))
                        continue;
                    const T = this.buckets[w], C = T.layers[0], P = C.sourceLayer || "_geojsonTileLayer", R = f[P], O = n.style.getLayerSourceCache(C);
                    let D = {};
                    O && (D = O._state.getState(P, void 0));
                    const B = this.imageAtlas ? Object.fromEntries(this.imageAtlas.patternPositions) : {}, q = Object.keys(D).length > 0 && !l;
                    q && !T.stateDependentLayers.length && !l || T.update(D, R, _, B, q ? T.stateDependentLayers : T.layers, l, v), (T instanceof s.b7 || T instanceof s.b8) && n._terrain && n._terrain.enabled && O && T.uploadPending() && n._terrain._clearRenderCacheForTile(O.id, this.tileID);
                    const G = n && n.style && n.style.getOwnLayer(w);
                    G && (this.queryPadding = Math.max(this.queryPadding, G.queryRadius(T)));
                } }
                holdingForFade() { return this.symbolFadeHoldUntil !== void 0; }
                symbolFadeFinished() { return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < s.q.now(); }
                clearFadeHold() { this.symbolFadeHoldUntil = void 0; }
                setHoldDuration(n) { this.symbolFadeHoldUntil = s.q.now() + n; }
                setTexture(n, l) { const f = l.context, _ = f.gl; this.texture = this.texture || l.getTileTexture(n.width), this.texture && this.texture instanceof s.T ? this.texture.update(n) : (this.texture = new s.T(f, n, _.RGBA8, { useMipmap: !0 }), this.texture.bind(_.LINEAR, _.CLAMP_TO_EDGE)); }
                setDependencies(n, l) { const f = {}; for (const _ of l)
                    f[_] = !0; this.dependencies[n] = f; }
                hasDependency(n, l) { for (const f of n) {
                    const _ = this.dependencies[f];
                    if (_) {
                        for (const v of l)
                            if (_[v])
                                return !0;
                    }
                } return !1; }
                clearQueryDebugViz() { }
                _makeDebugTileBoundsBuffers(n, l) { if (!l || l.name === "mercator" || this._tileDebugBuffer)
                    return; const f = s.b9(Lg, this.tileID.canonical, this.tileTransform)[0], _ = new s.ba, v = new s.bb; for (let w = 0; w < f.length; w++) {
                    const { x: T, y: C } = f[w];
                    _.emplaceBack(T, C), v.emplaceBack(w);
                } v.emplaceBack(0), this._tileDebugIndexBuffer = n.createIndexBuffer(v), this._tileDebugBuffer = n.createVertexBuffer(_, s.bc.members), this._tileDebugSegments = s.bd.simpleSegment(0, 0, _.length, v.length); }
                _makeTileBoundsBuffers(n, l) { if (this._tileBoundsBuffer || !l || l.name === "mercator")
                    return; const f = s.b9(Lg, this.tileID.canonical, this.tileTransform)[0]; let _, v; if (this.isRaster) {
                    const w = function (T, C) { const P = s.aW(T, C), R = Math.pow(2, T.z); for (let K = 0; K < Qo; K++)
                        for (let W = 0; W < Qo; W++) {
                            const oe = s.aX((T.x + (W + cd(W)) / Qs) / R), de = s.aY((T.y + (K + cd(K)) / Qs) / R), me = C.project(oe, de), we = K * Qo + W;
                            Jo[2 * we + 0] = Math.round((me.x * P.scale - P.x) * s.aj), Jo[2 * we + 1] = Math.round((me.y * P.scale - P.y) * s.aj);
                        } Za.fill(0), ko.fill(0); for (let K = 2045; K >= 0; K--) {
                        const W = 4 * K, oe = Wa[W + 0], de = Wa[W + 1], me = Wa[W + 2], we = Wa[W + 3], ve = oe + me >> 1, xe = de + we >> 1, ge = ve + xe - de, Se = xe + oe - ve, Ce = de * Qo + oe, je = we * Qo + me, ze = xe * Qo + ve, rt = Math.hypot((Jo[2 * Ce + 0] + Jo[2 * je + 0]) / 2 - Jo[2 * ze + 0], (Jo[2 * Ce + 1] + Jo[2 * je + 1]) / 2 - Jo[2 * ze + 1]) >= 16;
                        Za[ze] = Za[ze] || (rt ? 1 : 0), K < 1022 && (Za[ze] = Za[ze] || Za[(de + Se >> 1) * Qo + (oe + ge >> 1)] || Za[(we + Se >> 1) * Qo + (me + ge >> 1)]);
                    } const O = new s.aZ, D = new s.a_; let B = 0; function q(K, W) { const oe = W * Qo + K; return ko[oe] === 0 && (O.emplaceBack(Jo[2 * oe + 0], Jo[2 * oe + 1], K * s.aj / Qs, W * s.aj / Qs), ko[oe] = ++B), ko[oe] - 1; } function G(K, W, oe, de, me, we) { const ve = K + oe >> 1, xe = W + de >> 1; if (Math.abs(K - me) + Math.abs(W - we) > 1 && Za[xe * Qo + ve])
                        G(me, we, K, W, ve, xe), G(oe, de, me, we, ve, xe);
                    else {
                        const ge = q(K, W), Se = q(oe, de), Ce = q(me, we);
                        D.emplaceBack(ge, Se, Ce);
                    } } return G(0, 0, Qs, Qs, Qs, 0), G(Qs, Qs, 0, 0, 0, Qs), { vertices: O, indices: D }; }(this.tileID.canonical, l);
                    _ = w.vertices, v = w.indices;
                }
                else {
                    _ = new s.aZ, v = new s.a_;
                    for (const { x: T, y: C } of f)
                        _.emplaceBack(T, C, 0, 0);
                    const w = s.be(_.int16.subarray(0, 4 * _.length), void 0, 4);
                    for (let T = 0; T < w.length; T += 3)
                        v.emplaceBack(w[T], w[T + 1], w[T + 2]);
                } this._tileBoundsBuffer = n.createVertexBuffer(_, s.bf.members), this._tileBoundsIndexBuffer = n.createIndexBuffer(v), this._tileBoundsSegments = s.bd.simpleSegment(0, 0, _.length, v.length); }
                _makeGlobeTileDebugBuffers(n, l) { const f = l.projection; if (!f || f.name !== "globe" || l.freezeTileCoverage)
                    return; const _ = this.tileID.canonical, v = s.bg(_, l), w = s.bh(v), T = s.ah(l.zoom); let C; T > 0 && (C = s.bi(new Float64Array(16), l.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(n, _, l, w, C, T), this._makeGlobeTileDebugTextBuffer(n, _, l, w, C, T); }
                _globePoint(n, l, f, _, v, w, T) { let C = s.bj(n, l, f); if (w) {
                    const P = 1 << f.z, R = s.ay(_.center.lng), O = s.aH(_.center.lat), D = (f.x + .5) / P - R;
                    let B = 0;
                    D > .5 ? B = -1 : D < -.5 && (B = 1);
                    let q = (n / s.aj + f.x) / P + B, G = (l / s.aj + f.y) / P;
                    q = (q - R) * _._pixelsPerMercatorPixel + R, G = (G - O) * _._pixelsPerMercatorPixel + O;
                    const K = [q * _.worldSize, G * _.worldSize, 0];
                    s.ad(K, K, w), C = s.bk(C, K, T);
                } return s.ad(C, C, v); }
                _makeGlobeTileDebugBorderBuffer(n, l, f, _, v, w) { const T = new s.ba, C = new s.bb, P = new s.bl, R = (D, B, q, G, K) => { const W = (q - D) / (K - 1), oe = (G - B) / (K - 1), de = T.length; for (let me = 0; me < K; me++) {
                    const we = D + me * W, ve = B + me * oe;
                    T.emplaceBack(we, ve);
                    const xe = this._globePoint(we, ve, l, f, _, v, w);
                    P.emplaceBack(xe[0], xe[1], xe[2]), C.emplaceBack(de + me);
                } }, O = s.aj; R(0, 0, O, 0, 16), R(O, 0, O, O, 16), R(O, O, 0, O, 16), R(0, O, 0, 0, 16), this._tileDebugIndexBuffer = n.createIndexBuffer(C), this._tileDebugBuffer = n.createVertexBuffer(T, s.bc.members), this._globeTileDebugBorderBuffer = n.createVertexBuffer(P, s.bm.members), this._tileDebugSegments = s.bd.simpleSegment(0, 0, T.length, C.length); }
                _makeGlobeTileDebugTextBuffer(n, l, f, _, v, w) { const T = s.aj / 4, C = new s.ba, P = new s.a_, R = new s.bl, O = 25; P.reserve(32), C.reserve(O), R.reserve(O); const D = (B, q) => O * B + q; for (let B = 0; B < O; B++) {
                    const q = B * T;
                    for (let G = 0; G < O; G++) {
                        const K = G * T;
                        C.emplaceBack(K, q);
                        const W = this._globePoint(K, q, l, f, _, v, w);
                        R.emplaceBack(W[0], W[1], W[2]);
                    }
                } for (let B = 0; B < 4; B++)
                    for (let q = 0; q < 4; q++) {
                        const G = D(B, q), K = D(B, q + 1), W = D(B + 1, q), oe = D(B + 1, q + 1);
                        P.emplaceBack(G, K, W), P.emplaceBack(W, K, oe);
                    } this._tileDebugTextIndexBuffer = n.createIndexBuffer(P), this._tileDebugTextBuffer = n.createVertexBuffer(C, s.bc.members), this._globeTileDebugTextBuffer = n.createVertexBuffer(R, s.bm.members), this._tileDebugTextSegments = s.bd.simpleSegment(0, 0, O, 32); }
                destroy(n = !1) { for (const l in this.buckets)
                    this.buckets[l].destroy(); this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !n && this.texture && this.texture instanceof s.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded"; }
            }
            s.bp.setPbf(s.bq);
            class ud extends Xa {
                constructor(n, l, f, _, v) { super(n, l, f, _, v), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = !1; }
                getLayers() { return this._mrt ? Object.values(this._mrt.layers) : []; }
                getLayer(n) { return this._mrt && this._mrt.getLayer(n); }
                setTexture(n, l) { const f = l.context, _ = f.gl; this.texture = this.texture || l.getTileTexture(n.width), this.texture && this.texture instanceof s.T ? this.texture.update(n, { premultiply: !1 }) : this.texture = new s.T(f, n, _.RGBA8, { premultiply: !1 }); }
                flushQueues() { for (; this._workQueue.length;)
                    this._workQueue.pop()(); for (; this._fetchQueue.length;)
                    this._fetchQueue.pop()(); }
                fetchHeader(n = 16384, l) { const f = this._mrt = new s.bp(30), _ = Object.assign({}, this.requestParams, { headers: { Range: "bytes=0-" + (n - 1) } }); return this.entireBuffer = null, this.request = s.br(_, (v, w, T, C) => { if (v)
                    l(v);
                else
                    try {
                        const P = f.getHeaderLength(w);
                        if (P > n)
                            return void (this.request = this.fetchHeader(P, l));
                        f.parseHeader(w), this._isHeaderLoaded = !0;
                        let R = 0;
                        for (const O of Object.values(f.layers))
                            R = Math.max(R, O.dataIndex[O.dataIndex.length - 1].lastByte);
                        w.byteLength >= R && (this.entireBuffer = w), l(null, this.entireBuffer || w, T, C);
                    }
                    catch (P) {
                        l(P);
                    } }), this.request; }
                fetchBand(n, l, f) { const _ = this._mrt; if (!this._isHeaderLoaded || !_)
                    return void f(new Error("Tile header is not ready")); const v = this.actor; if (!v)
                    return void f(new Error("Can't fetch tile band without an actor")); let w; const T = (O, D) => { w.complete(O, D), O ? f(O) : (this.updateTextureDescriptor(n, l), f(null, this.textureDescriptor && this.textureDescriptor.img)); }, C = (O, D) => { if (O)
                    return f(O); const B = v.send("decodeRasterArray", { type: "raster-array", source: this.source, scope: this.scope, tileID: this.tileID, uid: this.uid, buffer: D, task: w }, T, void 0, !0); this._workQueue.push(() => { B && B.cancel(), w.cancel(); }); }, P = _.getLayer(n); if (!P)
                    return void f(new Error(`Unknown sourceLayer "${n}"`)); if (P.hasDataForBand(l))
                    return this.updateTextureDescriptor(n, l), void f(null, this.textureDescriptor ? this.textureDescriptor.img : null); const R = P.getDataRange([l]); if (w = _.createDecodingTask(R), !w || w.tasks.length)
                    if (this.flushQueues(), this.entireBuffer)
                        C(null, this.entireBuffer.slice(R.firstByte, R.lastByte + 1));
                    else {
                        const O = Object.assign({}, this.requestParams, { headers: { Range: `bytes=${R.firstByte}-${R.lastByte}` } }), D = s.br(O, C);
                        this._fetchQueue.push(() => { D.cancel(), w.cancel(); });
                    }
                else
                    f(null); }
                updateNeeded(n, l) { return (!this.textureDescriptor || this.textureDescriptor.band !== l || this.textureDescriptor.layer !== n) && this.state !== "errored"; }
                updateTextureDescriptor(n, l) { if (!this._mrt)
                    return; const f = this._mrt.getLayer(n); if (!f || !f.hasBand(l) || !f.hasDataForBand(l))
                    return; const { bytes: _, tileSize: v, buffer: w, offset: T, scale: C } = f.getBandView(l), P = v + 2 * w, R = new s.r({ width: P, height: P }, _), O = this.texture; O && O instanceof s.T && O.update(R, { premultiply: !1 }), this.textureDescriptor = { layer: n, band: l, img: R, buffer: w, offset: T, tileSize: v, format: f.pixelFormat, mix: [C, 256 * C, 65536 * C, 16777216 * C] }; }
            }
            class Og {
                constructor(n, l) { this.max = n, this.onRemove = l, this.reset(); }
                reset() { for (const n in this.data)
                    for (const l of this.data[n])
                        l.timeout && clearTimeout(l.timeout), this.onRemove(l.value); return this.data = {}, this.order = [], this; }
                add(n, l, f) { const _ = n.wrapped().key; this.data[_] === void 0 && (this.data[_] = []); const v = { value: l, timeout: void 0 }; if (f !== void 0 && (v.timeout = setTimeout(() => { this.remove(n, v); }, f)), this.data[_].push(v), this.order.push(_), this.order.length > this.max) {
                    const w = this._getAndRemoveByKey(this.order[0]);
                    w && this.onRemove(w);
                } return this; }
                has(n) { return n.wrapped().key in this.data; }
                getAndRemove(n) { return this.has(n) ? this._getAndRemoveByKey(n.wrapped().key) : null; }
                _getAndRemoveByKey(n) { const l = this.data[n].shift(); return l.timeout && clearTimeout(l.timeout), this.data[n].length === 0 && delete this.data[n], this.order.splice(this.order.indexOf(n), 1), l.value; }
                getByKey(n) { const l = this.data[n]; return l ? l[0].value : null; }
                get(n) { return this.has(n) ? this.data[n.wrapped().key][0].value : null; }
                remove(n, l) { if (!this.has(n))
                    return this; const f = n.wrapped().key, _ = l === void 0 ? 0 : this.data[f].indexOf(l), v = this.data[f][_]; return this.data[f].splice(_, 1), v.timeout && clearTimeout(v.timeout), this.data[f].length === 0 && delete this.data[f], this.onRemove(v.value), this.order.splice(this.order.indexOf(f), 1), this; }
                setMaxSize(n) { for (this.max = n; this.order.length > this.max;) {
                    const l = this._getAndRemoveByKey(this.order[0]);
                    l && this.onRemove(l);
                } return this; }
                filter(n) { const l = []; for (const f in this.data)
                    for (const _ of this.data[f])
                        n(_.value) || l.push(_); for (const f of l)
                    this.remove(f.value.tileID, f); }
            }
            class hd {
                constructor() { this.state = {}, this.stateChanges = {}, this.deletedStates = {}; }
                updateState(n, l, f) { const _ = String(l); if (this.stateChanges[n] = this.stateChanges[n] || {}, this.stateChanges[n][_] = this.stateChanges[n][_] || {}, s.l(this.stateChanges[n][_], f), this.deletedStates[n] === null) {
                    this.deletedStates[n] = {};
                    for (const v in this.state[n])
                        v !== _ && (this.deletedStates[n][v] = null);
                }
                else if (this.deletedStates[n] && this.deletedStates[n][_] === null) {
                    this.deletedStates[n][_] = {};
                    for (const v in this.state[n][_])
                        f[v] || (this.deletedStates[n][_][v] = null);
                }
                else
                    for (const v in f)
                        this.deletedStates[n] && this.deletedStates[n][_] && this.deletedStates[n][_][v] === null && delete this.deletedStates[n][_][v]; }
                removeFeatureState(n, l, f) { if (this.deletedStates[n] === null)
                    return; const _ = String(l); if (this.deletedStates[n] = this.deletedStates[n] || {}, f && l !== void 0)
                    this.deletedStates[n][_] !== null && (this.deletedStates[n][_] = this.deletedStates[n][_] || {}, this.deletedStates[n][_][f] = null);
                else if (l !== void 0)
                    if (this.stateChanges[n] && this.stateChanges[n][_])
                        for (f in this.deletedStates[n][_] = {}, this.stateChanges[n][_])
                            this.deletedStates[n][_][f] = null;
                    else
                        this.deletedStates[n][_] = null;
                else
                    this.deletedStates[n] = null; }
                getState(n, l) { const f = this.state[n] || {}, _ = this.stateChanges[n] || {}, v = this.deletedStates[n]; if (v === null)
                    return {}; if (l !== void 0) {
                    const T = String(l), C = s.l({}, f[T], _[T]);
                    if (v) {
                        const P = v[l];
                        if (P === null)
                            return {};
                        for (const R in P)
                            delete C[R];
                    }
                    return C;
                } const w = s.l({}, f, _); if (v)
                    for (const T in v)
                        delete w[T]; return w; }
                initializeTileState(n, l) { n.refreshFeatureState(l); }
                coalesceChanges(n, l) { const f = {}; for (const _ in this.stateChanges) {
                    this.state[_] = this.state[_] || {};
                    const v = {};
                    for (const w in this.stateChanges[_])
                        this.state[_][w] || (this.state[_][w] = {}), s.l(this.state[_][w], this.stateChanges[_][w]), v[w] = this.state[_][w];
                    f[_] = v;
                } for (const _ in this.deletedStates) {
                    this.state[_] = this.state[_] || {};
                    const v = {};
                    if (this.deletedStates[_] === null)
                        for (const w in this.state[_])
                            v[w] = {}, this.state[_][w] = {};
                    else
                        for (const w in this.deletedStates[_]) {
                            if (this.deletedStates[_][w] === null)
                                this.state[_][w] = {};
                            else if (this.state[_][w])
                                for (const T of Object.keys(this.deletedStates[_][w]))
                                    delete this.state[_][w][T];
                            v[w] = this.state[_][w];
                        }
                    f[_] = f[_] || {}, s.l(f[_], v);
                } if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(f).length !== 0)
                    for (const _ in n)
                        n[_].refreshFeatureState(l); }
            }
            class As extends s.E {
                constructor(n, l, f) { super(), this.id = n, this._onlySymbols = f, l.on("data", _ => { _.dataType === "source" && _.sourceDataType === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && _.dataType === "source" && _.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform)); }), l.on("error", () => { this._sourceErrored = !0; }), this._source = l, this._tiles = {}, this._cache = new Og(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = l.minTileCacheSize, this._maxTileCacheSize = l.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = !1, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new hd, this._isRaster = this._source.type === "raster" || this._source.type === "raster-dem" || this._source.type === "raster-array" || this._source.type === "custom" && this._source._dataType === "raster"; }
                onAdd(n) { this.map = n, this._minTileCacheSize = this._minTileCacheSize === void 0 && n ? n._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = this._maxTileCacheSize === void 0 && n ? n._maxTileCacheSize : this._maxTileCacheSize; }
                loaded() { if (this._sourceErrored)
                    return !0; if (!this._sourceLoaded || !this._source.loaded())
                    return !1; for (const n in this._tiles)
                    if (!this._tiles[n].loaded())
                        return !1; return !0; }
                getSource() { return this._source; }
                pause() { this._paused = !0; }
                resume() { if (!this._paused)
                    return; const n = this._shouldReloadOnResume; this._paused = !1, this._shouldReloadOnResume = !1, n && this.reload(), this.transform && this.update(this.transform); }
                _loadTile(n, l) { return n.isSymbolTile = this._onlySymbols, n.isExtraShadowCaster = this._shadowCasterTiles[n.tileID.key], this._source.loadTile(n, l); }
                _unloadTile(n) { if (this._source.unloadTile)
                    return this._source.unloadTile(n); }
                _abortTile(n) { if (this._source.abortTile)
                    return this._source.abortTile(n); }
                serialize() { return this._source.serialize(); }
                prepare(n) { this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null); for (const l in this._tiles) {
                    const f = this._tiles[l];
                    f.upload(n), f.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
                } }
                getIds() { return Object.values(this._tiles).map(n => n.tileID).sort(Wf).map(n => n.key); }
                getRenderableIds(n, l) { const f = []; for (const _ in this._tiles)
                    this._isIdRenderable(+_, n, l) && f.push(this._tiles[_]); return n ? f.sort((_, v) => { const w = _.tileID, T = v.tileID, C = new s.P(w.canonical.x, w.canonical.y)._rotate(this.transform.angle), P = new s.P(T.canonical.x, T.canonical.y)._rotate(this.transform.angle); return w.overscaledZ - T.overscaledZ || P.y - C.y || P.x - C.x; }).map(_ => _.tileID.key) : f.map(_ => _.tileID).sort(Wf).map(_ => _.key); }
                hasRenderableParent(n) { const l = this.findLoadedParent(n, 0); return !!l && this._isIdRenderable(l.tileID.key); }
                _isIdRenderable(n, l, f) { return this._tiles[n] && this._tiles[n].hasData() && !this._coveredTiles[n] && (l || !this._tiles[n].holdingForFade()) && (f || !this._shadowCasterTiles[n]); }
                reload() { if (this._paused)
                    this._shouldReloadOnResume = !0;
                else {
                    this._cache.reset();
                    for (const n in this._tiles)
                        this._tiles[n].state !== "errored" && this._reloadTile(+n, "reloading");
                } }
                _reloadTile(n, l) { const f = this._tiles[n]; f && (f.state !== "loading" && (f.state = l), this._loadTile(f, this._tileLoaded.bind(this, f, n, l))); }
                _tileLoaded(n, l, f, _) { if (_)
                    if (n.state = "errored", _.status !== 404)
                        this._source.fire(new s.z(_, { tile: n }));
                    else {
                        if (this._source.fire(new s.A("data", { dataType: "source", sourceDataType: "error", sourceId: this._source.id, tile: n })), !(n.tileID.key in this._loadedParentTiles))
                            return;
                        if (this._source.type === "raster-dem" && this.usedForTerrain && this.map.painter.terrain) {
                            const v = this.map.painter.terrain;
                            this.update(this.transform, v.getScaledDemTileSize(), !0), v.resetTileLookupCache(this.id);
                        }
                        else
                            this.update(this.transform);
                    }
                else
                    n.timeAdded = s.q.now(), f === "expired" && (n.refreshedUponExpiration = !0), this._setTileReloadTimer(l, n), this._source.type === "raster-dem" && n.dem && this._backfillDEM(n), this._state.initializeTileState(n, this.map ? this.map.painter : null), this._source.fire(new s.A("data", { dataType: "source", tile: n, coord: n.tileID, sourceCacheId: this.id })); }
                _backfillDEM(n) { const l = this.getRenderableIds(); for (let _ = 0; _ < l.length; _++) {
                    const v = l[_];
                    if (n.neighboringTiles && n.neighboringTiles[v]) {
                        const w = this.getTileByID(v);
                        f(n, w), f(w, n);
                    }
                } function f(_, v) { if (!_.dem || _.dem.borderReady)
                    return; _.needsHillshadePrepare = !0, _.needsDEMTextureUpload = !0; let w = v.tileID.canonical.x - _.tileID.canonical.x; const T = v.tileID.canonical.y - _.tileID.canonical.y, C = Math.pow(2, _.tileID.canonical.z), P = v.tileID.key; w === 0 && T === 0 || Math.abs(T) > 1 || (Math.abs(w) > 1 && (Math.abs(w + C) === 1 ? w += C : Math.abs(w - C) === 1 && (w -= C)), v.dem && _.dem && (_.dem.backfillBorder(v.dem, w, T), _.neighboringTiles && _.neighboringTiles[P] && (_.neighboringTiles[P].backfilled = !0))); } }
                getTile(n) { return this.getTileByID(n.key); }
                getTileByID(n) { return this._tiles[n]; }
                _retainLoadedChildren(n, l, f, _) { for (const v in this._tiles) {
                    let w = this._tiles[v];
                    if (_[v] || !w.hasData() || w.tileID.overscaledZ <= l || w.tileID.overscaledZ > f)
                        continue;
                    let T = w.tileID;
                    for (; w && w.tileID.overscaledZ > l + 1;) {
                        const P = w.tileID.scaledTo(w.tileID.overscaledZ - 1);
                        w = this._tiles[P.key], w && w.hasData() && (T = P);
                    }
                    let C = T;
                    for (; C.overscaledZ > l;)
                        if (C = C.scaledTo(C.overscaledZ - 1), n[C.key]) {
                            _[T.key] = T;
                            break;
                        }
                } }
                findLoadedParent(n, l) { if (n.key in this._loadedParentTiles) {
                    const f = this._loadedParentTiles[n.key];
                    return f && f.tileID.overscaledZ >= l ? f : null;
                } for (let f = n.overscaledZ - 1; f >= l; f--) {
                    const _ = n.scaledTo(f), v = this._getLoadedTile(_);
                    if (v)
                        return v;
                } }
                _getLoadedTile(n) { const l = this._tiles[n.key]; return l && l.hasData() ? l : this._cache.getByKey(this._source.reparseOverscaled ? n.wrapped().key : n.canonical.key); }
                updateCacheSize(n, l) { l = l || this._source.tileSize; const f = Math.ceil(n.width / l) + 1, _ = Math.ceil(n.height / l) + 1, v = Math.floor(f * _ * 5), w = typeof this._minTileCacheSize == "number" ? Math.max(this._minTileCacheSize, v) : v, T = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, w) : w; this._cache.setMaxSize(T); }
                handleWrapJump(n) { const l = Math.round((n - (this._prevLng === void 0 ? n : this._prevLng)) / 360); if (this._prevLng = n, l) {
                    const f = {};
                    for (const _ in this._tiles) {
                        const v = this._tiles[_];
                        v.tileID = v.tileID.unwrapTo(v.tileID.wrap + l), f[v.tileID.key] = v;
                    }
                    this._tiles = f;
                    for (const _ in this._timers)
                        clearTimeout(this._timers[_]), delete this._timers[_];
                    for (const _ in this._tiles)
                        this._setTileReloadTimer(+_, this._tiles[_]);
                } }
                update(n, l, f, _, v) { if (this.transform = n, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage || this.usedForTerrain && !f)
                    return; this.updateCacheSize(n, l), this.transform.projection.name !== "globe" && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {}; const w = this._source.type === "batched-model"; let T, C = this._source.maxzoom; const P = this.map && this.map.painter ? this.map.painter._terrain : null; if (P && P.sourceCache === this && P.attenuationRange()) {
                    const D = P.attenuationRange()[0], B = Math.floor(D) - Math.log2(P.getDemUpscale());
                    C > B && (C = B);
                } if (this.used || this.usedForTerrain) {
                    if (this._source.tileID)
                        T = n.getVisibleUnwrappedCoordinates(this._source.tileID).map(D => new s.aM(D.canonical.z, D.wrap, D.canonical.z, D.canonical.x, D.canonical.y));
                    else if (this.tileCoverLift !== 0) {
                        const D = n.clone();
                        D.tileCoverLift = this.tileCoverLift, T = D.coveringTiles({ tileSize: l || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: C, roundZoom: this._source.roundZoom && !f, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: w }), this._source.minzoom <= 1 && n.projection.name === "globe" && (T.push(new s.aM(1, 0, 1, 0, 0)), T.push(new s.aM(1, 0, 1, 1, 0)), T.push(new s.aM(1, 0, 1, 0, 1)), T.push(new s.aM(1, 0, 1, 1, 1)));
                    }
                    else if (T = n.coveringTiles({ tileSize: l || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: C, roundZoom: this._source.roundZoom && !f, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: w }), this._source.hasTile) {
                        const D = this._source.hasTile.bind(this._source);
                        T = T.filter(B => D(B));
                    }
                }
                else
                    T = []; if (T.length > 0 && this.transform.projection.name !== "globe" && !this.usedForTerrain && !Zf(this._source.type)) {
                    const D = n.coveringZoomLevel({ tileSize: l || this._source.tileSize, roundZoom: this._source.roundZoom && !f }), B = Math.min(D, this._source.maxzoom);
                    if (w) {
                        const q = n.extendTileCover(T, B);
                        for (const G of q)
                            T.push(G);
                    }
                    else if (v) {
                        const q = n.extendTileCover(T, B, this.transform._camera.forward());
                        for (const G of q)
                            T.push(G);
                    }
                    else if (this.castsShadows && _) {
                        const q = n.extendTileCover(T, B, _);
                        for (const G of q)
                            this._shadowCasterTiles[G.key] = !0, T.push(G);
                    }
                } const R = this._updateRetainedTiles(T); if (Zf(this._source.type) && T.length !== 0) {
                    const D = {}, B = {}, q = Object.keys(R);
                    for (const K of q) {
                        const W = R[K], oe = this._tiles[K];
                        if (!oe || oe.fadeEndTime && oe.fadeEndTime <= s.q.now())
                            continue;
                        const de = this.findLoadedParent(W, Math.max(W.overscaledZ - As.maxOverzooming, this._source.minzoom));
                        de && (this._addTile(de.tileID), D[de.tileID.key] = de.tileID), B[K] = W;
                    }
                    const G = T[T.length - 1].overscaledZ;
                    for (const K in this._tiles) {
                        const W = this._tiles[K];
                        if (R[K] || !W.hasData())
                            continue;
                        let oe = W.tileID;
                        for (; oe.overscaledZ > G;) {
                            oe = oe.scaledTo(oe.overscaledZ - 1);
                            const de = this._tiles[oe.key];
                            if (de && de.hasData() && B[oe.key]) {
                                R[K] = W.tileID;
                                break;
                            }
                        }
                    }
                    for (const K in D)
                        R[K] || (this._coveredTiles[K] = !0, R[K] = D[K]);
                } for (const D in R)
                    this._tiles[D].clearFadeHold(); const O = s.bs(this._tiles, R); for (const D of O) {
                    const B = this._tiles[D];
                    B.hasSymbolBuckets && !B.holdingForFade() ? B.setHoldDuration(this.map._fadeDuration) : B.hasSymbolBuckets && !B.symbolFadeFinished() || this._removeTile(+D);
                } this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate(); }
                releaseSymbolFadeTiles() { for (const n in this._tiles)
                    this._tiles[n].holdingForFade() && this._removeTile(+n); }
                _updateRetainedTiles(n) { const l = {}; if (n.length === 0)
                    return l; const f = {}, _ = n.reduce((P, R) => Math.min(P, R.overscaledZ), 1 / 0), v = n[0].overscaledZ, w = Math.max(v - As.maxOverzooming, this._source.minzoom), T = Math.max(v + As.maxUnderzooming, this._source.minzoom), C = {}; for (const P of n) {
                    const R = this._addTile(P);
                    l[P.key] = P, R.hasData() || _ < this._source.maxzoom && (C[P.key] = P);
                } this._retainLoadedChildren(C, _, T, l); for (const P of n) {
                    let R = this._tiles[P.key];
                    if (R.hasData())
                        continue;
                    if (P.canonical.z >= this._source.maxzoom) {
                        const D = P.children(this._source.maxzoom)[0], B = this.getTile(D);
                        if (B && B.hasData()) {
                            l[D.key] = D;
                            continue;
                        }
                    }
                    else {
                        const D = P.children(this._source.maxzoom);
                        if (l[D[0].key] && l[D[1].key] && l[D[2].key] && l[D[3].key])
                            continue;
                    }
                    let O = R.wasRequested();
                    for (let D = P.overscaledZ - 1; D >= w; --D) {
                        const B = P.scaledTo(D);
                        if (f[B.key] || (f[B.key] = !0, R = this.getTile(B), !R && O && (R = this._addTile(B)), R && (l[B.key] = B, O = R.wasRequested(), R.hasData())))
                            break;
                    }
                } return l; }
                _updateLoadedParentTileCache() { this._loadedParentTiles = {}; for (const n in this._tiles) {
                    const l = [];
                    let f, _ = this._tiles[n].tileID;
                    for (; _.overscaledZ > 0;) {
                        if (_.key in this._loadedParentTiles) {
                            f = this._loadedParentTiles[_.key];
                            break;
                        }
                        l.push(_.key);
                        const v = _.scaledTo(_.overscaledZ - 1);
                        if (f = this._getLoadedTile(v), f)
                            break;
                        _ = v;
                    }
                    for (const v of l)
                        this._loadedParentTiles[v] = f;
                } }
                _addTile(n) { let l = this._tiles[n.key]; if (l)
                    return l.isExtraShadowCaster !== !0 || this._shadowCasterTiles[n.key] || this._reloadTile(n.key, "reloading"), l; l = this._cache.getAndRemove(n), l && (this._setTileReloadTimer(n.key, l), l.tileID = n, this._state.initializeTileState(l, this.map ? this.map.painter : null), this._cacheTimers[n.key] && (clearTimeout(this._cacheTimers[n.key]), delete this._cacheTimers[n.key], this._setTileReloadTimer(n.key, l))); const f = !!l; if (!f) {
                    const _ = this.map ? this.map.painter : null, v = this._source.tileSize * n.overscaleFactor();
                    l = this._source.type === "raster-array" ? new ud(n, v, this.transform.tileZoom, _, this._isRaster) : new Xa(n, v, this.transform.tileZoom, _, this._isRaster), this._loadTile(l, this._tileLoaded.bind(this, l, n.key, l.state));
                } return l.uses++, this._tiles[n.key] = l, f || this._source.fire(new s.A("dataloading", { tile: l, coord: l.tileID, dataType: "source" })), l; }
                _setTileReloadTimer(n, l) { n in this._timers && (clearTimeout(this._timers[n]), delete this._timers[n]); const f = l.getExpiryTimeout(); f && (this._timers[n] = setTimeout(() => { this._reloadTile(n, "expired"), delete this._timers[n]; }, f)); }
                _removeTile(n) { const l = this._tiles[n]; l && (l.uses--, delete this._tiles[n], this._timers[n] && (clearTimeout(this._timers[n]), delete this._timers[n]), l.uses > 0 || (l.hasData() && l.state !== "reloading" || l.state === "empty" ? this._cache.add(l.tileID, l, l.getExpiryTimeout()) : (l.aborted = !0, this._abortTile(l), this._unloadTile(l)))); }
                clearTiles() { this._shouldReloadOnResume = !1, this._paused = !1; for (const n in this._tiles)
                    this._removeTile(+n); this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id); }
                tilesIn(n, l, f) { const _ = [], v = this.transform; if (!v)
                    return _; const w = v.projection.name === "globe", T = s.ay(v.center.lng); for (const C in this._tiles) {
                    const P = this._tiles[C];
                    if (f && P.clearQueryDebugViz(), P.holdingForFade())
                        continue;
                    let R;
                    if (w) {
                        const O = P.tileID.canonical;
                        if (O.z === 0) {
                            const D = [Math.abs(s.aD(T, ...gu(O, -1)) - T), Math.abs(s.aD(T, ...gu(O, 1)) - T)];
                            R = [0, 2 * D.indexOf(Math.min(...D)) - 1];
                        }
                        else {
                            const D = [Math.abs(s.aD(T, ...gu(O, -1)) - T), Math.abs(s.aD(T, ...gu(O, 0)) - T), Math.abs(s.aD(T, ...gu(O, 1)) - T)];
                            R = [D.indexOf(Math.min(...D)) - 1];
                        }
                    }
                    else
                        R = [0];
                    for (const O of R) {
                        const D = n.containsTile(P, v, l, O);
                        D && _.push(D);
                    }
                } return _; }
                getShadowCasterCoordinates() { return this._getRenderableCoordinates(!1, !0); }
                getVisibleCoordinates(n) { return this._getRenderableCoordinates(n); }
                _getRenderableCoordinates(n, l) { const f = this.getRenderableIds(n, l).map(v => this._tiles[v].tileID), _ = this.transform.projection.name === "globe"; for (const v of f)
                    v.projMatrix = this.transform.calculateProjMatrix(v.toUnwrapped()), v.expandedProjMatrix = _ ? this.transform.calculateProjMatrix(v.toUnwrapped(), !1, !0) : v.projMatrix; return f; }
                sortCoordinatesByDistance(n) { const l = n.slice(), f = this.transform._camera.position, _ = this.transform._camera.forward(), v = {}; for (const w of l) {
                    const T = 1 / (1 << w.canonical.z);
                    v[w.key] = ((w.canonical.x + .5) * T + w.wrap - f[0]) * _[0] + ((w.canonical.y + .5) * T - f[1]) * _[1] - f[2] * _[2];
                } return l.sort((w, T) => v[w.key] - v[T.key]), l; }
                hasTransition() { if (this._source.hasTransition())
                    return !0; if (Zf(this._source.type))
                    for (const n in this._tiles) {
                        const l = this._tiles[n];
                        if (l.fadeEndTime !== void 0 && l.fadeEndTime >= s.q.now())
                            return !0;
                    } return !1; }
                setFeatureState(n, l, f) { this._state.updateState(n = n || "_geojsonTileLayer", l, f); }
                removeFeatureState(n, l, f) { this._state.removeFeatureState(n = n || "_geojsonTileLayer", l, f); }
                getFeatureState(n, l) { return this._state.getState(n = n || "_geojsonTileLayer", l); }
                setDependencies(n, l, f) { const _ = this._tiles[n]; _ && _.setDependencies(l, f); }
                reloadTilesForDependencies(n, l) { for (const f in this._tiles)
                    this._tiles[f].hasDependency(n, l) && this._reloadTile(+f, "reloading"); this._cache.filter(f => !f.hasDependency(n, l)); }
                _preloadTiles(n, l) { if (!this._sourceLoaded) {
                    const C = () => { this._sourceLoaded && (this._source.off("data", C), this._preloadTiles(n, l)); };
                    return void this._source.on("data", C);
                } const f = new Map, _ = Array.isArray(n) ? n : [n], v = this.map.painter.terrain, w = this.usedForTerrain && v ? v.getScaledDemTileSize() : this._source.tileSize; for (const C of _) {
                    const P = C.coveringTiles({ tileSize: w, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
                    for (const R of P)
                        f.set(R.key, R);
                    this.usedForTerrain && C.updateElevation(!1);
                } const T = Array.from(f.values()); s.bt(T, (C, P) => { const R = new Xa(C, this._source.tileSize * C.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster); this._loadTile(R, O => { this._source.type === "raster-dem" && R.dem && this._backfillDEM(R), P(O, R); }); }, l); }
            }
            function Wf(d, n) { const l = Math.abs(2 * d.wrap) - +(d.wrap < 0), f = Math.abs(2 * n.wrap) - +(n.wrap < 0); return d.overscaledZ - n.overscaledZ || f - l || n.canonical.y - d.canonical.y || n.canonical.x - d.canonical.x; }
            function Zf(d) { return d === "raster" || d === "image" || d === "video" || d === "custom"; }
            function gu(d, n) { const l = 1 << d.z; return [d.x / l + n, (d.x + 1) / l + n]; }
            As.maxOverzooming = 10, As.maxUnderzooming = 3;
            class d0 {
                constructor(n) { this.style = n, this.layersGotHidden = !1, this.layers = []; }
                processLayersChanged() { this.layers = []; const n = !1, l = !1; for (const f in this.style._mergedLayers) {
                    const _ = this.style._mergedLayers[f];
                    if (_.type === "fill-extrusion")
                        this.layers.push({ layer: _, visible: n, visibilityChanged: l });
                    else if (_.type === "model") {
                        const v = this.style.getLayerSource(_);
                        v && v.type === "batched-model" && this.layers.push({ layer: _, visible: n, visibilityChanged: l });
                    }
                } }
                onNewFrame(n) { this.layersGotHidden = !1; for (const l of this.layers) {
                    const f = l.layer;
                    let _ = !1;
                    f.type === "fill-extrusion" ? _ = !f.isHidden(n) && f.paint.get("fill-extrusion-opacity") > 0 : f.type === "model" && (_ = !f.isHidden(n) && f.paint.get("model-opacity").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !_ && l.visible, l.visible = _;
                } }
                updateZOffset(n, l) { this.currentBuildingBuckets = []; for (const _ of this.layers) {
                    const v = _.layer, w = this.style.getLayerSourceCache(v);
                    let T = 1;
                    v.type === "fill-extrusion" && (T = _.visible ? v.paint.get("fill-extrusion-vertical-scale") : 0);
                    let C = w ? w.getTile(l) : null;
                    if (!C && w && l.canonical.z > w.getSource().minzoom) {
                        let P = l.scaledTo(Math.min(w.getSource().maxzoom, l.overscaledZ - 1));
                        for (; P.overscaledZ >= w.getSource().minzoom && (C = w.getTile(P), !C && P.overscaledZ !== 0);)
                            P = P.scaledTo(P.overscaledZ - 1);
                    }
                    this.currentBuildingBuckets.push({ bucket: C ? C.getBucket(v) : null, tileID: C ? C.tileID : l, verticalScale: T });
                } n.hasAnyZOffset = !1; let f = !1; for (let _ = 0; _ < n.symbolInstances.length; _++) {
                    const v = n.symbolInstances.get(_), w = v.zOffset, T = this._getHeightAtTileOffset(l, v.tileAnchorX, v.tileAnchorY);
                    v.zOffset = T !== Number.NEGATIVE_INFINITY ? T : w, f || w === v.zOffset || (f = !0), n.hasAnyZOffset || v.zOffset === 0 || (n.hasAnyZOffset = !0);
                } f && (n.zOffsetBuffersNeedUpload = !0, n.zOffsetSortDirty = !0); }
                _mapCoordToOverlappingTile(n, l, f, _) { let v = l, w = f; if (n.canonical.z !== _.canonical.z) {
                    const T = _.canonical, C = 1 / (1 << n.canonical.z - T.z);
                    v = (l + n.canonical.x * s.aj) * C - T.x * s.aj | 0, w = (f + n.canonical.y * s.aj) * C - T.y * s.aj | 0;
                } return { tileX: v, tileY: w }; }
                _getHeightAtTileOffset(n, l, f) { let _, v; for (let w = 0; w < this.layers.length; ++w) {
                    if (this.layers[w].layer.type !== "fill-extrusion")
                        continue;
                    const { bucket: T, tileID: C, verticalScale: P } = this.currentBuildingBuckets[w];
                    if (!T)
                        continue;
                    const { tileX: R, tileY: O } = this._mapCoordToOverlappingTile(n, l, f, C), D = T.getHeightAtTileCoord(R, O);
                    D && D.height !== void 0 && (D.hidden ? _ = D.height : v = Math.max(D.height * P, v || 0));
                } if (v !== void 0)
                    return v; for (let w = 0; w < this.layers.length; ++w) {
                    const T = this.layers[w];
                    if (T.layer.type !== "model" || !T.visible)
                        continue;
                    const { bucket: C, tileID: P } = this.currentBuildingBuckets[w];
                    if (!C)
                        continue;
                    const { tileX: R, tileY: O } = this._mapCoordToOverlappingTile(n, l, f, P), D = C.getHeightAtTileCoord(R, O);
                    if (D && !D.hidden)
                        return D.height === void 0 && _ !== void 0 ? Math.min(D.maxHeight, _) * D.verticalScale : D.height ? D.height * D.verticalScale : Number.NEGATIVE_INFINITY;
                } return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY; }
            }
            function Xf(d, n) { const l = {}; for (const f in d)
                f !== "ref" && (l[f] = d[f]); return s.bu.forEach(f => { f in n && (l[f] = n[f]); }), l; }
            function Kf(d) { d = d.slice(); const n = Object.create(null); for (let l = 0; l < d.length; l++)
                n[d[l].id] = d[l]; for (let l = 0; l < d.length; l++)
                "ref" in d[l] && (d[l] = Xf(d[l], n[d[l].ref])); return d; }
            const Yr = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setSlot: "setSlot", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setSnow: "setSnow", setRain: "setRain", setCamera: "setCamera", setLights: "setLights", setProjection: "setProjection", addImport: "addImport", removeImport: "removeImport", updateImport: "updateImport", addIconset: "addIconset", removeIconset: "removeIconset" };
            function _u(d, n, l) { l.push({ command: Yr.addSource, args: [d, n[d]] }); }
            function yu(d, n, l) { n.push({ command: Yr.removeSource, args: [d] }), l[d] = !0; }
            function Hb(d, n, l, f) { yu(d, l, f), _u(d, n, l); }
            function f0(d, n, l) { let f; for (f in d[l])
                if (d[l].hasOwnProperty(f) && f !== "data" && !s.bv(d[l][f], n[l][f]))
                    return !1; for (f in n[l])
                if (n[l].hasOwnProperty(f) && f !== "data" && !s.bv(d[l][f], n[l][f]))
                    return !1; return !0; }
            function vc(d, n, l, f, _, v) { let w; for (w in n = n || {}, d = d || {})
                d.hasOwnProperty(w) && (s.bv(d[w], n[w]) || l.push({ command: v, args: [f, w, n[w], _] })); for (w in n)
                n.hasOwnProperty(w) && !d.hasOwnProperty(w) && (s.bv(d[w], n[w]) || l.push({ command: v, args: [f, w, n[w], _] })); }
            function Cl(d) { return d.id; }
            function vu(d, n) { return d[n.id] = n, d; }
            class p0 {
                constructor(n, l) { this.reset(n, l); }
                reset(n, l) { this.points = n || [], this._distances = [0]; for (let f = 1; f < this.points.length; f++)
                    this._distances[f] = this._distances[f - 1] + this.points[f].dist(this.points[f - 1]); this.length = this._distances[this._distances.length - 1], this.padding = Math.min(l || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding; }
                lerp(n) { if (this.points.length === 1)
                    return this.points[0]; n = s.aD(n, 0, 1); let l = 1, f = this._distances[l]; const _ = n * this.paddedLength + this.padding; for (; f < _ && l < this._distances.length;)
                    f = this._distances[++l]; const v = l - 1, w = this._distances[v], T = f - w, C = T > 0 ? (_ - w) / T : 0; return this.points[v].mult(1 - C).add(this.points[l].mult(C)); }
            }
            class zg {
                constructor(n, l, f) { const _ = this.boxCells = [], v = this.circleCells = []; this.xCellCount = Math.ceil(n / f), this.yCellCount = Math.ceil(l / f); for (let w = 0; w < this.xCellCount * this.yCellCount; w++)
                    _.push([]), v.push([]); this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = n, this.height = l, this.xScale = this.xCellCount / n, this.yScale = this.yCellCount / l, this.boxUid = 0, this.circleUid = 0; }
                keysLength() { return this.boxKeys.length + this.circleKeys.length; }
                insert(n, l, f, _, v) { this._forEachCell(l, f, _, v, this._insertBoxCell, this.boxUid++), this.boxKeys.push(n), this.bboxes.push(l), this.bboxes.push(f), this.bboxes.push(_), this.bboxes.push(v); }
                insertCircle(n, l, f, _) { this._forEachCell(l - _, f - _, l + _, f + _, this._insertCircleCell, this.circleUid++), this.circleKeys.push(n), this.circles.push(l), this.circles.push(f), this.circles.push(_); }
                _insertBoxCell(n, l, f, _, v, w) { this.boxCells[v].push(w); }
                _insertCircleCell(n, l, f, _, v, w) { this.circleCells[v].push(w); }
                _query(n, l, f, _, v, w) { if (f < 0 || n > this.width || _ < 0 || l > this.height)
                    return !v && []; const T = []; if (n <= 0 && l <= 0 && this.width <= f && this.height <= _) {
                    if (v)
                        return !0;
                    for (let C = 0; C < this.boxKeys.length; C++)
                        T.push({ key: this.boxKeys[C], x1: this.bboxes[4 * C], y1: this.bboxes[4 * C + 1], x2: this.bboxes[4 * C + 2], y2: this.bboxes[4 * C + 3] });
                    for (let C = 0; C < this.circleKeys.length; C++) {
                        const P = this.circles[3 * C], R = this.circles[3 * C + 1], O = this.circles[3 * C + 2];
                        T.push({ key: this.circleKeys[C], x1: P - O, y1: R - O, x2: P + O, y2: R + O });
                    }
                    return w ? T.filter(w) : T;
                } return this._forEachCell(n, l, f, _, this._queryCell, T, { hitTest: v, seenUids: { box: {}, circle: {} } }, w), v ? T.length > 0 : T; }
                _queryCircle(n, l, f, _, v) { const w = n - f, T = n + f, C = l - f, P = l + f; if (T < 0 || w > this.width || P < 0 || C > this.height)
                    return !_ && []; const R = []; return this._forEachCell(w, C, T, P, this._queryCellCircle, R, { hitTest: _, circle: { x: n, y: l, radius: f }, seenUids: { box: {}, circle: {} } }, v), _ ? R.length > 0 : R; }
                query(n, l, f, _, v) { return this._query(n, l, f, _, !1, v); }
                hitTest(n, l, f, _, v) { return this._query(n, l, f, _, !0, v); }
                hitTestCircle(n, l, f, _) { return this._queryCircle(n, l, f, !0, _); }
                _queryCell(n, l, f, _, v, w, T, C) { const P = T.seenUids, R = this.boxCells[v]; if (R !== null) {
                    const D = this.bboxes;
                    for (const B of R)
                        if (!P.box[B]) {
                            P.box[B] = !0;
                            const q = 4 * B;
                            if (n <= D[q + 2] && l <= D[q + 3] && f >= D[q + 0] && _ >= D[q + 1] && (!C || C(this.boxKeys[B]))) {
                                if (T.hitTest)
                                    return w.push(!0), !0;
                                w.push({ key: this.boxKeys[B], x1: D[q], y1: D[q + 1], x2: D[q + 2], y2: D[q + 3] });
                            }
                        }
                } const O = this.circleCells[v]; if (O !== null) {
                    const D = this.circles;
                    for (const B of O)
                        if (!P.circle[B]) {
                            P.circle[B] = !0;
                            const q = 3 * B;
                            if (this._circleAndRectCollide(D[q], D[q + 1], D[q + 2], n, l, f, _) && (!C || C(this.circleKeys[B]))) {
                                if (T.hitTest)
                                    return w.push(!0), !0;
                                {
                                    const G = D[q], K = D[q + 1], W = D[q + 2];
                                    w.push({ key: this.circleKeys[B], x1: G - W, y1: K - W, x2: G + W, y2: K + W });
                                }
                            }
                        }
                } }
                _queryCellCircle(n, l, f, _, v, w, T, C) { const P = T.circle, R = T.seenUids, O = this.boxCells[v]; if (O !== null) {
                    const B = this.bboxes;
                    for (const q of O)
                        if (!R.box[q]) {
                            R.box[q] = !0;
                            const G = 4 * q;
                            if (this._circleAndRectCollide(P.x, P.y, P.radius, B[G + 0], B[G + 1], B[G + 2], B[G + 3]) && (!C || C(this.boxKeys[q])))
                                return w.push(!0), !0;
                        }
                } const D = this.circleCells[v]; if (D !== null) {
                    const B = this.circles;
                    for (const q of D)
                        if (!R.circle[q]) {
                            R.circle[q] = !0;
                            const G = 3 * q;
                            if (this._circlesCollide(B[G], B[G + 1], B[G + 2], P.x, P.y, P.radius) && (!C || C(this.circleKeys[q])))
                                return w.push(!0), !0;
                        }
                } }
                _forEachCell(n, l, f, _, v, w, T, C) { const P = this._convertToXCellCoord(n), R = this._convertToYCellCoord(l), O = this._convertToXCellCoord(f), D = this._convertToYCellCoord(_); for (let B = P; B <= O; B++)
                    for (let q = R; q <= D; q++)
                        if (v.call(this, n, l, f, _, this.xCellCount * q + B, w, T, C))
                            return; }
                _convertToXCellCoord(n) { return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(n * this.xScale))); }
                _convertToYCellCoord(n) { return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(n * this.yScale))); }
                _circlesCollide(n, l, f, _, v, w) { const T = _ - n, C = v - l, P = f + w; return P * P > T * T + C * C; }
                _circleAndRectCollide(n, l, f, _, v, w, T) { const C = (w - _) / 2, P = Math.abs(n - (_ + C)); if (P > C + f)
                    return !1; const R = (T - v) / 2, O = Math.abs(l - (v + R)); if (O > R + f)
                    return !1; if (P <= C || O <= R)
                    return !0; const D = P - C, B = O - R; return D * D + B * B <= f * f; }
            }
            const xc = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, dd = Math.tan(85 * Math.PI / 180);
            function xu(d, n, l, f, _, v, w) { const T = s.bz(); if (l)
                if (v.name === "globe") {
                    const C = s.bA(_, n);
                    s.az(T, T, C);
                }
                else {
                    const C = s.bB([], w);
                    T[0] = C[0], T[1] = C[1], T[4] = C[2], T[5] = C[3], f || s.by(T, T, _.angle);
                }
            else
                s.az(T, _.labelPlaneMatrix, d); return T; }
            function Yf(d, n, l, f, _, v, w) { const T = xu(d, n, l, f, _, v, w); return v.name === "globe" && l || (T[2] = T[6] = T[10] = T[14] = 0), T; }
            function Fg(d, n, l, f, _, v, w) { if (l) {
                if (v.name === "globe") {
                    const T = xu(d, n, l, f, _, v, w);
                    return s.bi(T, T), s.az(T, d, T), T;
                }
                {
                    const T = s.bw(d), C = s.bx([]);
                    return C[0] = w[0], C[1] = w[1], C[4] = w[2], C[5] = w[3], s.az(T, T, C), f || s.by(T, T, -_.angle), T;
                }
            } return _.glCoordMatrix; }
            function Js(d, n, l, f) { const _ = [d, n, l, 1]; l ? s.aA(_, _, f) : m0(_, _, f); const v = _[3]; return _[0] /= v, _[1] /= v, _[2] /= v, _; }
            function Al(d, n) { return Math.min(.5 + d / n * .5, 1.5); }
            function Ng(d, n) { const l = d[0] / d[3], f = d[1] / d[3]; return l >= -n[0] && l <= n[0] && f >= -n[1] && f <= n[1]; }
            function Bg(d, n, l, f, _, v, w, T, C, P) { const R = l.transform, O = f ? d.textSizeData : d.iconSizeData, D = s.bH(O, l.transform.zoom), B = R.projection.name === "globe", q = [256 / l.width * 2 + 1, 256 / l.height * 2 + 1], G = f ? d.text.dynamicLayoutVertexArray : d.icon.dynamicLayoutVertexArray; G.clear(); let K = null; B && (K = f ? d.text.globeExtVertexArray : d.icon.globeExtVertexArray); const W = d.lineVertexArray, oe = f ? d.text.placedSymbolArray : d.icon.placedSymbolArray, de = l.transform.width / l.transform.height; let me, we = !1; for (let ve = 0; ve < oe.length; ve++) {
                const xe = oe.get(ve), { numGlyphs: ge, writingMode: Se } = xe;
                if (Se !== s.bI.vertical || we || me === s.bI.horizontal || (we = !0), me = Se, (xe.hidden || Se === s.bI.vertical) && !we) {
                    nn(ge, G);
                    continue;
                }
                we = !1;
                const Ce = new s.P(xe.tileAnchorX, xe.tileAnchorY);
                let { x: je, y: ze, z: rt } = R.projection.projectTilePoint(Ce.x, Ce.y, P.canonical);
                if (C) {
                    const [Vt, Xt, Bt] = C(Ce);
                    je += Vt, ze += Xt, rt += Bt;
                }
                const et = [je, ze, rt, 1];
                if (s.aA(et, et, n), !Ng(et, q)) {
                    nn(ge, G);
                    continue;
                }
                const vt = et[3], Fe = Al(l.transform.getCameraToCenterDistance(R.projection), vt), Ve = s.bJ(O, D, xe), Le = w ? Ve / Fe : Ve * Fe, st = Js(je, ze, rt, _);
                if (st[3] <= 0) {
                    nn(ge, G);
                    continue;
                }
                let He = {};
                const ht = s.al(d.layers[0].layout.get("text-max-angle")), nt = Math.cos(ht), dt = w ? null : C, ft = eo(xe, Le, !1, T, n, _, v, d.glyphOffsetArray, W, G, K, st, Ce, He, de, dt, R.projection, P, w, nt);
                we = ft.useVertical, dt && ft.needsFlipping && (He = {}), (ft.notEnoughRoom || we || ft.needsFlipping && eo(xe, Le, !0, T, n, _, v, d.glyphOffsetArray, W, G, K, st, Ce, He, de, dt, R.projection, P, w, nt).notEnoughRoom) && nn(ge, G);
            } f ? (d.text.dynamicLayoutVertexBuffer.updateData(G), K && d.text.globeExtVertexBuffer && d.text.globeExtVertexBuffer.updateData(K)) : (d.icon.dynamicLayoutVertexBuffer.updateData(G), K && d.icon.globeExtVertexBuffer && d.icon.globeExtVertexBuffer.updateData(K)); }
            function Qf(d, n, l, f, _, v, w, T, C, P, R, O, D, B, q, G, K) { const { lineStartIndex: W, glyphStartIndex: oe, segment: de } = T, me = oe + T.numGlyphs, we = W + T.lineLength, ve = n.getoffsetX(oe), xe = n.getoffsetX(me - 1), ge = fd(d * ve, l, f, _, v, w, de, W, we, C, P, R, O, D, !0, B, q, G, K); if (!ge)
                return null; const Se = fd(d * xe, l, f, _, v, w, de, W, we, C, P, R, O, D, !0, B, q, G, K); return Se ? { first: ge, last: Se } : null; }
            function wc(d, n, l, f) { return d === s.bI.horizontal && Math.abs(f) > Math.abs(l) ? { useVertical: !0 } : d === s.bI.vertical ? f > 0 ? { needsFlipping: !0 } : null : n !== xc.unknown && function (_, v) { return _ === 0 || Math.abs(v / _) > dd; }(l, f) ? n === xc.flipRequired ? { needsFlipping: !0 } : null : l < 0 ? { needsFlipping: !0 } : null; }
            function eo(d, n, l, f, _, v, w, T, C, P, R, O, D, B, q, G, K, W, oe, de) { const me = n / 24, we = d.lineOffsetX * me, ve = d.lineOffsetY * me, { lineStartIndex: xe, glyphStartIndex: ge, numGlyphs: Se, segment: Ce, writingMode: je, flipState: ze } = d, rt = xe + d.lineLength, et = vt => { if (R) {
                const [st, He, ht] = vt.up, nt = P.length;
                s.bK(R, nt + 0, st, He, ht), s.bK(R, nt + 1, st, He, ht), s.bK(R, nt + 2, st, He, ht), s.bK(R, nt + 3, st, He, ht);
            } const [Fe, Ve, Le] = vt.point; s.bL(P, Fe, Ve, Le, vt.angle); }; if (Se > 1) {
                const vt = Qf(me, T, we, ve, l, O, D, d, C, v, B, G, !1, K, W, oe, de);
                if (!vt)
                    return { notEnoughRoom: !0 };
                if (f && !l) {
                    let [Fe, Ve, Le] = vt.first.point, [st, He, ht] = vt.last.point;
                    [Fe, Ve] = Js(Fe, Ve, Le, w), [st, He] = Js(st, He, ht, w);
                    const nt = wc(je, ze, (st - Fe) * q, He - Ve);
                    if (d.flipState = nt && nt.needsFlipping ? xc.flipRequired : xc.flipNotRequired, nt)
                        return nt;
                }
                et(vt.first);
                for (let Fe = ge + 1; Fe < ge + Se - 1; Fe++) {
                    const Ve = fd(me * T.getoffsetX(Fe), we, ve, l, O, D, Ce, xe, rt, C, v, B, G, !1, !1, K, W, oe, de);
                    if (!Ve)
                        return P.length -= 4 * (Fe - ge), { notEnoughRoom: !0 };
                    et(Ve);
                }
                et(vt.last);
            }
            else {
                if (f && !l) {
                    const Fe = Js(D.x, D.y, 0, _), Ve = xe + Ce + 1, Le = new s.P(C.getx(Ve), C.gety(Ve)), st = Js(Le.x, Le.y, 0, _), He = st[3] > 0 ? st : Jf(D, Le, Fe, 1, _, void 0, K, W.canonical), ht = wc(je, ze, (He[0] - Fe[0]) * q, He[1] - Fe[1]);
                    if (d.flipState = ht && ht.needsFlipping ? xc.flipRequired : xc.flipNotRequired, ht)
                        return ht;
                }
                const vt = fd(me * T.getoffsetX(ge), we, ve, l, O, D, Ce, xe, rt, C, v, B, G, !1, !1, K, W, oe, de);
                if (!vt)
                    return { notEnoughRoom: !0 };
                et(vt);
            } return {}; }
            function jg(d, n, l, f, _) { const { x: v, y: w, z: T } = f.projectTilePoint(d.x, d.y, n); if (!_)
                return Js(v, w, T, l); const [C, P, R] = _(d); return Js(v + C, w + P, T + R, l); }
            function Jf(d, n, l, f, _, v, w, T) { const C = jg(d.sub(n)._unit()._add(d), T, _, w, v); return s.at(C, l, C), s.au(C, C), s.bF(C, l, C, f); }
            function fd(d, n, l, f, _, v, w, T, C, P, R, O, D, B, q, G, K, W, oe) { const de = f ? d - n : d + n; let me = de > 0 ? 1 : -1, we = 0; f && (me *= -1, we = Math.PI), me < 0 && (we += Math.PI); let ve = T + w + (me > 0 ? 0 : 1) | 0, xe = _, ge = _, Se = 0, Ce = 0; const je = Math.abs(de), ze = [], rt = []; let et = v, vt = et, Fe = s.bC([]); const Ve = () => Jf(vt, et, ge, je - Se + 1, R, D, G, K.canonical); for (; Se + Ce <= je;) {
                if (ve += me, ve < T || ve >= C)
                    return null;
                if (ge = xe, vt = et, ze.push(ge), B && rt.push(vt), et = new s.P(P.getx(ve), P.gety(ve)), xe = O[ve], !xe) {
                    const Bt = jg(et, K.canonical, R, G, D);
                    xe = Bt[3] > 0 ? O[ve] = Bt : Ve();
                }
                Se += Ce;
                const Vt = s.at([], xe, ge), Xt = s.bD(ge, xe);
                if (l && Xt > 0 && Ce > 0 && s.bE(Fe, Vt) / (Ce * Xt) < oe)
                    return null;
                Ce = Xt, Fe = Vt;
            } q && D && (O[ve] && (xe = Ve(), Ce = s.bD(ge, xe), Fe = s.at([], xe, ge)), O[ve] = xe); const Le = (je - Se) / Ce, st = et.sub(vt)._mult(Le)._add(vt), He = s.bF([], ge, Fe, Le); let ht = [0, 0, 1], nt = Fe[0], dt = Fe[1]; if (W && (ht = G.upVector(K.canonical, st.x, st.y), ht[0] !== 0 || ht[1] !== 0 || ht[2] !== 1)) {
                const Vt = [ht[2], 0, -ht[0]], Xt = s.bG([], ht, Vt);
                s.au(Vt, Vt), s.au(Xt, Xt), nt = s.bE(Fe, Vt), dt = s.bE(Fe, Xt);
            } if (l) {
                const Vt = s.bG([], ht, Fe);
                s.au(Vt, Vt), s.bF(He, He, Vt, l * me);
            } const ft = we + Math.atan2(dt, nt); return ze.push(He), B && rt.push(st), { point: He, angle: ft, path: ze, tilePath: rt, up: ht }; }
            function nn(d, n) { const l = n.length, f = l + 4 * d; n.resize(f), n.float32.fill(-1 / 0, 4 * l, 4 * f); }
            function m0(d, n, l) { const f = n[0], _ = n[1]; return d[0] = l[0] * f + l[4] * _ + l[12], d[1] = l[1] * f + l[5] * _ + l[13], d[3] = l[3] * f + l[7] * _ + l[15], d; }
            const nr = 100;
            class g0 {
                constructor(n, l, f = new zg(n.width + 200, n.height + 200, 25), _ = new zg(n.width + 200, n.height + 200, 25)) { this.transform = n, this.grid = f, this.ignoredGrid = _, this.pitchfactor = Math.cos(n._pitch) * n.cameraToCenterDistance, this.screenRightBoundary = n.width + nr, this.screenBottomBoundary = n.height + nr, this.gridRightBoundary = n.width + 200, this.gridBottomBoundary = n.height + 200, this.fogState = l; }
                placeCollisionBox(n, l, f, _, v, w, T, C) { let P = f.projectedAnchorX, R = f.projectedAnchorY, O = f.projectedAnchorZ; const D = f.elevation, B = f.tileID, q = n.getProjection(); if (D && B) {
                    const [ve, xe, ge] = q.upVector(B.canonical, f.tileAnchorX, f.tileAnchorY), Se = q.upVectorScale(B.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                    P += ve * D * Se, R += xe * D * Se, O += ge * D * Se;
                } const G = this.projectAndGetPerspectiveRatio(T, P, R, O, f.tileID, q.name === "globe" || !!D || this.transform.pitch > 0, q), K = w * G.perspectiveRatio, W = (f.x1 * l + _.x - f.padding) * K + G.point.x, oe = (f.y1 * l + _.y - f.padding) * K + G.point.y, de = (f.x2 * l + _.x + f.padding) * K + G.point.x, me = (f.y2 * l + _.y + f.padding) * K + G.point.y, we = G.perspectiveRatio <= .55 || G.occluded; return !this.isInsideGrid(W, oe, de, me) || !v && this.grid.hitTest(W, oe, de, me, C) || we ? { box: [], offscreen: !1, occluded: G.occluded } : { box: [W, oe, de, me], offscreen: this.isOffscreen(W, oe, de, me), occluded: !1 }; }
                placeCollisionCircles(n, l, f, _, v, w, T, C, P, R, O, D, B, q, G) { const K = [], W = this.transform.elevation, oe = n.getProjection(), de = W ? W.getAtTileOffsetFunc(G, this.transform.center.lat, this.transform.worldSize, oe) : null, me = new s.P(f.tileAnchorX, f.tileAnchorY); let { x: we, y: ve, z: xe } = oe.projectTilePoint(me.x, me.y, G.canonical); if (de) {
                    const [ht, nt, dt] = de(me);
                    we += ht, ve += nt, xe += dt;
                } const ge = oe.name === "globe", Se = this.projectAndGetPerspectiveRatio(T, we, ve, xe, G, ge || !!W || this.transform.pitch > 0, oe), { perspectiveRatio: Ce } = Se, je = (O ? w / Ce : w * Ce) / s.bO, ze = Js(we, ve, xe, C), rt = f.lineOffsetX * je, et = f.lineOffsetY * je, vt = s.al(n.layers[0].layout.get("text-max-angle")), Fe = Math.cos(vt), Ve = Se.signedDistanceFromCamera > 0 ? Qf(je, v, rt, et, !1, ze, me, f, _, C, {}, W && !O ? de : null, O && !!W, oe, G, O, Fe) : null; let Le = !1, st = !1, He = !0; if (Ve && !Se.occluded) {
                    const ht = .5 * B * Ce + q, nt = new s.P(-100, -100), dt = new s.P(this.screenRightBoundary, this.screenBottomBoundary), ft = new p0, { first: Vt, last: Xt } = Ve, Bt = Vt.path.length;
                    let Yt = [];
                    for (let mr = Bt - 1; mr >= 1; mr--)
                        Yt.push(Vt.path[mr]);
                    for (let mr = 1; mr < Xt.path.length; mr++)
                        Yt.push(Xt.path[mr]);
                    const $t = 2.5 * ht;
                    P && (Yt = Yt.map(([mr, Nr, vn], fn) => (de && !ge && (vn = de(fn < Bt - 1 ? Vt.tilePath[Bt - 1 - fn] : Xt.tilePath[fn - Bt + 2])[2]), Js(mr, Nr, vn, P))), Yt.some(mr => mr[3] <= 0) && (Yt = []));
                    let or = [];
                    if (Yt.length > 0) {
                        let mr = 1 / 0, Nr = -1 / 0, vn = 1 / 0, fn = -1 / 0;
                        for (const jr of Yt)
                            mr = Math.min(mr, jr[0]), vn = Math.min(vn, jr[1]), Nr = Math.max(Nr, jr[0]), fn = Math.max(fn, jr[1]);
                        Nr >= nt.x && mr <= dt.x && fn >= nt.y && vn <= dt.y && (or = [Yt.map(jr => new s.P(jr[0], jr[1]))], (mr < nt.x || Nr > dt.x || vn < nt.y || fn > dt.y) && (or = s.bM(or, nt.x, nt.y, dt.x, dt.y)));
                    }
                    for (const mr of or) {
                        ft.reset(mr, .25 * ht);
                        let Nr = 0;
                        Nr = ft.length <= .5 * ht ? 1 : Math.ceil(ft.paddedLength / $t) + 1;
                        for (let vn = 0; vn < Nr; vn++) {
                            const fn = vn / Math.max(Nr - 1, 1), jr = ft.lerp(fn), hi = jr.x + nr, Jn = jr.y + nr;
                            K.push(hi, Jn, ht, 0);
                            const xr = hi - ht, Hr = Jn - ht, Qr = hi + ht, xn = Jn + ht;
                            if (He = He && this.isOffscreen(xr, Hr, Qr, xn), st = st || this.isInsideGrid(xr, Hr, Qr, xn), !l && this.grid.hitTestCircle(hi, Jn, ht, D) && (Le = !0, !R))
                                return { circles: [], offscreen: !1, collisionDetected: Le, occluded: !1 };
                        }
                    }
                } return { circles: !R && Le || !st ? [] : K, offscreen: He, collisionDetected: Le, occluded: Se.occluded }; }
                queryRenderedSymbols(n) { if (n.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
                    return {}; const l = []; let f = 1 / 0, _ = 1 / 0, v = -1 / 0, w = -1 / 0; for (const R of n) {
                    const O = new s.P(R.x + nr, R.y + nr);
                    f = Math.min(f, O.x), _ = Math.min(_, O.y), v = Math.max(v, O.x), w = Math.max(w, O.y), l.push(O);
                } const T = this.grid.query(f, _, v, w).concat(this.ignoredGrid.query(f, _, v, w)), C = {}, P = {}; for (const R of T) {
                    const O = R.key;
                    if (C[O.bucketInstanceId] === void 0 && (C[O.bucketInstanceId] = {}), C[O.bucketInstanceId][O.featureIndex])
                        continue;
                    const D = [new s.P(R.x1, R.y1), new s.P(R.x2, R.y1), new s.P(R.x2, R.y2), new s.P(R.x1, R.y2)];
                    s.bN(l, D) && (C[O.bucketInstanceId][O.featureIndex] = !0, P[O.bucketInstanceId] === void 0 && (P[O.bucketInstanceId] = []), P[O.bucketInstanceId].push(O.featureIndex));
                } return P; }
                insertCollisionBox(n, l, f, _, v) { (l ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: f, featureIndex: _, collisionGroupID: v }, n[0], n[1], n[2], n[3]); }
                insertCollisionCircles(n, l, f, _, v) { const w = l ? this.ignoredGrid : this.grid, T = { bucketInstanceId: f, featureIndex: _, collisionGroupID: v }; for (let C = 0; C < n.length; C += 4)
                    w.insertCircle(T, n[C], n[C + 1], n[C + 2]); }
                projectAndGetPerspectiveRatio(n, l, f, _, v, w, T) { const C = [l, f, _, 1]; let P = !1; _ || this.transform.pitch > 0 ? (s.aA(C, C, n), this.fogState && v && T.name !== "globe" && (P = function (D, B, q, G, K, W) { const oe = W.calculateFogTileMatrix(K), de = [B, q, G]; return s.ad(de, de, oe), Wt(D, s.ae(de), W.pitch, W._fov); }(this.fogState, l, f, _, v.toUnwrapped(), this.transform) > .9)) : m0(C, C, n); const R = C[3]; return { point: new s.P((C[0] / R + 1) / 2 * this.transform.width + nr, (-C[1] / R + 1) / 2 * this.transform.height + nr), perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(T) / R * .5, 1.5), signedDistanceFromCamera: R, occluded: w && C[2] > R || P }; }
                isOffscreen(n, l, f, _) { return f < nr || n >= this.screenRightBoundary || _ < nr || l > this.screenBottomBoundary; }
                isInsideGrid(n, l, f, _) { return f >= 0 && n < this.gridRightBoundary && _ >= 0 && l < this.gridBottomBoundary; }
                getViewportMatrix() { const n = s.bx([]); return s.bo(n, n, [-100, -100, 0]), n; }
            }
            function ep(d, n, l) { const f = n.createTileMatrix(d, d.worldSize, l.toUnwrapped()); return s.az(new Float32Array(16), d.projMatrix, f); }
            function tp(d, n, l) { if (n.projection.name === l.projection.name)
                return d.projMatrix; const f = l.clone(); return f.setProjection(n.projection), ep(f, n.getProjection(), d); }
            function pd(d, n, l) { return n.name === l.projection.name ? d.projMatrix : ep(l, n, d); }
            class Do {
                constructor(n, l, f, _) { this.opacity = n ? Math.max(0, Math.min(1, n.opacity + (n.placed ? l : -l))) : _ && f ? 1 : 0, this.placed = f; }
                isHidden() { return this.opacity === 0 && !this.placed; }
            }
            class bc {
                constructor(n, l, f, _, v, w = !1) { this.text = new Do(n ? n.text : null, l, f, v), this.icon = new Do(n ? n.icon : null, l, _, v), this.clipped = w; }
                isHidden() { return this.text.isHidden() && this.icon.isHidden(); }
            }
            class Il {
                constructor(n, l, f, _ = !1) { this.text = n, this.icon = l, this.skipFade = f, this.clipped = _; }
            }
            class Qt {
                constructor() { this.invProjMatrix = s.bz(), this.viewportMatrix = s.bz(), this.circles = []; }
            }
            class bn {
                constructor(n, l, f, _, v) { this.bucketInstanceId = n, this.featureIndex = l, this.sourceLayerIndex = f, this.bucketIndex = _, this.tileID = v; }
            }
            class dn {
                constructor(n) { this.crossSourceCollisions = n, this.maxGroupID = 0, this.collisionGroups = {}; }
                get(n) { if (this.crossSourceCollisions)
                    return { ID: 0, predicate: null }; if (!this.collisionGroups[n]) {
                    const l = ++this.maxGroupID;
                    this.collisionGroups[n] = { ID: l, predicate: f => f.collisionGroupID === l };
                } return this.collisionGroups[n]; }
            }
            function Vs(d, n, l, f, _) { const { horizontalAlign: v, verticalAlign: w } = s.bV(d), T = -(v - .5) * n, C = -(w - .5) * l, P = s.bU(d, f); return new s.P(T + P[0] * _, C + P[1] * _); }
            function Pl(d, n, l, f, _) { const v = new s.P(d, n); return l && v._rotate(f ? _ : -_), v; }
            class un {
                constructor(n, l, f, _, v, w) { this.transform = n.clone(), this.projection = n.projection.name, this.collisionIndex = new g0(this.transform, v), this.buildingIndex = w, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = l, this.retainedQueryData = {}, this.collisionGroups = new dn(f), this.collisionCircleArrays = {}, this.prevPlacement = _, _ && (_.prevPlacement = void 0), this.placedOrientations = {}; }
                getBucketParts(n, l, f, _, v = 1) { const w = f.getBucket(l), T = f.latestFeatureIndex; if (!w || !T || l.fqid !== w.layerIds[0])
                    return; const C = w.layers[0].layout, P = w.layers[0].paint, R = f.collisionBoxArray, O = Math.pow(2, this.transform.zoom - f.tileID.overscaledZ), D = f.tileSize / s.aj, B = f.tileID.toUnwrapped(); this.transform.setProjection(w.projection); const q = (G = f.tileID, K = w.getProjection(), W = this.transform, K.name === this.projection ? W.calculateProjMatrix(G.toUnwrapped()) : ep(W, K, G)); var G, K, W; const oe = C.get("text-pitch-alignment") === "map", de = C.get("text-rotation-alignment") === "map"; l.compileFilter(l.options); const me = l.dynamicFilter(), we = l.dynamicFilterNeedsFeature(), ve = this.transform.calculatePixelsToTileUnitsMatrix(f), xe = Yf(q, f.tileID.canonical, oe, de, this.transform, w.getProjection(), ve); let ge = null; if (oe) {
                    const Ve = Fg(q, f.tileID.canonical, oe, de, this.transform, w.getProjection(), ve);
                    ge = s.az([], this.transform.labelPlaneMatrix, Ve);
                } let Se = null; me && f.latestFeatureIndex && (Se = { unwrappedTileID: B, dynamicFilter: me, dynamicFilterNeedsFeature: we }), this.retainedQueryData[w.bucketInstanceId] = new bn(w.bucketInstanceId, T, w.sourceLayerIndex, w.index, f.tileID); const [Ce, je] = w.layers[0].layout.get("text-size-scale-range"), ze = s.aD(v, Ce, je), [rt, et] = C.get("icon-size-scale-range"), vt = s.aD(v, rt, et), Fe = { bucket: w, layout: C, paint: P, posMatrix: q, textLabelPlaneMatrix: xe, labelToScreenMatrix: ge, clippingData: Se, scale: O, textPixelRatio: D, holdingForFade: f.holdingForFade(), collisionBoxArray: R, partiallyEvaluatedTextSize: s.bH(w.textSizeData, this.transform.zoom, ze), partiallyEvaluatedIconSize: s.bH(w.iconSizeData, this.transform.zoom, vt), collisionGroup: this.collisionGroups.get(w.sourceID), latestFeatureIndex: f.latestFeatureIndex }; if (_)
                    for (const Ve of w.sortKeyRanges) {
                        const { sortKey: Le, symbolInstanceStart: st, symbolInstanceEnd: He } = Ve;
                        n.push({ sortKey: Le, symbolInstanceStart: st, symbolInstanceEnd: He, parameters: Fe });
                    }
                else
                    n.push({ symbolInstanceStart: 0, symbolInstanceEnd: w.symbolInstances.length, parameters: Fe }); }
                attemptAnchorPlacement(n, l, f, _, v, w, T, C, P, R, O, D, B, q, G, K, W, oe) { const { textOffset0: de, textOffset1: me, crossTileID: we } = D, ve = [de, me], xe = Vs(n, f, _, ve, v), ge = this.collisionIndex.placeCollisionBox(q, v, l, Pl(xe.x, xe.y, w, T, this.transform.angle), O, C, P, R.predicate); if (K) {
                    const Se = q.getSymbolInstanceIconSize(oe, this.transform.zoom, D.placedIconSymbolIndex);
                    if (this.collisionIndex.placeCollisionBox(q, Se, K, Pl(xe.x, xe.y, w, T, this.transform.angle), O, C, P, R.predicate).box.length === 0)
                        return;
                } if (ge.box.length > 0) {
                    let Se;
                    return this.prevPlacement && this.prevPlacement.variableOffsets[we] && this.prevPlacement.placements[we] && this.prevPlacement.placements[we].text && (Se = this.prevPlacement.variableOffsets[we].anchor), this.variableOffsets[we] = { textOffset: ve, width: f, height: _, anchor: n, textScale: v, prevAnchor: Se }, this.markUsedJustification(q, n, D, G), q.allowVerticalPlacement && (this.markUsedOrientation(q, G, D), this.placedOrientations[we] = G), { shift: xe, placedGlyphBoxes: ge };
                } }
                placeLayerBucketPart(n, l, f, _, v = 1) { const { bucket: w, layout: T, paint: C, posMatrix: P, textLabelPlaneMatrix: R, labelToScreenMatrix: O, clippingData: D, textPixelRatio: B, holdingForFade: q, collisionBoxArray: G, partiallyEvaluatedTextSize: K, partiallyEvaluatedIconSize: W, collisionGroup: oe, latestFeatureIndex: de } = n.parameters, me = T.get("text-optional"), we = T.get("icon-optional"), ve = T.get("text-allow-overlap"), xe = T.get("icon-allow-overlap"), ge = T.get("text-rotation-alignment") === "map", Se = T.get("text-pitch-alignment") === "map", Ce = C.get("symbol-z-offset"), je = T.get("symbol-elevation-reference") === "sea", [ze, rt] = T.get("text-size-scale-range"), [et, vt] = T.get("icon-size-scale-range"), Fe = s.aD(v, ze, rt), Ve = s.aD(v, et, vt); this.transform.setProjection(w.projection); let Le = ve && (xe || !w.hasIconData() || we), st = xe && (ve || !w.hasTextData() || me); const He = !Ce.isConstant(); !w.collisionArrays && G && w.deserializeCollisionBoxes(G), f && _ && w.updateCollisionDebugBuffers(this.transform.zoom, G, Fe, Ve); const ht = (nt, dt, ft) => { const { crossTileID: Vt, numVerticalGlyphVertices: Xt } = nt; let Bt = null; if (D && D.dynamicFilterNeedsFeature || He) {
                    const Xr = this.retainedQueryData[w.bucketInstanceId];
                    Bt = de.loadFeature({ featureIndex: nt.featureIndex, bucketIndex: Xr.bucketIndex, sourceLayerIndex: Xr.sourceLayerIndex, layoutVertexArrayOffset: 0 });
                } if (D && !(0, D.dynamicFilter)({ zoom: this.transform.zoom, pitch: this.transform.pitch }, Bt, this.retainedQueryData[w.bucketInstanceId].tileID.canonical, new s.P(nt.tileAnchorX, nt.tileAnchorY), this.transform.calculateDistanceTileData(D.unwrappedTileID)))
                    return this.placements[Vt] = new Il(!1, !1, !1, !0), void l.add(Vt); const Yt = Ce.evaluate(Bt, {}); if (l.has(Vt))
                    return; if (q)
                    return void (this.placements[Vt] = new Il(!1, !1, !1)); let $t = !1, or = !1, mr = !0, Nr = !1, vn = !1, fn = null, jr = { box: null, offscreen: null, occluded: null }, hi = { box: null, offscreen: null, occluded: null }, Jn = null, xr = null, Hr = null, Qr = 0, xn = 0, Ii = 0; ft.textFeatureIndex ? Qr = ft.textFeatureIndex : nt.useRuntimeCollisionCircles && (Qr = nt.featureIndex), ft.verticalTextFeatureIndex && (xn = ft.verticalTextFeatureIndex); const _i = Xr => { Xr.tileID = this.retainedQueryData[w.bucketInstanceId].tileID; const Hn = this.transform.elevation; Xr.elevation = je ? Yt : Yt + (Hn ? Hn.getAtTileOffset(Xr.tileID, Xr.tileAnchorX, Xr.tileAnchorY) : 0), Xr.elevation += nt.zOffset; }, Ci = ft.textBox; if (Ci) {
                    _i(Ci);
                    const Xr = sn => { let Yn = s.bI.horizontal; if (w.allowVerticalPlacement && !sn && this.prevPlacement) {
                        const Wi = this.prevPlacement.placedOrientations[Vt];
                        Wi && (this.placedOrientations[Vt] = Wi, Yn = Wi, this.markUsedOrientation(w, Yn, nt));
                    } return Yn; }, Hn = (sn, Yn) => { if (w.allowVerticalPlacement && Xt > 0 && ft.verticalTextBox) {
                        for (const Wi of w.writingModes)
                            if (Wi === s.bI.vertical ? (jr = Yn(), hi = jr) : jr = sn(), jr && jr.box && jr.box.length)
                                break;
                    }
                    else
                        jr = sn(); };
                    if (T.get("text-variable-anchor")) {
                        let sn = T.get("text-variable-anchor");
                        if (this.prevPlacement && this.prevPlacement.variableOffsets[Vt]) {
                            const Ln = this.prevPlacement.variableOffsets[Vt];
                            sn.indexOf(Ln.anchor) > 0 && (sn = sn.filter(es => es !== Ln.anchor), sn.unshift(Ln.anchor));
                        }
                        const Yn = (Ln, es, wi) => { const as = w.getSymbolInstanceTextSize(K, nt, this.transform.zoom, dt), oa = (Ln.x2 - Ln.x1) * as + 2 * Ln.padding, rl = (Ln.y2 - Ln.y1) * as + 2 * Ln.padding, ro = nt.hasIconTextFit && !xe ? es : null; ro && _i(ro); let No = { box: [], offscreen: !1, occluded: !1 }; const Ia = ve ? 2 * sn.length : sn.length; for (let Pa = 0; Pa < Ia; ++Pa) {
                            const aa = this.attemptAnchorPlacement(sn[Pa % sn.length], Ln, oa, rl, as, ge, Se, B, P, oe, Pa >= sn.length, nt, dt, w, wi, ro, K, W);
                            if (aa && (No = aa.placedGlyphBoxes, No && No.box && No.box.length)) {
                                $t = !0, fn = aa.shift;
                                break;
                            }
                        } return No; };
                        Hn(() => Yn(Ci, ft.iconBox, s.bI.horizontal), () => { const Ln = ft.verticalTextBox; return Ln && _i(Ln), w.allowVerticalPlacement && !(jr && jr.box && jr.box.length) && Xt > 0 && Ln ? Yn(Ln, ft.verticalIconBox, s.bI.vertical) : { box: null, offscreen: null, occluded: null }; }), jr && ($t = jr.box, mr = jr.offscreen, Nr = jr.occluded);
                        const Wi = Xr(!(!jr || !jr.box));
                        if (!$t && this.prevPlacement) {
                            const Ln = this.prevPlacement.variableOffsets[Vt];
                            Ln && (this.variableOffsets[Vt] = Ln, this.markUsedJustification(w, Ln.anchor, nt, Wi));
                        }
                    }
                    else {
                        const sn = (Yn, Wi) => { const Ln = w.getSymbolInstanceTextSize(K, nt, this.transform.zoom, dt, v), es = this.collisionIndex.placeCollisionBox(w, Ln, Yn, new s.P(0, 0), ve, B, P, oe.predicate); return es && es.box && es.box.length && (this.markUsedOrientation(w, Wi, nt), this.placedOrientations[Vt] = Wi), es; };
                        Hn(() => sn(Ci, s.bI.horizontal), () => { const Yn = ft.verticalTextBox; return w.allowVerticalPlacement && Xt > 0 && Yn ? (_i(Yn), sn(Yn, s.bI.vertical)) : { box: null, offscreen: null, occluded: null }; }), Xr(!!(jr && jr.box && jr.box.length));
                    }
                } if (Jn = jr, $t = Jn && Jn.box && Jn.box.length > 0, mr = Jn && Jn.offscreen, Nr = Jn && Jn.occluded, nt.useRuntimeCollisionCircles) {
                    const Xr = w.text.placedSymbolArray.get(nt.centerJustifiedTextSymbolIndex >= 0 ? nt.centerJustifiedTextSymbolIndex : nt.verticalPlacedTextSymbolIndex), Hn = s.bJ(w.textSizeData, K, Xr), sn = T.get("text-padding");
                    xr = this.collisionIndex.placeCollisionCircles(w, ve, Xr, w.lineVertexArray, w.glyphOffsetArray, Hn, P, R, O, f, Se, oe.predicate, nt.collisionCircleDiameter * Hn / s.bO, sn, this.retainedQueryData[w.bucketInstanceId].tileID), $t = ve || xr.circles.length > 0 && !xr.collisionDetected, mr = mr && xr.offscreen, Nr = xr.occluded;
                } if (ft.iconFeatureIndex && (Ii = ft.iconFeatureIndex), ft.iconBox) {
                    const Xr = Hn => { _i(Hn); const sn = nt.hasIconTextFit && fn ? Pl(fn.x, fn.y, ge, Se, this.transform.angle) : new s.P(0, 0), Yn = w.getSymbolInstanceIconSize(W, this.transform.zoom, nt.placedIconSymbolIndex); return this.collisionIndex.placeCollisionBox(w, Yn, Hn, sn, xe, B, P, oe.predicate); };
                    hi && hi.box && hi.box.length && ft.verticalIconBox ? (Hr = Xr(ft.verticalIconBox), or = Hr.box.length > 0) : (Hr = Xr(ft.iconBox), or = Hr.box.length > 0), mr = mr && Hr.offscreen, vn = Hr.occluded;
                } const Kn = me || nt.numHorizontalGlyphVertices === 0 && Xt === 0, Cr = we || nt.numIconVertices === 0; if (Kn || Cr ? Cr ? Kn || (or = or && $t) : $t = or && $t : or = $t = or && $t, $t && Jn && Jn.box && this.collisionIndex.insertCollisionBox(Jn.box, T.get("text-ignore-placement"), w.bucketInstanceId, hi && hi.box && xn ? xn : Qr, oe.ID), or && Hr && this.collisionIndex.insertCollisionBox(Hr.box, T.get("icon-ignore-placement"), w.bucketInstanceId, Ii, oe.ID), xr && ($t && this.collisionIndex.insertCollisionCircles(xr.circles, T.get("text-ignore-placement"), w.bucketInstanceId, Qr, oe.ID), f)) {
                    const Xr = w.bucketInstanceId;
                    let Hn = this.collisionCircleArrays[Xr];
                    Hn === void 0 && (Hn = this.collisionCircleArrays[Xr] = new Qt);
                    for (let sn = 0; sn < xr.circles.length; sn += 4)
                        Hn.circles.push(xr.circles[sn + 0]), Hn.circles.push(xr.circles[sn + 1]), Hn.circles.push(xr.circles[sn + 2]), Hn.circles.push(xr.collisionDetected ? 1 : 0);
                } const qn = w.projection.name !== "globe"; Le = Le && (qn || !Nr), st = st && (qn || !vn), this.placements[Vt] = new Il($t || Le, or || st, mr || w.justReloaded), l.add(Vt); }; if (w.elevationType === "offset" && this.buildingIndex && this.buildingIndex.updateZOffset(w, this.retainedQueryData[w.bucketInstanceId].tileID), w.elevationType === "road" && w.updateRoadElevation(), w.updateZOffset(), w.sortFeaturesByY) {
                    const nt = w.getSortedSymbolIndexes(this.transform.angle);
                    for (let dt = nt.length - 1; dt >= 0; --dt) {
                        const ft = nt[dt];
                        ht(w.symbolInstances.get(ft), ft, w.collisionArrays[ft]);
                    }
                    w.hasAnyZOffset && s.w(`${w.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
                }
                else if (w.hasAnyZOffset) {
                    const nt = w.getSortedIndexesByZOffset();
                    for (let dt = 0; dt < nt.length; ++dt) {
                        const ft = nt[dt];
                        ht(w.symbolInstances.get(ft), ft, w.collisionArrays[ft]);
                    }
                }
                else
                    for (let nt = n.symbolInstanceStart; nt < n.symbolInstanceEnd; nt++)
                        ht(w.symbolInstances.get(nt), nt, w.collisionArrays[nt]); if (f && w.bucketInstanceId in this.collisionCircleArrays) {
                    const nt = this.collisionCircleArrays[w.bucketInstanceId];
                    s.bi(nt.invProjMatrix, P), nt.viewportMatrix = this.collisionIndex.getViewportMatrix();
                } w.justReloaded = !1; }
                markUsedJustification(n, l, f, _) { const { leftJustifiedTextSymbolIndex: v, centerJustifiedTextSymbolIndex: w, rightJustifiedTextSymbolIndex: T, verticalPlacedTextSymbolIndex: C, crossTileID: P } = f, R = s.bT(l), O = _ === s.bI.vertical ? C : R === "left" ? v : R === "center" ? w : R === "right" ? T : -1; v >= 0 && (n.text.placedSymbolArray.get(v).crossTileID = O >= 0 && v !== O ? 0 : P), w >= 0 && (n.text.placedSymbolArray.get(w).crossTileID = O >= 0 && w !== O ? 0 : P), T >= 0 && (n.text.placedSymbolArray.get(T).crossTileID = O >= 0 && T !== O ? 0 : P), C >= 0 && (n.text.placedSymbolArray.get(C).crossTileID = O >= 0 && C !== O ? 0 : P); }
                markUsedOrientation(n, l, f) { const _ = l === s.bI.horizontal || l === s.bI.horizontalOnly ? l : 0, v = l === s.bI.vertical ? l : 0, { leftJustifiedTextSymbolIndex: w, centerJustifiedTextSymbolIndex: T, rightJustifiedTextSymbolIndex: C, verticalPlacedTextSymbolIndex: P } = f, R = n.text.placedSymbolArray; w >= 0 && (R.get(w).placedOrientation = _), T >= 0 && (R.get(T).placedOrientation = _), C >= 0 && (R.get(C).placedOrientation = _), P >= 0 && (R.get(P).placedOrientation = v); }
                commit(n) { this.commitTime = n, this.zoomAtLastRecencyCheck = this.transform.zoom; const l = this.prevPlacement; let f = !1; this.prevZoomAdjustment = l ? l.zoomAdjustment(this.transform.zoom) : 0; const _ = l ? l.symbolFadeChange(n) : 1, v = l ? l.opacities : {}, w = l ? l.variableOffsets : {}, T = l ? l.placedOrientations : {}; for (const C in this.placements) {
                    const P = this.placements[C], R = v[C];
                    R ? (this.opacities[C] = new bc(R, _, P.text, P.icon, null, P.clipped), f = f || P.text !== R.text.placed || P.icon !== R.icon.placed) : (this.opacities[C] = new bc(null, _, P.text, P.icon, P.skipFade, P.clipped), f = f || P.text || P.icon);
                } for (const C in v) {
                    const P = v[C];
                    if (!this.opacities[C]) {
                        const R = new bc(P, _, !1, !1);
                        R.isHidden() || (this.opacities[C] = R, f = f || P.text.placed || P.icon.placed);
                    }
                } for (const C in w)
                    this.variableOffsets[C] || !this.opacities[C] || this.opacities[C].isHidden() || (this.variableOffsets[C] = w[C]); for (const C in T)
                    this.placedOrientations[C] || !this.opacities[C] || this.opacities[C].isHidden() || (this.placedOrientations[C] = T[C]); f ? this.lastPlacementChangeTime = n : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = l ? l.lastPlacementChangeTime : n); }
                updateLayerOpacities(n, l, f, _) { const v = new Set; for (const w of l) {
                    const T = w.getBucket(n);
                    T && w.latestFeatureIndex && n.fqid === T.layerIds[0] && (this.updateBucketOpacities(T, v, w, w.collisionBoxArray, f, _, w.tileID, n.scope), T.elevationType === "offset" && this.buildingIndex && this.buildingIndex.updateZOffset(T, w.tileID), T.elevationType === "road" && T.updateRoadElevation(), T.updateZOffset());
                } }
                updateBucketOpacities(n, l, f, _, v, w, T, C) { n.hasTextData() && n.text.opacityVertexArray.clear(), n.hasIconData() && n.icon.opacityVertexArray.clear(), n.hasIconCollisionBoxData() && n.iconCollisionBox.collisionVertexArray.clear(), n.hasTextCollisionBoxData() && n.textCollisionBox.collisionVertexArray.clear(); const P = n.layers[0].layout, R = n.layers[0].paint, O = !!n.layers[0].dynamicFilter(), D = new bc(null, 0, !1, !1, !0), B = P.get("text-allow-overlap"), q = P.get("icon-allow-overlap"), G = P.get("text-variable-anchor"), K = P.get("text-rotation-alignment") === "map", W = P.get("text-pitch-alignment") === "map", oe = R.get("symbol-z-offset"), de = P.get("symbol-elevation-reference") === "sea", me = !oe.isConstant(), we = new bc(null, 0, B && (q || !n.hasIconData() || P.get("icon-optional")), q && (B || !n.hasTextData() || P.get("text-optional")), !0); !n.collisionArrays && _ && (n.hasIconCollisionBoxData() || n.hasTextCollisionBoxData()) && n.deserializeCollisionBoxes(_); const ve = (ge, Se, Ce) => { for (let je = 0; je < Se / 4; je++)
                    ge.opacityVertexArray.emplaceBack(Ce); }; let xe = 0; w && n.updateReplacement(T, w); for (let ge = 0; ge < n.symbolInstances.length; ge++) {
                    const Se = n.symbolInstances.get(ge), { numHorizontalGlyphVertices: Ce, numVerticalGlyphVertices: je, crossTileID: ze, numIconVertices: rt, tileAnchorX: et, tileAnchorY: vt } = Se;
                    let Fe = null;
                    const Ve = this.retainedQueryData[n.bucketInstanceId];
                    me && Se && Ve && (Fe = f.latestFeatureIndex.loadFeature({ featureIndex: Se.featureIndex, bucketIndex: Ve.bucketIndex, sourceLayerIndex: Ve.sourceLayerIndex, layoutVertexArrayOffset: 0 }));
                    const Le = oe.evaluate(Fe, {}), st = l.has(ze);
                    let He = this.opacities[ze];
                    st ? He = D : He || (He = we, this.opacities[ze] = He), l.add(ze);
                    const ht = Ce > 0 || je > 0, nt = rt > 0, dt = this.placedOrientations[ze], ft = dt === s.bI.vertical, Vt = dt === s.bI.horizontal || dt === s.bI.horizontalOnly;
                    !ht && !nt || He.isHidden() || xe++;
                    let Xt = !1;
                    if ((ht || nt) && w)
                        for (const Bt of n.activeReplacements) {
                            if (s.bP(Bt, v, s.bQ.Symbol, C) || Bt.min.x > et || et > Bt.max.x || Bt.min.y > vt || vt > Bt.max.y)
                                continue;
                            const Yt = s.bR(et, vt, T.canonical, Bt.footprintTileId.canonical);
                            if (Xt = s.bS(Yt, Bt.footprint), Xt)
                                break;
                        }
                    if (ht) {
                        const Bt = Xt ? Ml : wu(He.text);
                        ve(n.text, Ce, ft ? Ml : Bt), ve(n.text, je, Vt ? Ml : Bt);
                        const Yt = He.text.isHidden(), { leftJustifiedTextSymbolIndex: $t, centerJustifiedTextSymbolIndex: or, rightJustifiedTextSymbolIndex: mr, verticalPlacedTextSymbolIndex: Nr } = Se, vn = n.text.placedSymbolArray, fn = Yt || ft ? 1 : 0;
                        $t >= 0 && (vn.get($t).hidden = fn), or >= 0 && (vn.get(or).hidden = fn), mr >= 0 && (vn.get(mr).hidden = fn), Nr >= 0 && (vn.get(Nr).hidden = Yt || Vt ? 1 : 0);
                        const jr = this.variableOffsets[ze];
                        jr && this.markUsedJustification(n, jr.anchor, Se, dt);
                        const hi = this.placedOrientations[ze];
                        hi && (this.markUsedJustification(n, "left", Se, hi), this.markUsedOrientation(n, hi, Se));
                    }
                    if (nt) {
                        const Bt = Xt ? Ml : wu(He.icon), { placedIconSymbolIndex: Yt, verticalPlacedIconSymbolIndex: $t } = Se, or = n.icon.placedSymbolArray, mr = He.icon.isHidden() ? 1 : 0;
                        Yt >= 0 && (ve(n.icon, rt, ft ? Ml : Bt), or.get(Yt).hidden = mr), $t >= 0 && (ve(n.icon, Se.numVerticalIconVertices, Vt ? Ml : Bt), or.get($t).hidden = mr);
                    }
                    if (n.hasIconCollisionBoxData() || n.hasTextCollisionBoxData()) {
                        const Bt = n.collisionArrays[ge];
                        if (Bt) {
                            let Yt = new s.P(0, 0), $t = !0;
                            if (Bt.textBox || Bt.verticalTextBox) {
                                if (G) {
                                    const mr = this.variableOffsets[ze];
                                    mr ? (Yt = Vs(mr.anchor, mr.width, mr.height, mr.textOffset, mr.textScale), K && Yt._rotate(W ? this.transform.angle : -this.transform.angle)) : $t = !1;
                                }
                                O && ($t = !He.clipped), Bt.textBox && Tc(n.textCollisionBox.collisionVertexArray, He.text.placed, !$t || ft, Le, de, Yt.x, Yt.y), Bt.verticalTextBox && Tc(n.textCollisionBox.collisionVertexArray, He.text.placed, !$t || Vt, Le, de, Yt.x, Yt.y);
                            }
                            const or = $t && !!(!Vt && Bt.verticalIconBox);
                            Bt.iconBox && Tc(n.iconCollisionBox.collisionVertexArray, He.icon.placed, or, Le, de, Se.hasIconTextFit ? Yt.x : 0, Se.hasIconTextFit ? Yt.y : 0), Bt.verticalIconBox && Tc(n.iconCollisionBox.collisionVertexArray, He.icon.placed, !or, Le, de, Se.hasIconTextFit ? Yt.x : 0, Se.hasIconTextFit ? Yt.y : 0);
                        }
                    }
                } if (n.fullyClipped = xe === 0, n.sortFeatures(this.transform.angle), this.retainedQueryData[n.bucketInstanceId] && (this.retainedQueryData[n.bucketInstanceId].featureSortOrder = n.featureSortOrder), n.hasTextData() && n.text.opacityVertexBuffer && n.text.opacityVertexBuffer.updateData(n.text.opacityVertexArray), n.hasIconData() && n.icon.opacityVertexBuffer && n.icon.opacityVertexBuffer.updateData(n.icon.opacityVertexArray), n.hasIconCollisionBoxData() && n.iconCollisionBox.collisionVertexBuffer && n.iconCollisionBox.collisionVertexBuffer.updateData(n.iconCollisionBox.collisionVertexArray), n.hasTextCollisionBoxData() && n.textCollisionBox.collisionVertexBuffer && n.textCollisionBox.collisionVertexBuffer.updateData(n.textCollisionBox.collisionVertexArray), n.bucketInstanceId in this.collisionCircleArrays) {
                    const ge = this.collisionCircleArrays[n.bucketInstanceId];
                    n.placementInvProjMatrix = ge.invProjMatrix, n.placementViewportMatrix = ge.viewportMatrix, n.collisionCircleArray = ge.circles, delete this.collisionCircleArrays[n.bucketInstanceId];
                } }
                symbolFadeChange(n) { return this.fadeDuration === 0 ? 1 : (n - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment; }
                zoomAdjustment(n) { return Math.max(0, (this.transform.zoom - n) / 1.5); }
                hasTransitions(n) { return this.stale || n - this.lastPlacementChangeTime < this.fadeDuration; }
                stillRecent(n, l) { const f = this.zoomAtLastRecencyCheck === l ? 1 - this.zoomAdjustment(l) : 1; return this.zoomAtLastRecencyCheck = l, this.commitTime + this.fadeDuration * f > n; }
                setStale() { this.stale = !0; }
            }
            function Tc(d, n, l, f, _, v, w) { d.emplaceBack(n ? 1 : 0, l ? 1 : 0, v || 0, w || 0, f, _ ? 1 : 0), d.emplaceBack(n ? 1 : 0, l ? 1 : 0, v || 0, w || 0, f, _ ? 1 : 0), d.emplaceBack(n ? 1 : 0, l ? 1 : 0, v || 0, w || 0, f, _ ? 1 : 0), d.emplaceBack(n ? 1 : 0, l ? 1 : 0, v || 0, w || 0, f, _ ? 1 : 0); }
            const md = Math.pow(2, 25), gd = Math.pow(2, 24), Is = Math.pow(2, 17), Ri = Math.pow(2, 16), Wb = Math.pow(2, 9), _d = Math.pow(2, 8), Vg = Math.pow(2, 1);
            function wu(d) { if (d.opacity === 0 && !d.placed)
                return 0; if (d.opacity === 1 && d.placed)
                return 4294967295; const n = d.placed ? 1 : 0, l = Math.floor(127 * d.opacity); return l * md + n * gd + l * Is + n * Ri + l * Wb + n * _d + l * Vg + n; }
            const Ml = 0;
            class rp {
                constructor(n) { this._sortAcrossTiles = n.layout.get("symbol-z-order") !== "viewport-y" && n.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = new Set, this._bucketParts = []; }
                continuePlacement(n, l, f, _, v, w) { const T = this._bucketParts; for (; this._currentTileIndex < n.length;)
                    if (l.getBucketParts(T, _, n[this._currentTileIndex], this._sortAcrossTiles, w), this._currentTileIndex++, v())
                        return !0; for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, T.sort((C, P) => C.sortKey - P.sortKey)); this._currentPartIndex < T.length;) {
                    const C = T[this._currentPartIndex];
                    if (l.placeLayerBucketPart(C, this._seenCrossTileIDs, f, C.symbolInstanceStart === 0, w), this._currentPartIndex++, v())
                        return !0;
                } return !1; }
            }
            class Ps {
                constructor(n, l, f, _, v, w, T, C, P) { this.placement = new un(n, v, w, T, C, P), this._currentPlacementIndex = l.length - 1, this._forceFullPlacement = f, this._showCollisionBoxes = _, this._done = !1; }
                isDone() { return this._done; }
                continuePlacement(n, l, f, _, v) { const w = s.q.now(), T = () => { const C = s.q.now() - w; return !this._forceFullPlacement && C > 2; }; for (; this._currentPlacementIndex >= 0;) {
                    const C = l[n[this._currentPlacementIndex]], P = this.placement.collisionIndex.transform.zoom;
                    if (C.type === "symbol" && (!C.minzoom || C.minzoom <= P) && (!C.maxzoom || C.maxzoom > P)) {
                        const R = C, O = R.layout.get("symbol-z-elevate"), D = R.layout.get("symbol-sort-key").constantOr(1) !== void 0, B = R.layout.get("symbol-z-order"), q = B === "viewport-y" || B === "auto" && !(B !== "viewport-y" && D), G = R.layout.get("text-allow-overlap") || R.layout.get("icon-allow-overlap") || R.layout.get("text-ignore-placement") || R.layout.get("icon-ignore-placement"), K = q && G, W = this._inProgressLayer = this._inProgressLayer || new rp(R), oe = s.C(C.source, C.scope);
                        if (W.continuePlacement(O || K ? _[oe] : f[oe], this.placement, this._showCollisionBoxes, C, T, v))
                            return;
                        delete this._inProgressLayer;
                    }
                    this._currentPlacementIndex--;
                } this._done = !0; }
                commit(n) { return this.placement.commit(n), this.placement; }
            }
            const ea = 512 / s.aj / 2;
            class Us {
                constructor(n, l, f) { this.tileID = n, this.bucketInstanceId = f, this.index = new s.bW(l.length, 16, Int32Array), this.keys = [], this.crossTileIDs = []; const _ = n.canonical.x * s.aj, v = n.canonical.y * s.aj; for (let w = 0; w < l.length; w++) {
                    const { key: T, crossTileID: C, tileAnchorX: P, tileAnchorY: R } = l.get(w), O = Math.floor((_ + P) * ea), D = Math.floor((v + R) * ea);
                    this.index.add(O, D), this.keys.push(T), this.crossTileIDs.push(C);
                } this.index.finish(); }
                findMatches(n, l, f) { const _ = this.tileID.canonical.z < l.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - l.canonical.z), v = ea / Math.pow(2, l.canonical.z - this.tileID.canonical.z), w = l.canonical.x * s.aj, T = l.canonical.y * s.aj; for (let C = 0; C < n.length; C++) {
                    const P = n.get(C);
                    if (P.crossTileID)
                        continue;
                    const { key: R, tileAnchorX: O, tileAnchorY: D } = P, B = Math.floor((w + O) * v), q = Math.floor((T + D) * v), G = this.index.range(B - _, q - _, B + _, q + _).sort((K, W) => K - W);
                    for (const K of G) {
                        const W = this.crossTileIDs[K];
                        if (this.keys[K] === R && !f.has(W)) {
                            f.add(W), P.crossTileID = W;
                            break;
                        }
                    }
                } }
            }
            class _0 {
                constructor() { this.maxCrossTileID = 0; }
                generate() { return ++this.maxCrossTileID; }
            }
            class bu {
                constructor() { this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0; }
                handleWrapJump(n) { const l = Math.round((n - this.lng) / 360); if (l !== 0)
                    for (const f in this.indexes) {
                        const _ = this.indexes[f], v = {};
                        for (const w in _) {
                            const T = _[w];
                            T.tileID = T.tileID.unwrapTo(T.tileID.wrap + l), v[T.tileID.key] = T;
                        }
                        this.indexes[f] = v;
                    } this.lng = n; }
                addBucket(n, l, f) { if (this.indexes[n.overscaledZ] && this.indexes[n.overscaledZ][n.key]) {
                    if (this.indexes[n.overscaledZ][n.key].bucketInstanceId === l.bucketInstanceId)
                        return !1;
                    this.removeBucketCrossTileIDs(n.overscaledZ, this.indexes[n.overscaledZ][n.key]);
                } for (let v = 0; v < l.symbolInstances.length; v++)
                    l.symbolInstances.get(v).crossTileID = 0; this.usedCrossTileIDs[n.overscaledZ] || (this.usedCrossTileIDs[n.overscaledZ] = new Set); const _ = this.usedCrossTileIDs[n.overscaledZ]; for (const v in this.indexes) {
                    const w = this.indexes[v];
                    if (Number(v) > n.overscaledZ)
                        for (const T in w) {
                            const C = w[T];
                            C.tileID.isChildOf(n) && C.findMatches(l.symbolInstances, n, _);
                        }
                    else {
                        const T = w[n.scaledTo(Number(v)).key];
                        T && T.findMatches(l.symbolInstances, n, _);
                    }
                } for (let v = 0; v < l.symbolInstances.length; v++) {
                    const w = l.symbolInstances.get(v);
                    w.crossTileID || (w.crossTileID = f.generate(), _.add(w.crossTileID));
                } return this.indexes[n.overscaledZ] === void 0 && (this.indexes[n.overscaledZ] = {}), this.indexes[n.overscaledZ][n.key] = new Us(n, l.symbolInstances, l.bucketInstanceId), !0; }
                removeBucketCrossTileIDs(n, l) { for (const f of l.crossTileIDs)
                    this.usedCrossTileIDs[n].delete(f); }
                removeStaleBuckets(n) { let l = !1; for (const f in this.indexes) {
                    const _ = this.indexes[f];
                    for (const v in _)
                        n[_[v].bucketInstanceId] || (this.removeBucketCrossTileIDs(f, _[v]), delete _[v], l = !0);
                } return l; }
            }
            class ji {
                constructor() { this.layerIndexes = {}, this.crossTileIDs = new _0, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}; }
                addLayer(n, l, f, _) { let v = this.layerIndexes[n.fqid]; v === void 0 && (v = this.layerIndexes[n.fqid] = new bu); let w = !1; const T = {}; _.name !== "globe" && v.handleWrapJump(f); for (const C of l) {
                    const P = C.getBucket(n);
                    P && n.fqid === P.layerIds[0] && (P.bucketInstanceId || (P.bucketInstanceId = ++this.maxBucketInstanceId), v.addBucket(C.tileID, P, this.crossTileIDs) && (w = !0), T[P.bucketInstanceId] = !0);
                } return v.removeStaleBuckets(T) && (w = !0), w; }
                pruneUnusedLayers(n) { const l = {}; n.forEach(f => { l[f] = !0; }); for (const f in this.layerIndexes)
                    l[f] || delete this.layerIndexes[f]; }
            }
            const Ms = 771;
            class Rr {
                constructor(n, l, f, _) { this.blendFunction = n, this.blendColor = l, this.mask = f, this.blendEquation = _; }
            }
            Rr.Replace = [1, 0, 1, 0], Rr.disabled = new Rr(Rr.Replace, s.am.transparent, [!1, !1, !1, !1]), Rr.unblended = new Rr(Rr.Replace, s.am.transparent, [!0, !0, !0, !0]), Rr.alphaBlended = new Rr([1, Ms, 1, Ms], s.am.transparent, [!0, !0, !0, !0]), Rr.alphaBlendedNonPremultiplied = new Rr([770, Ms, 770, Ms], s.am.transparent, [!0, !0, !0, !0]), Rr.multiply = new Rr([774, 0, 774, 0], s.am.transparent, [!0, !0, !0, !0]);
            class Ut {
                constructor(n, l, f) { this.func = n, this.mask = l, this.range = f; }
            }
            Ut.ReadOnly = !1, Ut.ReadWrite = !0, Ut.disabled = new Ut(519, Ut.ReadOnly, [0, 1]);
            const yd = 7680;
            class dr {
                constructor(n, l, f, _, v, w) { this.test = n, this.ref = l, this.mask = f, this.fail = _, this.depthFail = v, this.pass = w; }
            }
            dr.disabled = new dr({ func: 519, mask: 0 }, 0, 0, yd, yd, yd);
            const Sc = 1029, Tu = 2305;
            class fr {
                constructor(n, l, f) { this.enable = n, this.mode = l, this.frontFace = f; }
            }
            function y0(d, n) { const l = s.c1(d, 3); s.c3(d, n), s.c7(d, 3, l); }
            function ta(d, n) { const l = s.bY([]); return s.bZ(l, l, -n), s.b_(l, l, -d), l; }
            function v0(d, n) { const l = [d[0], d[1], 0], f = [n[0], n[1], 0]; if (s.ae(l) >= 1e-15) {
                const w = s.au([], l);
                s.b$(f, w, s.bE(f, w)), n[0] = f[0], n[1] = f[1];
            } const _ = s.bG([], n, d); if (s.c0(_) < 1e-15)
                return null; const v = Math.atan2(-_[1], _[0]); return ta(Math.atan2(Math.sqrt(d[0] * d[0] + d[1] * d[1]), -d[2]), v); }
            fr.disabled = new fr(!1, Sc, Tu), fr.backCCW = new fr(!0, Sc, Tu), fr.backCW = new fr(!0, Sc, 2304), fr.frontCW = new fr(!0, 1028, 2304), fr.frontCCW = new fr(!0, 1028, Tu);
            class np {
                constructor(n, l) { this.position = n, this.orientation = l; }
                get position() { return this._position; }
                set position(n) { if (n) {
                    const l = n instanceof s.ac ? n : new s.ac(n[0], n[1], n[2]);
                    this._renderWorldCopies && (l.x = s.bX(l.x, 0, 1)), this._position = l;
                }
                else
                    this._position = null; }
                lookAtPoint(n, l) { if (this.orientation = null, !this.position)
                    return; const f = this.position, _ = this._elevation ? this._elevation.getAtPointOrZero(s.ac.fromLngLat(n)) : 0, v = s.ac.fromLngLat(n, _), w = [v.x - f.x, v.y - f.y, v.z - f.z]; l || (l = [0, 0, 1]), l[2] = Math.abs(l[2]), this.orientation = v0(w, l); }
                setPitchBearing(n, l) { this.orientation = ta(s.al(n), s.al(-l)); }
            }
            class vs {
                constructor(n, l) { this._transform = s.bx([]), this.orientation = l, this.position = n; }
                get mercatorPosition() { const n = this.position; return new s.ac(n[0], n[1], n[2]); }
                get position() { const n = s.c1(this._transform, 3); return [n[0], n[1], n[2]]; }
                set position(n) { var l; n && s.c7(this._transform, 3, [(l = n)[0], l[1], l[2], 1]); }
                get orientation() { return this._orientation; }
                set orientation(n) { this._orientation = n || s.bY([]), n && y0(this._transform, this._orientation); }
                getPitchBearing() { const n = this.forward(), l = this.right(); return { bearing: Math.atan2(-l[1], l[0]), pitch: Math.atan2(Math.sqrt(n[0] * n[0] + n[1] * n[1]), -n[2]) }; }
                setPitchBearing(n, l) { this._orientation = ta(n, l), y0(this._transform, this._orientation); }
                forward() { const n = s.c1(this._transform, 2); return [-n[0], -n[1], -n[2]]; }
                up() { const n = s.c1(this._transform, 1); return [-n[0], -n[1], -n[2]]; }
                right() { const n = s.c1(this._transform, 0); return [n[0], n[1], n[2]]; }
                getCameraToWorld(n, l) { const f = new Float64Array(16); return s.bi(f, this.getWorldToCamera(n, l)), f; }
                getCameraToWorldMercator() { return this._transform; }
                getWorldToCameraPosition(n, l, f) { const _ = this.position; s.b$(_, _, -n); const v = new Float64Array(16); return s.bn(v, [f, f, f]), s.bo(v, v, _), v[10] *= l, v; }
                getWorldToCamera(n, l) { const f = new Float64Array(16), _ = new Float64Array(4), v = this.position; return s.c2(_, this._orientation), s.b$(v, v, -n), s.c3(f, _), s.bo(f, f, v), f[1] *= -1, f[5] *= -1, f[9] *= -1, f[13] *= -1, f[8] *= l, f[9] *= l, f[10] *= l, f[11] *= l, f; }
                getCameraToClipPerspective(n, l, f, _) { const v = new Float64Array(16); return s.c4(v, n, l, f, _), v; }
                getCameraToClipOrthographic(n, l, f, _, v, w) { const T = new Float64Array(16); return s.c5(T, n, l, f, _, v, w), T; }
                getDistanceToElevation(n, l = !1) { const f = n === 0 ? 0 : s.c6(n, l ? s.aY(this.position[1]) : this.position[1]), _ = this.forward(); return (f - this.position[2]) / _[2]; }
                clone() { return new vs([...this.position], [...this.orientation]); }
            }
            const Rs = { BaseColor: 5, MetallicRoughness: 6, Normal: 7, Occlusion: 8, Emission: 9, LUT: 10, ShadowMap0: 11 };
            class Su {
                constructor(n = 0, l = 0, f = 0, _ = 0) { if (isNaN(n) || n < 0 || isNaN(l) || l < 0 || isNaN(f) || f < 0 || isNaN(_) || _ < 0)
                    throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers"); this.top = n, this.bottom = l, this.left = f, this.right = _; }
                interpolate(n, l, f) { return l.top != null && n.top != null && (this.top = s.ai(n.top, l.top, f)), l.bottom != null && n.bottom != null && (this.bottom = s.ai(n.bottom, l.bottom, f)), l.left != null && n.left != null && (this.left = s.ai(n.left, l.left, f)), l.right != null && n.right != null && (this.right = s.ai(n.right, l.right, f)), this; }
                getCenter(n, l) { const f = s.aD((this.left + n - this.right) / 2, 0, n), _ = s.aD((this.top + l - this.bottom) / 2, 0, l); return new s.P(f, _); }
                equals(n) { return this.top === n.top && this.bottom === n.bottom && this.left === n.left && this.right === n.right; }
                clone() { return new Su(this.top, this.bottom, this.left, this.right); }
                toJSON() { return { top: this.top, bottom: this.bottom, left: this.left, right: this.right }; }
            }
            const Rl = 15;
            class Ec {
                constructor(n, l, f, _, v, w, T) { this.tileSize = 512, this._renderWorldCopies = v === void 0 || v, this._minZoom = n || 0, this._maxZoom = l || 22, this._minPitch = f ?? 0, this._maxPitch = _ ?? 60, this.setProjection(w), this.setMaxBounds(T), this.width = 0, this.height = 0, this._center = new s.cd(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new Su, this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new vs, this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = !1, this._horizonShift = .1, this._orthographicProjectionAtLowPitch = !1, this._allowWorldUnderZoom = !1; }
                clone() { const n = new Ec(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection(), this.maxBounds); return n._elevation = this._elevation, n._centerAltitude = this._centerAltitude, n._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, n.tileSize = this.tileSize, n.mercatorFromTransition = this.mercatorFromTransition, n.width = this.width, n.height = this.height, n.cameraElevationReference = this.cameraElevationReference, n._center = this._center, n._setZoom(this.zoom), n._seaLevelZoom = this._seaLevelZoom, n.angle = this.angle, n._fov = this._fov, n._pitch = this._pitch, n._nearZ = this._nearZ, n._farZ = this._farZ, n._averageElevation = this._averageElevation, n._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, n._unmodified = this._unmodified, n._edgeInsets = this._edgeInsets.clone(), n._camera = this._camera.clone(), n._calcMatrices(), n.freezeTileCoverage = this.freezeTileCoverage, n.frustumCorners = this.frustumCorners, n._allowWorldUnderZoom = this._allowWorldUnderZoom, n; }
                get isOrthographic() { return this.projection.name !== "globe" && this._orthographicProjectionAtLowPitch && this.pitch < Rl; }
                get elevation() { return this._elevation; }
                set elevation(n) { this._elevation !== n && (this._elevation = n, this._updateCameraOnTerrain(), this._calcMatrices()); }
                get depthOcclusionForSymbolsAndCircles() { return this.projection.name !== "globe" && !this.isOrthographic; }
                updateElevation(n, l = !1) { const f = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration; (this._seaLevelZoom == null || f) && this._updateCameraOnTerrain(), (n || f) && this._constrainCamera(l), this._calcMatrices(); }
                getProjection() { return s.aF(this.projection, ["name", "center", "parallels"]); }
                setProjection(n) { this.projectionOptions = n || { name: "mercator" }; const l = this.projection ? this.getProjection() : void 0; this.projection = s.ce(this.projectionOptions); const f = this.getProjection(), _ = !s.bv(l, f); return _ && this._calcMatrices(), this.mercatorFromTransition = !1, _; }
                setOrthographicProjectionAtLowPitch(n) { return this._orthographicProjectionAtLowPitch !== n && (this._orthographicProjectionAtLowPitch = n, this._calcMatrices(), !0); }
                setMercatorFromTransition() { const n = this.projection.name; this.mercatorFromTransition = !0, this.projectionOptions = { name: "mercator" }, this.projection = s.ce({ name: "mercator" }); const l = n !== this.projection.name; return l && this._calcMatrices(), l; }
                get minZoom() { return this._minZoom; }
                set minZoom(n) { this._minZoom !== n && (this._minZoom = n, this.zoom = Math.max(this.zoom, n)); }
                get maxZoom() { return this._maxZoom; }
                set maxZoom(n) { this._maxZoom !== n && (this._maxZoom = n, this.zoom = Math.min(this.zoom, n)); }
                get minPitch() { return this._minPitch; }
                set minPitch(n) { this._minPitch !== n && (this._minPitch = n, this.pitch = Math.max(this.pitch, n)); }
                get maxPitch() { return this._maxPitch; }
                set maxPitch(n) { this._maxPitch !== n && (this._maxPitch = n, this.pitch = Math.min(this.pitch, n)); }
                get renderWorldCopies() { return this._renderWorldCopies && this.projection.supportsWorldCopies === !0; }
                set renderWorldCopies(n) { n === void 0 ? n = !0 : n === null && (n = !1), this._renderWorldCopies = n; }
                get worldSize() { return this.tileSize * this.scale; }
                get cameraWorldSizeForFog() { const n = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON); return this._worldSizeFromZoom(this._zoomFromMercatorZ(n)); }
                get cameraWorldSize() { const n = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON); return this._worldSizeFromZoom(this._zoomFromMercatorZ(n)); }
                get pixelsPerMeter() { return this.projection.pixelsPerMeter(this.center.lat, this.worldSize); }
                get cameraPixelsPerMeter() { return s.c6(1, this.center.lat) * this.cameraWorldSizeForFog; }
                get centerOffset() { return this.centerPoint._sub(this.size._div(2)); }
                get size() { return new s.P(this.width, this.height); }
                get bearing() { return s.bX(this.rotation, -180, 180); }
                set bearing(n) { this.rotation = n; }
                get rotation() { return -this.angle / Math.PI * 180; }
                set rotation(n) { const l = -n * Math.PI / 180; this.angle !== l && (this._unmodified = !1, this.angle = l, this._calcMatrices(), this.rotationMatrix = s.cf(), s.cg(this.rotationMatrix, this.rotationMatrix, this.angle)); }
                get pitch() { return this._pitch / Math.PI * 180; }
                set pitch(n) { const l = s.aD(n, this.minPitch, this.maxPitch) / 180 * Math.PI; this._pitch !== l && (this._unmodified = !1, this._pitch = l, this._calcMatrices()); }
                get aspect() { return this.width / this.height; }
                get fov() { return this._fov / Math.PI * 180; }
                set fov(n) { n = Math.max(.01, Math.min(60, n)), this._fov !== n && (this._unmodified = !1, this._fov = s.al(n), this._calcMatrices()); }
                get fovX() { return this._fov; }
                get fovY() { const n = 1 / Math.tan(.5 * this.fovX); return 2 * Math.atan(1 / this.aspect / n); }
                get averageElevation() { return this._averageElevation; }
                set averageElevation(n) { this._averageElevation = n, this._calcFogMatrices(), this._distanceTileDataCache = {}; }
                get zoom() { return this._zoom; }
                set zoom(n) { const l = Math.min(Math.max(n, this.minZoom), this.maxZoom); this._zoom !== l && (this._unmodified = !1, this._setZoom(l), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices()); }
                _setZoom(n) { this._zoom = n, this.scale = this.zoomScale(n), this.tileZoom = Math.floor(n), this.zoomFraction = n - this.tileZoom; }
                get tileCoverLift() { return this._tileCoverLift; }
                set tileCoverLift(n) { this._tileCoverLift !== n && (this._tileCoverLift = n); }
                _updateCameraOnTerrain() { const n = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, l = this.elevation && n === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration; if (!this._elevation || n === Number.NEGATIVE_INFINITY && (!l || !this._centerAltitude))
                    return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0); const f = this._elevation; l || this._centerAltitude && this._centerAltitudeValidForExaggeration && f.exaggeration() && this._centerAltitudeValidForExaggeration !== f.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * f.exaggeration(), this._centerAltitudeValidForExaggeration = f.exaggeration()) : (this._centerAltitude = n || 0, this._centerAltitudeValidForExaggeration = f.exaggeration()), this._updateSeaLevelZoom(); }
                _updateSeaLevelZoom() { this._centerAltitudeValidForExaggeration !== void 0 && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize)); }
                sampleAverageElevation() { if (!this._elevation)
                    return 0; const n = this._elevation, l = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]], f = this.horizonLineFromTop(); let _ = 0, v = 0; for (let w = 0; w < l.length; w++) {
                    const T = new s.P(l[w][0] * this.width, f + l[w][1] * (this.height - f)), C = n.pointCoordinate(T);
                    if (!C)
                        continue;
                    const P = 1 / Math.hypot(C[0] - this._camera.position[0], C[1] - this._camera.position[1]);
                    _ += C[3] * P, v += P;
                } return v === 0 ? NaN : _ / v; }
                get center() { return this._center; }
                set center(n) { n.lat === this._center.lat && n.lng === this._center.lng || (this._unmodified = !1, this._center = n, this._terrainEnabled() && (this.cameraElevationReference === "ground" ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices()); }
                _updateZoomFromElevation() { if (this._seaLevelZoom == null || !this._elevation)
                    return; const n = this._seaLevelZoom, l = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), f = this.pixelsPerMeter / this.worldSize * l, _ = this._mercatorZfromZoom(n), v = this._mercatorZfromZoom(this._maxZoom), w = Math.max(_ - f, v); this._setZoom(this._zoomFromMercatorZ(w)); }
                get padding() { return this._edgeInsets.toJSON(); }
                set padding(n) { this._edgeInsets.equals(n) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, n, 1), this._calcMatrices()); }
                computeZoomRelativeTo(n) { const l = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, n.toAltitude())); let f; f = n.z < this._camera.position[2] ? [l.x, l.y, l.z] : [n.x, n.y, n.z]; const _ = s.ae(s.at([], this._camera.position, f)); return s.aD(this._zoomFromMercatorZ(_), this._minZoom, this._maxZoom); }
                setFreeCameraOptions(n) { if (!this.height || !n.position && !n.orientation)
                    return; this._updateCameraState(); let l = !1; if (n.orientation && !s.ch(n.orientation, this._camera.orientation) && (l = this._setCameraOrientation(n.orientation)), n.position) {
                    const f = [n.position.x, n.position.y, n.position.z];
                    s.ci(f, this._camera.position) || (this._setCameraPosition(f), l = !0);
                } l && (this._updateStateFromCamera(), this.recenterOnTerrain()); }
                getFreeCameraOptions() { this._updateCameraState(); const n = this._camera.position, l = new np; return l.position = new s.ac(n[0], n[1], n[2]), l.orientation = this._camera.orientation, l._elevation = this.elevation, l._renderWorldCopies = this.renderWorldCopies, l; }
                _setCameraOrientation(n) { if (!s.cj(n))
                    return !1; s.ck(n, n); const l = s.cl([], [0, 0, -1], n), f = s.cl([], [0, -1, 0], n); if (f[2] < 0)
                    return !1; const _ = v0(l, f); return !!_ && (this._camera.orientation = _, !0); }
                _setCameraPosition(n) { const l = this.zoomScale(this.minZoom) * this.tileSize, f = this.zoomScale(this.maxZoom) * this.tileSize, _ = this.cameraToCenterDistance; n[2] = s.aD(n[2], _ / f, _ / l), this._camera.position = n; }
                get centerPoint() { return this._edgeInsets.getCenter(this.width, this.height); }
                get fovAboveCenter() { return this._fov * (.5 + this.centerOffset.y / this.height); }
                isPaddingEqual(n) { return this._edgeInsets.equals(n); }
                interpolatePadding(n, l, f) { this._unmodified = !1, this._edgeInsets.interpolate(n, l, f), this._constrain(), this._calcMatrices(); }
                coveringZoomLevel(n) { const l = (n.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / n.tileSize)); return Math.max(0, l); }
                getVisibleUnwrappedCoordinates(n) { const l = [new s.cm(0, n)]; if (this.renderWorldCopies) {
                    const f = this.pointCoordinate(new s.P(0, 0)), _ = this.pointCoordinate(new s.P(this.width, 0)), v = this.pointCoordinate(new s.P(this.width, this.height)), w = this.pointCoordinate(new s.P(0, this.height)), T = Math.floor(Math.min(f.x, _.x, v.x, w.x)), C = Math.floor(Math.max(f.x, _.x, v.x, w.x)), P = 1;
                    for (let R = T - P; R <= C + P; R++)
                        R !== 0 && l.push(new s.cm(R, n));
                } return l; }
                isLODDisabled(n) { return (!n || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace; }
                extendTileCover(n, l, f) { let _ = []; const v = f != null, w = !v; if (w && this.zoom < l || v && f[0] === 0 && f[1] === 0)
                    return _; const T = new Set, C = (R, O, D, B, q) => { const G = s.cK(O, R, D, B, q); T.has(G) || (_.push(new s.aM(R, O, D, B, q)), T.add(G)); }; for (let R = 0; R < n.length; R++) {
                    const O = n[R];
                    if (w && O.canonical.z !== l)
                        continue;
                    const D = O.canonical, B = O.overscaledZ, q = O.wrap, G = 1 << D.z, K = D.x + 1 < G, W = D.x > 0, oe = D.y + 1 < G, de = D.y > 0, me = O.wrap - (W ? 0 : 1), we = O.wrap + (K ? 0 : 1), ve = W ? D.x - 1 : G - 1, xe = K ? D.x + 1 : 0;
                    if (v)
                        f[0] < 0 ? (C(B, we, D.z, xe, D.y), f[1] < 0 && oe && (C(B, q, D.z, D.x, D.y + 1), C(B, we, D.z, xe, D.y + 1)), f[1] > 0 && de && (C(B, q, D.z, D.x, D.y - 1), C(B, we, D.z, xe, D.y - 1))) : f[0] > 0 ? (C(B, me, D.z, ve, D.y), f[1] < 0 && oe && (C(B, q, D.z, D.x, D.y + 1), C(B, me, D.z, ve, D.y + 1)), f[1] > 0 && de && (C(B, q, D.z, D.x, D.y - 1), C(B, me, D.z, ve, D.y - 1))) : f[1] < 0 && oe ? C(B, q, D.z, D.x, D.y + 1) : de && C(B, q, D.z, D.x, D.y - 1);
                    else {
                        const ge = O.visibleQuadrants;
                        1 & ge && (C(B, me, D.z, ve, D.y), de && (C(B, q, D.z, D.x, D.y - 1), C(B, me, D.z, ve, D.y - 1))), 2 & ge && (C(B, we, D.z, xe, D.y), de && (C(B, q, D.z, D.x, D.y - 1), C(B, we, D.z, xe, D.y - 1))), 4 & ge && (C(B, me, D.z, ve, D.y), oe && (C(B, q, D.z, D.x, D.y + 1), C(B, me, D.z, ve, D.y + 1))), 8 & ge && (C(B, we, D.z, xe, D.y), oe && (C(B, q, D.z, D.x, D.y + 1), C(B, we, D.z, xe, D.y + 1)));
                    }
                } const P = []; for (const R of _)
                    _.some(O => R.isChildOf(O)) || P.push(R); if (_ = P.filter(R => !n.some(O => !!(R.overscaledZ < l && O.isChildOf(R)) || R.equals(O) || R.isChildOf(O))), w) {
                    const R = 1 << l, O = this.projection.name === "globe" ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), D = [R * O.x, R * O.y], B = 4, q = B * B;
                    _ = _.filter(G => { const K = G.canonical.x + .5 - D[0], W = G.canonical.y + .5 - D[1]; return K * K + W * W < q; });
                } return _; }
                coveringTiles(n) { let l = this.coveringZoomLevel(n); const f = l, _ = this.elevation && this.elevation.exaggeration(), v = _ && !n.isTerrainDEM, w = this.projection.name === "mercator"; if (n.minzoom !== void 0 && l < n.minzoom)
                    return []; n.maxzoom !== void 0 && l > n.maxzoom && (l = n.maxzoom); const T = this.locationCoordinate(this.center), C = this.center.lat, P = 1 << l, R = [P * T.x, P * T.y, 0], O = this.projection.name === "globe", D = !O, B = s.cn.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, l, D), q = O ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), G = P * s.c6(1, this.center.lat), K = this._camera.position[2] / s.c6(1, this.center.lat), W = [P * q.x, P * q.y, K * (D ? 1 : G)], oe = O || _, de = this.cameraToCenterDistance / n.tileSize * (n.roundZoom ? 1 : .502), me = this.isLODDisabled(!0) ? l : 0; let we; if (this._elevation && n.isTerrainDEM)
                    we = 1e4 * this._elevation.exaggeration();
                else if (this._elevation) {
                    const Le = this._elevation.getMinMaxForVisibleTiles();
                    we = Le ? Le.max : this._centerAltitude;
                }
                else
                    we = this._centerAltitude; const ve = n.isTerrainDEM ? -we : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, xe = this.projection.isReprojectedInTileSpace ? s.co(this) : 1, ge = Le => { const He = new s.ac(Le.x + 25e-6, Le.y, Le.z), ht = new s.ac(Le.x, Le.y + 25e-6, Le.z), nt = Le.toLngLat(), dt = He.toLngLat(), ft = ht.toLngLat(), Vt = this.locationCoordinate(nt), Xt = this.locationCoordinate(dt), Bt = this.locationCoordinate(ft), Yt = Math.hypot(Xt.x - Vt.x, Xt.y - Vt.y), $t = Math.hypot(Bt.x - Vt.x, Bt.y - Vt.y); return Math.sqrt(Yt * $t) * xe / 25e-6; }, Se = Le => { const st = we, He = ve; return { aabb: s.cr(this, P, 0, 0, 0, Le, He, st, this.projection), zoom: 0, x: 0, y: 0, minZ: He, maxZ: st, wrap: Le, fullyVisible: !1 }; }, Ce = []; let je = []; const ze = l, rt = n.reparseOverscaled ? f : l, et = (K - this._centerAltitude) * G, vt = Le => { if (!this._elevation || !Le.tileID || !w)
                    return; const st = this._elevation.getMinMaxForTile(Le.tileID), He = Le.aabb; st ? (He.min[2] = st.min, He.max[2] = st.max, He.center[2] = (He.min[2] + He.max[2]) / 2) : (Le.shouldSplit = Ve(Le), Le.shouldSplit || (He.min[2] = He.max[2] = He.center[2] = this._centerAltitude)); }, Fe = (Le, st) => { if (.707 * st < Le)
                    return 1; const He = st / Le; return He / (1.4144271570014144 + (Math.pow(1.1, He - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1); }, Ve = Le => { if (Le.zoom < me)
                    return !0; if (Le.zoom === ze)
                    return !1; if (Le.shouldSplit != null)
                    return Le.shouldSplit; const st = Le.aabb.distanceX(W), He = Le.aabb.distanceY(W); let ht = et, nt = 1; if (O) {
                    ht = Le.aabb.distanceZ(W);
                    const $t = Math.pow(2, Le.zoom), or = s.aY((Le.y + 1) / $t), mr = s.aY(Le.y / $t), Nr = Math.min(Math.max(C, or), mr), vn = s.cP(Nr) / s.cP(C);
                    if (nt = Nr === C ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, vn / this._mercatorScaleRatio), this.zoom <= s.cL && Le.zoom === ze - 1 && vn >= .9)
                        return !0;
                }
                else if (v && (ht = Le.aabb.distanceZ(W) * G), this.projection.isReprojectedInTileSpace && f <= 5) {
                    const $t = Math.pow(2, Le.zoom), or = ge(new s.ac((Le.x + .5) / $t, (Le.y + .5) / $t));
                    nt = or > .85 ? 1 : or;
                } if (!w) {
                    const $t = Math.sqrt(st * st + He * He + ht * ht);
                    let or = (1 << ze - Le.zoom) * de * nt;
                    return or *= Fe(Math.max(ht, et), $t), $t < or;
                } let dt = Number.MAX_VALUE, ft = 0; const Vt = Le.aabb.getCorners(), Xt = []; for (const $t of Vt) {
                    s.at(Xt, $t, W), O || (v ? Xt[2] *= G : Xt[2] = et);
                    const or = s.bE(Xt, this._camera.forward());
                    or < dt && (dt = or, ft = Math.abs(Xt[2]));
                } let Bt = (1 << ze - Le.zoom) * de * nt; if (Bt *= Fe(Math.max(ft, et), dt), dt < Bt)
                    return !0; const Yt = Le.aabb.closestPoint(R); return Yt[0] === R[0] && Yt[1] === R[1]; }; if (this.renderWorldCopies)
                    for (let Le = 1; Le <= 3; Le++)
                        Ce.push(Se(-Le)), Ce.push(Se(Le)); for (Ce.push(Se(0)); Ce.length > 0;) {
                    const Le = Ce.pop(), st = Le.x, He = Le.y;
                    let ht = Le.fullyVisible;
                    const nt = () => this.projection.name === "globe" && (Le.y === 0 || Le.y === (1 << Le.zoom) - 1);
                    if (!ht) {
                        let dt = oe ? Le.aabb.intersects(B) : Le.aabb.intersectsFlat(B);
                        if (dt === 0 && nt()) {
                            const ft = new s.cp(Le.zoom, st, He);
                            dt = s.cq(this, P, ft, !0).intersects(B);
                        }
                        if (dt === 0)
                            continue;
                        ht = dt === 2;
                    }
                    if (Le.zoom !== ze && Ve(Le))
                        for (let dt = 0; dt < 4; dt++) {
                            const ft = (st << 1) + dt % 2, Vt = (He << 1) + (dt >> 1), Xt = { aabb: w ? Le.aabb.quadrant(dt) : s.cr(this, P, Le.zoom + 1, ft, Vt, Le.wrap, Le.minZ, Le.maxZ, this.projection), zoom: Le.zoom + 1, x: ft, y: Vt, wrap: Le.wrap, fullyVisible: ht, tileID: void 0, shouldSplit: void 0, minZ: Le.minZ, maxZ: Le.maxZ };
                            v && !O && (Xt.tileID = new s.aM(Le.zoom + 1 === ze ? rt : Le.zoom + 1, Le.wrap, Le.zoom + 1, ft, Vt), vt(Xt)), Ce.push(Xt);
                        }
                    else {
                        const dt = Le.zoom === ze ? rt : Le.zoom;
                        if (n.minzoom && n.minzoom > dt)
                            continue;
                        let ft = 0;
                        if (!ht) {
                            let Yt = oe ? Le.aabb.intersectsPrecise(B) : Le.aabb.intersectsPreciseFlat(B);
                            if (Yt === 0 && nt()) {
                                const $t = new s.cp(Le.zoom, st, He);
                                Yt = s.cq(this, P, $t, !0).intersectsPrecise(B);
                            }
                            if (Yt === 0)
                                continue;
                            if (n.calculateQuadrantVisibility)
                                if (B.containsPoint(Le.aabb.center))
                                    ft = 15;
                                else
                                    for (let $t = 0; $t < 4; $t++)
                                        Le.aabb.quadrant($t).intersects(B) !== 0 && (ft |= 1 << $t);
                        }
                        const Vt = R[0] - (.5 + st + (Le.wrap << Le.zoom)) * (1 << l - Le.zoom), Xt = R[1] - .5 - He, Bt = Le.tileID ? Le.tileID : new s.aM(dt, Le.wrap, Le.zoom, st, He);
                        n.calculateQuadrantVisibility && (Bt.visibleQuadrants = ft), je.push({ tileID: Bt, distanceSq: Vt * Vt + Xt * Xt });
                    }
                } if (this.fogCullDistSq) {
                    const Le = this.fogCullDistSq, st = this.horizonLineFromTop();
                    je = je.filter(He => { const ht = [0, 0, 0, 1], nt = [s.aj, s.aj, 0, 1], dt = this.calculateFogTileMatrix(He.tileID.toUnwrapped()); s.aA(ht, ht, dt), s.aA(nt, nt, dt); const ft = s.cs([], ht, nt), Vt = s.ct([], ht, nt), Xt = s.cM(ft, Vt); if (Xt === 0)
                        return !0; let Bt = !1; const Yt = this._elevation; if (Yt && Xt > Le && st !== 0) {
                        const $t = this.calculateProjMatrix(He.tileID.toUnwrapped());
                        let or;
                        n.isTerrainDEM || (or = Yt.getMinMaxForTile(He.tileID)), or || (or = { min: ve, max: we });
                        const mr = s.cu(this.rotation), Nr = [mr[0] * s.aj, mr[1] * s.aj, or.max];
                        s.ad(Nr, Nr, $t), Bt = (1 - Nr[1]) * this.height * .5 < st;
                    } return Xt < Le || Bt; });
                } return je.sort((Le, st) => Le.distanceSq - st.distanceSq).map(Le => Le.tileID); }
                resize(n, l) { this.width = n, this.height = l, this.pixelsToGLUnits = [2 / n, -2 / l], this._constrain(), this._calcMatrices(); }
                get unmodified() { return this._unmodified; }
                zoomScale(n) { return Math.pow(2, n); }
                scaleZoom(n) { return Math.log(n) / Math.LN2; }
                project(n) { const l = s.aD(n.lat, -s.cv, s.cv), f = this.projection.project(n.lng, l); return new s.P(f.x * this.worldSize, f.y * this.worldSize); }
                unproject(n) { return this.projection.unproject(n.x / this.worldSize, n.y / this.worldSize); }
                get point() { return this.project(this.center); }
                get pointMerc() { return this.point._div(this.worldSize); }
                get pixelsPerMeterRatio() { return this.pixelsPerMeter / s.c6(1, this.center.lat) / this.worldSize; }
                setLocationAtPoint(n, l) { let f, _; const v = this.centerPoint; if (this.projection.name === "globe") {
                    const T = this.worldSize;
                    f = (l.x - v.x) / T, _ = (l.y - v.y) / T;
                }
                else {
                    const T = this.pointCoordinate(l), C = this.pointCoordinate(v);
                    f = T.x - C.x, _ = T.y - C.y;
                } const w = this.locationCoordinate(n); this.setLocation(new s.ac(w.x - f, w.y - _)); }
                setLocation(n) { this.center = this.coordinateLocation(n), this.projection.wrap && (this.center = this.center.wrap()); }
                locationPoint(n, l) { return this.projection.locationPoint(this, n, l); }
                locationPoint3D(n, l) { return this.projection.locationPoint(this, n, l, !0); }
                pointLocation(n) { return this.coordinateLocation(this.pointCoordinate(n)); }
                pointLocation3D(n, l) { return this.coordinateLocation(this.pointCoordinate3D(n, l)); }
                locationCoordinate(n, l) { const f = l ? s.c6(l, n.lat) : void 0, _ = this.projection.project(n.lng, n.lat); return new s.ac(_.x, _.y, f); }
                coordinateLocation(n) { return this.projection.unproject(n.x, n.y); }
                pointRayIntersection(n, l) { const f = l ?? this._centerAltitude, _ = [n.x, n.y, 0, 1], v = [n.x, n.y, 1, 1]; s.aA(_, _, this.pixelMatrixInverse), s.aA(v, v, this.pixelMatrixInverse); const w = v[3]; s.cw(_, _, 1 / _[3]), s.cw(v, v, 1 / w); const T = _[2], C = v[2]; return { p0: _, p1: v, t: T === C ? 0 : (f - T) / (C - T) }; }
                screenPointToMercatorRay(n) { const l = [n.x, n.y, 0, 1], f = [n.x, n.y, 1, 1]; return s.aA(l, l, this.pixelMatrixInverse), s.aA(f, f, this.pixelMatrixInverse), s.cw(l, l, 1 / l[3]), s.cw(f, f, 1 / f[3]), l[2] = s.c6(l[2], this._center.lat) * this.worldSize, f[2] = s.c6(f[2], this._center.lat) * this.worldSize, s.cw(l, l, 1 / this.worldSize), s.cw(f, f, 1 / this.worldSize), new s.av([l[0], l[1], l[2]], s.au([], s.at([], f, l))); }
                rayIntersectionCoordinate(n) { const { p0: l, p1: f, t: _ } = n, v = s.c6(l[2], this._center.lat), w = s.c6(f[2], this._center.lat); return new s.ac(s.ai(l[0], f[0], _) / this.worldSize, s.ai(l[1], f[1], _) / this.worldSize, s.ai(v, w, _)); }
                pointCoordinate(n, l = this._centerAltitude) { return this.projection.pointCoordinate(this, n.x, n.y, l); }
                pointCoordinate3D(n, l) { if (!this.elevation)
                    return this.pointCoordinate(n, l); let f = this.projection.pointCoordinate3D(this, n.x, n.y); if (f)
                    return new s.ac(f[0], f[1], f[2]); let _ = 0, v = this.horizonLineFromTop(); if (n.y > v)
                    return this.pointCoordinate(n, l); const w = .02 * v, T = n.clone(); for (let C = 0; C < 10 && v - _ > w; C++) {
                    T.y = s.ai(_, v, .66);
                    const P = this.projection.pointCoordinate3D(this, T.x, T.y);
                    P ? (v = T.y, f = P) : _ = T.y;
                } return f ? new s.ac(f[0], f[1], f[2]) : this.pointCoordinate(n); }
                isPointAboveHorizon(n) { return this.projection.isPointAboveHorizon(this, n); }
                isPointOnSurface(n) { if (n.y < 0 || n.y > this.height || n.x < 0 || n.x > this.width)
                    return !1; if (this.elevation || this.zoom >= s.cx)
                    return !this.isPointAboveHorizon(n); const l = this.pointCoordinate(n); return l.y >= 0 && l.y <= 1; }
                _coordinatePoint(n, l) { const f = l && this.elevation ? this.elevation.getAtPointOrZero(n, this._centerAltitude) : this._centerAltitude, _ = [n.x * this.worldSize, n.y * this.worldSize, f + n.toAltitude(), 1]; return s.aA(_, _, this.pixelMatrix), _[3] > 0 ? new s.P(_[0] / _[3], _[1] / _[3]) : new s.P(Number.MAX_VALUE, Number.MAX_VALUE); }
                _getBoundsNonRectangular() { const { top: n, left: l } = this._edgeInsets, f = this.height - this._edgeInsets.bottom, _ = this.width - this._edgeInsets.right, v = this.pointLocation3D(new s.P(l, n)), w = this.pointLocation3D(new s.P(_, n)), T = this.pointLocation3D(new s.P(_, f)), C = this.pointLocation3D(new s.P(l, f)); let P = Math.min(v.lng, w.lng, T.lng, C.lng), R = Math.max(v.lng, w.lng, T.lng, C.lng), O = Math.min(v.lat, w.lat, T.lat, C.lat), D = Math.max(v.lat, w.lat, T.lat, C.lat); const B = Math.pow(2, -this.zoom) / 16 * 270, q = this.projection.name === "globe" ? 1 : 4, G = (K, W, oe, de, me) => { const we = (K + oe) / 2, ve = (W + de) / 2, xe = new s.P(we, ve), { lng: ge, lat: Se } = this.pointLocation3D(xe), Ce = Math.max(0, P - ge, O - Se, ge - R, Se - D); P = Math.min(P, ge), R = Math.max(R, ge), O = Math.min(O, Se), D = Math.max(D, Se), (me < q || Ce > B) && (G(K, W, we, ve, me + 1), G(we, ve, oe, de, me + 1)); }; if (G(l, n, _, n, 1), G(_, n, _, f, 1), G(_, f, l, f, 1), G(l, f, l, n, 1), this.projection.name === "globe") {
                    const [K, W] = s.cy(this);
                    K ? (D = 90, R = 180, P = -180) : W && (O = -90, R = 180, P = -180);
                } return new s.aG(new s.cd(P, O), new s.cd(R, D)); }
                _getBoundsRectangular(n, l) { const { top: f, left: _ } = this._edgeInsets, v = this.height - this._edgeInsets.bottom, w = this.width - this._edgeInsets.right, T = new s.P(_, f), C = new s.P(w, f), P = new s.P(w, v), R = new s.P(_, v); let O = this.pointCoordinate(T, n), D = this.pointCoordinate(C, n); const B = this.pointCoordinate(P, l), q = this.pointCoordinate(R, l), G = (K, W) => (W.y - K.y) / (W.x - K.x); return O.y > 1 && D.y >= 0 ? O = new s.ac((1 - q.y) / G(q, O) + q.x, 1) : O.y < 0 && D.y <= 1 && (O = new s.ac(-q.y / G(q, O) + q.x, 0)), D.y > 1 && O.y >= 0 ? D = new s.ac((1 - B.y) / G(B, D) + B.x, 1) : D.y < 0 && O.y <= 1 && (D = new s.ac(-B.y / G(B, D) + B.x, 0)), new s.aG().extend(this.coordinateLocation(O)).extend(this.coordinateLocation(D)).extend(this.coordinateLocation(q)).extend(this.coordinateLocation(B)); }
                _getBoundsRectangularTerrain() { const n = this.elevation; if (!n.visibleDemTiles.length || n.isUsingMockSource())
                    return this._getBoundsRectangular(0, 0); const l = n.visibleDemTiles.reduce((f, _) => { if (_.dem) {
                    const v = _.dem.tree;
                    f.min = Math.min(f.min, v.minimums[0]), f.max = Math.max(f.max, v.maximums[0]);
                } return f; }, { min: Number.MAX_VALUE, max: 0 }); return this._getBoundsRectangular(l.min * n.exaggeration(), l.max * n.exaggeration()); }
                getBounds() { return this.projection.name === "mercator" || this.projection.name === "equirectangular" ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular(); }
                horizonLineFromTop(n = !0) { const l = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) - this.centerOffset.y, f = this.height / 2 - l * (1 - this._horizonShift); return n ? Math.max(0, f) : f; }
                getMaxBounds() { return this.maxBounds; }
                setMaxBounds(n) { this.maxBounds = n, this.minLat = -s.cv, this.maxLat = s.cv, this.minLng = -180, this.maxLng = 180, n && (this.minLat = n.getSouth(), this.maxLat = n.getNorth(), this.minLng = n.getWest(), this.maxLng = n.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = s.ay(this.minLng) * this.tileSize, this.worldMaxX = s.ay(this.maxLng) * this.tileSize, this.worldMinY = s.aH(this.maxLat) * this.tileSize, this.worldMaxY = s.aH(this.minLat) * this.tileSize, this._constrain(); }
                calculatePosMatrix(n, l) { return this.projection.createTileMatrix(this, l, n); }
                calculateDistanceTileData(n) { const l = n.key, f = this._distanceTileDataCache; if (f[l])
                    return f[l]; const _ = n.canonical, v = 1 / this.height, w = this.cameraWorldSize, T = w / this.zoomScale(_.z), C = (_.x + Math.pow(2, _.z) * n.wrap) * T, P = _.y * T, R = this.point; R.x *= w / this.worldSize, R.y *= w / this.worldSize; const O = this.angle, D = Math.sin(-O), B = -Math.cos(-O); return f[l] = { bearing: [D, B], center: [(R.x - C) * v, (R.y - P) * v], scale: T / s.aj * v }, f[l]; }
                calculateFogTileMatrix(n) { const l = n.key, f = this._fogTileMatrixCache; if (f[l])
                    return f[l]; const _ = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, n); return s.az(_, this.worldToFogMatrix, _), f[l] = new Float32Array(_), f[l]; }
                calculateProjMatrix(n, l = !1, f = !1) { const _ = n.key; let v; if (v = f ? this._expandedProjMatrixCache : l ? this._alignedProjMatrixCache : this._projMatrixCache, v[_])
                    return v[_]; const w = this.calculatePosMatrix(n, this.worldSize); let T; return T = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : f ? this.expandedFarZProjMatrix : l ? this.alignedProjMatrix : this.projMatrix, s.az(w, T, w), v[_] = new Float32Array(w), v[_]; }
                calculatePixelsToTileUnitsMatrix(n) { const l = n.tileID.key, f = this._pixelsToTileUnitsCache; if (f[l])
                    return f[l]; const _ = s.cz(n, this); return f[l] = _, f[l]; }
                customLayerMatrix() { return this.mercatorMatrix.slice(); }
                globeToMercatorMatrix() { if (this.projection.name === "globe") {
                    const n = 1 / this.worldSize, l = s.bn([], [n, n, n]);
                    return s.az(l, l, this.globeMatrix), l;
                } }
                recenterOnTerrain() { if (!this._elevation || this.projection.name === "globe")
                    return; const n = this._elevation; this._updateCameraState(); const l = s.c6(1, this._center.lat) * this.worldSize, f = this._computeCameraPosition(l), _ = this._camera.forward(), v = s.c6(1, this._center.lat); f[2] /= v, _[2] /= v, s.au(_, _); const w = n.raycast(f, _, n.exaggeration()); if (w) {
                    const T = s.bF([], f, _, w), C = new s.ac(T[0], T[1], s.c6(T[2], s.aY(T[1]))), P = (C.z + s.ae([C.x - f[0], C.y - f[1], C.z - f[2] * v])) * this._pixelsPerMercatorPixel;
                    this._seaLevelZoom = this._zoomFromMercatorZ(P), this._centerAltitude = C.toAltitude(), this._center = this.coordinateLocation(C), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
                } }
                _constrainCamera(n = !1) { if (!this._elevation)
                    return; const l = this._elevation, f = s.c6(1, this._center.lat) * this.worldSize, _ = this._computeCameraPosition(f), v = l.getAtPointOrZero(new s.ac(..._)), w = this.pixelsPerMeter / this.worldSize * v, T = this._minimumHeightOverTerrain(), C = _[2] - w; if (C <= T)
                    if (C < 0 || n) {
                        const P = this.locationCoordinate(this._center, this._centerAltitude), R = [_[0], _[1], P.z - _[2]], O = s.ae(R);
                        R[2] -= (T - C) / this._pixelsPerMercatorPixel;
                        const D = s.ae(R);
                        if (D === 0)
                            return;
                        s.b$(R, R, O / D * this._pixelsPerMercatorPixel), this._camera.position = [_[0], _[1], P.z * this._pixelsPerMercatorPixel - R[2]], this._updateStateFromCamera();
                    }
                    else
                        this._isCameraConstrained = !0; }
                _constrain() { if (!this.center || !this.width || !this.height || this._constraining)
                    return; this._constraining = !0; const n = this.projection.name === "globe" || this.mercatorFromTransition; if (this.projection.isReprojectedInTileSpace || n) {
                    const D = this.center;
                    return D.lat = s.aD(D.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !n) && (D.lng = s.aD(D.lng, this.minLng, this.maxLng)), this.center = D, void (this._constraining = !1);
                } const l = this._unmodified, { x: f, y: _ } = this.point; let v = 0, w = f, T = _; const C = this.width / 2, P = this.height / 2, R = this.worldMinY * this.scale, O = this.worldMaxY * this.scale; if (_ - P < R && (T = R + P), _ + P > O && (T = O - P), O - R < this.height && (v = Math.max(v, this.height / (O - R)), T = (O + R) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                    const D = this.worldMinX * this.scale, B = this.worldMaxX * this.scale, q = this.worldSize / 2 - (D + B) / 2;
                    w = (f + q + this.worldSize) % this.worldSize - q, w - C < D && (w = D + C), w + C > B && (w = B - C), B - D < this.width && (v = Math.max(v, this.width / (B - D)), w = (B + D) / 2);
                } w === f && T === _ || this._allowWorldUnderZoom || (this.center = this.unproject(new s.P(w, T))), v && !this._allowWorldUnderZoom && (this.zoom += this.scaleZoom(v)), this._constrainCamera(), this._unmodified = l, this._constraining = !1; }
                _minZoomForBounds() { let n = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY))); return this.maxBounds && (n = Math.max(n, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), n; }
                _maxCameraBoundsDistance() { return this._mercatorZfromZoom(this._minZoomForBounds()); }
                _calcMatrices() { if (!this.height)
                    return; const n = this.centerOffset, l = this.projection.name === "globe", f = this.pixelsPerMeter; this.projection.name === "globe" && (this._mercatorScaleRatio = s.c6(1, this.center.lat) / s.c6(1, s.cN)); const _ = s.cA(this.projection, this.zoom, this.width, this.height, 1024); this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, _), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50; const v = this.projection.zAxisUnit === "meters" ? f : 1, w = this._camera.getWorldToCamera(this.worldSize, v); let T; const C = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ); if (C[8] = 2 * -n.x / this.width, C[9] = 2 * n.y / this.height, this.isOrthographic) {
                    let Se = .5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(.5 * this._fov), Ce = Se * this.aspect, je = -Ce, ze = -Se;
                    Ce -= n.x, je -= n.x, Se += n.y, ze += n.y, T = this._camera.getCameraToClipOrthographic(je, Ce, ze, Se, this._nearZ, this._farZ), ((rt, et, vt, Fe) => { for (let Ve = 0; Ve < 16; Ve++)
                        rt[Ve] = s.ai(et[Ve], vt[Ve], Fe); })(T, T, C, s.cO(this.pitch >= Rl ? 1 : this.pitch / Rl));
                }
                else
                    T = C; const P = s.cB([], C, w); let R = s.cB([], T, w); if (this.projection.isReprojectedInTileSpace) {
                    const Se = this.locationCoordinate(this.center), Ce = s.bx([]);
                    s.bo(Ce, Ce, [Se.x * this.worldSize, Se.y * this.worldSize, 0]), s.az(Ce, Ce, s.cC(this)), s.bo(Ce, Ce, [-Se.x * this.worldSize, -Se.y * this.worldSize, 0]), s.az(R, R, Ce), s.az(P, P, Ce), this.inverseAdjustmentMatrix = s.cD(this);
                }
                else
                    this.inverseAdjustmentMatrix = [1, 0, 0, 1]; if (this.mercatorMatrix = s.cE([], R, [this.worldSize, this.worldSize, this.worldSize / v, 1]), this.projMatrix = R, this.invProjMatrix = s.bi(new Float64Array(16), this.projMatrix), l) {
                    const Se = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
                    Se[8] = 2 * -n.x / this.width, Se[9] = 2 * n.y / this.height, this.expandedFarZProjMatrix = s.cB([], Se, w);
                }
                else
                    this.expandedFarZProjMatrix = this.projMatrix; const O = s.bi([], T); this.frustumCorners = s.cF.fromInvProjectionMatrix(O, this.horizonLineFromTop(), this.height), this.cameraFrustum = s.cn.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !l); const D = new Float32Array(16); s.bx(D), s.cE(D, D, [1, -1, 1]), s.cG(D, D, this._pitch), s.by(D, D, this.angle); const B = s.c4(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ); this.starsProjMatrix = s.bw(B); const q = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift; B[8] = 2 * -n.x / this.width, B[9] = 2 * (n.y + q) / this.height, this.skyboxMatrix = s.az(D, B, D); const G = this.point, K = G.x, W = G.y, oe = this.width % 2 / 2, de = this.height % 2 / 2, me = Math.cos(this.angle), we = Math.sin(this.angle), ve = K - Math.round(K) + me * oe + we * de, xe = W - Math.round(W) + me * de + we * oe, ge = new Float64Array(R); if (s.bo(ge, ge, [ve > .5 ? ve - 1 : ve, xe > .5 ? xe - 1 : xe, 0]), this.alignedProjMatrix = ge, R = s.bz(), s.cE(R, R, [this.width / 2, -this.height / 2, 1]), s.bo(R, R, [1, -1, 0]), this.labelPlaneMatrix = R, R = s.bz(), s.cE(R, R, [1, -1, 1]), s.bo(R, R, [-1, -1, 0]), s.cE(R, R, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = R, this.pixelMatrix = s.az(new Float64Array(16), this.labelPlaneMatrix, P), this._calcFogMatrices(), this._distanceTileDataCache = {}, R = s.bi(new Float64Array(16), this.pixelMatrix), !R)
                    throw new Error("failed to invert matrix"); if (this.pixelMatrixInverse = R, this.projection.name === "globe" || this.mercatorFromTransition) {
                    this.globeMatrix = s.cH(this);
                    const Se = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
                    this.globeCenterInViewSpace = s.ad(Se, Se, w), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
                }
                else
                    this.globeMatrix = R; this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {}; }
                _calcFogMatrices() { this._fogTileMatrixCache = {}; const n = this.cameraWorldSizeForFog, l = this.cameraPixelsPerMeter, f = this._camera.position, _ = 1 / this.height / this._pixelsPerMercatorPixel, v = [n, n, l]; s.b$(v, v, _), s.b$(f, f, -1), s.cI(f, f, v); const w = s.bz(); s.bo(w, w, f), s.cE(w, w, v), this.mercatorFogMatrix = w, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(n, l, _); }
                _computeCameraPosition(n) { const l = (n = n || this.pixelsPerMeter) / this.pixelsPerMeter, f = this._camera.forward(), _ = this.point, v = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * l - n / this.worldSize * this._centerAltitude; return [_.x / this.worldSize - f[0] * v, _.y / this.worldSize - f[1] * v, n / this.worldSize * this._centerAltitude - f[2] * v]; }
                _updateCameraState() { this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition()); }
                _translateCameraConstrained(n) { const l = this._maxCameraBoundsDistance() * Math.cos(this._pitch), f = this._camera.position[2], _ = n[2]; let v = 1; this.projection.wrap && (this.center = this.center.wrap()), _ > 0 && (v = Math.min((l - f) / _, 1)), this._camera.position = s.bF([], this._camera.position, n, v), this._updateStateFromCamera(); }
                _updateStateFromCamera() { const n = this._camera.position, l = this._camera.forward(), { pitch: f, bearing: _ } = this._camera.getPitchBearing(), v = s.c6(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, w = this._mercatorZfromZoom(this._maxZoom) * Math.cos(s.al(this._maxPitch)), T = Math.max((n[2] - v) / Math.cos(f), w), C = this._zoomFromMercatorZ(T); s.bF(n, n, l, T), this._pitch = s.aD(f, s.al(this.minPitch), s.al(this.maxPitch)), this.angle = s.bX(_, -Math.PI, Math.PI), this._setZoom(s.aD(C, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new s.ac(n[0], n[1], n[2])), this._unmodified = !1, this._constrain(), this._calcMatrices(); }
                _worldSizeFromZoom(n) { return Math.pow(2, n) * this.tileSize; }
                _mercatorZfromZoom(n) { return this.cameraToCenterDistance / this._worldSizeFromZoom(n); }
                _minimumHeightOverTerrain() { const n = Math.min(this._seaLevelZoom != null ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4; return this._mercatorZfromZoom(n); }
                _zoomFromMercatorZ(n) { return this.scaleZoom(this.cameraToCenterDistance / (n * this.tileSize)); }
                zoomFromMercatorZAdjusted(n) { let l = 0, f = s.cx, _ = 0, v = 1 / 0; for (; f - l > 1e-6 && f > l;) {
                    const w = l + .5 * (f - l), T = this.tileSize * Math.pow(2, w), C = this.getCameraToCenterDistance(this.projection, w, T), P = this.scaleZoom(C / (n * this.tileSize)), R = Math.abs(w - P);
                    R < v && (v = R, _ = w), w < P ? l = w : f = w;
                } return _; }
                _terrainEnabled() { return !(!this._elevation || !this.projection.supportsTerrain && (s.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1)); }
                anyCornerOffEdge(n, l) { const f = Math.min(n.x, l.x), _ = Math.max(n.x, l.x), v = Math.min(n.y, l.y), w = Math.max(n.y, l.y); if (v < this.horizonLineFromTop(!1))
                    return !0; if (this.projection.name !== "mercator")
                    return !1; const T = [new s.P(f, v), new s.P(_, w), new s.P(f, w), new s.P(_, v)], C = this.renderWorldCopies ? -3 : 0, P = this.renderWorldCopies ? 4 : 1; for (const R of T) {
                    const O = this.pointRayIntersection(R);
                    if (O.t < 0)
                        return !0;
                    const D = this.rayIntersectionCoordinate(O);
                    if (D.x < C || D.y < 0 || D.x > P || D.y > 1)
                        return !0;
                } return !1; }
                isHorizonVisible() { return this.pitch + s.cJ(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new s.P(0, 0), new s.P(this.width, this.height)); }
                zoomDeltaToMovement(n, l) { const f = s.ae(s.at([], this._camera.position, n)), _ = this._zoomFromMercatorZ(f) + l; return f - this._mercatorZfromZoom(_); }
                getCameraPoint() { if (this.projection.name === "globe") {
                    const n = function ([l, f, _], v) { const w = [l, f, _, 1]; s.aA(w, w, v); const T = w[3] = Math.max(w[3], 1e-6); return w[0] /= T, w[1] /= T, w[2] /= T, w; }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
                    return new s.P(n[0], n[1]);
                } {
                    const n = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                    return this.centerPoint.add(new s.P(0, n));
                } }
                getCameraToCenterDistance(n, l = this.zoom, f = this.worldSize) { const _ = s.cA(n, l, this.width, this.height, 1024), v = n.pixelSpaceConversion(this.center.lat, f, _); let w = .5 / Math.tan(.5 * this._fov) * this.height * v; return this.isOrthographic && (w = s.ai(1, w, s.cO(this.pitch >= Rl ? 1 : this.pitch / Rl))), w; }
                getWorldToCameraMatrix() { const n = this._camera.getWorldToCamera(this.worldSize, this.projection.zAxisUnit === "meters" ? this.pixelsPerMeter : 1); return this.projection.name === "globe" && s.az(n, n, this.globeMatrix), n; }
                getFrustum(n) { return s.cn.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, n, this.projection.zAxisUnit === "meters"); }
            }
            const Cc = (d, n) => { if (n > 0 && d.terrain && s.w("Cutoff is currently disabled on terrain"), n <= 0 || d.terrain)
                return { shouldRenderCutoff: !1, uniformValues: { u_cutoff_params: [0, 0, 0, 1] } }; const l = d.transform, f = Math.max(Math.abs(l._zoom - (d.minCutoffZoom - 1)), 1), _ = l.isLODDisabled(!1) ? s.af(60, 45, l.pitch) : s.af(30, 15, l.pitch), v = l._farZ - l._nearZ, w = n * l.height, T = ((1 - (C = _)) * l.cameraToCenterDistance + C * (l._farZ + w)) * f; var C; return { shouldRenderCutoff: _ < 1, uniformValues: { u_cutoff_params: [l._nearZ, l._farZ, (T - l._nearZ) / v, (T - w - l._nearZ) / v] } }; }, ks = { cascadeCount: 2, normalOffset: 3, shadowMapResolution: 2048 };
            class vd {
                constructor(n, l) { this.aabb = n, this.lastCascade = l; }
            }
            class xd {
                add(n, l) { const f = this.receivers[n.key]; f !== void 0 ? (f.aabb.min[0] = Math.min(f.aabb.min[0], l.min[0]), f.aabb.min[1] = Math.min(f.aabb.min[1], l.min[1]), f.aabb.min[2] = Math.min(f.aabb.min[2], l.min[2]), f.aabb.max[0] = Math.max(f.aabb.max[0], l.max[0]), f.aabb.max[1] = Math.max(f.aabb.max[1], l.max[1]), f.aabb.max[2] = Math.max(f.aabb.max[2], l.max[2])) : this.receivers[n.key] = new vd(l, null); }
                clear() { this.receivers = {}; }
                get(n) { return this.receivers[n.key]; }
                computeRequiredCascades(n, l, f) { const _ = s.cV.fromPoints(n.points); let v = 0; for (const w in this.receivers) {
                    const T = this.receivers[w];
                    if (!T || !_.intersectsAabb(T.aabb))
                        continue;
                    T.aabb.min = _.closestPoint(T.aabb.min), T.aabb.max = _.closestPoint(T.aabb.max);
                    const C = T.aabb.getCorners();
                    for (let P = 0; P < f.length; P++) {
                        let R = !0;
                        for (const O of C) {
                            const D = [O[0] * l, O[1] * l, O[2]];
                            if (s.ad(D, D, f[P].matrix), D[0] < -1 || D[0] > 1 || D[1] < -1 || D[1] > 1) {
                                R = !1;
                                break;
                            }
                        }
                        if (T.lastCascade = P, v = Math.max(v, P), R)
                            break;
                    }
                } return v + 1; }
            }
            class Zb {
                constructor(n) { this.painter = n, this._enabled = !1, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new xd, this._depthMode = new Ut(n.context.gl.LEQUAL, Ut.ReadWrite, [0, 1]), this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, .0012, .012], u_shadowmap_0: 0, u_shadowmap_1: 0 }, this._forceDisable = !1, this.useNormalOffset = !1, n.tp.registerParameter(this, ["Shadows"], "_forceDisable", { label: "forceDisable" }, () => { this.painter.style.map.triggerRepaint(); }), n.tp.registerParameter(ks, ["Shadows"], "cascadeCount", { min: 1, max: 2, step: 1 }), n.tp.registerParameter(ks, ["Shadows"], "normalOffset", { min: 0, max: 10, step: .05 }), n.tp.registerParameter(ks, ["Shadows"], "shadowMapResolution", { min: 32, max: 2048, step: 32 }), n.tp.registerBinding(this, ["Shadows"], "_numCascadesToRender", { readonly: !0, label: "numCascadesToRender" }); }
                destroy() { for (const n of this._cascades)
                    n.texture.destroy(), n.framebuffer.destroy(); this._cascades = []; }
                updateShadowParameters(n, l) { const f = this.painter; if (this._enabled = !1, this._shadowLayerCount = 0, this._receivers.clear(), !l || !l.properties)
                    return; const _ = l.properties.get("shadow-intensity"); if (!l.shadowsEnabled() || _ <= 0 || (this._shadowLayerCount = f.style.order.reduce((q, G) => { const K = f.style._mergedLayers[G]; return q + (K.hasShadowPass() && !K.isHidden(n.zoom) ? 1 : 0); }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled))
                    return; const v = f.context, w = ks.shadowMapResolution, T = ks.shadowMapResolution; if (this._cascades.length === 0 || ks.shadowMapResolution !== this._cascades[0].texture.size[0]) {
                    this._cascades = [];
                    for (let q = 0; q < ks.cascadeCount; ++q) {
                        const G = f._shadowMapDebug, K = v.gl, W = v.createFramebuffer(w, T, G, "texture"), oe = new s.T(v, { width: w, height: T, data: null }, K.DEPTH_COMPONENT16);
                        if (W.depthAttachment.set(oe.texture), G) {
                            const de = new s.T(v, { width: w, height: T, data: null }, K.RGBA8);
                            W.colorAttachment.set(de.texture);
                        }
                        this._cascades.push({ framebuffer: W, texture: oe, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new s.cn, scale: 0 });
                    }
                } this.shadowDirection = Ug(l); let C = 0; if (n.elevation) {
                    const q = n.elevation, G = [1e4, -1e4];
                    q.visibleDemTiles.filter(K => K.dem).forEach(K => { const W = K.dem.tree; G[0] = Math.min(G[0], W.minimums[0]), G[1] = Math.max(G[1], W.maximums[0]); }), G[0] !== 1e4 && (C = (G[1] - G[0]) * q.exaggeration());
                } const P = 1.5 * n.cameraToCenterDistance, R = 3 * P, O = new Float64Array(16); for (let q = 0; q < this._cascades.length; ++q) {
                    const G = this._cascades[q];
                    let K = n.height / 50, W = 1;
                    ks.cascadeCount === 1 ? W = R : q === 0 ? W = P : (K = P, W = R);
                    const [oe, de] = $g(n, this.shadowDirection, K, W, ks.shadowMapResolution, C);
                    G.scale = n.scale, G.matrix = oe, G.boundingSphereRadius = de, s.bi(O, G.matrix), G.frustum = s.cn.fromInvProjectionMatrix(O, 1, 0, !0), G.far = W;
                } const D = this._cascades.length - 1; this._uniformValues.u_fade_range = [.75 * this._cascades[D].far, this._cascades[D].far], this._uniformValues.u_shadow_intensity = _, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / ks.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = ks.shadowMapResolution, this._uniformValues.u_shadowmap_0 = Rs.ShadowMap0, this._uniformValues.u_shadowmap_1 = Rs.ShadowMap0 + 1, this._groundShadowTiles = f.transform.coveringTiles({ tileSize: 512, renderWorldCopies: !0 }); const B = f.transform.elevation; for (const q of this._groundShadowTiles) {
                    let G = { min: 0, max: 0 };
                    if (B) {
                        const K = B.getMinMaxForTile(q);
                        K && (G = K);
                    }
                    this.addShadowReceiver(q.toUnwrapped(), G.min, G.max);
                } }
                get enabled() { return this._enabled && !this._forceDisable; }
                set enabled(n) { this._enabled = n; }
                drawShadowPass(n, l) { if (!this.enabled)
                    return; const f = this.painter, _ = f.context; this._numCascadesToRender = this._receivers.computeRequiredCascades(f.transform.getFrustum(0), f.transform.worldSize, this._cascades), _.viewport.set([0, 0, ks.shadowMapResolution, ks.shadowMapResolution]); for (let v = 0; v < this._numCascadesToRender; ++v) {
                    f.currentShadowCascade = v, _.bindFramebuffer.set(this._cascades[v].framebuffer.framebuffer), _.clear({ color: s.am.white, depth: 1 });
                    for (const w of n.order) {
                        const T = n._mergedLayers[w];
                        if (!T.hasShadowPass() || T.isHidden(f.transform.zoom))
                            continue;
                        const C = n.getLayerSourceCache(T), P = C ? l[C.id] : void 0;
                        (T.type === "model" || P && P.length) && f.renderLayer(f, C, T, P);
                    }
                } f.currentShadowCascade = 0; }
                drawGroundShadows() { if (!this.enabled)
                    return; const n = this.painter, l = n.style, f = n.context, _ = l.directionalLight, v = l.ambientLight; if (!_ || !v)
                    return; const w = [], T = Cc(n, n.longestCutoffRange); T.shouldRenderCutoff && w.push("RENDER_CUTOFF"), w.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), this.useNormalOffset && w.push("NORMAL_OFFSET"); const C = Sa(l, _, v), P = new Ut(f.gl.LEQUAL, Ut.ReadOnly, n.depthRangeFor3D); for (const R of this._groundShadowTiles) {
                    const O = R.toUnwrapped(), D = n.isTileAffectedByFog(R), B = n.getOrCreateProgram("groundShadow", { defines: w, overrideFog: D });
                    this.setupShadows(O, B), n.uploadCommonUniforms(f, B, O, null, T);
                    const q = { u_matrix: n.transform.calculateProjMatrix(O), u_ground_shadow_factor: C };
                    B.draw(n, f.gl.TRIANGLES, P, dr.disabled, Rr.multiply, fr.disabled, q, "ground_shadow", n.tileExtentBuffer, n.quadTriangleIndexBuffer, n.tileExtentSegments, null, n.transform.zoom, null, null);
                } }
                getShadowPassColorMode() { return this.painter._shadowMapDebug ? Rr.unblended : Rr.disabled; }
                getShadowPassDepthMode() { return this._depthMode; }
                getShadowCastingLayerCount() { return this._shadowLayerCount; }
                calculateShadowPassMatrixFromTile(n) { const l = this.painter.transform, f = l.calculatePosMatrix(n, l.worldSize); return s.az(f, this._cascades[this.painter.currentShadowCascade].matrix, f), Float32Array.from(f); }
                calculateShadowPassMatrixFromMatrix(n) { return s.az(n, this._cascades[this.painter.currentShadowCascade].matrix, n), Float32Array.from(n); }
                setupShadows(n, l, f, _ = 0) { if (!this.enabled)
                    return; const v = this.painter.transform, w = this.painter.context, T = w.gl, C = this._uniformValues, P = new Float64Array(16), R = v.calculatePosMatrix(n, v.worldSize); for (let O = 0; O < this._cascades.length; O++)
                    s.az(P, this._cascades[O].matrix, R), C[O === 0 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(P), w.activeTexture.set(T.TEXTURE0 + Rs.ShadowMap0 + O), this._cascades[O].texture.bind(T.NEAREST, T.CLAMP_TO_EDGE); if (this.useNormalOffset = !!f, this.useNormalOffset) {
                    const O = s.cT(n.canonical), D = 2 / v.tileSize * s.aj / ks.shadowMapResolution, B = D * this._cascades[0].boundingSphereRadius, q = D * this._cascades[this._cascades.length - 1].boundingSphereRadius, G = (f === "vector-tile" ? 1 : 3) / Math.pow(2, _ - n.canonical.z - (1 - v.zoom + Math.floor(v.zoom)));
                    C.u_shadow_normal_offset = [O, B * G, q * G], C.u_shadow_bias = [6e-5, .0012, .012];
                }
                else
                    C.u_shadow_bias = [36e-5, .0012, .012]; l.setShadowUniformValues(w, C); }
                setupShadowsFromMatrix(n, l, f = !1) { if (!this.enabled)
                    return; const _ = this.painter.context, v = _.gl, w = this._uniformValues, T = new Float64Array(16); for (let C = 0; C < ks.cascadeCount; C++)
                    s.az(T, this._cascades[C].matrix, n), w[C === 0 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(T), _.activeTexture.set(v.TEXTURE0 + Rs.ShadowMap0 + C), this._cascades[C].texture.bind(v.NEAREST, v.CLAMP_TO_EDGE); if (this.useNormalOffset = f, f) {
                    const C = ks.normalOffset;
                    w.u_shadow_normal_offset = [1, C, C], w.u_shadow_bias = [6e-5, .0012, .012];
                }
                else
                    w.u_shadow_bias = [36e-5, .0012, .012]; l.setShadowUniformValues(_, w); }
                getShadowUniformValues() { return this._uniformValues; }
                getCurrentCascadeFrustum() { return this._cascades[this.painter.currentShadowCascade].frustum; }
                computeSimplifiedTileShadowVolume(n, l, f, _) { if (_[2] >= 0)
                    return {}; const v = function (C, P, R) { const O = R / (1 << C.canonical.z); return new s.cV([C.canonical.x * O + C.wrap * R, C.canonical.y * O + C.wrap * R, 0], [(C.canonical.x + 1) * O + C.wrap * R, (C.canonical.y + 1) * O + C.wrap * R, P]); }(n, l, f).getCorners(), w = l / -_[2]; _[0] < 0 ? (s.cU(v[0], v[0], [_[0] * w, 0, 0]), s.cU(v[3], v[3], [_[0] * w, 0, 0])) : _[0] > 0 && (s.cU(v[1], v[1], [_[0] * w, 0, 0]), s.cU(v[2], v[2], [_[0] * w, 0, 0])), _[1] < 0 ? (s.cU(v[0], v[0], [0, _[1] * w, 0]), s.cU(v[1], v[1], [0, _[1] * w, 0])) : _[1] > 0 && (s.cU(v[2], v[2], [0, _[1] * w, 0]), s.cU(v[3], v[3], [0, _[1] * w, 0])); const T = {}; return T.vertices = v, T.planes = [Ka(v[1], v[0], v[4]), Ka(v[2], v[1], v[5]), Ka(v[3], v[2], v[6]), Ka(v[0], v[3], v[7])], T; }
                addShadowReceiver(n, l, f) { this._receivers.add(n, s.cV.fromTileIdAndHeight(n, l, f)); }
                getMaxCascadeForTile(n) { const l = this._receivers.get(n); return l && l.lastCascade ? l.lastCascade : 0; }
            }
            function Ka(d, n, l) { const f = s.at([], l, n), _ = s.at([], d, n), v = s.bG([], f, _), w = s.ae(v); return w === 0 ? [0, 0, 1, 0] : (s.b$(v, v, 1 / w), [v[0], v[1], v[2], -s.bE(v, n)]); }
            function Ug(d) { const n = d.properties.get("direction"), l = s.cR(n.x, n.y, n.z); l[2] = s.aD(l[2], 0, 75); const f = s.cW([l[0], l[1], l[2]]); return s.cS(f.x, f.y, f.z); }
            function Sa(d, n, l) { const f = n.properties.get("color-use-theme") === "none", _ = n.properties.get("color"), v = n.properties.get("intensity"), w = n.properties.get("direction"), T = [w.x, w.y, w.z], C = l.properties.get("color-use-theme") === "none", P = l.properties.get("color"), R = l.properties.get("intensity"), O = Math.max(s.bE([0, 0, 1], T), 0), D = [0, 0, 0]; s.b$(D, P.toRenderColor(C ? null : d.getLut(n.scope)).toArray01Linear().slice(0, 3), R); const B = [0, 0, 0]; return s.b$(B, _.toRenderColor(f ? null : d.getLut(l.scope)).toArray01Linear().slice(0, 3), O * v), s.cX([D[0] > 0 ? D[0] / (D[0] + B[0]) : 0, D[1] > 0 ? D[1] / (D[1] + B[1]) : 0, D[2] > 0 ? D[2] / (D[2] + B[2]) : 0]); }
            function $g(d, n, l, f, _, v) { const w = d.zoom, T = d.scale, C = d.worldSize, P = 1 / C, R = d.aspect, O = Math.sqrt(1 + R * R) * Math.tan(.5 * d.fovX), D = O * O, B = f - l, q = f + l; let G, K; D > B / q ? (G = f, K = f * O) : (G = .5 * q * (1 + D), K = .5 * Math.sqrt(B * B + 2 * (f * f + l * l) * D + q * q * D * D)); const W = d.projection.pixelsPerMeter(d.center.lat, C), oe = d._camera.getCameraToWorldMercator(), de = [0, 0, -G * P]; s.ad(de, de, oe); let me = K * P; const we = d._edgeInsets; if (!(we.left === 0 && we.top === 0 && we.right === 0 && we.bottom === 0 || we.left === we.right && we.top === we.bottom)) {
                const ht = d._camera.getWorldToCamera(d.worldSize, d.projection.zAxisUnit === "meters" ? W : 1), nt = d._camera.getCameraToClipPerspective(d._fov, d.width / d.height, l, f);
                nt[8] = 2 * -d.centerOffset.x / d.width, nt[9] = 2 * d.centerOffset.y / d.height;
                const dt = new Float64Array(16);
                s.cB(dt, nt, ht);
                const ft = new Float64Array(16);
                s.bi(ft, dt);
                const Vt = s.cn.fromInvProjectionMatrix(ft, C, w, !0);
                for (const Xt of Vt.points) {
                    const Bt = ((ve = Xt)[0] /= T, ve[1] /= T, ve[2] = s.c6(ve[2], d._center.lat), ve);
                    me = Math.max(me, s.c0(s.cY([], de, Bt)));
                }
            } var ve; me *= _ / (_ - 1); const xe = Math.acos(n[2]), ge = Math.atan2(-n[0], -n[1]), Se = new vs; Se.position = de, Se.setPitchBearing(xe, ge); const Ce = Se.getWorldToCamera(C, W), je = me * C, ze = Math.min(d._mercatorZfromZoom(17) * C * -2, -2 * je), rt = Se.getCameraToClipOrthographic(-je, je, -je, je, ze, (je + v * W) / n[2]), et = new Float64Array(16); s.az(et, rt, Ce); const vt = s.cS(Math.floor(1e6 * de[0]) / 1e6 * C, Math.floor(1e6 * de[1]) / 1e6 * C, 0), Fe = .5 * _, Ve = [0, 0, 0]; s.ad(Ve, vt, et), s.b$(Ve, Ve, Fe); const Le = [Math.floor(Ve[0]), Math.floor(Ve[1]), Math.floor(Ve[2])], st = [0, 0, 0]; s.at(st, Ve, Le), s.b$(st, st, -1 / Fe); const He = new Float64Array(16); return s.bx(He), s.bo(He, He, st), s.az(et, He, et), [et, je]; }
            class kl extends s.E {
                constructor(n) { super(), this.requestManager = n, this.models = { "": {} }, this.modelUris = { "": {} }, this.modelByURL = {}, this.numModelsLoading = {}; }
                loadModel(n, l) { return s.aS(this.requestManager.transformRequest(l, s.R.Model).url).then(f => { if (!f)
                    return; const _ = s.aT(f), v = new s.aU(n, void 0, void 0, _); return v.computeBoundsAndApplyParent(), v; }).catch(f => { if (f && f.status === 404)
                    return null; this.fire(new s.z(new Error(`Could not load model ${n} from ${l}: ${f.message}`))); }); }
                load(n, l, f = { forceReload: !1 }) { this.models[l] || (this.models[l] = {}); const _ = Object.keys(n), v = [], w = []; for (const T of _) {
                    const C = n[T];
                    this.hasURLBeenRequested(C) && !f.forceReload || (this.modelByURL[C] = { modelId: T, scope: l }, v.push(this.loadModel(T, C)), w.push(T)), this.models[l][T] || (this.models[l][T] = { model: null, numReferences: 1 });
                } this.numModelsLoading[l] = (this.numModelsLoading[l] || 0) + w.length, Promise.allSettled(v).then(T => { for (let C = 0; C < T.length; C++) {
                    const { status: P } = T[C];
                    if (P === "rejected")
                        continue;
                    const { value: R } = T[C];
                    this.models[l][w[C]] || (this.models[l][w[C]] = { model: null, numReferences: 1 }), this.models[l][w[C]].model = R;
                } this.numModelsLoading[l] -= w.length, this.fire(new s.A("data", { dataType: "style" })); }).catch(T => { this.fire(new s.z(new Error(`Could not load models: ${T.message}`))); }); }
                isLoaded() { for (const n in this.numModelsLoading)
                    if (this.numModelsLoading[n] > 0)
                        return !1; return !0; }
                hasModel(n, l, f = { exactIdMatch: !1 }) { return !!(f.exactIdMatch ? this.getModel(n, l) : this.getModelByURL(this.modelUris[l][n])); }
                getModel(n, l) { return this.models[l] || (this.models[l] = {}), this.models[l][n] ? this.models[l][n].model : void 0; }
                getModelByURL(n) { if (!n)
                    return null; const l = this.modelByURL[n]; return l ? this.models[l.scope][l.modelId].model : null; }
                hasModelBeenAdded(n, l) { return this.models[l] && this.models[l][n] !== void 0; }
                getModelURIs(n) { return this.modelUris[n] || {}; }
                addModel(n, l, f) { this.models[f] || (this.models[f] = {}), this.modelUris[f] || (this.modelUris[f] = {}); const _ = this.requestManager.normalizeModelURL(l); if ((this.hasModel(n, f, { exactIdMatch: !0 }) || this.hasModelBeenAdded(n, f)) && this.modelUris[f][n] === _)
                    this.models[f][n].numReferences++;
                else if (this.hasURLBeenRequested(_)) {
                    const { scope: v, modelId: w } = this.modelByURL[_];
                    this.models[v][w].numReferences++;
                }
                else
                    this.modelUris[f][n] = _, this.load({ [n]: this.modelUris[f][n] }, f); }
                addModelURLs(n, l) { this.models[l] || (this.models[l] = {}), this.modelUris[l] || (this.modelUris[l] = {}); const f = this.modelUris[l]; for (const _ in n)
                    f[_] = this.requestManager.normalizeModelURL(n[_]); }
                reloadModels(n) { this.load(this.modelUris[n], n, { forceReload: !0 }); }
                addModelsFromBucket(n, l) { this.models[l] || (this.models[l] = {}), this.modelUris[l] || (this.modelUris[l] = {}); const f = {}; for (const _ of n)
                    this.hasModel(_, l, { exactIdMatch: !0 }) || this.hasURLBeenRequested(_) ? this.models[l][_].numReferences++ : this.modelUris[l][_] && !this.hasURLBeenRequested(_) ? f[_] = this.modelUris[l][_] : !this.hasURLBeenRequested(_) && s.cZ(_, !1) && (this.modelUris[l][_] = this.requestManager.normalizeModelURL(_), f[_] = this.modelUris[l][_]); this.load(f, l); }
                hasURLBeenRequested(n) { return this.modelByURL[n] !== void 0; }
                removeModel(n, l, f = !1) { if (this.models[l] && this.models[l][n] && (this.models[l][n].numReferences--, this.models[l][n].numReferences === 0)) {
                    const _ = this.modelUris[l][n];
                    f || delete this.modelUris[l][n], delete this.modelByURL[_];
                    const v = this.models[l][n].model;
                    if (!v)
                        return;
                    delete this.models[l][n], v.destroy();
                } }
                destroy() { for (const n of Object.keys(this.models))
                    for (const l of Object.keys(this.models[n])) {
                        const f = this.models[n][l].model;
                        delete this.models[n][l], f && f.destroy();
                    } this.models = { "": {} }, this.modelUris = { "": {} }, this.modelByURL = {}, this.numModelsLoading = {}; }
                listModels(n) { return this.models[n] || (this.models[n] = {}), Object.keys(this.models[n]); }
                upload(n, l) { this.models[l] || (this.models[l] = {}); for (const f in this.models[l])
                    this.models[l][f].model && this.models[l][f].model.upload(n.context); }
            }
            const Xb = new s.a7({ data: new s.a8(s.a5.colorTheme.data) }), Kb = { "mbx-indoor-active-floorplans": { default: ["literal", []] }, "mbx-indoor-underground": { default: ["literal", !1] }, "mbx-indoor-loaded-levels": { default: ["literal", []] }, "mbx-indoor-level-height": { default: ["literal", {}] }, "mbx-indoor-level-base": { default: ["literal", {}] }, "mbx-indoor-level-selected": { default: ["literal", {}] }, "mbx-indoor-level-overlapped": { default: ["literal", {}] } };
            function x0(d) { return d = d || {}, Object.assign(d, Kb); }
            class w0 extends s.E {
                constructor(n) { super(), this.mergeFloors = !0, this._scope = void 0, this._queryFeatureSetId = void 0, this._buildingEntryFeatureSetId = void 0, this._selectedFloorplan = void 0, this._indoorData = void 0, this._selectedLevel = void 0, this._floorplanStates = {}, s.aV(["_onLoad", "_onMove", "_checkFloorplanVisible"], this), this._map = n, this._checkFloorplanVisible(!0), this._map.on("load", this._onLoad), this._map.on("move", this._onMove); }
                destroy() { this._map.indoor.off("load", this._onLoad), this._map.indoor.off("move", this._onMove), this._map = void 0; }
                _onLoad() { this._map.style.forEachFragmentStyle(n => { n.stylesheet.indoor && (this._queryFeatureSetId ? this.fire(new s.z(new Error("Multiple indoor map styles detected, simultaneous usage is not allowed currently."))) : (this._queryFeatureSetId = n.stylesheet.indoor.floorplanFeaturesetId, this._buildingEntryFeatureSetId = n.stylesheet.indoor.buildingFeaturesetId, this._scope = n.scope)); }), this._queryFeatureSetId && this._buildingEntryFeatureSetId && this._map.addInteraction("mbx-indoor-buildingclick", { type: "click", target: { featuresetId: this._buildingEntryFeatureSetId, importId: this._scope }, handler: n => (n.feature && n.feature.properties.floorplan && this.selectFloorplan(n.feature.properties.floorplan), !0) }), this._checkFloorplanVisible(!0); }
                _onMove() { this._checkFloorplanVisible(!1); }
                _checkFloorplanVisible(n) { if (!this._queryFeatureSetId || !this._map.isStyleLoaded() || this._map.transform.zoom < 13)
                    return; this._indoorData && !function (w, T) { const [C, P] = w, { center: R, radius: O } = T, [D, B] = R, q = Math.abs(C - D); return Math.sqrt((q > 180 ? 360 - q : q) ** 2 + (P - B) ** 2) <= O; }([this._map.getCenter().lng, this._map.getCenter().lat], this._indoorData.circumCircle) && (this._indoorData = void 0, this._selectedFloorplan = void 0, this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !1), this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", ["literal", []]), this.fire(new s.A("floorplangone"))); const l = { target: { featuresetId: this._queryFeatureSetId, importId: this._scope } }, f = new s.P(this._map.transform.width / 2, this._map.transform.height / 2), _ = [new s.P(0, 0), new s.P(this._map.transform.width, this._map.transform.height)], v = this._map.queryRenderedFeatures(n ? _ : f, l); v.length > 0 && (this._selectedFloorplan && v[0].properties.id === this._selectedFloorplan.properties.id || (this._selectedFloorplan = v[0], this._floorplanSelected(!1))); }
                _floorplanSelected(n) { this._indoorData = JSON.parse(this._selectedFloorplan.properties["indoor-data"]), this._indoorData.id = this._selectedFloorplan.properties.id, this._indoorData.circumCircle = function (v) { const [[w, T], [C, P]] = v, R = (C - w + 360) % 360, O = R > 180 ? 360 - R : R; return { center: [(w + O / 2 + 360) % 360, (T + P) / 2], radius: Math.sqrt(O ** 2 + (P - T) ** 2) / 2 }; }(this._indoorData.extent), this._floorplanStates[this._indoorData.id] || (this._floorplanStates[this._indoorData.id] = {}); const l = this._floorplanStates[this._indoorData.id].selectedBuilding, f = this._floorplanStates[this._indoorData.id].selectedLevel; let _; if (this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", this._indoorData.floorplanIDs), this._selectedLevel)
                    for (const v of this._indoorData.levels)
                        v.id === this._selectedLevel.id && (_ = v.id); if (this.fire(new s.A("floorplanselected", { buildings: this._indoorData.buildings, levels: this._indoorData.levels, selectedLevelId: _ })), l) {
                    const v = this._indoorData.buildings.find(w => w.id === l);
                    this._buildingSelected(v, !1);
                }
                else
                    this._indoorData.buildings.length > 0 && this._buildingSelected(this._indoorData.buildings[0], !1); if (f) {
                    const v = this._indoorData.levels.find(w => w.id === f);
                    this._updateLevels(v, n);
                }
                else
                    n && this._indoorData["default-levels"].length > 0 && this.selectLevel(this._indoorData["default-levels"][0]); }
                _buildingSelected(n, l) { l && n && n.extent && this._map.fitBounds(n.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }), this._floorplanStates[this._indoorData.id].selectedBuilding = n ? n.id : void 0; const f = this._indoorData.levels.filter(_ => n.levels.includes(_.id)); this.fire(new s.A("buildingselected", { buildingId: n.id, levels: f })); }
                _levelSelected(n) { if (n === "overview")
                    this._updateLevels(void 0, !0);
                else {
                    const l = this._indoorData.levels.find(f => f.id === n);
                    this._updateLevels(l, !0);
                } this.fire(new s.A("levelselected", { levelId: n === "overview" ? void 0 : n })); }
                _updateLevels(n, l) { if (!n)
                    return this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", []]), this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !1), this._floorplanStates[this._indoorData.id].selectedLevel = void 0, void (l && this._indoorData.extent && this._map.fitBounds(this._indoorData.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() })); function f(P) { const R = P.indexOf("/floor/"); if (R === -1)
                    return P; const O = R + 7, D = P.indexOf("/", O); return D === -1 ? P.slice(O) : P.slice(O, D); } this._selectedLevel = n, this._floorplanStates[this._indoorData.id].selectedLevel = n ? n.id : void 0; const _ = [], v = {}, w = {}, T = {}, C = {}; for (const P of this._indoorData.levels)
                    if (_.push(P.id), v[P.id] = P.height, w[P.id] = P.base, n) {
                        if (this.mergeFloors) {
                            const R = f(n.id), O = f(P.id);
                            T[P.id] = O === R ? "true" : "false";
                        }
                        else
                            T[P.id] = P.id === n.id ? "true" : "false";
                        C[P.id] = P.base < n.base ? "true" : "false";
                    }
                    else
                        C[P.id] = !0; if (this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", _]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-height", ["literal", v]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-base", ["literal", w]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-selected", ["literal", T]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-overlapped", ["literal", C]), n && (this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !!n.isUnderground), l && n.extent)) {
                    const P = this._map.cameraForBounds(n.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }), R = this._map.getZoom(), O = P.zoom ? Math.abs(R - P.zoom) : 0;
                    this._map.fitBounds(n.extent, O >= 1 ? { pitch: this._map.getPitch(), bearing: this._map.getBearing() } : { pitch: this._map.getPitch(), bearing: this._map.getBearing(), zoom: R });
                } }
                selectFloorplan(n) { const l = { target: { featuresetId: this._queryFeatureSetId, importId: this._scope } }, f = [new s.P(0, 0), new s.P(this._map.transform.width, this._map.transform.height)], _ = this._map.queryRenderedFeatures(f, l); if (_.length > 0) {
                    for (const v of _)
                        if (JSON.parse(v.properties["indoor-data"]).floorplanIDs.includes(n)) {
                            this._selectedFloorplan = v, this._floorplanSelected(!0);
                            break;
                        }
                } }
                selectBuilding(n) { const l = this._indoorData.buildings.find(f => f.id === n); this._buildingSelected(l, !0); }
                selectLevel(n) { this._levelSelected(n); }
            }
            function Yb(d) { if (!d.metadata || !d.metadata.content_area)
                return; const n = s.q.devicePixelRatio, { left: l, top: f, width: _, height: v } = d.metadata.content_area, w = l * n, T = f * n; return [w, T, w + _ * n, T + v * n]; }
            function ip(d) { if (d)
                return d.map(([n, l]) => [n * s.q.devicePixelRatio, l * s.q.devicePixelRatio]); }
            class b0 {
                constructor(n, l, f) { this.id = n, this.scope = l, this.sourceCache = f, this.pendingRequests = new Set, this.missingRequests = new Set; }
                addPendingRequest(n) { this.missingRequests.has(n.name) || this.pendingRequests.has(n.name) || this.pendingRequests.add(n.name); }
                hasPendingRequests() { return this.pendingRequests.size > 0; }
                resolvePendingRequests() { const n = new Map; if (!this.sourceCache.loaded())
                    return n; const l = this.sourceCache.getVisibleCoordinates(); if (l.length === 0)
                    return n; const f = this.sourceCache.getSource(); if (!(f instanceof _c))
                    return n; const _ = l.map(w => this.sourceCache.getTile(w)), v = f.getImages(_, Array.from(this.pendingRequests)); for (const [w, T] of v)
                    n.set(s.I.from({ name: w, iconsetId: this.id }), T), this.pendingRequests.delete(w); for (const w of this.pendingRequests)
                    this.missingRequests.add(w); return this.pendingRequests.clear(), n; }
            }
            const Dl = (d, n) => ke(d, n && n.filter(l => l.identifier !== "source.canvas")), T0 = s.aF(Yr, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setSnow", "setRain", "setProjection", "setCamera", "addImport", "removeImport", "updateImport", "addIconset", "removeIconset"]), S0 = s.aF(Yr, ["setCenter", "setZoom", "setBearing", "setPitch"]), Ya = new Set(["background", "sky", "slot", "custom"]), wd = { version: 8, layers: [], sources: {} }, Gg = { duration: 300, delay: 0 };
            class Lo extends s.E {
                constructor(n, l = {}) { super(), this.map = n, this.scope = l.scope || "", this.globalId = null, this.fragments = [], this.importDepth = l.importDepth || 0, this.importsCache = l.importsCache || new Map, this.resolvedImports = l.resolvedImports || new Set, this.transition = s.l({}, Gg), this._buildingIndex = new d0(this), this.crossTileSymbolIndex = new ji, this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = !1, this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this._changes = l.styleChanges || new Gn, this.dispatcher = l.dispatcher ? l.dispatcher : new s.D(s.d0(), this), l.imageManager ? this.imageManager = l.imageManager : (this.imageManager = new Xo(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.addScope(this.scope), this.glyphManager = l.glyphManager ? l.glyphManager : new s.d1(n._requestManager, l.localFontFamily ? s.d2.all : l.localIdeographFontFamily ? s.d2.ideographs : s.d2.none, l.localFontFamily || l.localIdeographFontFamily), l.modelManager ? this.modelManager = l.modelManager : (this.modelManager = new kl(n._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._precompileDone = !1, this._shouldPrecompile = !1, this._availableImages = [], this._availableModels = {}, this._order = [], this._markersNeedUpdate = !1, this.options = l.configOptions ? l.configOptions : new Map, this._configDependentLayers = l.configDependentLayers ? l.configDependentLayers : new Set, this._config = l.config, this._styleColorTheme = { lut: null, lutLoading: !1, lutLoadingCorrelationID: 0, colorTheme: null, colorThemeOverride: l.colorThemeOverride }, this._styleColorThemeForScope = {}, this._initialConfig = l.initialConfig, this.dispatcher.broadcast("setReferrer", s.d3()); const f = this; this._rtlTextPluginCallback = Lo.registerForPluginStateChange(_ => { f.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: _.pluginStatus, pluginURL: _.pluginURL }, (v, w) => { if (s.d4(v), w && w.every(T => T))
                    for (const T in f._sourceCaches) {
                        const C = f._sourceCaches[T], P = C.getSource().type;
                        P !== "vector" && P !== "geojson" || C.reload();
                    } }); }), this.on("data", _ => { if (_.dataType !== "source" || _.sourceDataType !== "metadata")
                    return; const v = this.getOwnSource(_.sourceId); if (v && v.vectorLayerIds)
                    for (const w in this._layers) {
                        const T = this._layers[w];
                        T.source === v.id && this._validateLayer(T);
                    } }); }
                load(n) { return n ? (typeof n == "string" ? this.loadURL(n) : this.loadJSON(n), this) : this; }
                _getGlobalId(n) { if (!n)
                    return null; if (typeof n == "string") {
                    if (s.f(n))
                        return n;
                    const l = s.d5(n);
                    if (!l.startsWith("http"))
                        try {
                            return new URL(l, location.href).toString();
                        }
                        catch {
                            return l;
                        }
                    return l;
                } return `json://${s.d6(JSON.stringify(n))}`; }
                _diffStyle(n, l, f) { this.globalId = this._getGlobalId(n); const _ = (v, w) => { try {
                    w(null, this.setState(v, f));
                }
                catch (T) {
                    w(T, !1);
                } }; if (typeof n == "string") {
                    const v = this.map._requestManager.normalizeStyleURL(n), w = this.map._requestManager.transformRequest(v, s.R.Style);
                    s.n(w, (T, C) => { T ? this.fire(new s.z(T)) : C && _(C, l); });
                }
                else
                    typeof n == "object" && _(n, l); }
                loadURL(n, l = {}) { this.fire(new s.A("dataloading", { dataType: "style" })); const f = typeof l.validate == "boolean" ? l.validate : !s.f(n); this.globalId = this._getGlobalId(n), n = this.map._requestManager.normalizeStyleURL(n, l.accessToken), this.resolvedImports.add(n); const _ = this.importsCache.get(n); if (_)
                    return this._load(_, f); const v = this.map._requestManager.transformRequest(n, s.R.Style); this._request = s.n(v, (w, T) => { if (this._request = null, w)
                    this.fire(new s.z(w));
                else if (T)
                    return this.importsCache.set(n, T), this._load(T, f); }); }
                loadJSON(n, l = {}) { this.fire(new s.A("dataloading", { dataType: "style" })), this.globalId = this._getGlobalId(n), this._request = s.q.frame(() => { this._request = null, this._load(n, l.validate !== !1); }); }
                loadEmpty() { this.fire(new s.A("dataloading", { dataType: "style" })), this._load(wd, !1); }
                _loadImports(n, l, f) { if (this.importDepth >= 4)
                    return s.w("Style doesn't support nesting deeper than 5"), Promise.resolve(); const _ = []; for (const v of n) {
                    const w = this._createFragmentStyle(v), T = new Promise(R => { w.once("style.import.load", R), w.once("error", R); }).then(() => this.mergeAll());
                    if (_.push(T), this.resolvedImports.has(v.url)) {
                        w.loadEmpty();
                        continue;
                    }
                    const C = v.data || this.importsCache.get(v.url);
                    C ? (w.loadJSON(C, { validate: l }), this._isInternalStyle(C) && (w.globalId = null)) : v.url ? w.loadURL(v.url, { validate: l }) : w.loadEmpty();
                    const P = { style: w, id: v.id, config: v.config };
                    if (f) {
                        const R = this.fragments.findIndex(({ id: O }) => O === f);
                        this.fragments = this.fragments.slice(0, R).concat(P).concat(this.fragments.slice(R));
                    }
                    else
                        this.fragments.push(P);
                } return Promise.allSettled(_); }
                getImportGlobalIds(n = this, l = new Set) { for (const f of n.fragments)
                    f.style.globalId && l.add(f.style.globalId), this.getImportGlobalIds(f.style, l); return [...l.values()]; }
                _createFragmentStyle(n) { const l = this.scope ? s.C(n.id, this.scope) : n.id; let f; const _ = this._initialConfig && this._initialConfig[l]; (n.config || _) && (f = s.l({}, n.config, _)); const v = new Lo(this.map, { scope: l, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: f, configOptions: this.options, colorThemeOverride: n["color-theme"], configDependentLayers: this._configDependentLayers }); return v.setEventedParent(this.map, { style: v }), v; }
                _reloadImports() { this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle(); }
                _isInternalStyle(n) { return this.isRootStyle() && (n.fragment || !!n.schema && n.fragment !== !1); }
                _load(n, l) { const f = n.indoor ? x0(n.schema) : n.schema; if (this._isInternalStyle(n)) {
                    const w = s.l({}, wd, { imports: [{ id: "basemap", data: n, url: "" }] });
                    return void this._load(w, l);
                } if (this.updateConfig(this._config, f), l && Dl(this, Ro(n)))
                    return; this._loaded = !0, this.stylesheet = s.d7(n); const _ = () => { for (const P in n.sources)
                    this.addSource(P, n.sources[P], { validate: !1, isInitialLoad: !0 }); if (n.iconsets)
                    for (const P in n.iconsets)
                        this.addIconset(P, n.iconsets[P]); n.sprite ? this._loadIconset(n.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 })), this.setGlyphsUrl(n.glyphs); const w = Kf(this.stylesheet.layers); if (this._order = w.map(P => P.id), this.stylesheet.light && s.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights)
                    if (this.stylesheet.lights.length === 1 && this.stylesheet.lights[0].type === "flat") {
                        const P = this.stylesheet.lights[0];
                        this.light = new qe(P.properties, P.id);
                    }
                    else
                        this.setLights(this.stylesheet.lights); this.light || (this.light = new qe(this.stylesheet.light)), this._layers = {}; for (const P of w) {
                    const R = s.dc(P, this.scope, this._styleColorTheme.lut, this.options);
                    R.configDependencies.size !== 0 && this._configDependentLayers.add(R.fqid), R.setEventedParent(this, { layer: { id: R.id } }), this._layers[R.id] = R;
                    const O = this.getOwnLayerSourceCache(R), D = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                    O && R.canCastShadows() && D && (O.castsShadows = !0);
                } this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.addModelURLs(this.stylesheet.models); const T = this.stylesheet.terrain; T && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(T, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new s.A("data", { dataType: "style" })); const C = this.isRootStyle(); n.imports ? this._loadImports(n.imports, l).then(() => { this._reloadImports(), this.fire(new s.A(C ? "style.load" : "style.import.load")); }).catch(P => { this.fire(new s.z(new Error("Failed to load imports", P))), this.fire(new s.A(C ? "style.load" : "style.import.load")); }) : (this._reloadImports(), this.fire(new s.A(C ? "style.load" : "style.import.load"))); }; this._styleColorTheme.colorTheme = this.stylesheet["color-theme"]; const v = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme; if (v) {
                    const w = this._evaluateColorThemeData(v);
                    this._loadColorTheme(w).then(() => { _(); }).catch(T => { s.w(`Couldn't load color theme from the stylesheet: ${T}`), _(); });
                }
                else
                    this._styleColorTheme.lut = null, _(); }
                isRootStyle() { return this.importDepth === 0; }
                mergeAll() { let n, l, f, _, v, w, T, C, P, R; const O = {}; this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle(D => { if (D.stylesheet) {
                    if (D.light != null && (n = D.light), D.stylesheet.lights)
                        for (const B of D.stylesheet.lights)
                            B.type === "ambient" && D.ambientLight != null && (l = D.ambientLight), B.type === "directional" && D.directionalLight != null && (f = D.directionalLight);
                    _ = this._prioritizeTerrain(_, D.terrain, D.stylesheet.terrain), D.stylesheet.fog && D.fog != null && (v = D.fog), D.stylesheet.snow && D.snow != null && (w = D.snow), D.stylesheet.rain && D.rain != null && (T = D.rain), D.stylesheet.camera != null && (R = D.stylesheet.camera), D.stylesheet.projection != null && (C = D.stylesheet.projection), D.stylesheet.transition != null && (P = D.stylesheet.transition), O[D.scope] = D._styleColorTheme;
                } }), this.light = n, this.ambientLight = l, this.directionalLight = f, this.fog = v, this.snow = w, this.rain = T, this._styleColorThemeForScope = O, _ === null ? delete this.terrain : this.terrain = _, this.camera = R || { "camera-projection": "perspective" }, this.projection = C || { name: "mercator" }, this.transition = s.l({}, Gg, P), this.mergeSources(), this.mergeLayers(); }
                forEachFragmentStyle(n) { const l = f => { for (const _ of f.fragments)
                    l(_.style); n(f); }; l(this); }
                _prioritizeTerrain(n, l, f) { const _ = n && n.drapeRenderMode === 0; return f === null ? l && l.drapeRenderMode === 0 ? l : _ ? n : null : l != null && (!n || _ || l && l.drapeRenderMode === 1) ? l : n; }
                mergeTerrain() { let n; this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle(l => { n = this._prioritizeTerrain(n, l.terrain, l.stylesheet.terrain); }), n === null ? delete this.terrain : this.terrain = n; }
                mergeProjection() { let n; this.forEachFragmentStyle(l => { l.stylesheet.projection != null && (n = l.stylesheet.projection); }), this.projection = n || { name: "mercator" }; }
                mergeSources() { const n = {}, l = {}, f = {}; this.forEachFragmentStyle(_ => { for (const v in _._sourceCaches) {
                    const w = s.C(v, _.scope);
                    n[w] = _._sourceCaches[v];
                } for (const v in _._otherSourceCaches) {
                    const w = s.C(v, _.scope);
                    l[w] = _._otherSourceCaches[v];
                } for (const v in _._symbolSourceCaches) {
                    const w = s.C(v, _.scope);
                    f[w] = _._symbolSourceCaches[v];
                } }), this._mergedSourceCaches = n, this._mergedOtherSourceCaches = l, this._mergedSymbolSourceCaches = f; }
                mergeLayers() { const n = {}, l = [], f = {}; this._mergedSlots = [], this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this.forEachFragmentStyle(v => { for (const w of v._order) {
                    const T = v._layers[w];
                    if (T.type === "slot") {
                        const C = s.d8(w);
                        if (n[C])
                            continue;
                        n[C] = [];
                    }
                    T.slot && n[T.slot] ? n[T.slot].push(T) : l.push(T);
                } }), this._mergedOrder = []; const _ = (v = []) => { for (const w of v)
                    if (w.type === "slot") {
                        const T = s.d8(w.id);
                        n[T] && _(n[T]), this._mergedSlots.push(T);
                    }
                    else {
                        const T = s.C(w.id, w.scope);
                        this._mergedOrder.push(T), f[T] = w, w.is3D(!!this.terrain) && (this._has3DLayers = !0), w.type === "circle" && (this._hasCircleLayers = !0), w.type === "symbol" && (this._hasSymbolLayers = !0), w.type === "clip" && (this._clipLayerPresent = !0);
                    } }; _(l), this._mergedOrder.sort((v, w) => { const T = f[v], C = f[w]; return T.hasInitialOcclusionOpacityProperties ? C.is3D(!!this.terrain) ? 1 : 0 : T.is3D(!!this.terrain) && C.hasInitialOcclusionOpacityProperties ? -1 : 0; }), this._mergedLayers = f, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged(); }
                terrainSetForDrapingOnly() { return !!this.terrain && this.terrain.drapeRenderMode === 0; }
                getCamera() { return this.stylesheet.camera; }
                setCamera(n) { return this.stylesheet.camera = s.l({}, this.stylesheet.camera, n), this.camera = this.stylesheet.camera, this; }
                _evaluateColorThemeData(n) { return n.data ? function (l, f, _) { const v = s.l({}, f); for (const T of Object.keys(s.a5.colorTheme))
                    v[T] === void 0 && (v[T] = s.a5.colorTheme[T].default); const w = new s.a6(Xb, l, new Map(_)); return w.setTransitionOrValue(v, _), w.untransitioned().possiblyEvaluate(new s.aa(0)); }(this.scope, n, this.options).get("data") : null; }
                _loadColorTheme(n) { this._styleColorTheme.lutLoading = !0, this._styleColorTheme.lutLoadingCorrelationID += 1; const l = this._styleColorTheme.lutLoadingCorrelationID; return new Promise((f, _) => { const v = "data:image/png;base64,"; if (!n || n.length === 0)
                    return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = !1, void f(); let w = n; w.startsWith(v) || (w = v + w); const T = s.I.from("mapbox-reserved-lut"), C = new Image; C.src = w, C.onerror = () => { this._styleColorTheme.lutLoading = !1, _(new Error("Failed to load image data")); }, C.onload = () => { if (this._styleColorTheme.lutLoadingCorrelationID !== l)
                    return void f(); this._styleColorTheme.lutLoading = !1; const { width: P, height: R, data: O } = s.q.getImageData(C); if (R > 32)
                    return void _(new Error("The height of the image must be less than or equal to 32 pixels.")); if (P !== R * R)
                    return void _(new Error("The width of the image must be equal to the height squared.")); this.getImage(T) && this.removeImage(T), this.addImage(T, { data: new s.r({ width: P, height: R }, O), pixelRatio: 1, sdf: !1, usvg: !1, version: 0 }); const D = this.imageManager.getImage(T, this.scope); D ? (this._styleColorTheme.lut = { image: D.data, data: n }, f()) : _(new Error("Missing LUT image.")); }; }); }
                getLut(n) { const l = this._styleColorThemeForScope[n]; return l ? l.lut : null; }
                setProjection(n) { n ? this.stylesheet.projection = n : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection(); }
                applyProjectionUpdate() { this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0)); }
                _updateMapProjection() { this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection)); }
                _loadSprite(n) { this._spriteRequest = function (l, f, _) { let v, w, T; const C = s.q.devicePixelRatio > 1 ? "@2x" : ""; let P = s.n(f.transformRequest(f.normalizeSpriteURL(l, C, ".json"), s.R.SpriteJSON), (D, B) => { P = null, T || (T = D, v = B, O()); }), R = s.o(f.transformRequest(f.normalizeSpriteURL(l, C, ".png"), s.R.SpriteImage), (D, B) => { R = null, T || (T = D, w = B, O()); }); function O() { if (T)
                    _(T);
                else if (v && w) {
                    const D = s.q.getImageData(w), B = {};
                    for (const q in v) {
                        const { width: G, height: K, x: W, y: oe, sdf: de, pixelRatio: me, stretchX: we, stretchY: ve, content: xe } = v[q], ge = new s.r({ width: G, height: K });
                        s.r.copy(D, ge, { x: W, y: oe }, { x: 0, y: 0 }, { width: G, height: K }, null), B[q] = { data: ge, pixelRatio: me, sdf: de, stretchX: we, stretchY: ve, content: xe, usvg: !1 };
                    }
                    _(null, B);
                } } return { cancel() { P && (P.cancel(), P = null), R && (R.cancel(), R = null); } }; }(n, this.map._requestManager, (l, f) => { if (this._spriteRequest = null, l)
                    this.fire(new s.z(l));
                else if (f) {
                    const _ = new Map;
                    for (const v in f)
                        _.set(s.I.from(v), f[v]);
                    this.addImages(_);
                } this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 }), this.fire(new s.A("data", { dataType: "style" })); }); }
                addIconset(n, l) { if (l.type === "sprite")
                    return void this._loadSprite(l.url); const f = this.getOwnSourceCache(l.source); if (!f)
                    return void this.fire(new s.z(new Error(`Source "${l.source}" as specified by iconset "${n}" does not exist and cannot be used as an iconset source`))); const _ = f.getSource(); if (_.type !== "raster-array")
                    return void this.fire(new s.z(new Error(`Source "${l.source}" as specified by iconset "${n}" is not a "raster-array" source and cannot be used as an iconset source`))); _.partial = !1; const v = new b0(n, this.scope, f); this.imageManager.addImageProvider(v, this.scope); }
                removeIconset(n) { this.imageManager.removeImageProvider(n, this.scope); }
                _loadIconset(n) { if (!s.f(n) && this.map._spriteFormat !== "icon_set" || this.map._spriteFormat === "raster")
                    return void this._loadSprite(n); const l = this.map._spriteFormat === "auto"; var f, _; this._spriteRequest = (_ = (v, w) => { if (this._spriteRequest = null, v)
                    l ? this._loadSprite(n) : this.fire(new s.z(v));
                else if (w) {
                    const T = new Map;
                    for (const C in w)
                        T.set(s.I.from(C), w[C]);
                    this.addImages(T);
                } this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 }), this.fire(new s.A("data", { dataType: "style" })); }, s.br((f = this.map._requestManager).transformRequest(f.normalizeIconsetURL(n), s.R.Iconset), (v, w) => { if (v)
                    return void _(v); const T = {}, C = s.c_(new s.bq(w)); for (const P of C.icons) {
                    const R = { version: 1, pixelRatio: s.q.devicePixelRatio, content: Yb(P), stretchX: P.metadata ? ip(P.metadata.stretch_x_areas) : void 0, stretchY: P.metadata ? ip(P.metadata.stretch_y_areas) : void 0, sdf: !1, usvg: !0, icon: P };
                    T[P.name] = R;
                } _(null, T); })); }
                _validateLayer(n) { const l = this.getOwnSource(n.source); if (!l)
                    return; const f = n.sourceLayer; f && (l.type === "geojson" || l.vectorLayerIds && l.vectorLayerIds.indexOf(f) === -1) && this.fire(new s.z(new Error(`Source layer "${f}" does not exist on source "${l.id}" as specified by style layer "${n.id}"`))); }
                loaded() { if (!this._loaded || Object.keys(this._changes.getUpdatedSourceCaches()).length)
                    return !1; for (const n in this._sourceCaches)
                    if (!this._sourceCaches[n].loaded())
                        return !1; if (!this.imageManager.isLoaded() || this.imageManager.hasPatternsInFlight() || !this.modelManager.isLoaded() || this._styleColorTheme.lutLoading)
                    return !1; for (const { style: n } of this.fragments)
                    if (!n.loaded())
                        return !1; return !0; }
                _serializeImports() { if (this.stylesheet.imports)
                    return this.stylesheet.imports.map((n, l) => { const f = this.fragments[l]; return f && f.style && (n.data = f.style.serialize()), n; }); }
                _serializeSources() { const n = {}; for (const l in this._sourceCaches) {
                    const f = this._sourceCaches[l].getSource();
                    n[f.id] || (n[f.id] = f.serialize());
                } return n; }
                _serializeLayers(n) { const l = []; for (const f of n) {
                    const _ = this._layers[f];
                    _ && _.type !== "custom" && l.push(_.serialize());
                } return l; }
                hasLightTransitions() { return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition()); }
                hasFogTransition() { return !!this.fog && this.fog.hasTransition(); }
                hasSnowTransition() { return !!this.snow && this.snow.hasTransition(); }
                hasRainTransition() { return !!this.rain && this.rain.hasTransition(); }
                hasTransitions() { if (this.hasLightTransitions() || this.hasFogTransition() || this.hasSnowTransition() || this.hasRainTransition())
                    return !0; for (const n in this._sourceCaches)
                    if (this._sourceCaches[n].hasTransition())
                        return !0; for (const n in this._layers)
                    if (this._layers[n].hasTransition())
                        return !0; return !1; }
                get order() { return this.terrain ? this._drapedFirstOrder : this._mergedOrder; }
                _getOrder(n) { return n ? this.order : this._mergedOrder; }
                isLayerDraped(n) { return !!this.terrain && n.isDraped(this.getLayerSourceCache(n)); }
                _checkLoaded() { if (!this._loaded)
                    throw new Error("Style is not done loading"); }
                _checkLayer(n) { const l = this.getOwnLayer(n); if (l)
                    return l; this.fire(new s.z(new Error(`The layer '${n}' does not exist in the map's style.`))); }
                _checkSource(n) { const l = this.getOwnSource(n); if (l)
                    return l; this.fire(new s.z(new Error(`The source '${n}' does not exist in the map's style.`))); }
                precompilePrograms(n, l) { const f = this.map.painter; if (f)
                    for (let _ = n.minzoom || 0; _ < (n.maxzoom || 25.5); _++) {
                        const v = n.getProgramIds();
                        if (v)
                            for (const w of v) {
                                const T = n.getDefaultProgramParams(w, l.zoom, this._styleColorTheme.lut);
                                T && (f.style = this, this.fog && (f._fogVisible = !0, T.overrideFog = !0, f.getOrCreateProgram(w, T)), f._fogVisible = !1, T.overrideFog = !1, f.getOrCreateProgram(w, T), (this.stylesheet.terrain || this.stylesheet.projection && this.stylesheet.projection.name === "globe") && (T.overrideRtt = !0, f.getOrCreateProgram(w, T)));
                            }
                    } }
                update(n) { if (!this._loaded)
                    return; this.ambientLight && this.ambientLight.recalculate(n), this.directionalLight && this.directionalLight.recalculate(n); const l = this.calculateLightsBrightness(); n.brightness = l || 0, l !== this._brightness && (this._brightness = l, this.dispatcher.broadcast("setBrightness", l)); const f = this._changes.isDirty(); let _ = !1; if (this._changes.isDirty()) {
                    const T = this._changes.getLayerUpdatesByScope();
                    for (const C in T) {
                        const { updatedIds: P, removedIds: R } = T[C];
                        (P || R) && (this._updateWorkerLayers(C, P, R), _ = !0);
                    }
                    this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(n), this.light && this.light.updateTransitions(n), this.ambientLight && this.ambientLight.updateTransitions(n), this.directionalLight && this.directionalLight.updateTransitions(n), this.fog && this.fog.updateTransitions(n), this.snow && this.snow.updateTransitions(n), this.rain && this.rain.updateTransitions(n), this._changes.reset();
                } const v = {}; for (const T in this._mergedSourceCaches) {
                    const C = this._mergedSourceCaches[T];
                    v[T] = C.used, C.used = !1, C.tileCoverLift = 0;
                } for (const T of this._mergedOrder) {
                    const C = this._mergedLayers[T];
                    if (C.recalculate(n, this._availableImages), !C.isHidden(n.zoom)) {
                        const P = this.getLayerSourceCache(C);
                        P && (P.used = !0, P.tileCoverLift = Math.max(P.tileCoverLift, C.tileCoverLift()));
                    }
                    !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback(() => { this.precompilePrograms(C, n); }) : this.precompilePrograms(C, n));
                } this._shouldPrecompile && (this._precompileDone = !0), this.terrain && _ && this.mergeLayers(); const w = this.imageManager.getPendingImageProviders(); for (const T of w)
                    T.sourceCache.used = !0; for (const T in v) {
                    const C = this._mergedSourceCaches[T];
                    v[T] !== C.used && C.getSource().fire(new s.A("data", { sourceDataType: "visibility", dataType: "source", sourceId: C.getSource().id }));
                } this.light && this.light.recalculate(n), this.terrain && this.terrain.recalculate(n), this.fog && this.fog.recalculate(n), this.snow && this.snow.recalculate(n), this.rain && this.rain.recalculate(n), this.z = n.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), this.imageManager.clearUpdatedImages(this.scope), f && this.fire(new s.A("data", { dataType: "style" })); }
                updateImageProviders() { const n = this.imageManager.getPendingImageProviders(); for (const l of n) {
                    const f = l.resolvePendingRequests(), _ = this.getFragmentStyle(l.scope);
                    _ && _.addImages(f);
                } }
                _updateTilesForChangedImages() { const n = {}; for (const l in this._mergedSourceCaches) {
                    const f = this._mergedSourceCaches[l].getSource().scope;
                    n[f] = n[f] || this._changes.getUpdatedImages(f), n[f].length !== 0 && this._mergedSourceCaches[l].reloadTilesForDependencies(["icons", "patterns"], n[f]);
                } for (const l in n)
                    this._changes.resetUpdatedImages(l); }
                _updateWorkerLayers(n, l, f) { const _ = this.getFragmentStyle(n); _ && this.dispatcher.broadcast("updateLayers", { layers: l ? _._serializeLayers(l) : [], scope: n, removedIds: f || [], options: _.options }); }
                setState(n, l) { if (this._checkLoaded(), Dl(this, Ro(n)))
                    return !1; (n = s.d7(n)).layers = Kf(n.layers); const f = function (w, T) { if (!w)
                    return [{ command: Yr.setStyle, args: [T] }]; let C = []; try {
                    if (!s.bv(w.version, T.version))
                        return [{ command: Yr.setStyle, args: [T] }];
                    if (s.bv(w.center, T.center) || C.push({ command: Yr.setCenter, args: [T.center] }), s.bv(w.zoom, T.zoom) || C.push({ command: Yr.setZoom, args: [T.zoom] }), s.bv(w.bearing, T.bearing) || C.push({ command: Yr.setBearing, args: [T.bearing] }), s.bv(w.pitch, T.pitch) || C.push({ command: Yr.setPitch, args: [T.pitch] }), s.bv(w.sprite, T.sprite) || C.push({ command: Yr.setSprite, args: [T.sprite] }), s.bv(w.glyphs, T.glyphs) || C.push({ command: Yr.setGlyphs, args: [T.glyphs] }), s.bv(w.imports, T.imports) || function (B = [], q = [], G) { q = q || []; const K = (B = B || []).map(Cl), W = q.map(Cl), oe = B.reduce(vu, {}), de = q.reduce(vu, {}), me = K.slice(); let we, ve, xe, ge; for (we = 0, ve = 0; we < K.length; we++)
                        xe = K[we], de.hasOwnProperty(xe) ? ve++ : (G.push({ command: Yr.removeImport, args: [xe] }), me.splice(me.indexOf(xe, ve), 1)); for (we = 0, ve = 0; we < W.length; we++)
                        xe = W[W.length - 1 - we], me[me.length - 1 - we] !== xe && (oe.hasOwnProperty(xe) ? (G.push({ command: Yr.removeImport, args: [xe] }), me.splice(me.lastIndexOf(xe, me.length - ve), 1)) : ve++, ge = me[me.length - we], G.push({ command: Yr.addImport, args: [de[xe], ge] }), me.splice(me.length - we, 0, xe)); for (const Se of q) {
                        const Ce = oe[Se.id];
                        Ce && !s.bv(Ce, Se) && G.push({ command: Yr.updateImport, args: [Se.id, Se] });
                    } }(w.imports, T.imports, C), s.bv(w.transition, T.transition) || C.push({ command: Yr.setTransition, args: [T.transition] }), s.bv(w.light, T.light) || C.push({ command: Yr.setLight, args: [T.light] }), s.bv(w.fog, T.fog) || C.push({ command: Yr.setFog, args: [T.fog] }), s.bv(w.snow, T.snow) || C.push({ command: Yr.setSnow, args: [T.snow] }), s.bv(w.rain, T.rain) || C.push({ command: Yr.setRain, args: [T.rain] }), s.bv(w.projection, T.projection) || C.push({ command: Yr.setProjection, args: [T.projection] }), s.bv(w.lights, T.lights) || C.push({ command: Yr.setLights, args: [T.lights] }), s.bv(w.camera, T.camera) || C.push({ command: Yr.setCamera, args: [T.camera] }), s.bv(w.iconsets, T.iconsets) || function (B, q, G) { let K; for (K in q = q || {}, B = B || {})
                        B.hasOwnProperty(K) && (q.hasOwnProperty(K) || G.push({ command: Yr.removeIconset, args: [K] })); for (K in q) {
                        if (!q.hasOwnProperty(K))
                            continue;
                        const W = q[K];
                        B.hasOwnProperty(K) ? s.bv(B[K], W) || (G.push({ command: Yr.removeIconset, args: [K] }), G.push({ command: Yr.addIconset, args: [K, W] })) : G.push({ command: Yr.addIconset, args: [K, W] });
                    } }(w.iconsets, T.iconsets, C), !s.bv(w["color-theme"], T["color-theme"]))
                        return [{ command: Yr.setStyle, args: [T] }];
                    const P = {}, R = [];
                    (function (B, q, G, K) { let W; for (W in q = q || {}, B = B || {})
                        B.hasOwnProperty(W) && (q.hasOwnProperty(W) || yu(W, G, K)); for (W in q) {
                        if (!q.hasOwnProperty(W))
                            continue;
                        const oe = q[W];
                        B.hasOwnProperty(W) ? s.bv(B[W], oe) || (B[W].type === "geojson" && oe.type === "geojson" && f0(B, q, W) ? G.push({ command: Yr.setGeoJSONSourceData, args: [W, oe.data] }) : Hb(W, q, G, K)) : _u(W, q, G);
                    } })(w.sources, T.sources, R, P);
                    const O = [];
                    w.layers && w.layers.forEach(B => { B.source && P[B.source] ? C.push({ command: Yr.removeLayer, args: [B.id] }) : O.push(B); });
                    let D = w.terrain;
                    D && P[D.source] && (C.push({ command: Yr.setTerrain, args: [void 0] }), D = void 0), C = C.concat(R), s.bv(D, T.terrain) || C.push({ command: Yr.setTerrain, args: [T.terrain] }), function (B, q, G) { q = q || []; const K = (B = B || []).map(Cl), W = q.map(Cl), oe = B.reduce(vu, {}), de = q.reduce(vu, {}), me = K.slice(), we = Object.create(null); let ve, xe, ge, Se, Ce, je, ze; for (ve = 0, xe = 0; ve < K.length; ve++)
                        ge = K[ve], de.hasOwnProperty(ge) ? xe++ : (G.push({ command: Yr.removeLayer, args: [ge] }), me.splice(me.indexOf(ge, xe), 1)); for (ve = 0, xe = 0; ve < W.length; ve++)
                        ge = W[W.length - 1 - ve], me[me.length - 1 - ve] !== ge && (oe.hasOwnProperty(ge) ? (G.push({ command: Yr.removeLayer, args: [ge] }), me.splice(me.lastIndexOf(ge, me.length - xe), 1)) : xe++, je = me[me.length - ve], G.push({ command: Yr.addLayer, args: [de[ge], je] }), me.splice(me.length - ve, 0, ge), we[ge] = !0); for (ve = 0; ve < W.length; ve++)
                        if (ge = W[ve], Se = oe[ge], Ce = de[ge], !we[ge] && !s.bv(Se, Ce))
                            if (s.bv(Se.source, Ce.source) && s.bv(Se["source-layer"], Ce["source-layer"]) && s.bv(Se.type, Ce.type)) {
                                for (ze in vc(Se.layout, Ce.layout, G, ge, null, Yr.setLayoutProperty), vc(Se.paint, Ce.paint, G, ge, null, Yr.setPaintProperty), s.bv(Se.slot, Ce.slot) || G.push({ command: Yr.setSlot, args: [ge, Ce.slot] }), s.bv(Se.filter, Ce.filter) || G.push({ command: Yr.setFilter, args: [ge, Ce.filter] }), s.bv(Se.minzoom, Ce.minzoom) && s.bv(Se.maxzoom, Ce.maxzoom) || G.push({ command: Yr.setLayerZoomRange, args: [ge, Ce.minzoom, Ce.maxzoom] }), Se)
                                    Se.hasOwnProperty(ze) && ze !== "layout" && ze !== "paint" && ze !== "filter" && ze !== "metadata" && ze !== "minzoom" && ze !== "maxzoom" && ze !== "slot" && (ze.indexOf("paint.") === 0 ? vc(Se[ze], Ce[ze], G, ge, ze.slice(6), Yr.setPaintProperty) : s.bv(Se[ze], Ce[ze]) || G.push({ command: Yr.setLayerProperty, args: [ge, ze, Ce[ze]] }));
                                for (ze in Ce)
                                    Ce.hasOwnProperty(ze) && !Se.hasOwnProperty(ze) && ze !== "layout" && ze !== "paint" && ze !== "filter" && ze !== "metadata" && ze !== "minzoom" && ze !== "maxzoom" && ze !== "slot" && (ze.indexOf("paint.") === 0 ? vc(Se[ze], Ce[ze], G, ge, ze.slice(6), Yr.setPaintProperty) : s.bv(Se[ze], Ce[ze]) || G.push({ command: Yr.setLayerProperty, args: [ge, ze, Ce[ze]] }));
                            }
                            else
                                G.push({ command: Yr.removeLayer, args: [ge] }), je = me[me.lastIndexOf(ge) + 1], G.push({ command: Yr.addLayer, args: [Ce, je] }); }(O, T.layers, C);
                }
                catch (P) {
                    console.warn("Unable to compute style diff:", P), C = [{ command: Yr.setStyle, args: [T] }];
                } return C; }(this.serialize(), n).filter(w => !(w.command in S0)); if (f.length === 0)
                    return !1; const _ = f.filter(w => !(w.command in T0)); if (_.length > 0)
                    throw new Error(`Unimplemented: ${_.map(w => w.command).join(", ")}.`); const v = []; return f.forEach(w => { v.push(this[w.command](...w.args)); }), l && Promise.all(v).then(l).catch(l), this.stylesheet = n, this.mergeAll(), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), !0; }
                _updateWorkerImages() { this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }); }
                _updateWorkerModels() { this._availableModels = this.modelManager.getModelURIs(this.scope), this.dispatcher.broadcast("setModels", { scope: this.scope, models: this._availableModels }); }
                addImages(n) { for (const [l, f] of n.entries()) {
                    if (this.getImage(l))
                        return this.fire(new s.z(new Error(`An image with the name "${l.name}" already exists.`)));
                    this.imageManager.addImage(l, this.scope, f), this._changes.updateImage(l, this.scope);
                } return this._updateWorkerImages(), this.fire(new s.A("data", { dataType: "style" })), this; }
                addImage(n, l) { return this.getImage(n) ? this.fire(new s.z(new Error(`An image with the name "${n.name}" already exists.`))) : (this.imageManager.addImage(n, this.scope, l), this._changes.updateImage(n, this.scope), this._updateWorkerImages(), this.fire(new s.A("data", { dataType: "style" })), this); }
                updateImage(n, l, f = !1) { this.imageManager.updateImage(n, this.scope, l), f && (this._changes.updateImage(n, this.scope), this._updateWorkerImages(), this.fire(new s.A("data", { dataType: "style" }))); }
                getImage(n) { return this.imageManager.getImage(n, this.scope); }
                removeImage(n) { return this.getImage(n) ? (this.imageManager.removeImage(n, this.scope), this._changes.updateImage(n, this.scope), this._updateWorkerImages(), this.fire(new s.A("data", { dataType: "style" })), this) : this.fire(new s.z(new Error("No image with this name exists."))); }
                listImages() { return this._checkLoaded(), this._availableImages.slice(); }
                addModelURLs(n) { return this.modelManager.addModelURLs(n, this.scope), this._updateWorkerModels(), this.fire(new s.A("data", { dataType: "style" })), this; }
                addModel(n, l, f = {}) { return this._checkLoaded(), this._validate(Ee, `models.${n}`, l, null, f) || (this.modelManager.addModel(n, l, this.scope), this.fire(new s.A("data", { dataType: "style" }))), this; }
                hasModel(n) { return this.modelManager.hasModel(n, this.scope); }
                removeModel(n) { return this.hasModel(n) ? (this.modelManager.removeModel(n, this.scope), this.fire(new s.A("data", { dataType: "style" })), this) : this.fire(new s.z(new Error("No model with this ID exists."))); }
                listModels() { return this._checkLoaded(), this.modelManager.listModels(this.scope); }
                addSource(n, l, f = {}) { if (this._checkLoaded(), this.getOwnSource(n) !== void 0)
                    throw new Error(`There is already a source with ID "${n}".`); if (!l.type)
                    throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(l).join(", ")}.`); if (["vector", "raster", "geojson", "video", "image"].indexOf(l.type) >= 0 && this._validate(id, `sources.${n}`, l, null, f))
                    return; this.map && this.map._collectResourceTiming && (l.collectResourceTiming = !0); const _ = mu(n, l, this.dispatcher, this); _.scope = this.scope, _.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(_.id), source: _.serialize(), sourceId: _.id })); const v = w => { const T = (w ? "symbol:" : "other:") + _.id, C = s.C(T, this.scope), P = this._sourceCaches[T] = new As(C, _, w); (w ? this._symbolSourceCaches : this._otherSourceCaches)[_.id] = P, P.onAdd(this.map); }; v(!1), l.type !== "vector" && l.type !== "geojson" || v(!0), _.onAdd && _.onAdd(this.map), f.isInitialLoad || (this.mergeSources(), this._changes.setDirty()); }
                removeSource(n) { this._checkLoaded(); const l = this.getOwnSource(n); if (!l)
                    throw new Error("There is no source with this ID"); for (const _ in this._layers)
                    if (this._layers[_].source === n)
                        return this.fire(new s.z(new Error(`Source "${n}" cannot be removed while layer "${_}" is using it.`))); if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === n)
                    return this.fire(new s.z(new Error(`Source "${n}" cannot be removed while terrain is using it.`))); if (this.stylesheet.iconsets) {
                    const _ = Object.entries(this.stylesheet.iconsets).find(([v, w]) => w.type === "source" && w.source === n);
                    if (_)
                        return this.fire(new s.z(new Error(`Source "${n}" cannot be removed while iconset "${_[0]}" is using it.`)));
                } const f = this.getOwnSourceCaches(n); for (const _ of f) {
                    const v = s.d8(_.id);
                    delete this._sourceCaches[v], this._changes.discardSourceCacheUpdate(_.id), _.fire(new s.A("data", { sourceDataType: "metadata", dataType: "source", sourceId: _.getSource().id })), _.setEventedParent(null), _.clearTiles();
                } return delete this._otherSourceCaches[n], delete this._symbolSourceCaches[n], this.mergeSources(), l.setEventedParent(null), l.onRemove && l.onRemove(this.map), this._changes.setDirty(), this; }
                setGeoJSONSourceData(n, l) { this._checkLoaded(), this.getOwnSource(n).setData(l), this._changes.setDirty(); }
                getOwnSource(n) { const l = this.getOwnSourceCache(n); return l && l.getSource(); }
                getOwnSources() { const n = []; for (const l in this._otherSourceCaches) {
                    const f = this.getOwnSourceCache(l);
                    f && n.push(f.getSource());
                } return n; }
                areTilesLoaded() { const n = this._mergedSourceCaches; for (const l in n) {
                    const f = n[l]._tiles;
                    for (const _ in f) {
                        const v = f[_];
                        if (v.state !== "loaded" && v.state !== "errored")
                            return !1;
                    }
                } return !0; }
                setLights(n) { if (this._checkLoaded(), !n)
                    return delete this.ambientLight, void delete this.directionalLight; const l = this._getTransitionParameters(); for (const _ of n) {
                    if (this._validate(sd, "lights", _))
                        return;
                    switch (_.type) {
                        case "ambient":
                            if (this.ambientLight) {
                                const v = this.ambientLight;
                                v.set(_), v.updateTransitions(l);
                            }
                            else
                                this.ambientLight = new vi(_, An || (An = new s.a7({ color: new s.a8(s.a5.properties_light_ambient.color), "color-use-theme": new s.a8({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new s.a8(s.a5.properties_light_ambient.intensity) })), this.scope, this.options);
                            break;
                        case "directional": if (this.directionalLight) {
                            const v = this.directionalLight;
                            v.set(_), v.updateTransitions(l);
                        }
                        else
                            this.directionalLight = new vi(_, en || (en = new s.a7({ direction: new s.an(s.a5.properties_light_directional.direction), color: new s.a8(s.a5.properties_light_directional.color), "color-use-theme": new s.a8({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new s.a8(s.a5.properties_light_directional.intensity), "cast-shadows": new s.a8(s.a5.properties_light_directional["cast-shadows"]), "shadow-quality": new s.a8(s.a5.properties_light_directional["shadow-quality"]), "shadow-intensity": new s.a8(s.a5.properties_light_directional["shadow-intensity"]) })), this.scope, this.options);
                    }
                } const f = new s.aa(this.z || 0, l); this.ambientLight && this.ambientLight.recalculate(f), this.directionalLight && this.directionalLight.recalculate(f), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness); }
                calculateLightsBrightness() { const n = this.directionalLight, l = this.ambientLight; if (!n || !l)
                    return; const f = D => .2126 * (D[0] <= .03928 ? D[0] / 12.92 : Math.pow((D[0] + .055) / 1.055, 2.4)) + .7152 * (D[1] <= .03928 ? D[1] / 12.92 : Math.pow((D[1] + .055) / 1.055, 2.4)) + .0722 * (D[2] <= .03928 ? D[2] / 12.92 : Math.pow((D[2] + .055) / 1.055, 2.4)), _ = n.properties.get("color").toRenderColor(null).toArray01(), v = n.properties.get("intensity"), w = n.properties.get("direction"), T = 1 - s.cR(w.x, w.y, w.z)[2] / 90, C = f(_) * v * T, P = l.properties.get("color").toRenderColor(null).toArray01(), R = l.properties.get("intensity"), O = f(P) * R; return Number(((C + O) / 2).toFixed(6)); }
                getBrightness() { return this._brightness; }
                getLights() { if (!this.enable3dLights())
                    return null; const n = []; return this.directionalLight && n.push(this.directionalLight.get()), this.ambientLight && n.push(this.ambientLight.get()), n; }
                enable3dLights() { return !!this.ambientLight && !!this.directionalLight; }
                getFragmentStyle(n) { if (n == null || n === "" && this.isRootStyle())
                    return this; if (s.d9(n)) {
                    const l = s.da(n), f = this.fragments.find(({ id: v }) => v === l);
                    if (!f)
                        return;
                    const _ = s.d8(n);
                    return f.style.getFragmentStyle(_);
                } {
                    const l = this.fragments.find(({ id: f }) => f === n);
                    return l ? l.style : void 0;
                } }
                setFeaturesetSelectors(n) { if (!n)
                    return; const l = {}, f = (_, v = "") => `${_}::${v}`; this._featuresetSelectors = {}; for (const _ in n) {
                    const v = this._featuresetSelectors[_] = [];
                    for (const w of n[_].selectors) {
                        if (w.featureNamespace) {
                            const C = this.getOwnLayer(w.layer);
                            if (!C) {
                                s.w(`Layer is undefined for selector: ${w.layer}`);
                                continue;
                            }
                            const P = f(C.source, C.sourceLayer);
                            if (P in l && l[P] !== w.featureNamespace) {
                                s.w(`"featureNamespace ${w.featureNamespace} of featureset ${_}'s selector is not associated to the same source, skip this selector`);
                                continue;
                            }
                            l[P] = w.featureNamespace;
                        }
                        let T;
                        if (w.properties)
                            for (const C in w.properties) {
                                const P = s.X(w.properties[C]);
                                P.result === "success" && (T = T || {}, T[C] = P.value);
                            }
                        v.push({ layerId: w.layer, namespace: w.featureNamespace, properties: T, uniqueFeatureID: w._uniqueFeatureID });
                    }
                } }
                getFeaturesetDescriptors(n) { const l = this.getFragmentStyle(n); if (!l || !l.stylesheet.featuresets)
                    return []; const f = []; for (const _ in l.stylesheet.featuresets)
                    f.push({ featuresetId: _, importId: l.scope ? l.scope : void 0 }); return f; }
                getFeaturesetLayers(n, l) { const f = this.getFragmentStyle(l), _ = f.stylesheet.featuresets; if (!_ || !_[n])
                    return this.fire(new s.z(new Error(`The featureset '${n}' does not exist in the map's style and cannot be queried.`))), []; const v = []; for (const w of _[n].selectors) {
                    const T = f.getOwnLayer(w.layer);
                    T && v.push(T);
                } return v; }
                getConfigProperty(n, l) { const f = this.getFragmentStyle(n); if (!f)
                    return null; const _ = s.C(l, f.scope), v = f.options.get(_), w = v ? v.value || v.default : null; return w ? w.serialize() : null; }
                setConfigProperty(n, l, f) { const _ = this.getFragmentStyle(n); if (!_)
                    return; const v = _.stylesheet.indoor ? x0(_.stylesheet.schema) : _.stylesheet.schema; if (!v || !v[l])
                    return; const w = s.X(f); if (w.result !== "success")
                    return void Dl(this, w.value); const T = w.value.expression, C = s.C(l, _.scope), P = _.options.get(C); if (!P)
                    return; let R; const { minValue: O, maxValue: D, stepValue: B, type: q, values: G } = v[l], K = s.X(v[l].default); K.result === "success" && (R = K.value.expression), R ? (this.options.set(C, Object.assign({}, P, { value: T, default: R, minValue: O, maxValue: D, stepValue: B, type: q, values: G })), this.updateConfigDependencies(l)) : this.fire(new s.z(new Error(`No schema defined for the config option "${l}" in the "${n}" fragment.`))); }
                getConfig(n) { const l = this.getFragmentStyle(n); if (!l)
                    return null; const f = l.stylesheet.schema; if (!f)
                    return null; const _ = {}; for (const v in f) {
                    const w = s.C(v, l.scope), T = l.options.get(w), C = T ? T.value || T.default : null;
                    _[v] = C ? C.serialize() : null;
                } return _; }
                setConfig(n, l) { const f = this.getFragmentStyle(n); f && (f.updateConfig(l, f.stylesheet.schema), this.updateConfigDependencies()); }
                getSchema(n) { const l = this.getFragmentStyle(n); return l ? l.stylesheet.schema : null; }
                setSchema(n, l) { const f = this.getFragmentStyle(n); f && (f.stylesheet.schema = l, f.updateConfig(f._config, l), this.updateConfigDependencies()); }
                updateConfig(n, l) { if (this._config = n, n || l)
                    if (l)
                        for (const f in l) {
                            let _, v;
                            const w = s.X(l[f].default);
                            if (w.result === "success" && (_ = w.value.expression), n && n[f] !== void 0) {
                                const D = s.X(n[f]);
                                D.result === "success" && (v = D.value.expression);
                            }
                            const { minValue: T, maxValue: C, stepValue: P, type: R, values: O } = l[f];
                            if (_) {
                                const D = s.C(f, this.scope);
                                this.options.set(D, { default: _, value: v, minValue: T, maxValue: C, stepValue: P, type: R, values: O });
                            }
                            else
                                this.fire(new s.z(new Error(`No schema defined for config option "${f}".`)));
                        }
                    else
                        this.fire(new s.z(new Error("Attempting to set config for a style without schema."))); }
                updateConfigDependencies(n) { for (const l of this._configDependentLayers) {
                    const f = this.getLayer(l);
                    if (f) {
                        if (n && !f.configDependencies.has(n))
                            continue;
                        f.possiblyEvaluateVisibility(), this._updateLayer(f);
                    }
                } this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle(l => { const f = l._styleColorTheme.colorThemeOverride ? l._styleColorTheme.colorThemeOverride : l._styleColorTheme.colorTheme; if (f) {
                    const _ = l._evaluateColorThemeData(f);
                    (!l._styleColorTheme.lut && _ !== "" || l._styleColorTheme.lut && _ !== l._styleColorTheme.lut.data) && l.setColorTheme(f);
                } }), this._changes.setDirty(); }
                addLayer(n, l, f = {}) { this._checkLoaded(); const _ = n.id; if (this._layers[_])
                    return void this.fire(new s.z(new Error(`Layer with id "${_}" already exists on this map`))); let v; if (n.type === "custom") {
                    if (Dl(this, s.db(n)))
                        return;
                    v = s.dc(n, this.scope, this._styleColorTheme.lut, this.options);
                }
                else {
                    if (typeof n.source == "object" && (this.addSource(_, n.source), n = s.d7(n), n = s.l(n, { source: _ })), this._validate(Z, `layers.${_}`, n, { arrayIndex: -1 }, f))
                        return;
                    v = s.dc(n, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(v), v.setEventedParent(this, { layer: { id: _ } });
                } v.configDependencies.size !== 0 && this._configDependentLayers.add(v.fqid); let w = this._order.length; if (l) {
                    const R = this._order.indexOf(l);
                    if (R === -1)
                        return void this.fire(new s.z(new Error(`Layer with id "${l}" does not exist on this map.`)));
                    v.slot === this._layers[l].slot ? w = R : s.w(`Layer with id "${l}" has a different slot. Layers can only be rearranged within the same slot.`);
                } this._order.splice(w, 0, _), this._layerOrderChanged = !0, this._layers[_] = v; const T = this.getOwnLayerSourceCache(v), C = !!this.directionalLight && this.directionalLight.shadowsEnabled(); T && v.canCastShadows() && C && (T.castsShadows = !0); const P = this._changes.getRemovedLayer(v); if (P && v.source && T && v.type !== "custom") {
                    this._changes.discardLayerRemoval(v);
                    const R = s.C(v.source, v.scope);
                    P.type !== v.type ? this._changes.updateSourceCache(R, "clear") : (this._changes.updateSourceCache(R, "reload"), T.pause());
                } this._updateLayer(v), v.onAdd && v.onAdd(this.map), v.scope = this.scope, this.mergeLayers(); }
                moveLayer(n, l) { this._checkLoaded(); const f = this._checkLayer(n); if (!f || n === l)
                    return; const _ = this._order.indexOf(n); this._order.splice(_, 1); let v = this._order.length; if (l) {
                    const w = this._order.indexOf(l);
                    if (w === -1)
                        return void this.fire(new s.z(new Error(`Layer with id "${l}" does not exist on this map.`)));
                    f.slot === this._layers[l].slot ? v = w : s.w(`Layer with id "${l}" has a different slot. Layers can only be rearranged within the same slot.`);
                } this._order.splice(v, 0, n), this._changes.setDirty(), this._layerOrderChanged = !0, this.mergeLayers(); }
                removeLayer(n) { this._checkLoaded(); const l = this._checkLayer(n); if (!l)
                    return; l.setEventedParent(null); const f = this._order.indexOf(n); this._order.splice(f, 1), delete this._layers[n], this._changes.setDirty(), this._layerOrderChanged = !0, this._configDependentLayers.delete(l.fqid), this._changes.removeLayer(l); const _ = this.getOwnLayerSourceCache(l); if (_ && _.castsShadows) {
                    let v = !1;
                    for (const w in this._layers)
                        if (this._layers[w].source === l.source && this._layers[w].canCastShadows()) {
                            v = !0;
                            break;
                        }
                    _.castsShadows = v;
                } l.onRemove && l.onRemove(this.map), this.mergeLayers(); }
                getOwnLayer(n) { return this._layers[n]; }
                hasLayer(n) { return n in this._mergedLayers; }
                hasLayerType(n) { for (const l in this._layers)
                    if (this._layers[l].type === n)
                        return !0; return !1; }
                setLayerZoomRange(n, l, f) { this._checkLoaded(); const _ = this._checkLayer(n); _ && (_.minzoom === l && _.maxzoom === f || (l != null && (_.minzoom = l), f != null && (_.maxzoom = f), this._updateLayer(_))); }
                getSlots() { return this._checkLoaded(), this._mergedSlots; }
                setSlot(n, l) { this._checkLoaded(); const f = this._checkLayer(n); f && f.slot !== l && (f.slot = l, this._updateLayer(f)); }
                setFilter(n, l, f = {}) { this._checkLoaded(); const _ = this._checkLayer(n); if (_ && !s.bv(_.filter, l))
                    return l == null ? (_.filter = void 0, void this._updateLayer(_)) : void (this._validate(re, `layers.${_.id}.filter`, l, { layerType: _.type }, f) || (_.filter = s.d7(l), this._updateLayer(_))); }
                getFilter(n) { const l = this._checkLayer(n); if (l)
                    return s.d7(l.filter); }
                setLayoutProperty(n, l, f, _ = {}) { this._checkLoaded(); const v = this._checkLayer(n); if (v && !s.bv(v.getLayoutProperty(l), f)) {
                    if (f != null && (!_ || _.validate !== !1) && Dl(v, Ae.call(Ro, { key: `layers.${n}.layout.${l}`, layerType: v.type, objectKey: l, value: f, styleSpec: s.a5, style: { glyphs: !0, sprite: !0 } })))
                        return;
                    v.setLayoutProperty(l, f), v.configDependencies.size !== 0 && this._configDependentLayers.add(v.fqid), this._updateLayer(v);
                } }
                getLayoutProperty(n, l) { const f = this._checkLayer(n); if (f)
                    return f.getLayoutProperty(l); }
                setPaintProperty(n, l, f, _ = {}) { this._checkLoaded(); const v = this._checkLayer(n); if (!v || s.bv(v.getPaintProperty(l), f) || f != null && (!_ || _.validate !== !1) && Dl(v, _e.call(Ro, { key: `layers.${n}.paint.${l}`, layerType: v.type, objectKey: l, value: f, styleSpec: s.a5 })))
                    return; const w = v.setPaintProperty(l, f); v.configDependencies.size !== 0 && this._configDependentLayers.add(v.fqid), w && this._updateLayer(v), this._changes.updatePaintProperties(v); }
                getPaintProperty(n, l) { const f = this._checkLayer(n); if (f)
                    return f.getPaintProperty(l); }
                setFeatureState(n, l) { if (this._checkLoaded(), "target" in n) {
                    if ("featuresetId" in n.target) {
                        const { featuresetId: C, importId: P } = n.target, R = this.getFragmentStyle(P), O = R.getFeaturesetLayers(C);
                        for (const { source: D, sourceLayer: B } of O)
                            R.setFeatureState({ id: n.id, source: D, sourceLayer: B }, l);
                    }
                    else if ("layerId" in n.target) {
                        const { layerId: C } = n.target, P = this.getLayer(C);
                        this.setFeatureState({ id: n.id, source: P.source, sourceLayer: P.sourceLayer }, l);
                    }
                    return;
                } const f = n.source, _ = n.sourceLayer, v = this._checkSource(f); if (!v)
                    return; const w = v.type; if (w === "geojson" && _)
                    return void this.fire(new s.z(new Error("GeoJSON sources cannot have a sourceLayer parameter."))); if (w === "vector" && !_)
                    return void this.fire(new s.z(new Error("The sourceLayer parameter must be provided for vector source types."))); n.id === void 0 && this.fire(new s.z(new Error("The feature id parameter must be provided."))); const T = this.getOwnSourceCaches(f); for (const C of T)
                    C.setFeatureState(_, n.id, l); }
                removeFeatureState(n, l) { if (this._checkLoaded(), "target" in n) {
                    if ("featuresetId" in n.target) {
                        const { featuresetId: C, importId: P } = n.target, R = this.getFragmentStyle(P), O = R.getFeaturesetLayers(C);
                        for (const { source: D, sourceLayer: B } of O)
                            R.removeFeatureState({ id: n.id, source: D, sourceLayer: B }, l);
                    }
                    else if ("layerId" in n.target) {
                        const { layerId: C } = n.target, P = this.getLayer(C);
                        this.removeFeatureState({ id: n.id, source: P.source, sourceLayer: P.sourceLayer }, l);
                    }
                    return;
                } const f = n.source, _ = this._checkSource(f); if (!_)
                    return; const v = _.type, w = v === "vector" ? n.sourceLayer : void 0; if (v === "vector" && !w)
                    return void this.fire(new s.z(new Error("The sourceLayer parameter must be provided for vector source types."))); if (l && typeof n.id != "string" && typeof n.id != "number")
                    return void this.fire(new s.z(new Error("A feature id is required to remove its specific state property."))); const T = this.getOwnSourceCaches(f); for (const C of T)
                    C.removeFeatureState(w, n.id, l); }
                getFeatureState(n) { if (this._checkLoaded(), "target" in n) {
                    let v;
                    if ("featuresetId" in n.target) {
                        const { featuresetId: w, importId: T } = n.target, C = this.getFragmentStyle(T), P = C.getFeaturesetLayers(w);
                        for (const { source: R, sourceLayer: O } of P) {
                            const D = C.getFeatureState({ id: n.id, source: R, sourceLayer: O });
                            if (D && !v)
                                v = D;
                            else if (!s.bv(v, D))
                                return void this.fire(new s.z(new Error("The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.")));
                        }
                    }
                    else if ("layerId" in n.target) {
                        const { layerId: w } = n.target, T = this.getLayer(w);
                        v = this.getFeatureState({ id: n.id, source: T.source, sourceLayer: T.sourceLayer });
                    }
                    return v;
                } const l = n.source, f = n.sourceLayer, _ = this._checkSource(l); if (_) {
                    if (_.type !== "vector" || f)
                        return n.id === void 0 && this.fire(new s.z(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(l)[0].getFeatureState(f, n.id);
                    this.fire(new s.z(new Error("The sourceLayer parameter must be provided for vector source types.")));
                } }
                setTransition(n) { return this.stylesheet.transition = s.l({}, this.stylesheet.transition, n), this.transition = this.stylesheet.transition, this; }
                getTransition() { return s.l({}, this.stylesheet.transition); }
                serialize() { this._checkLoaded(); const n = this.getTerrain(), l = n && this.terrain && this.terrain.scope === this.scope ? n : this.stylesheet.terrain; return s.dd({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, fragment: this.stylesheet.fragment, iconsets: this.stylesheet.iconsets, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: l, fog: this.stylesheet.fog, snow: this.stylesheet.snow, rain: this.stylesheet.rain, center: this.stylesheet.center, "color-theme": this.stylesheet["color-theme"], zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, f => f !== void 0); }
                _updateFilteredLayers(n) { for (const l of Object.values(this._mergedLayers))
                    n(l) && this._updateLayer(l); }
                _updateLayer(n) { this._changes.updateLayer(n); const l = this.getLayerSourceCache(n), f = s.C(n.source, n.scope), _ = this._changes.getUpdatedSourceCaches(); n.source && !_[f] && l && l.getSource().type !== "raster" && (this._changes.updateSourceCache(f, "reload"), l.pause()), n.invalidateCompiledFilter(); }
                _flattenAndSortRenderedFeatures(n) { const l = T => this._mergedLayers[T].is3D(!!this.terrain), f = this.order, _ = {}, v = []; for (let T = f.length - 1; T >= 0; T--) {
                    const C = f[T];
                    if (l(C)) {
                        _[C] = T;
                        for (const P of n) {
                            const R = P[C];
                            if (R)
                                for (const O of R)
                                    v.push(O);
                        }
                    }
                } v.sort((T, C) => C.intersectionZ - T.intersectionZ); const w = []; for (let T = f.length - 1; T >= 0; T--) {
                    const C = f[T];
                    if (l(C))
                        for (let P = v.length - 1; P >= 0; P--) {
                            const R = v[P].feature;
                            if (R.layer && _[R.layer.id] < T)
                                break;
                            w.push(R), v.pop();
                        }
                    else
                        for (const P of n) {
                            const R = P[C];
                            if (R)
                                for (const O of R)
                                    w.push(O.feature);
                        }
                } return w; }
                queryRenderedFeatures(n, l, f) { let _; l && !Array.isArray(l) && l.filter && (this._validate(re, "queryRenderedFeatures.filter", l.filter, null, l), _ = s.b3(l.filter)); const v = {}, w = R => { if (Ya.has(R.type))
                    return; const O = this.getOwnLayerSourceCache(R), D = v[O.id] = v[O.id] || { sourceCache: O, layers: {}, has3DLayers: !1 }; R.is3D(!!this.terrain) && (D.has3DLayers = !0), D.layers[R.fqid] = D.layers[R.fqid] || { styleLayer: R, targets: [] }, D.layers[R.fqid].targets.push({ filter: _ }); }; if (l && l.layers) {
                    if (!Array.isArray(l.layers))
                        return this.fire(new s.z(new Error("parameters.layers must be an Array."))), [];
                    for (const R of l.layers) {
                        const O = this._layers[R];
                        if (!O)
                            return this.fire(new s.z(new Error(`The layer '${R}' does not exist in the map's style and cannot be queried for features.`))), [];
                        w(O);
                    }
                }
                else
                    for (const R in this._layers)
                        w(this._layers[R]); const T = this._queryRenderedFeatures(n, v, f), C = this._flattenAndSortRenderedFeatures(T), P = []; for (const R of C)
                    s.de(R.layer.id) === this.scope && P.push(R); return P; }
                queryRenderedFeatureset(n, l, f) { let _; l && !Array.isArray(l) && l.filter && (this._validate(re, "queryRenderedFeatures.filter", l.filter, null, l), _ = s.b3(l.filter)); const v = "mock", w = []; if (l && l.target)
                    w.push(Object.assign({}, l, { targetId: v, filter: _ }));
                else {
                    const R = this.getFeaturesetDescriptors();
                    for (const O of R)
                        w.push({ targetId: v, filter: _, target: O });
                    for (const { style: O } of this.fragments) {
                        const D = O.getFeaturesetDescriptors();
                        for (const B of D)
                            w.push({ targetId: v, filter: _, target: B });
                    }
                } const T = this.queryRenderedTargets(n, w, f), C = [], P = new Set; for (const R of T)
                    for (const O of R.variants[v])
                        ad(O, R, P) || C.push(new s.df(R, O)); return C; }
                queryRenderedTargets(n, l, f) { const _ = {}, v = (T, C, P, R) => { const O = _[C.id] = _[C.id] || { sourceCache: C, layers: {}, has3DLayers: !1 }; if (O.layers[T.fqid] = O.layers[T.fqid] || { styleLayer: T, targets: [] }, T.is3D(!!this.terrain) && (O.has3DLayers = !0), !R)
                    return P.uniqueFeatureID = !1, void O.layers[T.fqid].targets.push(P); O.layers[T.fqid].targets.push(Object.assign({}, P, { namespace: R.namespace, properties: R.properties, uniqueFeatureID: R.uniqueFeatureID })); }; for (const T of l)
                    if ("featuresetId" in T.target) {
                        const { featuresetId: C, importId: P } = T.target, R = this.getFragmentStyle(P);
                        if (!R || !R._featuresetSelectors)
                            continue;
                        const O = R._featuresetSelectors[C];
                        if (!O) {
                            this.fire(new s.z(new Error(`The featureset '${C}' does not exist in the map's style and cannot be queried for features.`)));
                            continue;
                        }
                        for (const D of O) {
                            const B = R.getOwnLayer(D.layerId);
                            B && !Ya.has(B.type) && v(B, R.getOwnLayerSourceCache(B), T, D);
                        }
                    }
                    else if ("layerId" in T.target) {
                        const { layerId: C } = T.target, P = this.getLayer(C);
                        if (!P || Ya.has(P.type))
                            continue;
                        v(P, this.getLayerSourceCache(P), T);
                    } const w = this._queryRenderedFeatures(n, _, f); return this._flattenAndSortRenderedFeatures(w); }
                _queryRenderedFeatures(n, l, f) { const _ = [], v = !!this.map._showQueryGeometry, w = Mi.createFromScreenPoints(n, f); for (const T in l) {
                    const C = yc(w, l[T], this._availableImages, f, v);
                    Object.keys(C).length && _.push(C);
                } if (this.placement)
                    for (const T in l) {
                        if (!l[T].sourceCache._onlySymbols)
                            continue;
                        const C = ld(w.screenGeometry, l[T], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData);
                        Object.keys(C).length && _.push(C);
                    } return _; }
                querySourceFeatures(n, l) { const f = l && l.filter; f && this._validate(re, "querySourceFeatures.filter", f, null, l); let _ = []; const v = this.getOwnSourceCaches(n); for (const w of v)
                    _ = _.concat(kg(w, l)); return _; }
                addSourceType(n, l, f) { return Lo.getSourceType(n) ? f(new Error(`A source type called "${n}" already exists.`)) : (Lo.setSourceType(n, l), l.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: n, url: l.workerSourceURL }, f) : f(null, null)); }
                getFlatLight() { return this.light.getLight(); }
                setFlatLight(n, l, f = {}) { this._checkLoaded(); const _ = this.light.getLight(); let v = !1; for (const T in n)
                    if (!s.bv(n[T], _[T])) {
                        v = !0;
                        break;
                    } if (!v)
                    return; const w = this._getTransitionParameters(); this.light.setLight(n, l, f), this.light.updateTransitions(w); }
                getTerrain() { return this.terrain && this.terrain.drapeRenderMode === 1 ? this.terrain.get() : null; }
                setTerrainForDraping() { this.setTerrain({ source: "", exaggeration: 0 }, 0); }
                checkCanvasFingerprintNoise() { this.disableElevatedTerrain === void 0 && (this.disableElevatedTerrain = s.q.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && s.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode).")); }
                setTerrain(n, l = 1) { if (this._checkLoaded(), !n)
                    return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), l === 0 && delete this.terrain, n === null ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0); this.checkCanvasFingerprintNoise(); let f = n; const _ = n.source == null; if (l === 1) {
                    if (this.disableElevatedTerrain)
                        return;
                    if (typeof f.source == "object") {
                        const T = "terrain-dem-src";
                        this.addSource(T, f.source), f = s.d7(f), f = s.l(f, { source: T });
                    }
                    const v = s.l({}, f), w = {};
                    if (this.terrain && _) {
                        v.source = this.terrain.get().source;
                        const T = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
                        T && (w.style = T.serialize());
                    }
                    if (this._validate(Et, "terrain", v, w))
                        return;
                } if (!this.terrain || this.terrain.scope !== this.scope && !_ || this.terrain && l !== this.terrain.drapeRenderMode) {
                    if (!f)
                        return;
                    this._createTerrain(f, l), this.fire(new s.A("data", { dataType: "style" }));
                }
                else {
                    const v = this.terrain, w = v.get();
                    for (const T of Object.keys(s.a5.terrain))
                        !f.hasOwnProperty(T) && s.a5.terrain[T].default && (f[T] = s.a5.terrain[T].default);
                    for (const T in n)
                        if (!s.bv(n[T], w[T])) {
                            v.set(n, this.options), this.stylesheet.terrain = n;
                            const C = this._getTransitionParameters({ duration: 0 });
                            v.updateTransitions(C), this.fire(new s.A("data", { dataType: "style" }));
                            break;
                        }
                } this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = !0; }
                _createFog(n) { const l = this.fog = new Fr(n, this.map.transform, this.scope, this.options); this.stylesheet.fog = l.get(); const f = this._getTransitionParameters({ duration: 0 }); l.updateTransitions(f); }
                _createSnow(n) { const l = this.snow = new In(n, this.map.transform, this.scope, this.options); this.stylesheet.snow = l.get(); const f = this._getTransitionParameters({ duration: 0 }); l.updateTransitions(f); }
                _createRain(n) { const l = this.rain = new Dn(n, this.map.transform, this.scope, this.options); this.stylesheet.rain = l.get(); const f = this._getTransitionParameters({ duration: 0 }); l.updateTransitions(f); }
                _updateMarkersOpacity() { this.map._markers.length !== 0 && this.map._requestDomTask(() => { for (const n of this.map._markers)
                    n._evaluateOpacity(); }); }
                getFog() { return this.fog ? this.fog.get() : null; }
                setFog(n) { if (this._checkLoaded(), !n)
                    return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0); if (this.fog) {
                    const l = this.fog;
                    if (!s.bv(l.get(), n)) {
                        l.set(n, this.options), this.stylesheet.fog = l.get();
                        const f = this._getTransitionParameters({ duration: 0 });
                        l.updateTransitions(f);
                    }
                }
                else
                    this._createFog(n); this._markersNeedUpdate = !0; }
                getSnow() { return this.snow ? this.snow.get() : null; }
                setSnow(n) { if (this._checkLoaded(), !n)
                    return delete this.snow, void delete this.stylesheet.snow; if (this.snow) {
                    const l = this.snow;
                    if (!s.bv(l.get(), n)) {
                        l.set(n, this.options), this.stylesheet.snow = l.get();
                        const f = this._getTransitionParameters({ duration: 0 });
                        l.updateTransitions(f);
                    }
                }
                else
                    this._createSnow(n); this._markersNeedUpdate = !0; }
                getRain() { return this.rain ? this.rain.get() : null; }
                setRain(n) { if (this._checkLoaded(), !n)
                    return delete this.rain, void delete this.stylesheet.rain; if (this.rain) {
                    const l = this.rain;
                    if (!s.bv(l.get(), n)) {
                        l.set(n, this.options), this.stylesheet.rain = l.get();
                        const f = this._getTransitionParameters({ duration: 0 });
                        l.updateTransitions(f);
                    }
                }
                else
                    this._createRain(n); this._markersNeedUpdate = !0; }
                _reloadColorTheme() { const n = () => { for (const _ in this._layers)
                    this._layers[_].lut = this._styleColorTheme.lut; for (const _ in this._sourceCaches)
                    this._sourceCaches[_].clearTiles(); }, l = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme; if (!l)
                    return this._styleColorTheme.lut = null, void n(); const f = this._evaluateColorThemeData(l); this._loadColorTheme(f).then(() => { this.fire(new s.A("colorthemeset")), n(); }).catch(_ => { s.w(`Couldn't set color theme: ${_}`); }); }
                setColorTheme(n) { this._checkLoaded(), this._styleColorTheme.colorThemeOverride && s.w("Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible."), this._styleColorTheme.colorTheme = n, this._reloadColorTheme(); }
                setImportColorTheme(n, l) { const f = this.getFragmentStyle(n); f && (f._styleColorTheme.colorThemeOverride = l, f._reloadColorTheme()); }
                _getTransitionParameters(n) { return { now: s.q.now(), transition: s.l(this.transition, n) }; }
                updateDrapeFirstLayers() { if (!this.terrain)
                    return; const n = [], l = []; for (const f of this._mergedOrder)
                    this.isLayerDraped(this._mergedLayers[f]) ? n.push(f) : l.push(f); this._drapedFirstOrder = [], this._drapedFirstOrder.push(...n), this._drapedFirstOrder.push(...l); }
                _createTerrain(n, l) { const f = this.terrain = new tt(n, l, this.scope, this.options); l === 1 && (this.stylesheet.terrain = n), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate(); const _ = this._getTransitionParameters({ duration: 0 }); f.updateTransitions(_); }
                _force3DLayerUpdate() { for (const n in this._layers) {
                    const l = this._layers[n];
                    l.type === "fill-extrusion" && this._updateLayer(l);
                } }
                _forceSymbolLayerUpdate() { for (const n in this._layers) {
                    const l = this._layers[n];
                    l.type === "symbol" && this._updateLayer(l);
                } }
                _validate(n, l, f, _, v = {}) { if (v && v.validate === !1)
                    return !1; const w = s.l({}, this.serialize()); return Dl(this, n.call(Ro, s.l({ key: l, style: w, value: f, styleSpec: s.a5 }, _))); }
                _remove() { this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), s.dg.off("pluginStateChange", this._rtlTextPluginCallback); for (const n in this._mergedLayers)
                    this._mergedLayers[n].setEventedParent(null); for (const n in this._mergedSourceCaches)
                    this._mergedSourceCaches[n].clearTiles(), this._mergedSourceCaches[n].setEventedParent(null); this.imageManager.removeScope(this.scope), this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.modelManager.destroy(), this.dispatcher.remove()); }
                clearSource(n) { const l = this.getSourceCaches(n); for (const f of l)
                    f.clearTiles(); }
                clearSources() { for (const n in this._mergedSourceCaches)
                    this._mergedSourceCaches[n].clearTiles(); }
                reloadSource(n) { const l = this.getSourceCaches(n); for (const f of l)
                    f.resume(), f.reload(); }
                reloadSources() { for (const n of this.getSources())
                    n.reload && n.reload(); }
                reloadModels() { this.modelManager.reloadModels(""), this.forEachFragmentStyle(n => { n.modelManager.reloadModels(n.scope); }); }
                updateSources(n) { let l; this.directionalLight && (l = Ug(this.directionalLight)); const f = new Set; for (const _ in this._mergedLayers) {
                    const v = this._mergedLayers[_];
                    v.hasElevation() && !f.has(v.source) && f.add(v.source);
                } for (const _ in this._mergedSourceCaches) {
                    const v = this._mergedSourceCaches[_], w = f.has(v._source.id);
                    v.update(n, void 0, void 0, l, w);
                } }
                _generateCollisionBoxes() { for (const n in this._sourceCaches) {
                    const l = this._sourceCaches[n];
                    l.resume(), l.reload();
                } }
                _updatePlacement(n, l, f, _, v, w, T = !1) { let C = !1, P = !1; const R = {}, O = {}; for (const D of this._mergedOrder) {
                    const B = this._mergedLayers[D];
                    if (B.type !== "symbol")
                        continue;
                    const q = s.C(B.source, B.scope);
                    let G = R[q];
                    if (!G) {
                        const W = this.getLayerSourceCache(B);
                        if (!W)
                            continue;
                        const oe = W.getRenderableIds(!0).map(de => W.getTileByID(de));
                        O[q] = oe.slice(), G = R[q] = oe.sort((de, me) => me.tileID.overscaledZ - de.tileID.overscaledZ || (de.tileID.isLessThan(me.tileID) ? -1 : 1));
                    }
                    const K = this.crossTileSymbolIndex.addLayer(B, G, l.center.lng, l.projection);
                    C = C || K;
                } if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), T = T || this._layerOrderChanged || _ === 0, this._layerOrderChanged && this.fire(new s.A("neworder")), (T || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(s.q.now(), l.zoom)) && (this.pauseablePlacement = new Ps(l, this._mergedOrder, T, f, _, v, this.placement, this.fog && l.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, R, O, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(s.q.now()), P = !0), C && this.pauseablePlacement.placement.setStale()), P || C) {
                    this._buildingIndex.onNewFrame(l.zoom);
                    for (let D = 0; D < this._mergedOrder.length; D++) {
                        const B = this._mergedLayers[this._mergedOrder[D]];
                        if (B.type !== "symbol")
                            continue;
                        const q = this.isLayerClipped(B);
                        this.placement.updateLayerOpacities(B, R[s.C(B.source, B.scope)], D, q ? w : null);
                    }
                } return { needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(s.q.now()) }; }
                _releaseSymbolFadeTiles() { for (const n in this._sourceCaches)
                    this._sourceCaches[n].releaseSymbolFadeTiles(); }
                addImport(n, l) { this._checkLoaded(); const f = this.stylesheet.imports = this.stylesheet.imports || []; if (f.findIndex(({ id: v }) => v === n.id) !== -1)
                    return void this.fire(new s.z(new Error(`Import with id '${n.id}' already exists in the map's style.`))); if (!l)
                    return f.push(n), this._loadImports([n], !0); const _ = f.findIndex(({ id: v }) => v === l); return _ === -1 && this.fire(new s.z(new Error(`Import with id "${l}" does not exist on this map.`))), this.stylesheet.imports = f.slice(0, _).concat(n).concat(f.slice(_)), this._loadImports([n], !0, l); }
                updateImport(n, l) { this._checkLoaded(); const f = this.stylesheet.imports || [], _ = this.getImportIndex(n); return _ === -1 ? this : typeof l == "string" ? (this.setImportUrl(n, l), this) : (l.url && l.url !== f[_].url && this.setImportUrl(n, l.url), s.bv(l.config, f[_].config) || this.setImportConfig(n, l.config, l.data.schema), s.bv(l.data, f[_].data) || this.setImportData(n, l.data), this); }
                moveImport(n, l) { this._checkLoaded(); let f = this.stylesheet.imports || []; const _ = this.getImportIndex(n); if (_ === -1)
                    return this; const v = this.getImportIndex(l); if (v === -1)
                    return this; const w = f[_], T = this.fragments[_]; return f = f.filter(({ id: C }) => C !== n), this.fragments = this.fragments.filter(({ id: C }) => C !== n), this.stylesheet.imports = f.slice(0, v).concat(w).concat(f.slice(v)), this.fragments = this.fragments.slice(0, v).concat(T).concat(this.fragments.slice(v)), this.mergeLayers(), this; }
                setImportUrl(n, l) { this._checkLoaded(); const f = this.stylesheet.imports || [], _ = this.getImportIndex(n); if (_ === -1)
                    return this; f[_].url = l; const v = this.fragments[_]; return v.style = this._createFragmentStyle(f[_]), v.style.on("style.import.load", () => this.mergeAll()), v.style.loadURL(l), this; }
                setImportData(n, l) { this._checkLoaded(); const f = this.getImportIndex(n), _ = this.stylesheet.imports || []; return f === -1 ? this : l ? (this.fragments[f].style.setState(l), this._reloadImports(), this) : (delete _[f].data, this.setImportUrl(n, _[f].url)); }
                setImportConfig(n, l, f) { this._checkLoaded(); const _ = this.getImportIndex(n), v = this.stylesheet.imports || []; if (_ === -1)
                    return this; l ? v[_].config = l : delete v[_].config; const w = this.fragments[_]; f && w.style.stylesheet && (w.style.stylesheet.schema = f); const T = w.style.stylesheet && w.style.stylesheet.schema; return w.config = l, w.style.updateConfig(l, T), this.updateConfigDependencies(), this; }
                removeImport(n) { this._checkLoaded(); const l = this.stylesheet.imports || [], f = this.getImportIndex(n); f !== -1 && (l.splice(f, 1), this.fragments[f].style._remove(), this.fragments.splice(f, 1), this._reloadImports()); }
                getImportIndex(n) { const l = (this.stylesheet.imports || []).findIndex(f => f.id === n); return l === -1 && this.fire(new s.z(new Error(`Import '${n}' does not exist in the map's style and cannot be updated.`))), l; }
                getLayer(n) { return this._mergedLayers[n]; }
                getSources() { const n = []; for (const l in this._mergedOtherSourceCaches) {
                    const f = this._mergedOtherSourceCaches[l];
                    f && n.push(f.getSource());
                } return n; }
                getSource(n, l) { const f = this.getSourceCache(n, l); return f && f.getSource(); }
                getLayerSource(n) { const l = this.getLayerSourceCache(n); return l && l.getSource(); }
                getSourceCache(n, l) { const f = s.C(n, l); return this._mergedOtherSourceCaches[f]; }
                getLayerSourceCache(n) { const l = s.C(n.source, n.scope); return n.type === "symbol" ? this._mergedSymbolSourceCaches[l] : this._mergedOtherSourceCaches[l]; }
                getSourceCaches(n) { if (n == null)
                    return Object.values(this._mergedSourceCaches); const l = []; return this._mergedOtherSourceCaches[n] && l.push(this._mergedOtherSourceCaches[n]), this._mergedSymbolSourceCaches[n] && l.push(this._mergedSymbolSourceCaches[n]), l; }
                updateSourceCaches() { const n = this._changes.getUpdatedSourceCaches(); for (const l in n) {
                    const f = n[l];
                    f === "reload" ? this.reloadSource(l) : f === "clear" && this.clearSource(l);
                } }
                updateLayers(n) { const l = this._changes.getUpdatedPaintProperties(); for (const f of l) {
                    const _ = this.getLayer(f);
                    _ && _.updateTransitions(n);
                } }
                getGlyphsUrl() { return this.stylesheet.glyphs; }
                setGlyphsUrl(n) { this.stylesheet.glyphs = n, this.glyphManager.setURL(n, this.scope); }
                getImages(n, l, f) { this.imageManager.getImages(l.images, l.scope, f), this._updateTilesForChangedImages(); const _ = w => { if (w) {
                    const T = l.images.map(C => s.I.toString(C));
                    w.setDependencies(l.tileID.key, l.type, T);
                } }, v = s.C(l.source, l.scope); _(this._mergedOtherSourceCaches[v]), _(this._mergedSymbolSourceCaches[v]); }
                rasterizeImages(n, l, f) { this.imageManager.rasterizeImages(l, f); }
                getGlyphs(n, l, f) { this.glyphManager.getGlyphs(l.stacks, l.scope, f); }
                getResource(n, l, f) { return s.dh(l, f); }
                getOwnSourceCache(n) { return this._otherSourceCaches[n]; }
                getOwnLayerSourceCache(n) { return n.type === "symbol" ? this._symbolSourceCaches[n.source] : this._otherSourceCaches[n.source]; }
                getOwnSourceCaches(n) { const l = []; return this._otherSourceCaches[n] && l.push(this._otherSourceCaches[n]), this._symbolSourceCaches[n] && l.push(this._symbolSourceCaches[n]), l; }
                _isSourceCacheLoaded(n) { const l = this.getOwnSourceCaches(n); return l.length === 0 ? (this.fire(new s.z(new Error(`There is no source with ID '${n}'`))), !1) : l.every(f => f.loaded()); }
                has3DLayers() { return this._has3DLayers; }
                hasSymbolLayers() { return this._hasSymbolLayers; }
                hasCircleLayers() { return this._hasCircleLayers; }
                isLayerClipped(n, l) { if (!this._clipLayerPresent && n.type !== "fill-extrusion")
                    return !1; const f = n.type === "fill-extrusion" && n.sourceLayer === "building"; if (n.is3D(!!this.terrain)) {
                    if (f || l && l.type === "batched-model" || n.type === "model")
                        return !0;
                }
                else if (n.type === "symbol")
                    return !0; return !1; }
                _clearWorkerCaches() { this.dispatcher.broadcast("clearCaches"); }
                destroy() { this._clearWorkerCaches(), this.fragments.forEach(n => { n.style._remove(); }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain); }
            }
            Lo.getSourceType = function (d) { return od[d]; }, Lo.setSourceType = function (d, n) { od[d] = n; }, Lo.registerForPluginStateChange = s.c$;
            var Eu = `
#define EPSILON 0.0000001
#define PI 3.141592653589793
#ifdef RENDER_CUTOFF
float cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}
#endif`, Cu = `
out vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}
#ifdef INDICATOR_CUTOUT
uniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;
#endif
vec4 applyCutout(vec4 color,float height) {
#ifdef INDICATOR_CUTOUT
float verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);
#else
return color;
#endif
}
#ifdef DEBUG_WIREFRAME
#define HANDLE_WIREFRAME_DEBUG \\
glFragColor=vec4(0.7,0.0,0.0,0.7); \\
gl_FragDepth=gl_FragCoord.z-0.0001;
#else
#define HANDLE_WIREFRAME_DEBUG
#endif
#ifdef RENDER_CUTOFF
uniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;
#endif
vec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}`, qg = `
#define EXTENT 8192.0
#define RAD_TO_DEG 180.0/PI
#define DEG_TO_RAD PI/180.0
#define GLOBE_RADIUS EXTENT/PI/2.0
float wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}
#ifdef PROJECTION_GLOBE_VIEW
vec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {
#ifndef PROJECTED_POS_ON_VIEWPORT
float tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;
#else
return vec3(0.0);
#endif
}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(
unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}
#ifdef RENDER_CUTOFF
uniform vec4 u_cutoff_params;out float v_cutoff_opacity;
#endif
const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)
{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}`, sp = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", po = `
#define ELEVATION_SCALE 7.0
#define ELEVATION_OFFSET 450.0
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(
mix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}
#else
vec3 elevationVector(vec2 pos) { return vec3(0,0,1); }
#endif
#ifdef TERRAIN
uniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}float prevElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}
#ifdef TERRAIN_VERTEX_MORPHING
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}
#else
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
return currentElevation(apos);}
#endif
vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}
#else
float elevation(vec2 pos) { return 0.0; }
#endif
#ifdef DEPTH_OCCLUSION
uniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;
#ifdef DEPTH_D24
float unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}
#else
highp float unpack_depth_rgba(vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}
#endif
bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;
#ifdef DEPTH_D24
float depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);
#else
float depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));
#endif
return coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;
#ifdef DEPTH_D24
highp vec4 depth=vec4(
texture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r
);depth=unpack_depth4(depth);
#else
highp vec4 depth=vec4(
unpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))
);
#endif
return depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {
#ifdef DEPTH_D24
highp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);
#else
highp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));
#endif
res+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}
#else
bool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }
#endif//DEPTH_OCCLUSION`, op = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}
#endif`, It = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {return color;}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}
#endif`, Hg = `#ifdef RASTER_ARRAY
uniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)
);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)
);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}
#endif`, ap = `#ifdef RASTER_ARRAY
uniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}
#endif
uniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}`, lp = `#ifdef RENDER_SHADOWS
uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}
#endif//RENDER_SHADOWS`, Wg = `#ifdef RENDER_SHADOWS
#ifdef DEPTH_TEXTURE
uniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;
#else
uniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;
#endif
uniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;
#ifdef DEPTH_TEXTURE
shadow_depth=texture(u_shadowmap_1,uv).r;
#else
shadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;
#endif
return step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;
#ifdef DEPTH_TEXTURE
shadow_depth=texture(u_shadowmap_0,uv).r;
#else
shadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;
#endif
return step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;
#ifdef TEXTURE_GATHER
highp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));
#else
highp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(
shadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)
);
#endif
vec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return clamp(mix(lerpx.x,lerpx.y,f.y),0.0,1.0);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {
#ifdef SHADOWS_SINGLE_CASCADE
light_view_pos0.xyz/=light_view_pos0.w;vec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);
#else
light_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return clamp(mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth)),0.0,1.0);
#endif
}highp float calculate_shadow_bias(float NDotL) {
#ifdef NORMAL_OFFSET
return 0.5*u_shadow_bias.x;
#else
return 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));
#endif
}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)
{highp vec2 biasUV=vec2(
pos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}
#endif`;
            const Ac = [];
            Iu(Eu, Ac), Iu(qg, Ac), Iu(Cu, Ac);
            const Oo = { "_prelude_fog.vertex.glsl": op, "_prelude_terrain.vertex.glsl": po, "_prelude_shadow.vertex.glsl": lp, "_prelude_fog.fragment.glsl": It, "_prelude_shadow.fragment.glsl": Wg, "_prelude_lighting.glsl": `
#ifdef LIGHTING_3D_MODE
uniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}
#endif//LIGHTING_3D_MODE`, "_prelude_raster_array.glsl": Hg, "_prelude_raster_particle.glsl": ap }, Au = {};
            Wr("", po), Wr(It, op), Wr(Wg, lp), Wr(Hg, ""), Wr(ap, "");
            const Ll = Wr(Cu, qg), bd = Eu;
            var Ic = { background: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec4 u_color;uniform float u_opacity;
#ifdef LIGHTING_3D_MODE
in vec4 v_color;
#endif
void main() {vec4 out_color;
#ifdef LIGHTING_3D_MODE
out_color=v_color;
#else
out_color=u_color;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_lighting.glsl"
in vec2 a_pos;uniform mat4 u_matrix;
#ifdef LIGHTING_3D_MODE
uniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0,1);
#ifdef LIGHTING_3D_MODE
v_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), backgroundPattern: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), building: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec4 v_color;in highp vec3 v_normal;in highp float v_height;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;
#endif
uniform lowp float u_opacity;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 apply_lighting_linear(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return color*(ambient_contrib+directional_contrib);}void main() {vec4 color=vec4(v_color.rgb,1.0);vec3 normal=normalize(v_normal);vec3 xy_flipped_normal=vec3(-normal.xy,normal.z);float shadowed_lighting_factor=0.0;
#ifdef RENDER_SHADOWS
shadowed_lighting_factor=shadowed_light_factor_normal(xy_flipped_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
shadowed_lighting_factor=dot(normal,u_lighting_directional_dir);
#endif
color.rgb=apply_lighting_linear(color.rgb,xy_flipped_normal,shadowed_lighting_factor);color.rgb=mix(color.rgb,v_color.rgb,v_color.a);color*=u_opacity;
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos,v_height));
#endif
#ifdef RENDER_CUTOFF
color*=v_cutoff_opacity;
#endif
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,v_height);
#endif
glFragColor=vec4(linearTosRGB(color.rgb),color.a);
#ifdef DEBUG_SHOW_NORMALS
color.rgb=xy_flipped_normal*0.5+vec3(0.5,0.5,0.5);color.a=1.0;glFragColor=color;
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec3 a_pos_3f;in vec3 a_normal_3f;out vec4 v_color;out highp vec3 v_normal;out highp float v_height;uniform mat4 u_matrix;uniform mat4 u_normal_matrix;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;
#endif
vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}
#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive
void main() {
#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive
vec4 color_emissive=decode_color(part_color_emissive);v_color=vec4(sRGBToLinear(color_emissive.rgb),color_emissive.a);v_normal=vec3(u_normal_matrix*vec4(a_normal_3f,0.0));vec3 pos=a_pos_3f;v_height=pos.z;gl_Position=u_matrix*vec4(pos,1.0);
#ifdef RENDER_SHADOWS
vec3 shadow_pos=pos;
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset_model(v_normal);shadow_pos+=offset*shadow_normal_offset_multiplier0();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1.0);v_depth_shadows=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
}`), buildingDepth: Wr(`in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`, "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;void main() {gl_Position=u_matrix*vec4(a_pos_3f,1.0);v_depth=gl_Position.z/gl_Position.w;}"), circle: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
uniform float u_emissive_strength;void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float antialiase_blur_opacity=smoothstep(0.0,antialiasblur,extrude_length-1.0);float opacity_t=blur_positive==1.0 ? 
smoothstep(0.0,-antialiased_blur,1.0-extrude_length) : 
smoothstep(antialiased_blur,0.0,extrude_length-1.0)-antialiase_blur_opacity;float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(
antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)
);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_apply_premultiplied(out_color,v_fog_pos);
#endif
glFragColor=out_color*(v_visibility*opacity_t);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define NUM_VISIBILITY_RINGS 2
#define INV_SQRT2 0.70710678
#define ELEVATION_BIAS 0.0001
#define NUM_SAMPLES_PER_RING 16
uniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
#ifdef ELEVATED_ROADS
in float a_circle_z_offset;
#endif
out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
vec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {
#if defined(TERRAIN)
return elevation(pos)+ELEVATION_BIAS;
#else
return 0.0;
#endif
}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);
#ifdef PITCH_WITH_MAP
#ifdef PROJECTION_GLOBE_VIEW
return u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );
#else
return u_matrix*( world_center+vec4(sample_offset,0,0) );
#endif
#else
return projected_center+vec4(sample_offset,0,0);
#endif
}float get_sample_step() {
#ifdef PITCH_WITH_MAP
return 2.0*PI/float(NUM_SAMPLES_PER_RING);
#else
return PI/float(NUM_SAMPLES_PER_RING);
#endif
}void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);
#else 
surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);
#endif
#ifdef ELEVATED_ROADS
world_center.z+=a_circle_z_offset+ELEVATION_BIAS;
#endif
vec4 projected_center=u_matrix*world_center;float view_scale=0.0;
#ifdef PITCH_WITH_MAP
#ifdef SCALE_WITH_MAP
view_scale=1.0;
#else
view_scale=projected_center.w/u_camera_to_center_distance;
#endif
#else
#ifdef SCALE_WITH_MAP
view_scale=u_camera_to_center_distance;
#else
view_scale=projected_center.w;
#endif
#endif
gl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;
#ifdef TERRAIN
float step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;
#ifdef PITCH_WITH_MAP
float cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;
#else
occlusion_world_center=world_center;occlusion_projected_center=projected_center;
#endif
for(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);
#else
visibility=1.0;
#endif
#ifdef PROJECTION_GLOBE_VIEW
visibility=1.0;
#endif
v_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);
#ifdef FOG
v_fog_pos=fog_position(world_center.xyz);
#endif
}`), clippingMask: Wr("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Wr(`#include "_prelude_fog.fragment.glsl"
uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);
#ifdef FOG
if (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_terrain.vertex.glsl"
#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#else
pos=vec3(tilePos+extrude,elevation(tilePos));
#endif
gl_Position=u_matrix*vec4(pos,1);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`), heatmapTexture: Wr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(0.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: Wr("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", `#include "_prelude_terrain.vertex.glsl"
in vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}`), collisionCircle: Wr("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", `in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(
mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}`), debug: Wr("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", `#include "_prelude_terrain.vertex.glsl"
in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;
#endif
out vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
gl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);
#else
gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);
#endif
}`), elevatedStructuresDepth: Wr(`void main() {
#ifndef DEPTH_TEXTURE
glFragColor=vec4(0.);
#endif
}`, "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform float u_depth_bias;void main() {gl_Position=u_matrix*vec4(a_pos,a_height,1);gl_Position.z=gl_Position.z+u_depth_bias;}"), elevatedStructuresDepthReconstruct: Wr(`#ifdef DEPTH_RECONSTRUCTION
in float v_height;
#endif
void main() {
#ifdef DEPTH_RECONSTRUCTION
if (v_height >=0.0)
discard;
#endif
glFragColor=vec4(1.0,0.0,0.0,1.0);}`, `in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform vec3 u_camera_pos;uniform highp float u_depth_bias;uniform lowp float u_height_scale;uniform lowp float u_reset_depth;
#ifdef DEPTH_RECONSTRUCTION
out float v_height;
#endif
void main() {vec3 vpos=vec3(a_pos,a_height*u_height_scale);
#ifdef DEPTH_RECONSTRUCTION
if (u_camera_pos.z > vpos.z) {vpos-=(u_camera_pos-vpos)*(vpos.z/(u_camera_pos.z-vpos.z));}v_height=a_height;
#endif
gl_Position=u_matrix*vec4(vpos,1);gl_Position.z=u_reset_depth==1.0 ? gl_Position.w : gl_Position.z+u_depth_bias;}`), elevatedStructures: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
in vec3 v_normal;in float v_height;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth;
#endif
void main() {vec3 color=vec3(241.0/255.0,236.0/255.0,225.0/255.0);
#ifdef LIGHTING_3D_MODE
vec3 normal=normalize(v_normal);
#ifdef RENDER_SHADOWS
float shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);
#else
color=apply_lighting(color,normal);
#endif
if (v_height < 0.0) {float penetration=max(v_height+7.5,0.0);float occlusion=1.0-1.0/PI*acos(1.0-penetration/4.0);color=color*(1.0-pow(occlusion,2.0)*0.3);}
#endif
#ifdef FOG
color=fog_apply(color,v_fog_pos);
#endif
vec4 out_color=vec4(color,1.0);
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_height);
#endif
glFragColor=out_color;HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;in float a_height;in vec3 a_pos_normal_3;uniform mat4 u_matrix;out vec3 v_normal;out float v_height;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;
#endif
void main() {v_normal=a_pos_normal_3/16384.0;v_height=a_height;vec3 pos=vec3(a_pos,a_height);gl_Position=u_matrix*vec4(pos,1);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=pos;vec3 shd_pos1=pos;
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(v_normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fill: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
vec4 out_color=color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=opacity;
#ifdef INDICATOR_CUTOUT
if (v_z_offset >=0.0) {out_color=applyCutout(out_color,v_z_offset);}
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp float z_offset
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=z_offset;
#endif
}`), fillOutline: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
in highp vec2 v_pos;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
uniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp float z_offset
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillOutlinePattern: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FILL_PATTERN_TRANSITION
uniform float u_pattern_transition;
#endif
uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
in highp vec2 v_pos;in highp vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef FILL_PATTERN_TRANSITION
vec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
out highp vec2 v_pos;out highp vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize highp float z_offset
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillPattern: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FILL_PATTERN_TRANSITION
uniform float u_pattern_transition;
#endif
in highp vec2 v_pos;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef FILL_PATTERN_TRANSITION
vec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
out highp vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize highp float z_offset
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillExtrusion: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec4 v_color;in vec4 v_flat;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;
#endif
uniform lowp float u_opacity;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec2 v_ao;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
in vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
in highp vec3 v_normal;
#endif
uniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
in float v_flood_radius;in float v_has_floodlight;
#endif
in float v_height;
#pragma mapbox: define highp float emissive_strength
void main() {
#pragma mapbox: initialize highp float emissive_strength
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
vec3 normal=normalize(v_normal);
#endif
float z;vec4 color=v_color;
#ifdef ZERO_ROOF_RADIUS
z=float(normal.z > 0.00001);
#ifdef LIGHTING_3D_MODE
normal=mix(normal,vec3(0.0,0.0,1.0),z);
#else
color=mix(v_color,v_roof_color,z);
#endif
#endif
float h=max(0.0,v_height);float ao_shade=1.0;
#ifdef FAUX_AO
float intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;
#ifdef ZERO_ROOF_RADIUS
concave*=(1.0-z);
#endif
float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
color.rgb*=mix(ao_shade,1.0,v_has_floodlight);
#else
color.rgb*=ao_shade;
#endif
#else
color.rgb*=ao_shade;
#endif
#endif
#ifdef LIGHTING_3D_MODE
float flood_radiance=0.0;
#ifdef FLOOD_LIGHT
flood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;
#endif
#ifdef RENDER_SHADOWS
#ifdef FLOOD_LIGHT
float ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);
#else
float shadowed_lighting_factor;
#ifdef RENDER_CUTOFF
shadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}
#else
shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);
#endif
color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);
#endif
#else
color.rgb=apply_lighting(color.rgb,normal);
#ifdef FLOOD_LIGHT
color.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);
#endif
#endif
color.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));
#endif
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,h);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
uniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
out vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
out highp vec3 v_normal;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec2 v_ao;
#endif
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
out float v_flood_radius;out float v_has_floodlight;
#endif
out float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define highp float flood_light_wall_radius
#pragma mapbox: define highp float line_width
#pragma mapbox: define highp float emissive_strength
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize highp float flood_light_wall_radius
#pragma mapbox: initialize highp float line_width
#pragma mapbox: initialize highp float emissive_strength
base*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
v_normal=normal;
#endif
base=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);
#else
h=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
float cutoff=1.0;vec3 scaled_pos=pos;
#ifdef RENDER_CUTOFF
vec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=cutoff_opacity(u_cutoff_params,ground.z);if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
gl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=pos;vec3 shd_pos1=pos;
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);
#endif
float NdotL=0.0;float colorvalue=0.0;
#ifndef LIGHTING_3D_MODE
colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#endif
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
float is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;
#endif
v_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);
#else
v_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
float roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`), fillExtrusionDepth: Wr(`in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`, `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp float line_width
#pragma mapbox: define highp vec4 color
out highp float v_depth;void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp float line_width
#pragma mapbox: initialize highp vec4 color
base*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
vec3 pos;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);
#else
pos=vec3(pos_nx.xy,t > 0.0 ? height : base);
#endif
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}`), fillExtrusionPattern: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
uniform float u_pattern_transition;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
in vec3 v_normal;
#endif
in highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define mediump vec4 pattern
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define highp float pixel_ratio
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize highp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
vec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;
#else
out_color=out_color*v_lighting;
#endif
#ifdef FAUX_AO
float intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,height);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
out highp vec2 v_pos;out vec4 v_lighting;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
out vec3 v_normal;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump vec4 pattern
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define highp float pixel_ratio
#pragma mapbox: define highp float line_width
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize highp float pixel_ratio
#pragma mapbox: initialize highp float line_width
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=z;vec3 p;float c_ele;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);
#else
p=vec3(pos_nx.xy,z);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0
? pos_nx.xy
: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;
#ifdef LIGHTING_3D_MODE
NdotL=calculate_NdotL(normal);
#else
NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);
#endif
if (normal.y !=0.0) {float r=0.84;
#ifndef LIGHTING_3D_MODE
r=mix(0.7,0.98,1.0-u_lightintensity);
#endif
NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
v_normal=normal;
#else
v_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;
#endif
#ifdef FOG
v_fog_pos=fog_position(p);
#endif
}`), groundShadow: Wr(`#include "_prelude_shadow.fragment.glsl"
precision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;
#ifdef FOG
in float v_fog_opacity;
#endif
void main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);
#ifdef RENDER_CUTOFF
shadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));
#endif
#ifdef FOG
shadow=mix(shadow,vec3(1.0),v_fog_opacity);
#endif
#ifdef INDICATOR_CUTOUT
shadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);
#endif
glFragColor=vec4(shadow,1.0);}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;
#ifdef FOG
out float v_fog_opacity;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);
#ifdef FOG
v_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);
#endif
}`), fillExtrusionGroundEffect: Wr(`uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;
#ifdef SDF_SUBPASS
in highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}
#ifdef FOG
in highp float v_fog;
#endif
#endif
void main() {
#ifdef CLEAR_SUBPASS
vec4 color=vec4(1.0);
#ifdef CLEAR_FROM_TEXTURE
color=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));
#endif
glFragColor=color;
#else
#ifdef SDF_SUBPASS
highp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;
#ifdef FOG
fog=v_fog;
#endif
#ifdef RENDER_CUTOFF
fog*=v_cutoff_opacity;
#endif
glFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));
#else
vec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);
#ifdef OVERDRAW_INSPECTOR
color=vec4(1.0);
#endif
glFragColor=color;
#endif
HANDLE_WIREFRAME_DEBUG;
#endif
}`, `#include "_prelude_fog.vertex.glsl"
in highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;
#ifdef SDF_SUBPASS
out highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;
#ifdef FOG
out highp float v_fog;
#endif
#endif
uniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;
#pragma mapbox: define highp float flood_light_ground_radius
const float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {
#pragma mapbox: initialize highp float flood_light_ground_radius
vec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;
#ifdef SDF_SUBPASS
v_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);
#ifdef FOG
v_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);
#endif
#endif
float hidden_by_landmark=0.0;
#ifdef HAS_CENTROID
hidden_by_landmark=a_hidden_by_landmark;
#endif
float isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
}`), hillshadePrepare: Wr(`precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(
(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)
)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(
deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef LIGHTING_3D_MODE
glFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);
#endif
#ifdef FOG
glFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), line: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec3 v_uv;
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef RENDER_LINE_DASH
uniform sampler2D u_dash_image;in vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform sampler2D u_gradient_image;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
float linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);
#ifdef RENDER_LINE_DASH
float sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);
#endif
highp vec4 out_color;
#ifdef RENDER_LINE_GRADIENT
out_color=texture(u_gradient_image,v_uv.xy);
#else
out_color=color;
#endif
float trim_alpha=1.0;
#ifdef RENDER_LINE_TRIM_OFFSET
highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}
#endif
if (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}
#ifdef RENDER_LINE_BORDER
float edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
out_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=(alpha*opacity);
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define EXTRUDE_SCALE 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)
in vec3 a_z_offset_width;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
in highp vec3 a_packed;
#endif
#ifdef RENDER_LINE_DASH
in float a_linesofar;
#endif
uniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;
#ifdef ELEVATED
uniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {
#ifdef ELEVATION_REFERENCE_SEA
return 0.0;
#else
return elevation(apos);
#endif
}
#endif
out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec3 v_uv;
#ifdef ELEVATED_ROADS
out highp float v_road_z_offset;
#endif
#ifdef RENDER_LINE_DASH
uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform float u_image_height;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float a_z_offset;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
a_z_offset=a_z_offset_width.x;
#endif
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;
#ifdef VARIABLE_LINE_WIDTH
float left=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);halfwidth=(u_width_scale*(left==1.0 ? a_z_offset_width.y : a_z_offset_width.z))/2.0;
#else
halfwidth=(u_width_scale*width)/2.0;
#endif
offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;
#ifdef ELEVATED_ROADS
v_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;
#else
#ifdef ELEVATED
vec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;
#ifdef CROSS_SLOPE_VERTICAL
float top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);
#else
#ifdef CROSS_SLOPE_HORIZONTAL
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;
#else
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;
#endif
#endif
gl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);
#else
gl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);
#endif
#endif
#ifdef ELEVATED_ROADS
#ifdef RENDER_SHADOWS
vec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifndef RENDER_TO_TEXTURE
float epsilon=0.0001;float extrude_length_without_perspective=max(length(dist),epsilon);float extrude_length_with_perspective=max(length(projected_extrude_xy/gl_Position.w*u_units_to_pixels),epsilon);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));
#else
v_gamma_scale=1.0;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
highp float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float line_progress=a_packed[2];
#ifdef RENDER_LINE_GRADIENT
highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec3(a_uv_x,a_split_index*texel_height-half_texel_height,line_progress);
#else
v_uv=vec3(a_uv_x,0.0,line_progress);
#endif
#endif
#ifdef RENDER_LINE_DASH
float scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);
#endif
v_width2=vec2(outset,inset);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=a_z_offset;
#endif
}`), linePattern: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;
#ifdef LINE_PATTERN_TRANSITION
uniform float u_pattern_transition;
#endif
in vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef RENDER_LINE_TRIM_OFFSET
in highp vec3 v_uv;
#endif
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef LINE_JOIN_NONE
in vec2 v_pattern_data;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
uniform float u_emissive_strength;
#pragma mapbox: define mediump vec4 pattern
#ifdef LINE_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define mediump float pixel_ratio
#pragma mapbox: define mediump float blur
#pragma mapbox: define mediump float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern
#ifdef LINE_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize mediump float pixel_ratio
#pragma mapbox: initialize mediump float blur
#pragma mapbox: initialize mediump float opacity
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LINE_PATTERN_TRANSITION
vec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl*texel_size-texel_size,pattern_b_br*texel_size+texel_size,vec2(x,y));vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);color=color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}
#endif
#ifdef LINE_JOIN_NONE
highp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}
#endif
#ifdef LIGHTING_3D_MODE
color=apply_lighting_with_emission_ground(color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,v_z_offset);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
in vec3 a_z_offset_width;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
in highp vec3 a_packed;
#endif
in highp float a_linesofar;
#ifdef LINE_JOIN_NONE
in highp vec3 a_pattern_data;out vec2 v_pattern_data;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;
#ifdef ELEVATED
uniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {
#ifdef ELEVATION_REFERENCE_SEA
return 0.0;
#else
return elevation(apos);
#endif
}
#endif
out vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef RENDER_LINE_TRIM_OFFSET
out highp vec3 v_uv;
#endif
#ifdef ELEVATED_ROADS
out highp float v_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define mediump float blur
#pragma mapbox: define mediump float opacity
#pragma mapbox: define mediump float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define mediump float floorwidth
#pragma mapbox: define mediump vec4 pattern
#ifdef LINE_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define mediump float pixel_ratio
void main() {
#pragma mapbox: initialize mediump float blur
#pragma mapbox: initialize mediump float opacity
#pragma mapbox: initialize mediump float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize mediump float floorwidth
#pragma mapbox: initialize mediump vec4 pattern
#ifdef LINE_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize mediump float pixel_ratio
float a_z_offset;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
a_z_offset=a_z_offset_width.x;
#endif
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;
#ifdef ELEVATED_ROADS
v_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;
#else
#ifdef ELEVATED
vec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;
#ifdef CROSS_SLOPE_VERTICAL
float top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);
#else
#ifdef CROSS_SLOPE_HORIZONTAL
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;
#else
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;
#endif
#endif
gl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);
#else
gl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);
#endif
#endif
#ifdef ELEVATED_ROADS
#ifdef RENDER_SHADOWS
vec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));
#else
v_gamma_scale=1.0;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
highp float a_uv_x=a_packed[0];highp float line_progress=a_packed[2];v_uv=vec3(a_uv_x,0.0,line_progress);
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);
#ifdef LINE_JOIN_NONE
v_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=a_z_offset;
#endif
}`), raster: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_raster_array.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;
#ifdef PROJECTION_GLOBE_VIEW
in float v_split_fade;
#endif
uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;
#ifndef RASTER_ARRAY
uniform highp sampler2D u_image0;uniform sampler2D u_image1;
#endif
#ifdef RASTER_COLOR
uniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;
#endif
void main() {vec4 color0,color1,color;vec2 value;
#ifdef RASTER_COLOR
#ifdef RASTER_ARRAY
#ifdef RASTER_ARRAY_LINEAR
value=mix(
raTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#else
value=mix(
raTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#endif
if (value.y > 0.0) value.x/=value.y;
#else
color=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);
#endif
color=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;
#else
color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);
#endif
color.a*=u_opacity;
#ifdef GLOBE_POLES
color.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);
#endif
vec3 rgb=color.rgb;rgb=vec3(
dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef PROJECTION_GLOBE_VIEW
glFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));
#endif
#ifdef RENDER_CUTOFF
glFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;in vec2 a_texture_pos;
#endif
out vec2 v_pos0;out vec2 v_pos1;out float v_depth;
#ifdef PROJECTION_GLOBE_VIEW
out float v_split_fade;
#endif
void main() {vec2 uv;
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);
#endif
#else
float w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    
v_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;
#ifdef RENDER_CUTOFF
v_depth=gl_Position.z;
#endif
}`), rasterParticle: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8
in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
uv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), rasterParticleDraw: Wr("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", `#include "_prelude_raster_particle.glsl"
in float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(
mod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}`), rasterParticleTexture: Wr("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"), rasterParticleUpdate: Wr(`#include "_prelude_raster_particle.glsl"
uniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(
linearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)
);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}`, "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"), symbol: Wr(`#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;
#ifdef ICON_TRANSITION
uniform float u_icon_transition;
#endif
#ifdef COLOR_ADJUSTMENT
uniform mat4 u_color_adj_mat;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#else
#ifdef Z_OFFSET
#ifdef RENDER_SHADOWS
in highp float v_z_offset;
#endif
#endif
#endif
in vec2 v_tex_a;
#ifdef ICON_TRANSITION
in vec2 v_tex_b;
#endif
in float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;
#ifdef RENDER_TEXT_AND_SYMBOL
in float is_sdf;in vec2 v_tex_a_icon;
#endif
#ifdef Z_OFFSET
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#endif
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
vec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];
#ifdef RENDER_TEXT_AND_SYMBOL
if (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
return;}
#endif
#ifdef RENDER_SDF
float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;
#else
#ifdef ICON_TRANSITION
vec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);
#else
out_color=texture(u_texture,v_tex_a);
#endif
#ifdef COLOR_ADJUSTMENT
out_color=u_color_adj_mat*out_color;
#endif
#endif
out_color*=opacity*fade_opacity;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,emissive_strength);
#ifdef Z_OFFSET
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(abs(v_z_offset) > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#endif
#endif
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_terrain.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;
#ifdef Z_OFFSET
in float a_auto_z_offset;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_globe_anchor;in vec3 a_globe_normal;
#endif
#ifdef ICON_TRANSITION
in vec2 a_texb;
#endif
#ifdef OCCLUSION_QUERIES
in float a_occlusion_query_opacity;
#endif
#ifdef ELEVATED_ROADS
in vec3 a_x_axis;in vec3 a_y_axis;uniform float u_normal_scale;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#else
#ifdef Z_OFFSET
#ifdef RENDER_SHADOWS
out highp float v_z_offset;
#endif
#endif
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
out vec2 v_tex_a;
#ifdef ICON_TRANSITION
out vec2 v_tex_b;
#endif
out float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;
#ifdef RENDER_TEXT_AND_SYMBOL
out float is_sdf;out vec2 v_tex_a_icon;
#endif
#ifdef Z_OFFSET
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#endif
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
#pragma mapbox: define lowp float occlusion_opacity
#pragma mapbox: define lowp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
#pragma mapbox: initialize lowp float occlusion_opacity
#pragma mapbox: initialize lowp float z_offset
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);
#ifdef Z_OFFSET
e+=a_auto_z_offset;
#endif
vec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;
#ifdef PROJECTION_GLOBE_VIEW
vec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;
#else
offsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;
#endif
vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
#ifdef PROJECTED_POS_ON_VIEWPORT
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xyz+h,1.0);
#else
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz,mercator_pos,u_zoom_transition)+h;projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);    
#endif
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
#ifdef Z_OFFSET
z+=u_pitch_with_map ? a_auto_z_offset+z_offset : 0.0;
#else
z+=u_pitch_with_map ? z_offset : 0.0;
#endif
float occlusion_fade=globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));
#ifdef DEPTH_OCCLUSION
float depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;
#endif
#ifdef OCCLUSION_QUERIES
float occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;
#endif
float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);vec3 pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;
#else
#ifdef ELEVATED_ROADS
vec3 xAxis=vec3(a_x_axis.xy,a_x_axis.z*u_normal_scale);vec3 yAxis=vec3(a_y_axis.xy,a_y_axis.z*u_normal_scale);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;
#else
pos=vec3(projected_pos.xy/projected_pos.w+offset,z);
#endif
#endif
gl_Position=mix(u_coord_matrix*vec4(pos,1.0),AWAY,hidden);float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;
#ifdef RENDER_TEXT_AND_SYMBOL
is_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;
#endif
#ifdef ICON_TRANSITION
v_tex_b=a_texb/u_texsize;
#endif
#ifdef Z_OFFSET
#ifdef RENDER_SHADOWS
vec4 shd_pos=u_inv_matrix*vec4(pos,1.0);vec3 shd_pos0=shd_pos.xyz;vec3 shd_pos1=shd_pos.xyz;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=e;
#else
#ifdef Z_OFFSET
#ifdef RENDER_SHADOWS
v_z_offset=e;
#endif
#endif
#endif
}`), terrainRaster: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;in vec2 v_pos0;
#ifdef FOG
in float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;
#endif
uniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;
#ifdef LIGHTING_3D_MODE
const vec3 normal=vec3(0.0,0.0,1.0);
#ifdef RENDER_SHADOWS
float cutoffOpacity=1.0;
#ifdef RENDER_CUTOFF
cutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);
#endif
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
vec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;
#else
float lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));
#endif
#else
float lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;
#endif
#endif
#else
color=image_color;
#endif
#ifdef FOG
#ifdef ZERO_EXAGGERATION
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#else
color=fog_dither(fog_apply_from_vert(color,v_fog_opacity));
#endif
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;
#ifdef FOG
out float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;
#endif
void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);
#ifdef FOG
#ifdef ZERO_EXAGGERATION
v_fog_pos=fog_position(decodedPos);
#else
v_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));
#endif
#endif
#ifdef RENDER_SHADOWS
vec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);
#endif
}`), terrainDepth: Wr("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}`), skybox: Wr(`#include "_prelude_fog.fragment.glsl"
in lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(
cos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;
#ifdef FOG
sky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);
#endif
sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, sp), skyboxGradient: Wr(`#include "_prelude_fog.fragment.glsl"
in highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));
#ifdef FOG
color.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;
#endif
color*=u_opacity;glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, sp), skyboxCapture: Wr(`
in highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;
#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)
#define BETA_M                  vec3(21e-6,21e-6,21e-6)
#define MIE_G                   0.76
#define DENSITY_HEIGHT_SCALE_R  8000.0
#define DENSITY_HEIGHT_SCALE_M  1200.0
#define PLANET_RADIUS           6360e3
#define ATMOSPHERE_RADIUS       6420e3
#define SAMPLE_STEPS            10
#define DENSITY_STEPS           4
float ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}`, "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;
#ifndef FOG
uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;
#endif
void main() {vec4 color;
#ifdef CUSTOM_ANTIALIASING
highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;highp float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);highp float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
raster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(clamp(raster.rgb,vec3(0),vec3(1))*antialias,antialias);
#else
raster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;
#else
color=apply_lighting_ground(color);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;
#endif
out vec2 v_pos0;void main() {
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;vec2 uv=a_uv;
#else
float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);
#endif
v_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;
#ifdef GLOBE_POLES
vec3 up_vector=globe_derived_up_vector;
#else
vec3 up_vector=elevationVector(tile_pos);
#endif
float height=elevation(tile_pos);globe_pos+=up_vector*height;
#ifndef GLOBE_POLES
globe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;
#endif
#ifdef GLOBE_POLES
vec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);
#else
vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);
#endif
gl_Position=u_proj_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
}`), globeAtmosphere: Wr(`#include "_prelude_fog.fragment.glsl"
uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;
#ifdef PROJECTION_GLOBE_VIEW
globe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {
#ifdef ALPHA_PASS
glFragColor=vec4(0,0,0,0);return;
#else
#ifdef NATIVE
glFragColor=vec4(1,1,1,1);
#else
glFragColor=vec4(0,0,0,1);
#endif
return;
#endif
}
#endif
highp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?
0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;
#ifdef PROJECTION_GLOBE_VIEW
highp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?
PI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);
#else
horizon_angle=horizon_angle_mercator;
#endif
horizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;
#ifdef ALPHA_PASS
float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);
#else
vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;glFragColor=vec4(c*t,t);
#endif
}`, `in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(
mix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}`), model: Wr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;
#endif
#ifdef OCCLUSION_TEXTURE_TRANSFORM
uniform vec4 u_occlusionTextureTransform;
#endif
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#ifdef HAS_ATTRIBUTE_a_pbr
in lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;
#endif
#ifdef HAS_TEXTURE_u_baseColorTexture
uniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;
#endif
#ifdef HAS_TEXTURE_u_metallicRoughnessTexture
uniform sampler2D u_metallicRoughnessTexture;
#endif
#ifdef HAS_TEXTURE_u_occlusionTexture
uniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;
#endif
#ifdef HAS_TEXTURE_u_normalTexture
uniform sampler2D u_normalTexture;
#endif
#ifdef HAS_TEXTURE_u_emissionTexture
uniform sampler2D u_emissionTexture;
#endif
#ifdef APPLY_LUT_ON_GPU
uniform highp sampler3D u_lutTexture;
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
in highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;
#ifdef DEPTH_D24
highp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}
#else
highp float unpack_depth_rgba(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}
#endif
bool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;
#ifdef DEPTH_D24
highp float depth=unpack_depth(texture(u_depthTexture,coord).r);
#else
highp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));
#endif
return v_depth > depth+0.0005;}
#endif
#define saturate(_x) clamp(_x,0.,1.)
vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)
{
#ifdef LIGHTING_3D_MODE
vec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));
#endif
return apply_lighting(albedo,transformed_normal,lighting_factor);
#else
vec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;
#endif
}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;
#ifdef HAS_ATTRIBUTE_a_color_3f
albedo*=vec4(color_3f,1.0);
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#else
#ifdef HAS_ATTRIBUTE_a_color_4f
albedo*=color_4f;
#endif
#endif
#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)
vec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}
#ifdef UNPREMULT_TEXTURE_IN_SHADER
if(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;
#endif
if(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}
#endif
vec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);
#ifdef APPLY_LUT_ON_GPU
color=applyLUT(u_lutTexture,color);
#endif
return color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {
#ifdef HAS_TEXTURE_u_normalTexture
highp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;
#else
return mat3(1.0);
#endif
}highp vec3 getNormal(){highp vec3 n;
#ifdef HAS_ATTRIBUTE_a_normal_3f
n=normalize(normal_3f);
#else
highp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;
#endif
#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
vec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);
#endif
return n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;
#ifdef HAS_ATTRIBUTE_a_pbr
mat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;
#endif
#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) 
vec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;
#endif
const float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)
{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)
{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)
{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)
{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)
{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)
{
#ifdef LIGHTING_3D_MODE
return mat.diffuseColor;
#else
return mat.diffuseColor/PI;
#endif
}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)
{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)
{vec3 env_light=vec3(0.65,0.65,0.65);
#ifdef LIGHTING_3D_MODE
float ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;
#endif
vec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)
{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=NdotL;
#endif
vec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;
#if !defined(LIGHTING_3D_MODE)
const vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);
#endif
color*=intensityFactor;return color;}void main() {
#ifdef TERRAIN_FRAGMENT_OCCLUSION
if (isOccluded()) {discard;}
#endif
vec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;
#ifdef LIGHTING_3D_MODE
lightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;
#endif
vec4 finalColor;
#ifdef DIFFUSE_SHADED
vec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);
#ifdef HAS_TEXTURE_u_occlusionTexture
float ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;
#endif
finalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;
#else
Material mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;
#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
#ifdef OCCLUSION_TEXTURE_TRANSFORM
vec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;
#else
vec2 uv=uv_2f;
#endif
ao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;
#endif
vec4 emissive=u_emissiveFactor;
#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
emissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);
#endif
#ifdef APPLY_LUT_ON_GPU
float emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;
#endif
color+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;
#ifdef HAS_ATTRIBUTE_a_pbr
float resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;
#ifdef APPLY_LUT_ON_GPU
color_mix=applyLUT(u_lutTexture,color_mix);
#endif
color=mix(color,color_mix,min(1.0,resEmission));
#ifdef HAS_ATTRIBUTE_a_color_4f
float distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);
#endif
#endif
vec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);
#endif
#ifdef FOG
finalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));
#endif
#ifdef RENDER_CUTOFF
finalColor*=v_cutoff_opacity;
#endif
#ifdef INDICATOR_CUTOUT
finalColor=applyCutout(finalColor,v_position_height.w);
#endif
glFragColor=finalColor;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec3 a_pos_3f;
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr
#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength
uniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_normal_matrix;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;
#endif
out vec4 v_position_height;out lowp vec4 v_color_mix;
#ifdef TERRAIN_FRAGMENT_OCCLUSION
out highp float v_depth;
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
out lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;
#endif
vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute-custom highp vec4 pbr
#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength
highp mat4 normal_matrix;
#ifdef INSTANCED_ARRAYS
normal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
normal_matrix=u_normal_matrix;
#endif
vec3 local_pos;mat3 rs;
#ifdef MODEL_POSITION_ON_GPU
vec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;
#else
local_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);
#endif
v_position_height.w=a_pos_3f.z;
#ifdef HAS_ATTRIBUTE_a_pbr
vec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;
#endif
#ifdef FOG
v_fog_pos=fog_position(local_pos);
#endif
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
float x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);
#else
normal_3f=vec3(normal_matrix*vec4(normal_3f,0));
#endif
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#ifdef HAS_ATTRIBUTE_a_color_4f
v_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);
#endif
#endif
#ifdef RENDER_SHADOWS
vec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);
#ifdef NORMAL_OFFSET
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
vec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();
#else
vec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();
#endif
#endif
#endif
v_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;
#endif
}`), modelDepth: Wr(`in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`, `in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;
#ifdef MODEL_POSITION_ON_GPU
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_instance;
#endif
uniform highp mat4 u_node_matrix;
#endif
void main() {
#ifdef MODEL_POSITION_ON_GPU
highp mat4 instance;
#ifdef INSTANCED_ARRAYS
instance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
instance=u_instance;
#endif
vec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);
#else
gl_Position=u_matrix*vec4(a_pos_3f,1);
#endif
v_depth=gl_Position.z/gl_Position.w;}`), stars: Wr(`in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)
{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}`, `
in vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}`), snowParticle: Wr("in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}", `
in highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; 
uniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; 
uniform float u_horizontalOscillationRate; 
uniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+
localY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}`), rainParticle: Wr("in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}", `
in highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; 
uniform float u_velocity; 
uniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; 
pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+
localY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}`), vignette: Wr("uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}", "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}"), occlusion: Wr("uniform vec4 u_color;void main() {glFragColor=u_color;}", `#include "_prelude_terrain.vertex.glsl"
in highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;
#ifdef TERRAIN
float e=elevation(world_pos.xy);world_pos.z+=e;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}`) };
            function Iu(d, n) {
                const l = d.replace(/\s*\/\/[^\n]*\n/g, `
`).split(`
`);
                for (let f of l)
                    if (f = f.trim(), f[0] === "#" && f.includes("if") && !f.includes("endif")) {
                        f = f.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                        const _ = f.split(" ");
                        for (const v of _)
                            n.includes(v) || n.push(v);
                    }
            }
            function Wr(d, n) {
                const l = /#include\s+"([^"]+)"/g, f = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
                let _ = n.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
                _ && (_ = _.map(P => { const R = P.split(" "); return R[R.length - 1]; }), _ = [...new Set(_)]);
                const v = {}, w = [], T = [];
                if (d = d.replace(l, (P, R) => (T.push(R), "")), (n = n.replace(l, (P, R) => (w.push(R), ""))).includes("flat out"))
                    return void console.error("The usage of \"flat\" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071");
                let C = [...Ac];
                Iu(d, C), Iu(n, C);
                for (const P of [...w, ...T])
                    Oo[P] || console.error(`Undefined include: ${P}`), Au[P] || (Au[P] = [], Iu(Oo[P], Au[P])), C = [...C, ...Au[P]];
                return { fragmentSource: d = d.replace(f, (P, R, O, D, B) => (v[B] = !0, R === "define" ? `
#ifndef HAS_UNIFORM_u_${B}
in ${O} ${D} ${B};
#else
uniform ${O} ${D} u_${B};
#endif
` : R === "initialize" ? `
#ifdef HAS_UNIFORM_u_${B}
    ${O} ${D} ${B} = u_${B};
#endif
` : R === "define-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${B}
    in ${O} ${D} ${B};
#endif
` : R === "initialize-attribute" ? "" : void 0)), vertexSource: n = n.replace(f, (P, R, O, D, B) => {
                        const q = D === "float" ? "vec2" : D, G = B.match(/color/) ? "color" : q;
                        return R === "define-attribute-vertex-shader-only" ? `
#ifdef HAS_ATTRIBUTE_a_${B}
in ${O} ${D} a_${B};
#endif
` : v[B] ? R === "define" ? `
#ifndef HAS_UNIFORM_u_${B}
uniform lowp float u_${B}_t;
in ${O} ${q} a_${B};
out ${O} ${D} ${B};
#else
uniform ${O} ${D} u_${B};
#endif
` : R === "initialize" ? G === "vec4" ? `
#ifndef HAS_UNIFORM_u_${B}
    ${B} = a_${B};
#else
    ${O} ${D} ${B} = u_${B};
#endif
` : `
#ifndef HAS_UNIFORM_u_${B}
    ${B} = unpack_mix_${G}(a_${B}, u_${B}_t);
#else
    ${O} ${D} ${B} = u_${B};
#endif
` : R === "define-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${B}
    in ${O} ${D} a_${B};
    out ${O} ${D} ${B};
#endif
` : R === "initialize-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${B}
    ${B} = a_${B};
#endif
` : void 0 : R === "define" ? `
#ifndef HAS_UNIFORM_u_${B}
uniform lowp float u_${B}_t;
in ${O} ${q} a_${B};
#else
uniform ${O} ${D} u_${B};
#endif
` : R === "define-instanced" ? G === "mat4" ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${B}0;
in vec4 a_${B}1;
in vec4 a_${B}2;
in vec4 a_${B}3;
#else
uniform ${O} ${D} u_${B};
#endif
` : `
#ifdef INSTANCED_ARRAYS
in ${O} ${q} a_${B};
#else
uniform ${O} ${D} u_${B};
#endif
` : R === "initialize-attribute-custom" ? `
#ifdef HAS_ATTRIBUTE_a_${B}
    ${O} ${D} ${B} = a_${B};
#endif
` : G === "vec4" ? `
#ifndef HAS_UNIFORM_u_${B}
    ${O} ${D} ${B} = a_${B};
#else
    ${O} ${D} ${B} = u_${B};
#endif
` : `
#ifndef HAS_UNIFORM_u_${B}
    ${O} ${D} ${B} = unpack_mix_${G}(a_${B}, u_${B}_t);
#else
    ${O} ${D} ${B} = u_${B};
#endif
`;
                    }), staticAttributes: _, usedDefines: C, vertexIncludes: w, fragmentIncludes: T };
            }
            class Zg {
                constructor() { this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null; }
                bind(n, l, f, _, v, w, T, C) { this.context = n; let P = this.boundPaintVertexBuffers.length !== _.length; for (let O = 0; !P && O < _.length; O++)
                    this.boundPaintVertexBuffers[O] !== _[O] && (P = !0); let R = this.boundDynamicVertexBuffers.length !== T.length; for (let O = 0; !R && O < T.length; O++)
                    this.boundDynamicVertexBuffers[O] !== T[O] && (R = !0); if (!this.vao || this.boundProgram !== l || this.boundLayoutVertexBuffer !== f || P || R || this.boundIndexBuffer !== v || this.boundVertexOffset !== w)
                    this.freshBind(l, f, _, v, w, T, C);
                else {
                    n.bindVertexArrayOES.set(this.vao);
                    for (const O of T)
                        O && (O.bind(), C && O.instanceCount && O.setVertexAttribDivisor(n.gl, l, C));
                    v && v.dynamicDraw && v.bind();
                } }
                freshBind(n, l, f, _, v, w, T) { const C = n.numAttributes, P = this.context, R = P.gl; this.vao && this.destroy(), this.vao = P.gl.createVertexArray(), P.bindVertexArrayOES.set(this.vao), this.boundProgram = n, this.boundLayoutVertexBuffer = l, this.boundPaintVertexBuffers = f, this.boundIndexBuffer = _, this.boundVertexOffset = v, this.boundDynamicVertexBuffers = w, l.enableAttributes(R, n), l.bind(), l.setVertexAttribPointers(R, n, v); for (const O of f)
                    O.enableAttributes(R, n), O.bind(), O.setVertexAttribPointers(R, n, v); for (const O of w)
                    O && (O.enableAttributes(R, n), O.bind(), O.setVertexAttribPointers(R, n, v), T && O.instanceCount && O.setVertexAttribDivisor(R, n, T)); _ && _.bind(), P.currentNumAttributes = C; }
                destroy() { this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null); }
            }
            function Qb(d, n) { const l = Math.pow(2, n.canonical.z), f = n.canonical.y; return [new s.ac(0, f / l).toLngLat().lat, new s.ac(0, (f + 1) / l).toLngLat().lat]; }
            function E0(d, n, l, f, _, v, w) { const T = d.context, C = T.gl, P = l.hillshadeFBO; if (!P)
                return; d.prepareDrawTile(); const R = d.isTileAffectedByFog(n), O = d.getOrCreateProgram("hillshade", { overrideFog: R }); T.activeTexture.set(C.TEXTURE0), C.bindTexture(C.TEXTURE_2D, P.colorAttachment.get()); const D = ((K, W, oe, de) => { const me = oe.paint.get("hillshade-shadow-color"), we = oe.paint.get("hillshade-shadow-color-use-theme").constantOr("default") === "none", ve = oe.paint.get("hillshade-highlight-color"), xe = oe.paint.get("hillshade-highlight-color-use-theme").constantOr("default") === "none", ge = oe.paint.get("hillshade-accent-color"), Se = oe.paint.get("hillshade-accent-color-use-theme").constantOr("default") === "none", Ce = oe.paint.get("hillshade-emissive-strength"); let je = s.al(oe.paint.get("hillshade-illumination-direction")); if (oe.paint.get("hillshade-illumination-anchor") === "viewport")
                je -= K.transform.angle;
            else if (K.style && K.style.enable3dLights() && K.style.directionalLight) {
                const rt = K.style.directionalLight.properties.get("direction"), et = s.cR(rt.x, rt.y, rt.z);
                je = s.al(et[1]);
            } const ze = !K.options.moving; return { u_matrix: de || K.transform.calculateProjMatrix(W.tileID.toUnwrapped(), ze), u_image: 0, u_latrange: Qb(0, W.tileID), u_light: [oe.paint.get("hillshade-exaggeration"), je], u_shadow: me.toRenderColor(we ? null : oe.lut), u_highlight: ve.toRenderColor(xe ? null : oe.lut), u_emissive_strength: Ce, u_accent: ge.toRenderColor(Se ? null : oe.lut) }; })(d, l, f, d.terrain ? n.projMatrix : null); d.uploadCommonUniforms(T, O, n.toUnwrapped()); const { tileBoundsBuffer: B, tileBoundsIndexBuffer: q, tileBoundsSegments: G } = d.getTileBoundsBuffers(l); O.draw(d, C.TRIANGLES, _, v, w, fr.disabled, D, f.id, B, q, G); }
            function Xg(d, n, l) { if (!n.needsDEMTextureUpload)
                return; const f = d.context, _ = f.gl; f.pixelStoreUnpackPremultiplyAlpha.set(!1), n.demTexture = n.demTexture || d.getTileTexture(l.stride); const v = l.getPixels(); n.demTexture ? n.demTexture.update(v, { premultiply: !1 }) : n.demTexture = new s.T(f, v, _.R32F, { premultiply: !1 }), n.needsDEMTextureUpload = !1; }
            function Kg(d, n, l) { const f = d.context, _ = f.gl; if (!n.dem)
                return; const v = n.dem; if (f.activeTexture.set(_.TEXTURE1), Xg(d, n, v), !n.demTexture)
                return; n.demTexture.bind(_.NEAREST, _.CLAMP_TO_EDGE); const w = v.dim; f.activeTexture.set(_.TEXTURE0); let T = n.hillshadeFBO; if (!T) {
                const D = new s.T(f, { width: w, height: w, data: null }, _.RGBA8);
                D.bind(_.LINEAR, _.CLAMP_TO_EDGE), T = n.hillshadeFBO = f.createFramebuffer(w, w, !0, "renderbuffer"), T.colorAttachment.set(D.texture);
            } f.bindFramebuffer.set(T.framebuffer), f.viewport.set([0, 0, w, w]); const { tileBoundsBuffer: C, tileBoundsIndexBuffer: P, tileBoundsSegments: R } = d.getMercatorTileBoundsBuffers(), O = []; d.linearFloatFilteringSupported() && O.push("TERRAIN_DEM_FLOAT_FORMAT"), d.getOrCreateProgram("hillshadePrepare", { defines: O }).draw(d, _.TRIANGLES, Ut.disabled, dr.disabled, Rr.unblended, fr.disabled, ((D, B) => { const q = B.stride, G = s.bz(); return s.c5(G, 0, s.aj, -s.aj, 0, 0, 1), s.bo(G, G, [0, -s.aj, 0]), { u_matrix: G, u_image: 1, u_dimension: [q, q], u_zoom: D.overscaledZ }; })(n.tileID, v), l.id, C, P, R), n.needsHillshadePrepare = !1; }
            class li {
                constructor(n) { this.gl = n.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1; }
                get() { return this.current; }
                set(n) { }
                getDefault() { return this.default; }
                setDefault() { this.set(this.default); }
            }
            class Jb extends li {
                getDefault() { return s.am.transparent; }
                set(n) { const l = this.current; (n.r !== l.r || n.g !== l.g || n.b !== l.b || n.a !== l.a || this.dirty) && (this.gl.clearColor(n.r, n.g, n.b, n.a), this.current = n, this.dirty = !1); }
            }
            class eT extends li {
                getDefault() { return 1; }
                set(n) { (n !== this.current || this.dirty) && (this.gl.clearDepth(n), this.current = n, this.dirty = !1); }
            }
            class tT extends li {
                getDefault() { return 0; }
                set(n) { (n !== this.current || this.dirty) && (this.gl.clearStencil(n), this.current = n, this.dirty = !1); }
            }
            class C0 extends li {
                getDefault() { return [!0, !0, !0, !0]; }
                set(n) { const l = this.current; (n[0] !== l[0] || n[1] !== l[1] || n[2] !== l[2] || n[3] !== l[3] || this.dirty) && (this.gl.colorMask(n[0], n[1], n[2], n[3]), this.current = n, this.dirty = !1); }
            }
            class rT extends li {
                getDefault() { return !0; }
                set(n) { (n !== this.current || this.dirty) && (this.gl.depthMask(n), this.current = n, this.dirty = !1); }
            }
            class cp extends li {
                getDefault() { return 255; }
                set(n) { (n !== this.current || this.dirty) && (this.gl.stencilMask(n), this.current = n, this.dirty = !1); }
            }
            class nT extends li {
                getDefault() { return { func: this.gl.ALWAYS, ref: 0, mask: 255 }; }
                set(n) { const l = this.current; (n.func !== l.func || n.ref !== l.ref || n.mask !== l.mask || this.dirty) && (this.gl.stencilFunc(n.func, n.ref, n.mask), this.current = n, this.dirty = !1); }
            }
            class A0 extends li {
                getDefault() { const n = this.gl; return [n.KEEP, n.KEEP, n.KEEP]; }
                set(n) { const l = this.current; (n[0] !== l[0] || n[1] !== l[1] || n[2] !== l[2] || this.dirty) && (this.gl.stencilOp(n[0], n[1], n[2]), this.current = n, this.dirty = !1); }
            }
            class Yg extends li {
                getDefault() { return !1; }
                set(n) { if (n === this.current && !this.dirty)
                    return; const l = this.gl; n ? l.enable(l.STENCIL_TEST) : l.disable(l.STENCIL_TEST), this.current = n, this.dirty = !1; }
            }
            class up extends li {
                getDefault() { return [0, 1]; }
                set(n) { const l = this.current; (n[0] !== l[0] || n[1] !== l[1] || this.dirty) && (this.gl.depthRange(n[0], n[1]), this.current = n, this.dirty = !1); }
            }
            class Qg extends li {
                getDefault() { return !1; }
                set(n) { if (n === this.current && !this.dirty)
                    return; const l = this.gl; n ? l.enable(l.DEPTH_TEST) : l.disable(l.DEPTH_TEST), this.current = n, this.dirty = !1; }
            }
            class Pc extends li {
                getDefault() { return this.gl.LESS; }
                set(n) { (n !== this.current || this.dirty) && (this.gl.depthFunc(n), this.current = n, this.dirty = !1); }
            }
            class Jg extends li {
                getDefault() { return !1; }
                set(n) { if (n === this.current && !this.dirty)
                    return; const l = this.gl; n ? l.enable(l.BLEND) : l.disable(l.BLEND), this.current = n, this.dirty = !1; }
            }
            class I0 extends li {
                getDefault() { const n = this.gl; return [n.ONE, n.ZERO, n.ONE, n.ZERO]; }
                set(n) { const l = this.current; (n[0] !== l[0] || n[1] !== l[1] || n[2] !== l[2] || n[3] !== l[3] || this.dirty) && (this.gl.blendFuncSeparate(n[0], n[1], n[2], n[3]), this.current = n, this.dirty = !1); }
            }
            class Pu extends li {
                getDefault() { return s.am.transparent; }
                set(n) { const l = this.current; (n.r !== l.r || n.g !== l.g || n.b !== l.b || n.a !== l.a || this.dirty) && (this.gl.blendColor(n.r, n.g, n.b, n.a), this.current = n, this.dirty = !1); }
            }
            class Td extends li {
                getDefault() { return this.gl.FUNC_ADD; }
                set(n) { (n !== this.current || this.dirty) && (this.gl.blendEquationSeparate(n, n), this.current = n, this.dirty = !1); }
            }
            class hp extends li {
                getDefault() { return !1; }
                set(n) { if (n === this.current && !this.dirty)
                    return; const l = this.gl; n ? l.enable(l.CULL_FACE) : l.disable(l.CULL_FACE), this.current = n, this.dirty = !1; }
            }
            class dp extends li {
                getDefault() { return this.gl.BACK; }
                set(n) { (n !== this.current || this.dirty) && (this.gl.cullFace(n), this.current = n, this.dirty = !1); }
            }
            class Mu extends li {
                getDefault() { return this.gl.CCW; }
                set(n) { (n !== this.current || this.dirty) && (this.gl.frontFace(n), this.current = n, this.dirty = !1); }
            }
            let fp = class extends li {
                getDefault() { return null; }
                set(d) { (d !== this.current || this.dirty) && (this.gl.useProgram(d), this.current = d, this.dirty = !1); }
            };
            class e_ extends li {
                getDefault() { return this.gl.TEXTURE0; }
                set(n) { (n !== this.current || this.dirty) && (this.gl.activeTexture(n), this.current = n, this.dirty = !1); }
            }
            class P0 extends li {
                getDefault() { const n = this.gl; return [0, 0, n.drawingBufferWidth, n.drawingBufferHeight]; }
                set(n) { const l = this.current; (n[0] !== l[0] || n[1] !== l[1] || n[2] !== l[2] || n[3] !== l[3] || this.dirty) && (this.gl.viewport(n[0], n[1], n[2], n[3]), this.current = n, this.dirty = !1); }
            }
            class t_ extends li {
                getDefault() { return null; }
                set(n) { if (n === this.current && !this.dirty)
                    return; const l = this.gl; l.bindFramebuffer(l.FRAMEBUFFER, n), this.current = n, this.dirty = !1; }
            }
            class pp extends li {
                getDefault() { return null; }
                set(n) { if (n === this.current && !this.dirty)
                    return; const l = this.gl; l.bindRenderbuffer(l.RENDERBUFFER, n), this.current = n, this.dirty = !1; }
            }
            class Sd extends li {
                getDefault() { return null; }
                set(n) { if (n === this.current && !this.dirty)
                    return; const l = this.gl; l.bindTexture(l.TEXTURE_2D, n), this.current = n, this.dirty = !1; }
            }
            class M0 extends li {
                getDefault() { return null; }
                set(n) { if (n === this.current && !this.dirty)
                    return; const l = this.gl; l.bindBuffer(l.ARRAY_BUFFER, n), this.current = n, this.dirty = !1; }
            }
            class R0 extends li {
                getDefault() { return null; }
                set(n) { const l = this.gl; l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, n), this.current = n, this.dirty = !1; }
            }
            class k0 extends li {
                getDefault() { return null; }
                set(n) { this.gl && (n !== this.current || this.dirty) && (this.gl.bindVertexArray(n), this.current = n, this.dirty = !1); }
            }
            class Ru extends li {
                getDefault() { return 4; }
                set(n) { if (n === this.current && !this.dirty)
                    return; const l = this.gl; l.pixelStorei(l.UNPACK_ALIGNMENT, n), this.current = n, this.dirty = !1; }
            }
            class D0 extends li {
                getDefault() { return !1; }
                set(n) { if (n === this.current && !this.dirty)
                    return; const l = this.gl; l.pixelStorei(l.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n), this.current = n, this.dirty = !1; }
            }
            class iT extends li {
                getDefault() { return !1; }
                set(n) { if (n === this.current && !this.dirty)
                    return; const l = this.gl; l.pixelStorei(l.UNPACK_FLIP_Y_WEBGL, n), this.current = n, this.dirty = !1; }
            }
            class r_ extends li {
                constructor(n, l) { super(n), this.context = n, this.parent = l; }
                getDefault() { return null; }
            }
            class sT extends r_ {
                setDirty() { this.dirty = !0; }
                set(n) { if (n === this.current && !this.dirty)
                    return; this.context.bindFramebuffer.set(this.parent); const l = this.gl; l.framebufferTexture2D(l.FRAMEBUFFER, l.COLOR_ATTACHMENT0, l.TEXTURE_2D, n, 0), this.current = n, this.dirty = !1; }
            }
            class mp extends r_ {
                attachment() { return this.gl.DEPTH_ATTACHMENT; }
                set(n) { if (n === this.current && !this.dirty)
                    return; this.context.bindFramebuffer.set(this.parent); const l = this.gl; l.framebufferRenderbuffer(l.FRAMEBUFFER, this.attachment(), l.RENDERBUFFER, n), this.current = n, this.dirty = !1; }
            }
            class n_ extends r_ {
                attachment() { return this.gl.DEPTH_ATTACHMENT; }
                set(n) { if (n === this.current && !this.dirty)
                    return; this.context.bindFramebuffer.set(this.parent); const l = this.gl; l.framebufferTexture2D(l.FRAMEBUFFER, this.attachment(), l.TEXTURE_2D, n, 0), this.current = n, this.dirty = !1; }
            }
            class i_ extends mp {
                attachment() { return this.gl.DEPTH_STENCIL_ATTACHMENT; }
            }
            const s_ = (d, n, l) => ({ u_matrix: d, u_image0: 0, u_skirt_height: n, u_ground_shadow_factor: l }), o_ = (d, n, l, f, _, v, w, T, C, P, R, O, D, B, q, G) => ({ u_proj_matrix: Float32Array.from(d), u_globe_matrix: n, u_normalize_matrix: Float32Array.from(f), u_merc_matrix: l, u_zoom_transition: _, u_merc_center: v, u_image0: 0, u_frustum_tl: w, u_frustum_tr: T, u_frustum_br: C, u_frustum_bl: P, u_globe_pos: R, u_globe_radius: O, u_viewport: D, u_grid_matrix: G ? Float32Array.from(G) : new Float32Array(9), u_skirt_height: B, u_far_z_cutoff: q });
            function a_(d, n) { return d != null && n != null && !(!d.hasData() || !n.hasData()) && d.demTexture != null && n.demTexture != null && d.tileID.key !== n.tileID.key; }
            const ku = new class {
                constructor() { this.operations = {}; }
                newMorphing(d, n, l, f, _) { if (d in this.operations) {
                    const v = this.operations[d];
                    v.to.tileID.key !== l.tileID.key && (v.queued = l);
                }
                else
                    this.operations[d] = { startTime: f, phase: 0, duration: _, from: n, to: l, queued: null }; }
                getMorphValuesForProxy(d) { if (!(d in this.operations))
                    return null; const n = this.operations[d]; return { from: n.from, to: n.to, phase: n.phase }; }
                update(d) { for (const n in this.operations) {
                    const l = this.operations[n];
                    for (l.phase = (d - l.startTime) / l.duration; l.phase >= 1 || !this._validOp(l);)
                        if (!this._nextOp(l, d)) {
                            delete this.operations[n];
                            break;
                        }
                } }
                _nextOp(d, n) { return !!d.queued && (d.from = d.to, d.to = d.queued, d.queued = null, d.phase = 0, d.startTime = n, !0); }
                _validOp(d) { return d.from.hasData() && d.to.hasData(); }
            }, Du = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
            function Lu(d, n, l) { if (n === 0)
                return 0; const f = n < 1 && l === 514 ? .25 / n : 1; return 6 * Math.pow(1.5, 22 - d) * Math.max(n, 1) * f; }
            function L0(d, n) { const l = 1 << d.z; return !n && (d.x === 0 || d.x === l - 1) || d.y === 0 || d.y === l - 1; }
            const $s = d => ({ u_matrix: d });
            function Ed(d, n, l, f, _) { if (_ > 0) {
                const v = s.q.now(), w = (v - d.timeAdded) / _, T = n ? (v - n.timeAdded) / _ : -1, C = l.getSource(), P = f.coveringZoomLevel({ tileSize: C.tileSize, roundZoom: C.roundZoom }), R = !n || Math.abs(n.tileID.overscaledZ - P) > Math.abs(d.tileID.overscaledZ - P), O = R && d.refreshedUponExpiration ? 1 : s.aD(R ? w : 1 - T, 0, 1);
                return d.refreshedUponExpiration && w >= 1 && (d.refreshedUponExpiration = !1), n ? { opacity: 1, mix: 1 - O } : { opacity: O, mix: 0 };
            } return { opacity: 1, mix: 0 }; }
            class gp extends As {
                constructor(n) { const l = { type: "raster-dem", maxzoom: n.transform.maxZoom }, f = new s.D(s.d0(), null), _ = mu("mock-dem", l, f, n.style); super("mock-dem", _, !1), _.setEventedParent(this), this._sourceLoaded = !0; }
                _loadTile(n, l) { n.state = "loaded", l(null); }
            }
            class _p extends As {
                constructor(n) { const l = mu("proxy", { type: "geojson", maxzoom: n.transform.maxZoom }, new s.D(s.d0(), null), n.style); super("proxy", l, !1), l.setEventedParent(this), this.map = this.getSource().map = n, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {}; }
                update(n, l, f) { if (n.freezeTileCoverage)
                    return; this.transform = n; const _ = n.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((v, w) => { if (v[w.key] = "", !this._tiles[w.key]) {
                    const T = new Xa(w, this._source.tileSize * w.overscaleFactor(), n.tileZoom);
                    T.state = "loaded", this._tiles[w.key] = T;
                } return v; }, {}); for (const v in this._tiles)
                    v in _ || (this.freeFBO(v), this._tiles[v].unloadVectorData(), delete this._tiles[v]); }
                freeFBO(n) { const l = this.proxyCachedFBO[n]; if (l !== void 0) {
                    const f = Object.values(l);
                    this.renderCachePool.push(...f), delete this.proxyCachedFBO[n];
                } }
                deallocRenderCache() { this.renderCache.forEach(n => n.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {}; }
            }
            class yp extends s.aM {
                constructor(n, l, f) { super(n.overscaledZ, n.wrap, n.canonical.z, n.canonical.x, n.canonical.y), this.proxyTileKey = l, this.projMatrix = f; }
            }
            class vp extends s.dt {
                constructor(n, l) { super(), this._debugParams = { sortTilesHiZFirst: !0, disableRenderCache: !1 }, n.tp.registerParameter(this._debugParams, ["Terrain"], "sortTilesHiZFirst", {}, () => { this._style.map.triggerRepaint(); }), n.tp.registerParameter(this._debugParams, ["Terrain"], "disableRenderCache", {}, () => { this._style.map.triggerRepaint(); }), n.tp.registerButton(["Terrain"], "Invalidate Render Cache", () => { this.invalidateRenderCache = !0, this._style.map.triggerRepaint(); }), this.painter = n, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {}; const [f, _, v] = function (C) { const P = new s.ba, R = new s.a_, O = 131; P.reserve(17161), R.reserve(33800); const D = s.aj / 128, B = s.aj + D / 2, q = B + D; for (let K = -D; K < q; K += D)
                    for (let W = -D; W < q; W += D) {
                        const oe = W < 0 || W > B || K < 0 || K > B ? 24575 : 0, de = s.aD(Math.round(W), 0, s.aj), me = s.aD(Math.round(K), 0, s.aj);
                        P.emplaceBack(de + oe, me);
                    } const G = (K, W) => { const oe = W * O + K; R.emplaceBack(oe + 1, oe, oe + O), R.emplaceBack(oe + O, oe + O + 1, oe + 1); }; for (let K = 1; K < 129; K++)
                    for (let W = 1; W < 129; W++)
                        G(W, K); return [0, 129].forEach(K => { for (let W = 0; W < 130; W++)
                    G(W, K), G(K, W); }), [P, R, 32768]; }(), w = n.context; this.gridBuffer = w.createVertexBuffer(f, s.bc.members), this.gridIndexBuffer = w.createIndexBuffer(_), this.gridSegments = s.bd.simpleSegment(0, 0, f.length, _.length), this.gridNoSkirtSegments = s.bd.simpleSegment(0, 0, f.length, v), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new _p(l.map), this.orthoMatrix = s.bz(), s.c5(this.orthoMatrix, this.painter.transform.projection.name === "globe" ? .015 : 0, s.aj, 0, s.aj, 0, 1); const T = w.gl; this._overlapStencilMode = new dr({ func: T.GEQUAL, mask: 255 }, 0, 255, T.KEEP, T.KEEP, T.REPLACE), this._previousZoom = n.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = l, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new gp(l.map), this._pendingGroundEffectLayers = []; }
                set style(n) { n.on("data", this._onStyleDataEvent.bind(this)), this._style = n, this._style.map.on("moveend", () => { this._clearLineLayersFromRenderCache(); }); }
                update(n, l, f) {
                    if (n && n.terrain) {
                        this._style !== n && (this.style = n, this._evaluationZoom = void 0);
                        const _ = n.terrain.properties, v = n.terrain.drapeRenderMode === 0, w = n.terrain.isZoomDependent();
                        this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = s.q.now();
                        const T = n.terrain && n.terrain.scope, C = _.get("source"), P = v ? this._mockSourceCache : n.getSourceCache(C, T);
                        if (!P)
                            return void s.w(`Couldn't find terrain source "${C}".`);
                        if (this.sourceCache = P, this._attenuationRange = n.terrain.getAttenuationRange(), this._exaggeration = w ? this.calculateExaggeration(l) : _.get("exaggeration"), !l.projection.requiresDraping && w && this._exaggeration === 0)
                            return void this._disable();
                        this.enabled = !0;
                        const R = () => {
                            this.sourceCache.used && s.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                            const O = this.getScaledDemTileSize();
                            this.sourceCache.update(l, O, !0), this.resetTileLookupCache(this.sourceCache.id);
                        };
                        this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, R(), this._initializing = !0), R(), l.updateElevation(!0, f), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(l), this._emptyDEMTextureDirty = !0, this._previousZoom = l.zoom;
                    }
                    else
                        this._disable();
                }
                calculateExaggeration(n) { if (this._attenuationRange && n.zoom >= Math.ceil(this._attenuationRange[1]))
                    return this._style.terrain.getExaggeration(n.zoom); const l = this._previousCameraAltitude, f = n.getFreeCameraOptions().position.z / n.pixelsPerMeter * n.worldSize; this._previousCameraAltitude = f; const _ = l != null ? f - l : Number.MAX_VALUE; if (Math.abs(_) < 2)
                    return this._exaggeration; const v = n.zoom, w = this._style.terrain; if (!this._previousUpdateTimestamp)
                    return w.getExaggeration(v); let T = v - this._previousZoom; const C = this._previousUpdateTimestamp; let P = v; this._evaluationZoom != null && (P = this._evaluationZoom, Math.abs(v - P) > .5 && (T = .5 * (v - P + T)), T * _ < 0 && (P += T)), this._evaluationZoom = P; const R = w.getExaggeration(P), O = R === w.getExaggeration(Math.max(0, P - .1)); if (O && Math.abs(R - this._exaggeration) < .01)
                    return R; let D = Math.min(.1, .00375 * (this._updateTimestamp - C)); return (O || R < .1 || Math.abs(T) < 1e-4) && (D = Math.min(.2, 4 * D)), s.ai(this._exaggeration, R, D); }
                resetTileLookupCache(n) { this._findCoveringTileCache[n] = {}; }
                attenuationRange() { return this._attenuationRange; }
                getDemUpscale() { return this.proxySourceCache.getSource().tileSize / 128; }
                getScaledDemTileSize() { return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize; }
                _onStyleDataEvent(n) { n.coord && n.dataType === "source" ? this._clearRenderCacheForTile(n.sourceCacheId, n.coord) : n.dataType === "style" && (this.invalidateRenderCache = !0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0); }
                _disable() { if (this.enabled && (this.enabled = !1, this._emptyDEMTextureDirty = !0, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
                    for (const n in this._style._mergedSourceCaches)
                        this._style._mergedSourceCaches[n].usedForTerrain = !1; }
                destroy() { this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach(n => n.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy(); }
                _source() { return this.enabled ? this.sourceCache : null; }
                isUsingMockSource() { return this.sourceCache === this._mockSourceCache; }
                exaggeration() { return this.enabled ? this._exaggeration : 0; }
                get visibleDemTiles() { return this._visibleDemTiles; }
                get drapeBufferSize() { const n = 2 * this.proxySourceCache.getSource().tileSize; return [n, n]; }
                set useVertexMorphing(n) { this._useVertexMorphing = n; }
                updateTileBinding(n) { if (!this.enabled)
                    return; this.prevTerrainTileForTile = this.terrainTileForTile; const l = this.proxySourceCache, f = this.painter.transform; this._initializing && (this._initializing = f._centerAltitude === 0 && this.getAtPointOrZero(s.ac.fromLngLat(f.center), -1) === -1, this._emptyDEMTextureDirty = !this._initializing); const _ = this.proxyCoords = l.getIds().map(C => { const P = l.getTileByID(C).tileID; return P.projMatrix = f.calculateProjMatrix(P.toUnwrapped()), P; }); (function (C, P) { const R = P.transform.pointCoordinate(P.transform.getCameraPoint()), O = new s.P(R.x, R.y); C.sort((D, B) => { if (B.overscaledZ - D.overscaledZ)
                    return B.overscaledZ - D.overscaledZ; const q = new s.P(D.canonical.x + (1 << D.canonical.z) * D.wrap, D.canonical.y), G = new s.P(B.canonical.x + (1 << B.canonical.z) * B.wrap, B.canonical.y), K = O.mult(1 << D.canonical.z); return K.x -= .5, K.y -= .5, K.distSqr(q) - K.distSqr(G); }); })(_, this.painter); const v = this.proxyToSource || {}; this.proxyToSource = {}, _.forEach(C => { this.proxyToSource[C.key] = {}; }), this.terrainTileForTile = {}; const w = this._style._mergedSourceCaches; for (const C in w) {
                    const P = w[C];
                    if (!P.used || (P !== this.sourceCache && this.resetTileLookupCache(P.id), this._setupProxiedCoordsForOrtho(P, n[C], v), P.usedForTerrain))
                        continue;
                    const R = n[C];
                    P.getSource().reparseOverscaled && this._assignTerrainTiles(R);
                } this.proxiedCoords[l.id] = _.map(C => new yp(C, C.key, this.orthoMatrix)), this._assignTerrainTiles(_), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(v), this.renderingToTexture = !1; const T = {}; this._visibleDemTiles = []; for (const C of this.proxyCoords) {
                    const P = this.terrainTileForTile[C.key];
                    if (!P)
                        continue;
                    const R = P.tileID.key;
                    R in T || (this._visibleDemTiles.push(P), T[R] = R);
                } }
                _assignTerrainTiles(n) { this._initializing || n.forEach(l => { if (this.terrainTileForTile[l.key])
                    return; const f = this._findTileCoveringTileID(l, this.sourceCache); f && (this.terrainTileForTile[l.key] = f); }); }
                _prepareDEMTextures() { const n = this.painter.context, l = n.gl; for (const f in this.terrainTileForTile) {
                    const _ = this.terrainTileForTile[f], v = _.dem;
                    !v || _.demTexture && !_.needsDEMTextureUpload || (n.activeTexture.set(l.TEXTURE1), Xg(this.painter, _, v));
                } }
                _prepareDemTileUniforms(n, l, f, _) { if (!l || l.demTexture == null)
                    return !1; const v = n.tileID.canonical, w = Math.pow(2, l.tileID.canonical.z - v.z), T = _ || ""; return f[`u_dem_tl${T}`] = [v.x * w % 1, v.y * w % 1], f[`u_dem_scale${T}`] = w, !0; }
                get emptyDEMTexture() { return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture(); }
                _getLoadedAreaMinimum() { if (!this.enabled)
                    return 0; let n = 0; const l = this._visibleDemTiles.reduce((f, _) => { if (!_.dem)
                    return f; const v = _.dem.tree.minimums[0]; return v > 0 && n++, f + v; }, 0); return n ? l / n : 0; }
                _updateEmptyDEMTexture() { const n = this.painter.context, l = n.gl; n.activeTexture.set(l.TEXTURE2); const f = this._getLoadedAreaMinimum(), _ = new s.du({ width: 1, height: 1 }, new Float32Array([f])); this._emptyDEMTextureDirty = !1; let v = this._emptyDEMTexture; return v ? v.update(_, { premultiply: !1 }) : v = this._emptyDEMTexture = new s.T(n, _, l.R32F, { premultiply: !1 }), v; }
                setupElevationDraw(n, l, f) { const _ = this.painter.context, v = _.gl, w = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 }; w.u_exaggeration = this.exaggeration(); let T = null, C = null, P = 1; if (f && f.morphing && this._useVertexMorphing) {
                    const B = f.morphing.srcDemTile, q = f.morphing.dstDemTile;
                    P = f.morphing.phase, B && q && (this._prepareDemTileUniforms(n, B, w, "_prev") && (C = B), this._prepareDemTileUniforms(n, q, w) && (T = q));
                } const R = B => B && B.demTexture && this.painter.linearFloatFilteringSupported() ? v.LINEAR : v.NEAREST; let O = null; var D; if (this.enabled ? C && T ? (O = T.demTexture, _.activeTexture.set(v.TEXTURE4), C.demTexture.bind(R(C), v.CLAMP_TO_EDGE), w.u_dem_lerp = P) : (T = this.terrainTileForTile[n.tileID.key], O = this._prepareDemTileUniforms(n, T, w) ? T.demTexture : this.emptyDEMTexture) : O = this.emptyDEMTexture, _.activeTexture.set(v.TEXTURE2), O && (w.u_dem_size = (D = O).size[0] === 1 ? 1 : D.size[0] - 2, O.bind(R(T), v.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(f && f.useDepthForOcclusion, l, w), f && f.useMeterToDem && T) {
                    const B = (1 << T.tileID.canonical.z) * s.c6(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                    w.u_meter_to_dem = B;
                } if (f && f.labelPlaneMatrixInv && (w.u_label_plane_matrix_inv = f.labelPlaneMatrixInv), l.setTerrainUniformValues(_, w), this.painter.transform.projection.name === "globe") {
                    const B = this.globeUniformValues(this.painter.transform, n.tileID.canonical, f && f.useDenormalizedUpVectorScale);
                    l.setGlobeUniformValues(_, B);
                } }
                globeUniformValues(n, l, f) { const _ = n.projection; return { u_tile_tl_up: _.upVector(l, 0, 0), u_tile_tr_up: _.upVector(l, s.aj, 0), u_tile_br_up: _.upVector(l, s.aj, s.aj), u_tile_bl_up: _.upVector(l, 0, s.aj), u_tile_up_scale: f ? s.dv(1) : _.upVectorScale(l, n.center.lat, n.worldSize).metersToTile }; }
                renderToBackBuffer(n) { const l = this.painter, f = this.painter.context; n.length !== 0 && (f.bindFramebuffer.set(null), f.viewport.set([0, 0, l.width, l.height]), l.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function (_, v, w, T, C) { if (_.transform.projection.name === "globe")
                    (function (P, R, O, D, B) { const q = P.context, G = q.gl; let K, W; const oe = P.transform, de = s.dl(P, q, oe), me = (rt, et) => { if (W === et)
                        return; const vt = [Du[et], "PROJECTION_GLOBE_VIEW"]; de && vt.push("CUSTOM_ANTIALIASING"); const Fe = P.isTileAffectedByFog(rt); K = P.getOrCreateProgram("globeRaster", { defines: vt, overrideFog: Fe }), W = et; }, we = P.colorModeForRenderPass(), ve = new Ut(G.LEQUAL, Ut.ReadWrite, P.depthRangeFor3D); ku.update(B); const xe = s.dm(oe), ge = [s.ay(oe.center.lng), s.aH(oe.center.lat)], Se = P.globeSharedBuffers, Ce = [oe.width * s.q.devicePixelRatio, oe.height * s.q.devicePixelRatio], je = Float32Array.from(oe.globeMatrix), ze = { useDenormalizedUpVectorScale: !0 }; {
                        const rt = P.transform, et = Lu(rt.zoom, R.exaggeration(), R.sourceCache._source.tileSize);
                        W = -1;
                        const vt = G.TRIANGLES;
                        for (const Fe of D) {
                            const Ve = O.getTile(Fe), Le = dr.disabled, st = R.prevTerrainTileForTile[Fe.key], He = R.terrainTileForTile[Fe.key];
                            a_(st, He) && ku.newMorphing(Fe.key, st, He, B, 250), q.activeTexture.set(G.TEXTURE0), Ve.texture && Ve.texture.bind(G.LINEAR, G.CLAMP_TO_EDGE);
                            const ht = ku.getMorphValuesForProxy(Fe.key), nt = ht ? 1 : 0;
                            ht && s.L(ze, { morphing: { srcDemTile: ht.from, dstDemTile: ht.to, phase: s.dk(ht.phase) } });
                            const dt = s.dn(Fe.canonical), ft = s.dp(dt.getCenter().lat), Vt = s.dq(Fe.canonical, dt, ft, rt.worldSize / rt._pixelsPerMercatorPixel), Xt = s.bh(s.dr(Fe.canonical)), Bt = o_(rt.expandedFarZProjMatrix, je, xe, Xt, s.ah(rt.zoom), ge, rt.frustumCorners.TL, rt.frustumCorners.TR, rt.frustumCorners.BR, rt.frustumCorners.BL, rt.globeCenterInViewSpace, rt.globeRadius, Ce, et, rt._farZ, Vt);
                            if (me(Fe, nt), K && (R.setupElevationDraw(Ve, K, ze), P.uploadCommonUniforms(q, K, Fe.toUnwrapped()), Se)) {
                                const [Yt, $t, or] = Se.getGridBuffers(ft, et !== 0);
                                K.draw(P, vt, ve, Le, we, fr.backCCW, Bt, "globe_raster", Yt, $t, or);
                            }
                        }
                    } if (Se && (P.renderDefaultNorthPole || P.renderDefaultSouthPole)) {
                        const rt = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                        de && rt.push("CUSTOM_ANTIALIASING"), K = P.getOrCreateProgram("globeRaster", { defines: rt });
                        for (const et of D) {
                            const { x: vt, y: Fe, z: Ve } = et.canonical, Le = Fe === 0, st = Fe === (1 << Ve) - 1, [He, ht, nt, dt] = Se.getPoleBuffers(Ve, !1);
                            if (dt && (Le || st)) {
                                const ft = O.getTile(et);
                                q.activeTexture.set(G.TEXTURE0), ft.texture && ft.texture.bind(G.LINEAR, G.CLAMP_TO_EDGE);
                                let Vt = s.ds(Ve, vt, oe);
                                const Xt = s.bh(s.dr(et.canonical)), Bt = (Yt, $t) => Yt.draw(P, G.TRIANGLES, ve, dr.disabled, we, fr.disabled, o_(oe.expandedFarZProjMatrix, Vt, Vt, Xt, 0, ge, oe.frustumCorners.TL, oe.frustumCorners.TR, oe.frustumCorners.BR, oe.frustumCorners.BL, oe.globeCenterInViewSpace, oe.globeRadius, Ce, 0, oe._farZ), "globe_pole_raster", $t, nt, dt);
                                R.setupElevationDraw(ft, K, ze), P.uploadCommonUniforms(q, K, et.toUnwrapped()), Le && P.renderDefaultNorthPole && Bt(K, He), st && P.renderDefaultSouthPole && (Vt = s.cE(s.bz(), Vt, [1, -1, 1]), Bt(K, ht));
                            }
                        }
                    } })(_, v, w, T, C);
                else {
                    const P = _.context, R = P.gl;
                    let O, D;
                    const B = _.shadowRenderer, q = Cc(_, _.longestCutoffRange), G = we => { if (D === we)
                        return; const ve = []; ve.push(Du[we]), q.shouldRenderCutoff && ve.push("RENDER_CUTOFF"), B && (ve.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), B.useNormalOffset && ve.push("NORMAL_OFFSET")), O = _.getOrCreateProgram("terrainRaster", { defines: ve }), D = we; }, K = _.colorModeForRenderPass(), W = new Ut(R.LEQUAL, Ut.ReadWrite, _.depthRangeFor3D);
                    ku.update(C);
                    const oe = _.transform, de = Lu(oe.zoom, v.exaggeration(), v.sourceCache._source.tileSize);
                    let me = [0, 0, 0];
                    if (B) {
                        const we = _.style.directionalLight, ve = _.style.ambientLight;
                        we && ve && (me = Sa(_.style, we, ve));
                    }
                    {
                        D = -1;
                        const we = R.TRIANGLES, [ve, xe] = [v.gridIndexBuffer, v.gridSegments];
                        for (const ge of T) {
                            const Se = w.getTile(ge), Ce = dr.disabled, je = v.prevTerrainTileForTile[ge.key], ze = v.terrainTileForTile[ge.key];
                            a_(je, ze) && ku.newMorphing(ge.key, je, ze, C, 250), P.activeTexture.set(R.TEXTURE0), Se.texture && Se.texture.bind(R.LINEAR, R.CLAMP_TO_EDGE);
                            const rt = ku.getMorphValuesForProxy(ge.key), et = rt ? 1 : 0;
                            let vt;
                            rt && (vt = { morphing: { srcDemTile: rt.from, dstDemTile: rt.to, phase: s.dk(rt.phase) } });
                            const Fe = s_(ge.projMatrix, L0(ge.canonical, oe.renderWorldCopies) ? de / 10 : de, me);
                            if (G(et), !O)
                                continue;
                            v.setupElevationDraw(Se, O, vt);
                            const Ve = ge.toUnwrapped();
                            B && B.setupShadows(Ve, O), _.uploadCommonUniforms(P, O, Ve, null, q), O.draw(_, we, W, Ce, K, fr.backCCW, Fe, "terrain_raster", v.gridBuffer, ve, xe);
                        }
                    }
                } }(l, this, this.proxySourceCache, n, this._updateTimestamp), this.renderingToTexture = !0, l.gpuTimingDeferredRenderEnd(), n.splice(0, n.length)); }
                renderBatch(n) { if (this._drapedRenderBatches.length === 0)
                    return n + 1; this.renderingToTexture = !0; const l = this.painter, f = this.painter.context, _ = this.proxySourceCache, v = this.proxiedCoords[_.id], w = this._drapedRenderBatches.shift(), T = l.style.order, C = []; let P = 0; for (const R of v) {
                    const O = _.getTileByID(R.proxyTileKey), D = _.proxyCachedFBO[R.key] ? _.proxyCachedFBO[R.key][n] : void 0, B = D !== void 0 ? _.renderCache[D] : this.pool[P++], q = D !== void 0;
                    if (O.texture = B.tex, q && !B.dirty) {
                        C.push(O.tileID);
                        continue;
                    }
                    let G;
                    f.bindFramebuffer.set(B.fb.framebuffer), this.renderedToTile = !1, B.dirty && (f.clear({ color: s.am.transparent, stencil: 0 }), B.dirty = !1);
                    for (let K = w.start; K <= w.end; ++K) {
                        const W = l.style._mergedLayers[T[K]];
                        if (W.isHidden(l.transform.zoom))
                            continue;
                        const oe = l.style.getLayerSourceCache(W), de = oe ? this.proxyToSource[R.key][oe.id] : [R];
                        if (!de)
                            continue;
                        const me = de;
                        f.viewport.set([0, 0, B.fb.width, B.fb.height]), G !== (oe ? oe.id : null) && (this._setupStencil(B, de, W, oe), G = oe ? oe.id : null), l.renderLayer(l, oe, W, me);
                    }
                    if (this._drapedRenderBatches.length === 0)
                        for (const K of this._pendingGroundEffectLayers) {
                            const W = l.style._mergedLayers[T[K]];
                            if (W.isHidden(l.transform.zoom))
                                continue;
                            const oe = l.style.getLayerSourceCache(W), de = oe ? this.proxyToSource[R.key][oe.id] : [R];
                            if (!de)
                                continue;
                            const me = de;
                            f.viewport.set([0, 0, B.fb.width, B.fb.height]), G !== (oe ? oe.id : null) && (this._setupStencil(B, de, W, oe), G = oe ? oe.id : null), l.renderLayer(l, oe, W, me);
                        }
                    this.renderedToTile ? (B.dirty = !0, C.push(O.tileID)) : q || --P, P === 5 && (P = 0, this.renderToBackBuffer(C));
                } return this.renderToBackBuffer(C), this.renderingToTexture = !1, f.bindFramebuffer.set(null), f.viewport.set([0, 0, l.width, l.height]), w.end + 1; }
                postRender() { }
                isLayerOrderingCorrect(n) { const l = n.order.length; let f = -1, _ = l; for (let v = 0; v < l; ++v)
                    this._style.isLayerDraped(n._mergedLayers[n.order[v]]) ? f = Math.max(f, v) : _ = Math.min(_, v); return _ > f; }
                getMinElevationBelowMSL() { let n = 0; return this._visibleDemTiles.filter(l => l.dem).forEach(l => { n = Math.min(n, l.dem.tree.minimums[0]); }), n === 0 ? n : (n - 30) * this._exaggeration; }
                raycast(n, l, f) { if (!this._visibleDemTiles)
                    return null; const _ = this._visibleDemTiles.filter(v => v.dem).map(v => { const w = v.tileID, T = 1 << w.overscaledZ, { x: C, y: P } = w.canonical, R = C / T, O = (C + 1) / T, D = P / T, B = (P + 1) / T; return { minx: R, miny: D, maxx: O, maxy: B, t: v.dem.tree.raycastRoot(R, D, O, B, n, l, f), tile: v }; }); _.sort((v, w) => (v.t !== null ? v.t : Number.MAX_VALUE) - (w.t !== null ? w.t : Number.MAX_VALUE)); for (const v of _) {
                    if (v.t == null)
                        return null;
                    const w = v.tile.dem.tree.raycast(v.minx, v.miny, v.maxx, v.maxy, n, l, f);
                    if (w != null)
                        return w;
                } return null; }
                _createFBO() { const n = this.painter.context, l = n.gl, f = this.drapeBufferSize; n.activeTexture.set(l.TEXTURE0); const _ = new s.T(n, { width: f[0], height: f[1], data: null }, l.RGBA8); _.bind(l.LINEAR, l.CLAMP_TO_EDGE); const v = n.createFramebuffer(f[0], f[1], !0, null); return v.colorAttachment.set(_.texture), v.depthAttachment = new i_(n, v.framebuffer), this._sharedDepthStencil === void 0 ? (this._sharedDepthStencil = n.createRenderbuffer(n.gl.DEPTH_STENCIL, f[0], f[1]), this._stencilRef = 0, v.depthAttachment.set(this._sharedDepthStencil), n.clear({ stencil: 0 })) : v.depthAttachment.set(this._sharedDepthStencil), n.extTextureFilterAnisotropic && l.texParameterf(l.TEXTURE_2D, n.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, n.extTextureFilterAnisotropicMax), { fb: v, tex: _, dirty: !1 }; }
                _initFBOPool() { for (; this.pool.length < Math.min(5, this.proxyCoords.length);)
                    this.pool.push(this._createFBO()); }
                _shouldDisableRenderCache() { if (this._debugParams.disableRenderCache || this._style.hasLightTransitions())
                    return !0; for (const n in this._style._mergedSourceCaches)
                    if (this._style._mergedSourceCaches[n].hasTransition())
                        return !0; return this._style.order.some(n => { const l = this._style._mergedLayers[n], f = l.isHidden(this.painter.transform.zoom); return l.type === "hillshade" || l.type === "custom" ? !f && l.shouldRedrape() : !f && l.hasTransition(); }); }
                _clearLineLayersFromRenderCache() { let n = !1; for (const f of this._style.getSources())
                    if (f instanceof hs) {
                        n = !0;
                        break;
                    } if (!n)
                    return; const l = {}; for (let f = 0; f < this._style.order.length; ++f) {
                    const _ = this._style._mergedLayers[this._style.order[f]], v = this._style.getLayerSourceCache(_);
                    if (v && !l[v.id] && !_.isHidden(this.painter.transform.zoom) && _.type === "line" && _.widthExpression() instanceof s.ab) {
                        l[v.id] = !0;
                        for (const w of this.proxyCoords) {
                            const T = this.proxyToSource[w.key][v.id];
                            if (T)
                                for (const C of T)
                                    this._clearRenderCacheForTile(v.id, C);
                        }
                    }
                } }
                _clearRasterLayersFromRenderCache() { let n = !1; for (const f in this._style._mergedSourceCaches)
                    if (this._style._mergedSourceCaches[f]._source instanceof Ta) {
                        n = !0;
                        break;
                    } if (!n)
                    return; const l = {}; for (let f = 0; f < this._style.order.length; ++f) {
                    const _ = this._style._mergedLayers[this._style.order[f]], v = this._style.getLayerSourceCache(_);
                    if (!v || l[v.id] || _.isHidden(this.painter.transform.zoom) || _.type !== "raster")
                        continue;
                    const w = _.paint.get("raster-fade-duration");
                    for (const T of this.proxyCoords) {
                        const C = this.proxyToSource[T.key][v.id];
                        if (C)
                            for (const P of C) {
                                const R = Ed(v.getTile(P), v.findLoadedParent(P, 0), v, this.painter.transform, w);
                                (R.opacity !== 1 || R.mix !== 0) && this._clearRenderCacheForTile(v.id, P);
                            }
                    }
                } }
                _setupDrapedRenderBatches() { this._style.updateDrapeFirstLayers(); const n = this._style.order, l = n.length; if (l === 0)
                    return; const f = []; this._pendingGroundEffectLayers = []; let _, v = 0, w = this._style._mergedLayers[n[v]]; for (; !this._style.isLayerDraped(w) && w.isHidden(this.painter.transform.zoom) && ++v < l;)
                    w = this._style._mergedLayers[n[v]]; for (; v < l; ++v) {
                    const T = this._style._mergedLayers[n[v]];
                    T.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(T) ? _ === void 0 && (_ = v) : (T.type === "fill-extrusion" && this._pendingGroundEffectLayers.push(v), _ !== void 0 && (f.push({ start: _, end: v - 1 }), _ = void 0)));
                } if (_ !== void 0 && f.push({ start: _, end: v - 1 }), f.length !== 0) {
                    const T = f[f.length - 1];
                    this._pendingGroundEffectLayers.every(C => C > T.end) || s.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
                } this._drapedRenderBatches = f; }
                _setupRenderCache(n) { const l = this.proxySourceCache; if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
                    if (this.invalidateRenderCache = !1, l.renderCache.length > l.renderCachePool.length) {
                        const w = Object.values(l.proxyCachedFBO);
                        l.proxyCachedFBO = {};
                        for (let T = 0; T < w.length; ++T) {
                            const C = Object.values(w[T]);
                            l.renderCachePool.push(...C);
                        }
                    }
                    return;
                } this._clearRasterLayersFromRenderCache(); const f = this.proxyCoords, _ = this._tilesDirty; for (let w = f.length - 1; w >= 0; w--) {
                    const T = f[w];
                    if (l.getTileByID(T.key), l.proxyCachedFBO[T.key] !== void 0) {
                        const C = n[T.key], P = this.proxyToSource[T.key];
                        let R = 0;
                        for (const O in P) {
                            const D = P[O], B = C[O];
                            if (!B || B.length !== D.length || D.some((q, G) => q !== B[G] || _[O] && _[O].hasOwnProperty(q.key))) {
                                R = -1;
                                break;
                            }
                            ++R;
                        }
                        for (const O in l.proxyCachedFBO[T.key])
                            l.renderCache[l.proxyCachedFBO[T.key][O]].dirty = R < 0 || R !== Object.values(C).length;
                    }
                } const v = [...this._drapedRenderBatches]; v.sort((w, T) => T.end - T.start - (w.end - w.start)); for (const w of v)
                    for (const T of f) {
                        if (l.proxyCachedFBO[T.key])
                            continue;
                        let C = l.renderCachePool.pop();
                        C === void 0 && l.renderCache.length < 50 && (C = l.renderCache.length, l.renderCache.push(this._createFBO())), C !== void 0 && (l.proxyCachedFBO[T.key] = {}, l.proxyCachedFBO[T.key][w.start] = C, l.renderCache[C].dirty = !0);
                    } this._tilesDirty = {}; }
                _setupStencil(n, l, f, _) { if (!_ || !this._sourceTilesOverlap[_.id])
                    return void (this._overlapStencilType && (this._overlapStencilType = !1)); const v = this.painter.context, w = v.gl; if (l.length <= 1)
                    return void (this._overlapStencilType = !1); let T; if (f.isTileClipped())
                    T = l.length, this._overlapStencilMode.test = { func: w.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
                else {
                    if (!(l[0].overscaledZ > l[l.length - 1].overscaledZ))
                        return void (this._overlapStencilType = !1);
                    T = 1, this._overlapStencilMode.test = { func: w.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
                } this._stencilRef + T > 255 && (v.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += T, this._overlapStencilMode.ref = this._stencilRef, f.isTileClipped() && this._renderTileClippingMasks(l, this._overlapStencilMode.ref); }
                clipOrMaskOverlapStencilType() { return this._overlapStencilType === "Clip" || this._overlapStencilType === "Mask"; }
                stencilModeForRTTOverlap(n) { return this.renderingToTexture && this._overlapStencilType ? (this._overlapStencilType === "Clip" && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[n.key]), this._overlapStencilMode) : dr.disabled; }
                _renderTileClippingMasks(n, l) { const f = this.painter, _ = this.painter.context, v = _.gl; f._tileClippingMaskIDs = {}, _.setColorMode(Rr.disabled), _.setDepthMode(Ut.disabled); const w = f.getOrCreateProgram("clippingMask"); for (const T of n) {
                    const C = f._tileClippingMaskIDs[T.key] = --l;
                    w.draw(f, v.TRIANGLES, Ut.disabled, new dr({ func: v.ALWAYS, mask: 0 }, C, 255, v.KEEP, v.KEEP, v.REPLACE), Rr.disabled, fr.disabled, $s(T.projMatrix), "$clipping", f.tileExtentBuffer, f.quadTriangleIndexBuffer, f.tileExtentSegments);
                } }
                pointCoordinate(n) { const l = this.painter.transform; if (n.x < 0 || n.x > l.width || n.y < 0 || n.y > l.height)
                    return null; const f = [n.x, n.y, 1, 1]; s.aA(f, f, l.pixelMatrixInverse), s.cw(f, f, 1 / f[3]), f[0] /= l.worldSize, f[1] /= l.worldSize; const _ = l._camera.position, v = s.c6(1, l.center.lat), w = [_[0], _[1], _[2] / v, 0], T = s.cY([], f.slice(0, 3), w); s.au(T, T); const C = this.raycast(w, T, this._exaggeration); return C !== null && C ? (s.bF(w, w, T, C), w[3] = w[2], w[2] *= v, w) : null; }
                _setupProxiedCoordsForOrtho(n, l, f) { if (n.getSource() instanceof s.aP)
                    return this._setupProxiedCoordsForImageSource(n, l, f); this._findCoveringTileCache[n.id] = this._findCoveringTileCache[n.id] || {}; const _ = this.proxiedCoords[n.id] = [], v = this.proxyCoords; for (let C = 0; C < v.length; C++) {
                    const P = v[C], R = this._findTileCoveringTileID(P, n);
                    if (R) {
                        const O = this._createProxiedId(P, R, f[P.key] && f[P.key][n.id]);
                        _.push(O), this.proxyToSource[P.key][n.id] = [O];
                    }
                } let w = !1; const T = new Set; for (let C = 0; C < l.length; C++) {
                    const P = n.getTile(l[C]);
                    if (!P || !P.hasData())
                        continue;
                    const R = this._findTileCoveringTileID(P.tileID, this.proxySourceCache);
                    if (R && R.tileID.canonical.z !== P.tileID.canonical.z) {
                        const O = this.proxyToSource[R.tileID.key][n.id], D = this._createProxiedId(R.tileID, P, f[R.tileID.key] && f[R.tileID.key][n.id]);
                        O ? O.splice(O.length - 1, 0, D) : this.proxyToSource[R.tileID.key][n.id] = [D];
                        const B = this.proxyToSource[R.tileID.key][n.id];
                        T.has(B) || T.add(B), _.push(D), w = !0;
                    }
                } if (this._sourceTilesOverlap[n.id] = w, w && this._debugParams.sortTilesHiZFirst)
                    for (const C of T)
                        C.sort((P, R) => R.overscaledZ - P.overscaledZ); }
                _setupProxiedCoordsForImageSource(n, l, f) { if (!n.getSource().loaded())
                    return; const _ = this.proxiedCoords[n.id] = [], v = this.proxyCoords, w = n.getSource(), T = w.tileID; if (!T)
                    return; const C = new s.P(T.x, T.y)._div(1 << T.z), P = w.coordinates.map(s.ac.fromLngLat).reduce((O, D) => (O.min.x = Math.min(O.min.x, D.x - C.x), O.min.y = Math.min(O.min.y, D.y - C.y), O.max.x = Math.max(O.max.x, D.x - C.x), O.max.y = Math.max(O.max.y, D.y - C.y), O), { min: new s.P(Number.MAX_VALUE, Number.MAX_VALUE), max: new s.P(-Number.MAX_VALUE, -Number.MAX_VALUE) }), R = (O, D) => { const B = O.wrap + O.canonical.x / (1 << O.canonical.z), q = O.canonical.y / (1 << O.canonical.z), G = s.aj / (1 << O.canonical.z), K = D.wrap + D.canonical.x / (1 << D.canonical.z), W = D.canonical.y / (1 << D.canonical.z); return B + G < K + P.min.x || B > K + P.max.x || q + G < W + P.min.y || q > W + P.max.y; }; for (let O = 0; O < v.length; O++) {
                    const D = v[O];
                    for (let B = 0; B < l.length; B++) {
                        const q = n.getTile(l[B]);
                        if (!q || !q.hasData() || R(D, q.tileID))
                            continue;
                        const G = this._createProxiedId(D, q, f[D.key] && f[D.key][n.id]), K = this.proxyToSource[D.key][n.id];
                        K ? K.push(G) : this.proxyToSource[D.key][n.id] = [G], _.push(G);
                    }
                } }
                _createProxiedId(n, l, f) { let _ = this.orthoMatrix; if (f) {
                    const v = f.find(w => w.key === l.tileID.key);
                    if (v)
                        return v;
                } if (l.tileID.key !== n.key) {
                    const v = n.canonical.z - l.tileID.canonical.z;
                    let w, T, C;
                    _ = s.bz();
                    const P = l.tileID.wrap - n.wrap << n.overscaledZ;
                    v > 0 ? (w = s.aj >> v, T = w * ((l.tileID.canonical.x << v) - n.canonical.x + P), C = w * ((l.tileID.canonical.y << v) - n.canonical.y)) : (w = s.aj << -v, T = s.aj * (l.tileID.canonical.x - (n.canonical.x + P << -v)), C = s.aj * (l.tileID.canonical.y - (n.canonical.y << -v))), s.c5(_, 0, w, 0, w, 0, 1), s.bo(_, _, [T, C, 0]);
                } return new yp(l.tileID, n.key, _); }
                _findTileCoveringTileID(n, l) { let f = l.getTile(n); if (f && f.hasData())
                    return f; const _ = this._findCoveringTileCache[l.id], v = _[n.key]; if (f = v ? l.getTileByID(v) : null, f && f.hasData() || v === null)
                    return f; let w = f ? f.tileID : n, T = w.overscaledZ; const C = l.getSource().minzoom, P = []; if (!v) {
                    const O = l.getSource().maxzoom;
                    if (n.canonical.z >= O) {
                        const D = n.canonical.z - O;
                        l.getSource().reparseOverscaled ? (T = Math.max(n.canonical.z + 2, l.transform.tileZoom), w = new s.aM(T, n.wrap, O, n.canonical.x >> D, n.canonical.y >> D)) : D !== 0 && (T = O, w = new s.aM(T, n.wrap, O, n.canonical.x >> D, n.canonical.y >> D));
                    }
                    w.key !== n.key && (P.push(w.key), f = l.getTile(w));
                } const R = O => { P.forEach(D => { _[D] = O; }), P.length = 0; }; for (T -= 1; T >= C && (!f || !f.hasData()); T--) {
                    f && R(f.tileID.key);
                    const O = w.calculateScaledKey(T);
                    if (f = l.getTileByID(O), f && f.hasData())
                        break;
                    const D = _[O];
                    if (D === null)
                        break;
                    D === void 0 ? P.push(O) : f = l.getTileByID(D);
                } return R(f ? f.tileID.key : null), f && f.hasData() ? f : null; }
                findDEMTileFor(n) { return this.enabled ? this._findTileCoveringTileID(n, this.sourceCache) : null; }
                prepareDrawTile() { this.renderedToTile = !0; }
                _clearRenderCacheForTile(n, l) { let f = this._tilesDirty[n]; f || (f = this._tilesDirty[n] = {}), f[l.key] = !0; }
            }
            function l_(d, n, l) { const f = function (T, C, P) { const R = s.bE(C, T), O = s.bE(P, [.2126, .7152, .0722]), D = (q, G, K) => (1 - K) * q + K * G, B = D(1 - .3 * Math.min(O, 1), 1, Math.min(R + 1, 1)); return D(.92, 1, Math.asin(s.aD(C[2], -1, 1)) / Math.PI + .5) * B; }(d, [0, 0, 1], n), _ = [0, 0, 0]; s.b$(_, l.slice(0, 3), f); const v = [0, 0, 0]; s.b$(v, n.slice(0, 3), d[2]); const w = [0, 0, 0]; return s.cU(w, _, v), s.cX(w); }
            const xp = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"], c_ = ["stars", "rainParticle", "snowParticle", "fillExtrusion", "fillExtrusionGroundEffect", "elevatedStructures", "model", "symbol"];
            class wp {
                static cacheKey(n, l, f, _) { let v = `${l}${_ ? _.cacheKey : ""}`; for (const w of f)
                    n.usedDefines.includes(w) && (v += `/${w}`); return v; }
                constructor(n, l, f, _, v, w) {
                    const T = n.gl;
                    this.program = T.createProgram(), this.configuration = _, this.name = l, this.fixedDefines = [...w];
                    const C = _ ? _.getBinderAttributes() : [], P = (f.staticAttributes || []).concat(C);
                    let R = _ ? _.defines() : [];
                    R = R.concat(w.map(K => `#define ${K}`));
                    const O = `#version 300 es
`;
                    let D = O + R.concat("precision mediump float;", bd, Ll.fragmentSource).join(`
`);
                    for (const K of f.fragmentIncludes)
                        D += `
${Oo[K]}`;
                    D += `
${f.fragmentSource}`;
                    let B = O + R.concat("precision highp float;", bd, Ll.vertexSource).join(`
`);
                    for (const K of f.vertexIncludes)
                        B += `
${Oo[K]}`;
                    this.forceManualRenderingForInstanceIDShaders = n.forceManualRenderingForInstanceIDShaders && f.vertexSource.indexOf("gl_InstanceID") !== -1, this.forceManualRenderingForInstanceIDShaders && (B += `
uniform int u_instanceID;
`), B += `
${f.vertexSource}`, this.forceManualRenderingForInstanceIDShaders && (B = B.replaceAll("gl_InstanceID", "u_instanceID"));
                    const q = T.createShader(T.FRAGMENT_SHADER);
                    if (T.isContextLost())
                        return void (this.failedToCreate = !0);
                    T.shaderSource(q, D), T.compileShader(q), T.attachShader(this.program, q);
                    const G = T.createShader(T.VERTEX_SHADER);
                    if (T.isContextLost())
                        this.failedToCreate = !0;
                    else {
                        T.shaderSource(G, B), T.compileShader(G), T.attachShader(this.program, G), this.attributes = {}, this.numAttributes = P.length;
                        for (let K = 0; K < this.numAttributes; K++)
                            if (P[K]) {
                                const W = P[K].startsWith("a_") ? P[K] : `a_${P[K]}`;
                                T.bindAttribLocation(this.program, K, W), this.attributes[W] = K;
                            }
                        T.linkProgram(this.program), T.deleteShader(G), T.deleteShader(q), this.fixedUniforms = v(n), this.binderUniforms = _ ? _.getUniforms(n) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = (K => ({ u_instanceID: new s.cc(K) }))(n)), (w.includes("TERRAIN") || l.indexOf("symbol") !== -1 || l.indexOf("circle") !== -1) && (this.terrainUniforms = (K => ({ u_dem: new s.cc(K), u_dem_prev: new s.cc(K), u_dem_tl: new s.c9(K), u_dem_scale: new s.cb(K), u_dem_tl_prev: new s.c9(K), u_dem_scale_prev: new s.cb(K), u_dem_size: new s.cb(K), u_dem_lerp: new s.cb(K), u_exaggeration: new s.cb(K), u_depth: new s.cc(K), u_depth_size_inv: new s.c9(K), u_depth_range_unpack: new s.c9(K), u_occluder_half_size: new s.cb(K), u_occlusion_depth_offset: new s.cb(K), u_meter_to_dem: new s.cb(K), u_label_plane_matrix_inv: new s.c8(K) }))(n)), w.includes("GLOBE") && (this.globeUniforms = (K => ({ u_tile_tl_up: new s.ca(K), u_tile_tr_up: new s.ca(K), u_tile_br_up: new s.ca(K), u_tile_bl_up: new s.ca(K), u_tile_up_scale: new s.cb(K) }))(n)), w.includes("FOG") && (this.fogUniforms = (K => ({ u_fog_matrix: new s.c8(K), u_fog_range: new s.c9(K), u_fog_color: new s.cQ(K), u_fog_horizon_blend: new s.cb(K), u_fog_vertical_limit: new s.c9(K), u_fog_temporal_offset: new s.cb(K), u_frustum_tl: new s.ca(K), u_frustum_tr: new s.ca(K), u_frustum_br: new s.ca(K), u_frustum_bl: new s.ca(K), u_globe_pos: new s.ca(K), u_globe_radius: new s.cb(K), u_globe_transition: new s.cb(K), u_is_globe: new s.cc(K), u_viewport: new s.c9(K) }))(n)), w.includes("RENDER_CUTOFF") && (this.cutoffUniforms = (K => ({ u_cutoff_params: new s.cQ(K) }))(n)), w.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = (K => ({ u_lighting_ambient_color: new s.ca(K), u_lighting_directional_dir: new s.ca(K), u_lighting_directional_color: new s.ca(K), u_ground_radiance: new s.ca(K) }))(n)), w.includes("RENDER_SHADOWS") && (this.shadowUniforms = (K => ({ u_light_matrix_0: new s.c8(K), u_light_matrix_1: new s.c8(K), u_fade_range: new s.c9(K), u_shadow_normal_offset: new s.ca(K), u_shadow_intensity: new s.cb(K), u_shadow_texel_size: new s.cb(K), u_shadow_map_resolution: new s.cb(K), u_shadow_direction: new s.ca(K), u_shadow_bias: new s.ca(K), u_shadowmap_0: new s.cc(K), u_shadowmap_1: new s.cc(K) }))(n));
                    }
                }
                setTerrainUniformValues(n, l) { if (!this.terrainUniforms)
                    return; const f = this.terrainUniforms; if (!this.failedToCreate) {
                    n.program.set(this.program);
                    for (const _ in l)
                        f[_] && f[_].set(this.program, _, l[_]);
                } }
                setGlobeUniformValues(n, l) { if (!this.globeUniforms)
                    return; const f = this.globeUniforms; if (!this.failedToCreate) {
                    n.program.set(this.program);
                    for (const _ in l)
                        f[_] && f[_].set(this.program, _, l[_]);
                } }
                setFogUniformValues(n, l) { if (!this.fogUniforms)
                    return; const f = this.fogUniforms; if (!this.failedToCreate) {
                    n.program.set(this.program);
                    for (const _ in l)
                        f[_].set(this.program, _, l[_]);
                } }
                setCutoffUniformValues(n, l) { if (!this.cutoffUniforms)
                    return; const f = this.cutoffUniforms; if (!this.failedToCreate) {
                    n.program.set(this.program);
                    for (const _ in l)
                        f[_].set(this.program, _, l[_]);
                } }
                setLightsUniformValues(n, l) { if (!this.lightsUniforms)
                    return; const f = this.lightsUniforms; if (!this.failedToCreate) {
                    n.program.set(this.program);
                    for (const _ in l)
                        f[_].set(this.program, _, l[_]);
                } }
                setShadowUniformValues(n, l) { if (this.failedToCreate || !this.shadowUniforms)
                    return; const f = this.shadowUniforms; n.program.set(this.program); for (const _ in l)
                    f[_].set(this.program, _, l[_]); }
                _drawDebugWireframe(n, l, f, _, v, w, T, C, P, R) { const O = n.options.wireframe; if (O.terrain === !1 && O.layers2D === !1 && O.layers3D === !1)
                    return; const D = n.context; if (!(!(!O.terrain || this.name !== "terrainRaster" && this.name !== "globeRaster") || !(!O.layers2D || n._terrain && n._terrain.renderingToTexture || !xp.includes(this.name)) || !(!O.layers3D || !c_.includes(this.name))))
                    return; const B = D.gl, q = n.wireframeDebugCache.getLinesFromTrianglesBuffer(n.frameCounter, v, D); if (!q)
                    return; const G = [...this.fixedDefines]; G.push("DEBUG_WIREFRAME"); const K = n.getOrCreateProgram(this.name, { config: this.configuration, defines: G }); D.program.set(K.program); const W = (me, we, ve) => { if (we[me] && ve[me])
                    for (const xe in we[me])
                        ve[me][xe] && ve[me][xe].set(ve.program, xe, we[me][xe].current); }; P && P.setUniforms(K.program, D, K.binderUniforms, T, { zoom: C }), W("fixedUniforms", this, K), W("terrainUniforms", this, K), W("globeUniforms", this, K), W("fogUniforms", this, K), W("lightsUniforms", this, K), W("shadowUniforms", this, K), q.bind(), D.setColorMode(new Rr([B.ONE, B.ONE_MINUS_SRC_ALPHA, B.ZERO, B.ONE], s.am.transparent, [!0, !0, !0, !1])), D.setDepthMode(new Ut(l.func === B.LESS ? B.LEQUAL : l.func, Ut.ReadOnly, l.range)), D.setStencilMode(dr.disabled); const oe = 3 * w.primitiveLength * 2, de = 3 * w.primitiveOffset * 2 * 2; if (this.forceManualRenderingForInstanceIDShaders) {
                    const me = R || 1;
                    for (let we = 0; we < me; ++we)
                        K.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", we), B.drawElements(B.LINES, oe, B.UNSIGNED_SHORT, de);
                }
                else
                    R && R > 1 ? B.drawElementsInstanced(B.LINES, oe, B.UNSIGNED_SHORT, de, R) : B.drawElements(B.LINES, oe, B.UNSIGNED_SHORT, de); v.bind(), D.program.set(this.program), D.setDepthMode(l), D.setStencilMode(f), D.setColorMode(_); }
                checkUniforms(n, l, f) { if (this.fixedDefines.includes(l)) {
                    for (const _ of Object.keys(f))
                        if (!f[_].initialized)
                            throw new Error(`Program '${this.name}', from draw '${n}': uniform ${_} not set but required by ${l} being defined`);
                } }
                draw(n, l, f, _, v, w, T, C, P, R, O, D, B, q, G, K) { const W = n.context, oe = W.gl; if (this.failedToCreate)
                    return; W.program.set(this.program), W.setDepthMode(f), W.setStencilMode(_), W.setColorMode(v), W.setCullFace(w); for (const we of Object.keys(this.fixedUniforms))
                    this.fixedUniforms[we].set(this.program, we, T[we]); q && q.setUniforms(this.program, W, this.binderUniforms, D, { zoom: B }); const de = { [oe.POINTS]: 1, [oe.LINES]: 2, [oe.TRIANGLES]: 3, [oe.LINE_STRIP]: 1 }[l]; this.checkUniforms(C, "RENDER_SHADOWS", this.shadowUniforms); const me = K && K > 0 ? 1 : void 0; for (const we of O.get()) {
                    const ve = we.vaos || (we.vaos = {});
                    if ((ve[C] || (ve[C] = new Zg)).bind(W, this, P, q ? q.getPaintVertexBuffers() : [], R, we.vertexOffset, G || [], me), this.forceManualRenderingForInstanceIDShaders) {
                        const xe = K || 1;
                        for (let ge = 0; ge < xe; ++ge)
                            this.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", ge), R ? oe.drawElements(l, we.primitiveLength * de, oe.UNSIGNED_SHORT, we.primitiveOffset * de * 2) : oe.drawArrays(l, we.vertexOffset, we.vertexLength);
                    }
                    else
                        K && K > 1 ? oe.drawElementsInstanced(l, we.primitiveLength * de, oe.UNSIGNED_SHORT, we.primitiveOffset * de * 2, K) : R ? oe.drawElements(l, we.primitiveLength * de, oe.UNSIGNED_SHORT, we.primitiveOffset * de * 2) : oe.drawArrays(l, we.vertexOffset, we.vertexLength);
                    l === oe.TRIANGLES && R && this._drawDebugWireframe(n, f, _, v, R, we, D, B, q, K);
                } }
            }
            function Cd(d, n, l = 0) { const f = Math.pow(2, n.tileID.overscaledZ), _ = n.tileSize * Math.pow(2, d.transform.tileZoom) / f, v = _ * (n.tileID.canonical.x + n.tileID.wrap * f), w = _ * n.tileID.canonical.y; return { u_image: 0, u_texsize: n.imageAtlasTexture ? n.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / s.aw(n, 1, d.transform.tileZoom), u_pixel_coord_upper: [v >> 16, w >> 16], u_pixel_coord_lower: [65535 & v, 65535 & w], u_pattern_transition: l }; }
            const Ad = { terrain: 0, flat: 1 }, O0 = s.bz(), Mc = (d, n, l, f, _, v, w, T, C, P, R, O, D, B, q, G, K, W) => { const oe = n.style.light, de = oe.properties.get("position"), me = [de.x, de.y, de.z], we = s.dx(); oe.properties.get("anchor") === "viewport" && (s.dy(we, -n.transform.angle), s.dz(me, me, we)); const ve = oe.properties.get("color"), xe = n.transform, ge = { u_matrix: d, u_lightpos: me, u_lightintensity: oe.properties.get("intensity"), u_lightcolor: [ve.r, ve.g, ve.b], u_vertical_gradient: +l, u_opacity: f, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: O0, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_height_type: Ad[P], u_base_type: Ad[R], u_ao: _, u_edge_radius: v, u_width_scale: w, u_flood_light_color: q, u_vertical_scale: G, u_flood_light_intensity: K, u_ground_shadow_factor: W }; return xe.projection.name === "globe" && (ge.u_tile_id = [T.canonical.x, T.canonical.y, 1 << T.canonical.z], ge.u_zoom_transition = O, ge.u_inv_rot_matrix = B, ge.u_merc_center = D, ge.u_up_dir = xe.projection.upVector(new s.cp(0, 0, 0), D[0] * s.aj, D[1] * s.aj), ge.u_height_lift = C), ge; }, oT = (d, n, l, f, _, v) => ({ u_matrix: d, u_edge_radius: n, u_width_scale: l, u_vertical_scale: f, u_height_type: Ad[_], u_base_type: Ad[v] }), aT = (d, n, l, f, _, v, w, T, C, P, R, O, D, B, q, G, K, W) => { const oe = Mc(d, n, l, f, _, v, w, T, P, R, O, D, B, q, G, K, 1, [0, 0, 0]), de = { u_height_factor: -Math.pow(2, T.overscaledZ) / C.tileSize / 8 }; return s.l(oe, Cd(n, C, W), de); }, z0 = (d, n, l) => ({ u_matrix: d, u_emissive_strength: n, u_ground_shadow_factor: l }), F0 = (d, n, l, f, _, v = 0) => s.l(z0(d, n, _), Cd(l, f, v)), lT = (d, n, l, f) => ({ u_matrix: d, u_world: l, u_emissive_strength: n, u_ground_shadow_factor: f }), cT = (d, n, l, f, _, v, w = 0) => s.l(F0(d, n, l, f, v, w), { u_world: _ }), u_ = (d, n) => ({ u_matrix: d, u_ground_shadow_factor: n }), Id = (d, n, l, f, _) => ({ u_matrix: d, u_camera_pos: [n[0], n[1], n[2]], u_depth_bias: l, u_height_scale: f, u_reset_depth: _ }), N0 = (d, n, l, f) => { const _ = s.aj / l.tileSize; return { u_matrix: d, u_camera_to_center_distance: n.getCameraToCenterDistance(f), u_extrude_scale: [n.pixelsToGLUnits[0] / _, n.pixelsToGLUnits[1] / _] }; }, Rc = (d, n, l = 1) => ({ u_matrix: d, u_color: n.toRenderColor(null), u_overlay: 0, u_overlay_scale: l }), B0 = s.bz(), j0 = (d, n, l, f, _, v, w) => { const T = d.transform, C = T.projection.name === "globe", P = C ? s.dA(T.zoom, n.canonical) * T._pixelsPerMercatorPixel : s.aw(l, 1, v), R = { u_matrix: n.projMatrix, u_extrude_scale: P, u_intensity: w, u_inv_rot_matrix: B0, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] }; if (C) {
                R.u_inv_rot_matrix = f, R.u_merc_center = _, R.u_tile_id = [n.canonical.x, n.canonical.y, 1 << n.canonical.z], R.u_zoom_transition = s.ah(T.zoom);
                const O = _[0] * s.aj, D = _[1] * s.aj;
                R.u_up_dir = T.projection.upVector(new s.cp(0, 0, 0), O, D);
            } return R; };
            function h_(d, [n, l, f, _], [v, w]) { if (v === w)
                return [0, 0, 0, 0]; const T = 255 * (d - 1) / (d * (w - v)); return [n * T, l * T, f * T, _ * T]; }
            function bp(d, n, [l, f]) { return l === f ? 0 : .5 / d + (n - l) * (d - 1) / (d * (f - l)); }
            const Ol = (d, n, l, f, _, v, w, T, C, P, R, O, D, B, q, G, K, W, oe, de, me) => ({ u_matrix: d, u_normalize_matrix: n, u_globe_matrix: l, u_merc_matrix: f, u_grid_matrix: _, u_tl_parent: v, u_scale_parent: P, u_fade_t: R.mix, u_opacity: R.opacity * O.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: O.paint.get("raster-brightness-min"), u_brightness_high: O.paint.get("raster-brightness-max"), u_saturation_factor: s.dB(O.paint.get("raster-saturation")), u_contrast_factor: s.dC(O.paint.get("raster-contrast")), u_spin_weights: V0(O.paint.get("raster-hue-rotate")), u_perspective_transform: D, u_raster_elevation: B, u_zoom_transition: w, u_merc_center: T, u_cutoff_params: C, u_colorization_mix: h_(s.dD, G, W), u_colorization_offset: bp(s.dD, K, W), u_color_ramp: q, u_texture_offset: [de / (oe + 2 * de), oe / (oe + 2 * de)], u_texture_res: [oe + 2 * de, oe + 2 * de], u_emissive_strength: me });
            function V0(d) { d *= Math.PI / 180; const n = Math.sin(d), l = Math.cos(d); return [(2 * l + 1) / 3, (-Math.sqrt(3) * n - l + 1) / 3, (Math.sqrt(3) * n - l + 1) / 3]; }
            const mo = .05, d_ = (d, n, l, f, _, v, w, T, C, P, R, O) => ({ u_matrix: d, u_normalize_matrix: n, u_globe_matrix: l, u_merc_matrix: f, u_grid_matrix: _, u_tl_parent: v, u_scale_parent: P, u_fade_t: R.mix, u_opacity: R.opacity, u_image0: 0, u_image1: 1, u_raster_elevation: O, u_zoom_transition: w, u_merc_center: T, u_cutoff_params: C }), Tp = (d, n, l, f, _, v, w, T, C, P) => ({ u_particle_texture: d, u_particle_texture_side_len: n, u_tile_offset: l, u_velocity: f, u_color_ramp: v, u_velocity_res: _, u_max_speed: w, u_uv_offset: T, u_data_scale: [255 * C[0], 255 * C[1]], u_data_offset: P, u_particle_pos_scale: 1.1, u_particle_pos_offset: [mo, mo] }), U0 = (d, n, l, f, _, v, w, T, C, P) => ({ u_particle_texture: d, u_particle_texture_side_len: n, u_velocity: l, u_velocity_res: f, u_max_speed: _, u_speed_factor: v, u_reset_rate: w, u_rand_seed: Math.random(), u_uv_offset: T, u_data_scale: [255 * C[0], 255 * C[1]], u_data_offset: P, u_particle_pos_scale: 1.1, u_particle_pos_offset: [mo, mo] }), f_ = s.bz(), Sp = (d, n, l, f, _, v, w, T, C, P, R, O, D, B, q, G, K, W, oe, de, me, we, ve) => { const xe = _.transform, ge = { u_is_size_zoom_constant: +(d === "constant" || d === "source"), u_is_size_feature_constant: +(d === "constant" || d === "camera"), u_size_t: n ? n.uSizeT : 0, u_size: n ? n.uSize : 0, u_camera_to_center_distance: xe.getCameraToCenterDistance(oe), u_rotate_symbol: +l, u_aspect_ratio: xe.width / xe.height, u_fade_change: _.options.fadeDuration ? _.symbolFadeChange : 1, u_matrix: v, u_label_plane_matrix: w, u_coord_matrix: T, u_is_text: +P, u_elevation_from_sea: C ? 1 : 0, u_pitch_with_map: +f, u_texsize: R, u_texsize_icon: O, u_texture: 0, u_texture_icon: 1, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: f_, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: f_, u_up_vector: [0, -1, 0], u_color_adj_mat: me, u_icon_transition: we || 0, u_gamma_scale: f ? _.transform.getCameraToCenterDistance(oe) * Math.cos(_.terrain ? 0 : _.transform._pitch) : 1, u_device_pixel_ratio: s.q.devicePixelRatio, u_is_halo: +D, u_scale_factor: ve || 1, u_ground_shadow_factor: de, u_inv_matrix: s.bi(s.bz(), w) }; return oe.name === "globe" && (ge.u_tile_id = [B.canonical.x, B.canonical.y, 1 << B.canonical.z], ge.u_zoom_transition = q, ge.u_inv_rot_matrix = K, ge.u_merc_center = G, ge.u_camera_forward = xe._camera.forward(), ge.u_ecef_origin = s.dE(xe.globeMatrix, B.toUnwrapped()), ge.u_tile_matrix = Float32Array.from(xe.globeMatrix), ge.u_up_vector = W), ge; }, Ep = (d, n, l, f) => ({ u_matrix: d, u_emissive_strength: n, u_opacity: l, u_color: f }), $0 = (d, n, l, f, _, v, w, T, C) => s.l(function (P, R, O, D, B, q) { const { width: G, height: K } = D.imageManager.getPixelSize(R), W = Math.pow(2, q.tileID.overscaledZ), oe = q.tileSize * Math.pow(2, D.transform.tileZoom) / W, de = oe * (q.tileID.canonical.x + q.tileID.wrap * W), me = oe * q.tileID.canonical.y; return { u_image: 0, u_pattern_tl: O.tl, u_pattern_br: O.br, u_texsize: [G, K], u_pattern_size: O.displaySize, u_pattern_units_to_pixels: B ? [D.transform.width, -1 * D.transform.height] : [1 / s.aw(q, 1, D.transform.tileZoom), 1 / s.aw(q, 1, D.transform.tileZoom)], u_pixel_coord_upper: [de >> 16, me >> 16], u_pixel_coord_lower: [65535 & de, 65535 & me] }; }(0, v, w, f, T, C), { u_matrix: d, u_emissive_strength: n, u_opacity: l }), Cp = new Float32Array(s.bx([])), kc = (d, n, l, f, _, v, w, T, C, P, R, O, D, B = [0, 0, 0], q) => { const G = _.style.light, K = G.properties.get("position"), W = [-K.x, -K.y, K.z], oe = s.dx(); G.properties.get("anchor") === "viewport" && (s.dy(oe, -_.transform.angle), s.dz(W, W, oe)); const de = R.alphaMode === "MASK", me = G.properties.get("color").toRenderColor(null), we = D.paint.get("model-ambient-occlusion-intensity"), ve = D.paint.get("model-color").constantOr(s.am.white).toRenderColor(null), xe = D.paint.get("model-color-mix-intensity").constantOr(0); return { u_matrix: d, u_lighting_matrix: n, u_normal_matrix: l, u_node_matrix: f || Cp, u_lightpos: W, u_lightintensity: G.properties.get("intensity"), u_lightcolor: [me.r, me.g, me.b], u_camera_pos: B, u_opacity: v, u_baseTextureIsAlpha: 0, u_alphaMask: +de, u_alphaCutoff: R.alphaCutoff, u_baseColorFactor: [w.r, w.g, w.b, w.a], u_emissiveFactor: [T[0], T[1], T[2], 1], u_metallicFactor: C, u_roughnessFactor: P, u_baseColorTexture: Rs.BaseColor, u_metallicRoughnessTexture: Rs.MetallicRoughness, u_normalTexture: Rs.Normal, u_occlusionTexture: Rs.Occlusion, u_emissionTexture: Rs.Emission, u_lutTexture: Rs.LUT, u_color_mix: [ve.r, ve.g, ve.b, xe], u_aoIntensity: we, u_emissive_strength: O, u_occlusionTextureTransform: q || [0, 0, 0, 0] }; }, G0 = (d, n = Cp, l = Cp) => ({ u_matrix: d, u_instance: n, u_node_matrix: l }), uT = { fillExtrusion: d => ({ u_matrix: new s.c8(d), u_lightpos: new s.ca(d), u_lightintensity: new s.cb(d), u_lightcolor: new s.ca(d), u_vertical_gradient: new s.cb(d), u_opacity: new s.cb(d), u_edge_radius: new s.cb(d), u_width_scale: new s.cb(d), u_ao: new s.c9(d), u_height_type: new s.cc(d), u_base_type: new s.cc(d), u_tile_id: new s.ca(d), u_zoom_transition: new s.cb(d), u_inv_rot_matrix: new s.c8(d), u_merc_center: new s.c9(d), u_up_dir: new s.ca(d), u_height_lift: new s.cb(d), u_flood_light_color: new s.ca(d), u_vertical_scale: new s.cb(d), u_flood_light_intensity: new s.cb(d), u_ground_shadow_factor: new s.ca(d) }), fillExtrusionDepth: d => ({ u_matrix: new s.c8(d), u_edge_radius: new s.cb(d), u_width_scale: new s.cb(d), u_vertical_scale: new s.cb(d), u_height_type: new s.cc(d), u_base_type: new s.cc(d) }), fillExtrusionPattern: d => ({ u_matrix: new s.c8(d), u_lightpos: new s.ca(d), u_lightintensity: new s.cb(d), u_lightcolor: new s.ca(d), u_vertical_gradient: new s.cb(d), u_height_factor: new s.cb(d), u_edge_radius: new s.cb(d), u_width_scale: new s.cb(d), u_ao: new s.c9(d), u_height_type: new s.cc(d), u_base_type: new s.cc(d), u_tile_id: new s.ca(d), u_zoom_transition: new s.cb(d), u_inv_rot_matrix: new s.c8(d), u_merc_center: new s.c9(d), u_up_dir: new s.ca(d), u_height_lift: new s.cb(d), u_image: new s.cc(d), u_texsize: new s.c9(d), u_pixel_coord_upper: new s.c9(d), u_pixel_coord_lower: new s.c9(d), u_tile_units_to_pixels: new s.cb(d), u_opacity: new s.cb(d), u_pattern_transition: new s.cb(d) }), fillExtrusionGroundEffect: d => ({ u_matrix: new s.c8(d), u_opacity: new s.cb(d), u_ao_pass: new s.cb(d), u_meter_to_tile: new s.cb(d), u_ao: new s.c9(d), u_flood_light_intensity: new s.cb(d), u_flood_light_color: new s.ca(d), u_attenuation: new s.cb(d), u_edge_radius: new s.cb(d), u_fb: new s.cc(d), u_fb_size: new s.cb(d), u_dynamic_offset: new s.cb(d) }), fill: d => ({ u_matrix: new s.c8(d), u_emissive_strength: new s.cb(d), u_ground_shadow_factor: new s.ca(d) }), fillPattern: d => ({ u_matrix: new s.c8(d), u_emissive_strength: new s.cb(d), u_image: new s.cc(d), u_texsize: new s.c9(d), u_pixel_coord_upper: new s.c9(d), u_pixel_coord_lower: new s.c9(d), u_tile_units_to_pixels: new s.cb(d), u_ground_shadow_factor: new s.ca(d), u_pattern_transition: new s.cb(d) }), fillOutline: d => ({ u_matrix: new s.c8(d), u_emissive_strength: new s.cb(d), u_world: new s.c9(d), u_ground_shadow_factor: new s.ca(d) }), fillOutlinePattern: d => ({ u_matrix: new s.c8(d), u_emissive_strength: new s.cb(d), u_world: new s.c9(d), u_image: new s.cc(d), u_texsize: new s.c9(d), u_pixel_coord_upper: new s.c9(d), u_pixel_coord_lower: new s.c9(d), u_tile_units_to_pixels: new s.cb(d), u_ground_shadow_factor: new s.ca(d), u_pattern_transition: new s.cb(d) }), building: d => ({ u_matrix: new s.c8(d), u_normal_matrix: new s.c8(d), u_opacity: new s.cb(d) }), buildingDepth: d => ({ u_matrix: new s.c8(d) }), elevatedStructuresDepth: d => ({ u_matrix: new s.c8(d), u_depth_bias: new s.cb(d) }), elevatedStructures: d => ({ u_matrix: new s.c8(d), u_ground_shadow_factor: new s.ca(d) }), elevatedStructuresDepthReconstruct: d => ({ u_matrix: new s.c8(d), u_camera_pos: new s.ca(d), u_depth_bias: new s.cb(d), u_height_scale: new s.cb(d), u_reset_depth: new s.cb(d) }), circle: s.dF, collisionBox: d => ({ u_matrix: new s.c8(d), u_camera_to_center_distance: new s.cb(d), u_extrude_scale: new s.c9(d) }), collisionCircle: d => ({ u_matrix: new s.c8(d), u_inv_matrix: new s.c8(d), u_camera_to_center_distance: new s.cb(d), u_viewport_size: new s.c9(d) }), debug: d => ({ u_color: new s.di(d), u_matrix: new s.c8(d), u_overlay: new s.cc(d), u_overlay_scale: new s.cb(d) }), clippingMask: d => ({ u_matrix: new s.c8(d) }), heatmap: d => ({ u_extrude_scale: new s.cb(d), u_intensity: new s.cb(d), u_matrix: new s.c8(d), u_inv_rot_matrix: new s.c8(d), u_merc_center: new s.c9(d), u_tile_id: new s.ca(d), u_zoom_transition: new s.cb(d), u_up_dir: new s.ca(d) }), heatmapTexture: d => ({ u_image: new s.cc(d), u_color_ramp: new s.cc(d), u_opacity: new s.cb(d) }), hillshade: d => ({ u_matrix: new s.c8(d), u_image: new s.cc(d), u_latrange: new s.c9(d), u_light: new s.c9(d), u_shadow: new s.di(d), u_highlight: new s.di(d), u_emissive_strength: new s.cb(d), u_accent: new s.di(d) }), hillshadePrepare: d => ({ u_matrix: new s.c8(d), u_image: new s.cc(d), u_dimension: new s.c9(d), u_zoom: new s.cb(d) }), line: s.dG, linePattern: s.dH, raster: d => ({ u_matrix: new s.c8(d), u_normalize_matrix: new s.c8(d), u_globe_matrix: new s.c8(d), u_merc_matrix: new s.c8(d), u_grid_matrix: new s.dj(d), u_tl_parent: new s.c9(d), u_scale_parent: new s.cb(d), u_fade_t: new s.cb(d), u_opacity: new s.cb(d), u_image0: new s.cc(d), u_image1: new s.cc(d), u_brightness_low: new s.cb(d), u_brightness_high: new s.cb(d), u_saturation_factor: new s.cb(d), u_contrast_factor: new s.cb(d), u_spin_weights: new s.ca(d), u_perspective_transform: new s.c9(d), u_raster_elevation: new s.cb(d), u_zoom_transition: new s.cb(d), u_merc_center: new s.c9(d), u_cutoff_params: new s.cQ(d), u_colorization_mix: new s.cQ(d), u_colorization_offset: new s.cb(d), u_color_ramp: new s.cc(d), u_texture_offset: new s.c9(d), u_texture_res: new s.c9(d), u_emissive_strength: new s.cb(d) }), rasterParticle: d => ({ u_matrix: new s.c8(d), u_normalize_matrix: new s.c8(d), u_globe_matrix: new s.c8(d), u_merc_matrix: new s.c8(d), u_grid_matrix: new s.dj(d), u_tl_parent: new s.c9(d), u_scale_parent: new s.cb(d), u_fade_t: new s.cb(d), u_opacity: new s.cb(d), u_image0: new s.cc(d), u_image1: new s.cc(d), u_raster_elevation: new s.cb(d), u_zoom_transition: new s.cb(d), u_merc_center: new s.c9(d), u_cutoff_params: new s.cQ(d) }), rasterParticleTexture: d => ({ u_texture: new s.cc(d), u_opacity: new s.cb(d) }), rasterParticleDraw: d => ({ u_particle_texture: new s.cc(d), u_particle_texture_side_len: new s.cb(d), u_tile_offset: new s.c9(d), u_velocity: new s.cc(d), u_color_ramp: new s.cc(d), u_velocity_res: new s.c9(d), u_max_speed: new s.cb(d), u_uv_offset: new s.c9(d), u_data_scale: new s.c9(d), u_data_offset: new s.cb(d), u_particle_pos_scale: new s.cb(d), u_particle_pos_offset: new s.c9(d) }), rasterParticleUpdate: d => ({ u_particle_texture: new s.cc(d), u_particle_texture_side_len: new s.cb(d), u_velocity: new s.cc(d), u_velocity_res: new s.c9(d), u_max_speed: new s.cb(d), u_speed_factor: new s.cb(d), u_reset_rate: new s.cb(d), u_rand_seed: new s.cb(d), u_uv_offset: new s.c9(d), u_data_scale: new s.c9(d), u_data_offset: new s.cb(d), u_particle_pos_scale: new s.cb(d), u_particle_pos_offset: new s.c9(d) }), symbol: d => ({ u_is_size_zoom_constant: new s.cc(d), u_is_size_feature_constant: new s.cc(d), u_size_t: new s.cb(d), u_size: new s.cb(d), u_camera_to_center_distance: new s.cb(d), u_rotate_symbol: new s.cc(d), u_aspect_ratio: new s.cb(d), u_fade_change: new s.cb(d), u_matrix: new s.c8(d), u_label_plane_matrix: new s.c8(d), u_coord_matrix: new s.c8(d), u_is_text: new s.cc(d), u_elevation_from_sea: new s.cc(d), u_pitch_with_map: new s.cc(d), u_texsize: new s.c9(d), u_texsize_icon: new s.c9(d), u_texture: new s.cc(d), u_texture_icon: new s.cc(d), u_gamma_scale: new s.cb(d), u_device_pixel_ratio: new s.cb(d), u_tile_id: new s.ca(d), u_zoom_transition: new s.cb(d), u_inv_rot_matrix: new s.c8(d), u_merc_center: new s.c9(d), u_camera_forward: new s.ca(d), u_tile_matrix: new s.c8(d), u_up_vector: new s.ca(d), u_ecef_origin: new s.ca(d), u_is_halo: new s.cc(d), u_icon_transition: new s.cb(d), u_color_adj_mat: new s.c8(d), u_scale_factor: new s.cb(d), u_ground_shadow_factor: new s.ca(d), u_inv_matrix: new s.c8(d) }), background: d => ({ u_matrix: new s.c8(d), u_emissive_strength: new s.cb(d), u_opacity: new s.cb(d), u_color: new s.di(d) }), backgroundPattern: d => ({ u_matrix: new s.c8(d), u_emissive_strength: new s.cb(d), u_opacity: new s.cb(d), u_image: new s.cc(d), u_pattern_tl: new s.c9(d), u_pattern_br: new s.c9(d), u_texsize: new s.c9(d), u_pattern_size: new s.c9(d), u_pixel_coord_upper: new s.c9(d), u_pixel_coord_lower: new s.c9(d), u_pattern_units_to_pixels: new s.c9(d) }), terrainRaster: d => ({ u_matrix: new s.c8(d), u_image0: new s.cc(d), u_skirt_height: new s.cb(d), u_ground_shadow_factor: new s.ca(d) }), skybox: d => ({ u_matrix: new s.c8(d), u_sun_direction: new s.ca(d), u_cubemap: new s.cc(d), u_opacity: new s.cb(d), u_temporal_offset: new s.cb(d) }), skyboxGradient: d => ({ u_matrix: new s.c8(d), u_color_ramp: new s.cc(d), u_center_direction: new s.ca(d), u_radius: new s.cb(d), u_opacity: new s.cb(d), u_temporal_offset: new s.cb(d) }), skyboxCapture: d => ({ u_matrix_3f: new s.dj(d), u_sun_direction: new s.ca(d), u_sun_intensity: new s.cb(d), u_color_tint_r: new s.cQ(d), u_color_tint_m: new s.cQ(d), u_luminance: new s.cb(d) }), globeRaster: d => ({ u_proj_matrix: new s.c8(d), u_globe_matrix: new s.c8(d), u_normalize_matrix: new s.c8(d), u_merc_matrix: new s.c8(d), u_zoom_transition: new s.cb(d), u_merc_center: new s.c9(d), u_image0: new s.cc(d), u_grid_matrix: new s.dj(d), u_skirt_height: new s.cb(d), u_far_z_cutoff: new s.cb(d), u_frustum_tl: new s.ca(d), u_frustum_tr: new s.ca(d), u_frustum_br: new s.ca(d), u_frustum_bl: new s.ca(d), u_globe_pos: new s.ca(d), u_globe_radius: new s.cb(d), u_viewport: new s.c9(d) }), globeAtmosphere: d => ({ u_frustum_tl: new s.ca(d), u_frustum_tr: new s.ca(d), u_frustum_br: new s.ca(d), u_frustum_bl: new s.ca(d), u_horizon: new s.cb(d), u_transition: new s.cb(d), u_fadeout_range: new s.cb(d), u_color: new s.cQ(d), u_high_color: new s.cQ(d), u_space_color: new s.cQ(d), u_temporal_offset: new s.cb(d), u_horizon_angle: new s.cb(d) }), model: d => ({ u_matrix: new s.c8(d), u_lighting_matrix: new s.c8(d), u_normal_matrix: new s.c8(d), u_node_matrix: new s.c8(d), u_lightpos: new s.ca(d), u_lightintensity: new s.cb(d), u_lightcolor: new s.ca(d), u_camera_pos: new s.ca(d), u_opacity: new s.cb(d), u_baseColorFactor: new s.cQ(d), u_emissiveFactor: new s.cQ(d), u_metallicFactor: new s.cb(d), u_roughnessFactor: new s.cb(d), u_baseTextureIsAlpha: new s.cc(d), u_alphaMask: new s.cc(d), u_alphaCutoff: new s.cb(d), u_baseColorTexture: new s.cc(d), u_metallicRoughnessTexture: new s.cc(d), u_normalTexture: new s.cc(d), u_occlusionTexture: new s.cc(d), u_emissionTexture: new s.cc(d), u_lutTexture: new s.cc(d), u_color_mix: new s.cQ(d), u_aoIntensity: new s.cb(d), u_emissive_strength: new s.cb(d), u_occlusionTextureTransform: new s.cQ(d) }), modelDepth: d => ({ u_matrix: new s.c8(d), u_instance: new s.c8(d), u_node_matrix: new s.c8(d) }), groundShadow: d => ({ u_matrix: new s.c8(d), u_ground_shadow_factor: new s.ca(d) }), stars: d => ({ u_matrix: new s.c8(d), u_up: new s.ca(d), u_right: new s.ca(d), u_intensity_multiplier: new s.cb(d) }), snowParticle: d => ({ u_modelview: new s.c8(d), u_projection: new s.c8(d), u_time: new s.cb(d), u_cam_pos: new s.ca(d), u_velocityConeAperture: new s.cb(d), u_velocity: new s.cb(d), u_horizontalOscillationRadius: new s.cb(d), u_horizontalOscillationRate: new s.cb(d), u_boxSize: new s.cb(d), u_billboardSize: new s.cb(d), u_simpleShapeParameters: new s.c9(d), u_screenSize: new s.c9(d), u_thinningCenterPos: new s.c9(d), u_thinningShape: new s.ca(d), u_thinningAffectedRatio: new s.cb(d), u_thinningParticleOffset: new s.cb(d), u_particleColor: new s.cQ(d), u_direction: new s.ca(d) }), rainParticle: d => ({ u_modelview: new s.c8(d), u_projection: new s.c8(d), u_time: new s.cb(d), u_cam_pos: new s.ca(d), u_texScreen: new s.cc(d), u_velocityConeAperture: new s.cb(d), u_velocity: new s.cb(d), u_boxSize: new s.cb(d), u_rainDropletSize: new s.c9(d), u_distortionStrength: new s.cb(d), u_rainDirection: new s.ca(d), u_color: new s.cQ(d), u_screenSize: new s.c9(d), u_thinningCenterPos: new s.c9(d), u_thinningShape: new s.ca(d), u_thinningAffectedRatio: new s.cb(d), u_thinningParticleOffset: new s.cb(d), u_shapeDirectionalPower: new s.cb(d), u_shapeNormalPower: new s.cb(d), u_mode: new s.cb(d) }), vignette: d => ({ u_vignetteShape: new s.ca(d), u_vignetteColor: new s.cQ(d) }), occlusion: d => ({ u_matrix: new s.c8(d), u_anchorPos: new s.ca(d), u_screenSizePx: new s.c9(d), u_occluderSizePx: new s.c9(d), u_color: new s.cQ(d) }) };
            class Qa {
                constructor(n, l, f, _) { this.id = Qa.uniqueIdxCounter, Qa.uniqueIdxCounter++, this.context = n; const v = n.gl; this.buffer = v.createBuffer(), this.dynamicDraw = !!f, this.context.unbindVAO(), n.bindElementBuffer.set(this.buffer), v.bufferData(v.ELEMENT_ARRAY_BUFFER, l.arrayBuffer, this.dynamicDraw ? v.DYNAMIC_DRAW : v.STATIC_DRAW), this.dynamicDraw || _ || l.destroy(); }
                bind() { this.context.bindElementBuffer.set(this.buffer); }
                updateData(n) { this.id = Qa.uniqueIdxCounter, Qa.uniqueIdxCounter++; const l = this.context.gl; this.context.unbindVAO(), this.bind(), l.bufferSubData(l.ELEMENT_ARRAY_BUFFER, 0, n.arrayBuffer); }
                destroy() { this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer); }
            }
            Qa.uniqueIdxCounter = 0;
            const hT = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
            class p_ {
                constructor(n, l, f, _, v, w) { this.length = l.length, this.attributes = f, this.itemSize = l.bytesPerElement, this.dynamicDraw = _, this.instanceCount = w, this.context = n; const T = n.gl; this.buffer = T.createBuffer(), n.bindVertexBuffer.set(this.buffer), T.bufferData(T.ARRAY_BUFFER, l.arrayBuffer, this.dynamicDraw ? T.DYNAMIC_DRAW : T.STATIC_DRAW), this.dynamicDraw || v || l.destroy(); }
                bind() { this.context.bindVertexBuffer.set(this.buffer); }
                updateData(n) { const l = this.context.gl; this.bind(), l.bufferSubData(l.ARRAY_BUFFER, 0, n.arrayBuffer); }
                enableAttributes(n, l) { for (let f = 0; f < this.attributes.length; f++) {
                    const _ = l.attributes[this.attributes[f].name];
                    _ !== void 0 && n.enableVertexAttribArray(_);
                } }
                setVertexAttribPointers(n, l, f) { for (let _ = 0; _ < this.attributes.length; _++) {
                    const v = this.attributes[_], w = l.attributes[v.name];
                    w !== void 0 && n.vertexAttribPointer(w, v.components, n[hT[v.type]], !1, this.itemSize, v.offset + this.itemSize * (f || 0));
                } }
                setVertexAttribDivisor(n, l, f) { for (let _ = 0; _ < this.attributes.length; _++) {
                    const v = l.attributes[this.attributes[_].name];
                    v !== void 0 && this.instanceCount && this.instanceCount > 0 && n.vertexAttribDivisor(v, f);
                } }
                destroy() { this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer); }
            }
            class Ap {
                constructor(n, l, f, _, v) { this.context = n, this.width = l, this.height = f; const w = this.framebuffer = n.gl.createFramebuffer(); _ && (this.colorAttachment = new sT(n, w)), v && (this.depthAttachmentType = v, this.depthAttachment = v === "renderbuffer" ? new mp(n, w) : new n_(n, w)); }
                destroy() { const n = this.context.gl; if (this.colorAttachment) {
                    const l = this.colorAttachment.get();
                    l && n.deleteTexture(l);
                } if (this.depthAttachment && this.depthAttachmentType)
                    if (this.depthAttachmentType === "renderbuffer") {
                        const l = this.depthAttachment.get();
                        l && n.deleteRenderbuffer(l);
                    }
                    else {
                        const l = this.depthAttachment.get();
                        l && n.deleteTexture(l);
                    } n.deleteFramebuffer(this.framebuffer); }
            }
            class Ou {
                constructor(n, l) { this.gl = n, this.clearColor = new Jb(this), this.clearDepth = new eT(this), this.clearStencil = new tT(this), this.colorMask = new C0(this), this.depthMask = new rT(this), this.stencilMask = new cp(this), this.stencilFunc = new nT(this), this.stencilOp = new A0(this), this.stencilTest = new Yg(this), this.depthRange = new up(this), this.depthTest = new Qg(this), this.depthFunc = new Pc(this), this.blend = new Jg(this), this.blendFunc = new I0(this), this.blendColor = new Pu(this), this.blendEquation = new Td(this), this.cullFace = new hp(this), this.cullFaceSide = new dp(this), this.frontFace = new Mu(this), this.program = new fp(this), this.activeTexture = new e_(this), this.viewport = new P0(this), this.bindFramebuffer = new t_(this), this.bindRenderbuffer = new pp(this), this.bindTexture = new Sd(this), this.bindVertexBuffer = new M0(this), this.bindElementBuffer = new R0(this), this.bindVertexArrayOES = new k0(this), this.pixelStoreUnpack = new Ru(this), this.pixelStoreUnpackPremultiplyAlpha = new D0(this), this.pixelStoreUnpackFlipY = new iT(this), this.options = l ? Object.assign({}, l) : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = n.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = n.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = n.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = n.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = l && !!l.forceManualRenderingForInstanceIDShaders || this.renderer && this.renderer.indexOf("PowerVR") !== -1, this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = n.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = n.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = n.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = n.getParameter(n.MAX_TEXTURE_SIZE), this.maxPointSize = n.getParameter(n.ALIASED_POINT_SIZE_RANGE)[1]; }
                setDefault() { this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault(); }
                setDirty() { this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArrayOES.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0; }
                createIndexBuffer(n, l, f) { return new Qa(this, n, l, f); }
                createVertexBuffer(n, l, f, _, v) { return new p_(this, n, l, f, _, v); }
                createRenderbuffer(n, l, f) { const _ = this.gl, v = _.createRenderbuffer(); return this.bindRenderbuffer.set(v), _.renderbufferStorage(_.RENDERBUFFER, n, l, f), this.bindRenderbuffer.set(null), v; }
                createFramebuffer(n, l, f, _) { return new Ap(this, n, l, f, _); }
                clear({ color: n, depth: l, stencil: f, colorMask: _ }) { const v = this.gl; let w = 0; n && (w |= v.COLOR_BUFFER_BIT, this.clearColor.set(n), this.colorMask.set(_ || [!0, !0, !0, !0])), l !== void 0 && (w |= v.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(l), this.depthMask.set(!0)), f !== void 0 && (w |= v.STENCIL_BUFFER_BIT, this.clearStencil.set(f), this.stencilMask.set(255)), v.clear(w); }
                setCullFace(n) { n.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(n.mode), this.frontFace.set(n.frontFace)); }
                setDepthMode(n) { n.func !== this.gl.ALWAYS || n.mask ? (this.depthTest.set(!0), this.depthFunc.set(n.func), this.depthMask.set(n.mask), this.depthRange.set(n.range)) : this.depthTest.set(!1); }
                setStencilMode(n) { n.test.func !== this.gl.ALWAYS || n.mask ? (this.stencilTest.set(!0), this.stencilMask.set(n.mask), this.stencilOp.set([n.fail, n.depthFail, n.pass]), this.stencilFunc.set({ func: n.test.func, ref: n.ref, mask: n.test.mask })) : this.stencilTest.set(!1); }
                setColorMode(n) { s.bv(n.blendFunction, Rr.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(n.blendFunction), this.blendColor.set(n.blendColor), n.blendEquation ? this.blendEquation.set(n.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(n.mask); }
                unbindVAO() { this.bindVertexArrayOES.set(null); }
            }
            let Dc;
            function zu(d, n, l, f, _, v, w) { const T = d.context, C = T.gl, P = d.transform, R = d.getOrCreateProgram("collisionBox"), O = []; let D = 0, B = 0; for (let me = 0; me < f.length; me++) {
                const we = f[me], ve = n.getTile(we), xe = ve.getBucket(l);
                if (!xe)
                    continue;
                const ge = tp(we, xe, P);
                let Se = ge;
                _[0] === 0 && _[1] === 0 || (Se = d.translatePosMatrix(ge, ve, _, v));
                const Ce = w ? xe.textCollisionBox : xe.iconCollisionBox, je = xe.collisionCircleArray;
                if (je.length > 0) {
                    const ze = s.bz(), rt = Se;
                    s.cB(ze, xe.placementInvProjMatrix, P.glCoordMatrix), s.cB(ze, ze, xe.placementViewportMatrix), O.push({ circleArray: je, circleOffset: B, transform: rt, invTransform: ze, projection: xe.getProjection() }), D += je.length / 4, B = D;
                }
                Ce && (d.terrain && d.terrain.setupElevationDraw(ve, R), R.draw(d, C.LINES, Ut.disabled, dr.disabled, d.colorModeForRenderPass(), fr.disabled, N0(Se, P, ve, xe.getProjection()), l.id, Ce.layoutVertexBuffer, Ce.indexBuffer, Ce.segments, null, P.zoom, null, [Ce.collisionVertexBuffer, Ce.collisionVertexBufferExt]));
            } if (!w || !O.length)
                return; const q = d.getOrCreateProgram("collisionCircle"), G = new s.dI; G.resize(4 * D), G._trim(); let K = 0; for (const me of O)
                for (let we = 0; we < me.circleArray.length / 4; we++) {
                    const ve = 4 * we, xe = me.circleArray[ve + 0], ge = me.circleArray[ve + 1], Se = me.circleArray[ve + 2], Ce = me.circleArray[ve + 3];
                    G.emplace(K++, xe, ge, Se, Ce, 0), G.emplace(K++, xe, ge, Se, Ce, 1), G.emplace(K++, xe, ge, Se, Ce, 2), G.emplace(K++, xe, ge, Se, Ce, 3);
                } (!Dc || Dc.length < 2 * D) && (Dc = function (me) { const we = 2 * me, ve = new s.a_; ve.resize(we), ve._trim(); for (let xe = 0; xe < we; xe++) {
                const ge = 6 * xe;
                ve.uint16[ge + 0] = 4 * xe + 0, ve.uint16[ge + 1] = 4 * xe + 1, ve.uint16[ge + 2] = 4 * xe + 2, ve.uint16[ge + 3] = 4 * xe + 2, ve.uint16[ge + 4] = 4 * xe + 3, ve.uint16[ge + 5] = 4 * xe + 0;
            } return ve; }(D)); const W = T.createIndexBuffer(Dc, !0), oe = T.createVertexBuffer(G, s.dJ.members, !0); for (const me of O) {
                const we = { u_matrix: me.transform, u_inv_matrix: me.invTransform, u_camera_to_center_distance: (de = P).getCameraToCenterDistance(me.projection), u_viewport_size: [de.width, de.height] };
                q.draw(d, C.TRIANGLES, Ut.disabled, dr.disabled, d.colorModeForRenderPass(), fr.disabled, we, l.id, oe, W, s.bd.simpleSegment(0, 2 * me.circleOffset, me.circleArray.length, me.circleArray.length / 2), null, P.zoom);
            } var de; oe.destroy(), W.destroy(); }
            const Pd = s.bz();
            function Md(d) { const n = d._camera.getWorldToCamera(d.worldSize, 1), l = s.az([], n, d.globeMatrix); s.bi(l, l); const f = [0, 0, 0], _ = [0, 1, 0, 0]; return s.aA(_, _, l), f[0] = _[0], f[1] = _[1], f[2] = _[2], s.au(f, f), f; }
            function Ip({ width: d, height: n, anchor: l, textOffset: f, textScale: _ }, v) { const { horizontalAlign: w, verticalAlign: T } = s.bV(l), C = -(w - .5) * d, P = -(T - .5) * n, R = s.bU(l, f); return new s.P((C / _ + R[0]) * v, (P / _ + R[1]) * v); }
            function m_(d, n, l, f, _, v, w, T, C, P) { const R = d.text.placedSymbolArray, O = d.text.dynamicLayoutVertexArray, D = d.icon.dynamicLayoutVertexArray, B = {}, q = d.getProjection(), G = pd(w, q, _), K = _.elevation, W = q.upVectorScale(w.canonical, _.center.lat, _.worldSize).metersToTile; O.clear(); for (let oe = 0; oe < R.length; oe++) {
                const de = R.get(oe), { tileAnchorX: me, tileAnchorY: we, numGlyphs: ve } = de, xe = de.hidden || !de.crossTileID || d.allowVerticalPlacement && !de.placedOrientation ? null : f[de.crossTileID];
                if (xe) {
                    let ge = 0, Se = 0, Ce = 0;
                    if (K) {
                        const st = K ? K.getAtTileOffset(w, me, we) : 0, [He, ht, nt] = q.upVector(w.canonical, me, we);
                        ge = st * He * W, Se = st * ht * W, Ce = st * nt * W;
                    }
                    let [je, ze, rt, et] = Js(de.projectedAnchorX + ge, de.projectedAnchorY + Se, de.projectedAnchorZ + Ce, l ? G : v);
                    const vt = Al(_.getCameraToCenterDistance(q), et);
                    let Fe = s.bJ(d.textSizeData, C, de) * vt / s.bO;
                    l && (Fe *= d.tilePixelRatio / T);
                    const Ve = Ip(xe, Fe);
                    l ? ({ x: je, y: ze, z: rt } = q.projectTilePoint(me + Ve.x, we + Ve.y, w.canonical), [je, ze, rt] = Js(je + ge, ze + Se, rt + Ce, v)) : (n && Ve._rotate(-_.angle), je += Ve.x, ze += Ve.y, rt = 0);
                    const Le = d.allowVerticalPlacement && de.placedOrientation === s.bI.vertical ? Math.PI / 2 : 0;
                    for (let st = 0; st < ve; st++)
                        s.bL(O, je, ze, rt, Le);
                    P && de.associatedIconIndex >= 0 && (B[de.associatedIconIndex] = { x: je, y: ze, z: rt, angle: Le });
                }
                else
                    nn(ve, O);
            } if (P) {
                D.clear();
                const oe = d.icon.placedSymbolArray;
                for (let de = 0; de < oe.length; de++) {
                    const me = oe.get(de), { numGlyphs: we } = me, ve = B[de];
                    if (me.hidden || !ve)
                        nn(we, D);
                    else {
                        const { x: xe, y: ge, z: Se, angle: Ce } = ve;
                        for (let je = 0; je < we; je++)
                            s.bL(D, xe, ge, Se, Ce);
                    }
                }
                d.icon.dynamicLayoutVertexBuffer.updateData(D);
            } d.text.dynamicLayoutVertexBuffer.updateData(O); }
            function Pp(d, n, l, f, _, v, w = {}) { const T = l.paint.get("icon-translate"), C = l.paint.get("text-translate"), P = l.paint.get("icon-translate-anchor"), R = l.paint.get("text-translate-anchor"), O = l.layout.get("icon-rotation-alignment"), D = l.layout.get("text-rotation-alignment"), B = l.layout.get("icon-pitch-alignment"), q = l.layout.get("text-pitch-alignment"), G = l.layout.get("icon-keep-upright"), K = l.layout.get("text-keep-upright"), W = l.paint.get("icon-color-saturation"), oe = l.paint.get("icon-color-contrast"), de = l.paint.get("icon-color-brightness-min"), me = l.paint.get("icon-color-brightness-max"), we = l.layout.get("symbol-elevation-reference") === "sea", ve = d.context, xe = ve.gl, ge = d.transform, Se = O === "map", Ce = D === "map", je = B === "map", ze = q === "map", rt = l.layout.get("symbol-sort-key").constantOr(1) !== void 0; let et = !1; const vt = d.depthModeForSublayer(0, Ut.ReadOnly), Fe = new Ut(d.context.gl.LEQUAL, Ut.ReadOnly, d.depthRangeFor3D), Ve = [s.ay(ge.center.lng), s.aH(ge.center.lat)], Le = l.layout.get("text-variable-anchor"), st = ge.projection.name === "globe", He = [], ht = [0, -1, 0]; for (const nt of f) {
                const dt = n.getTile(nt), ft = dt.getBucket(l);
                if (!ft || ft.projection.name === "mercator" && st || ft.fullyClipped)
                    continue;
                const Vt = ft.projection.name === "globe", Xt = Vt ? s.ah(ge.zoom) : 0, Bt = pd(nt, ft.getProjection(), ge), Yt = ge.calculatePixelsToTileUnitsMatrix(dt), $t = Le && ft.hasTextData(), or = ft.hasIconTextFit() && $t && ft.hasIconData(), mr = ft.elevationType === "road" ? Fe : vt, Nr = ft.getProjection().createInversionMatrix(ge, nt.canonical), vn = d.shadowRenderer, fn = ft.elevationType === "road" && !!vn && vn.enabled;
                let jr = [0, 0, 0];
                if (fn) {
                    const Kn = d.style.directionalLight, Cr = d.style.ambientLight;
                    Kn && Cr && (jr = Sa(d.style, Kn, Cr));
                }
                const hi = Kn => { ge.depthOcclusionForSymbolsAndCircles && (l.hasInitialOcclusionOpacityProperties || d.terrain) && (Kn.push("DEPTH_D24"), Kn.push("DEPTH_OCCLUSION")); }, Jn = () => { const Kn = Se && l.layout.get("symbol-placement") !== "point", Cr = []; hi(Cr); const qn = Kn || or, Xr = l.paint.get("icon-image-cross-fade"); d.terrainRenderModeElevated() && je && Cr.push("PITCH_WITH_MAP_TERRAIN"), Vt && (Cr.push("PROJECTION_GLOBE_VIEW"), qn && Cr.push("PROJECTED_POS_ON_VIEWPORT")), Xr > 0 && Cr.push("ICON_TRANSITION"), ft.icon.zOffsetVertexBuffer && Cr.push("Z_OFFSET"), W === 0 && oe === 0 && de === 0 && me === 1 || Cr.push("COLOR_ADJUSTMENT"), ft.sdfIcons && Cr.push("RENDER_SDF"), fn && Cr.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"); const Hn = ft.icon.programConfigurations.get(l.id), sn = d.getOrCreateProgram("symbol", { config: Hn, defines: Cr }), Yn = dt.imageAtlasTexture ? dt.imageAtlasTexture.size : [0, 0], Wi = ft.iconSizeData, Ln = s.bH(Wi, ge.zoom), es = je || ge.pitch !== 0, wi = xu(Bt, dt.tileID.canonical, je, Se, ge, ft.getProjection(), Yt), as = Fg(Bt, dt.tileID.canonical, je, Se, ge, ft.getProjection(), Yt), oa = d.translatePosMatrix(as, dt, T, P, !0), rl = d.translatePosMatrix(Bt, dt, T, P), ro = qn ? Pd : wi, No = Se && !je && !Kn; let Ia = ht; !st && !ge.mercatorFromTransition || Se || (Ia = Md(ge)); const Pa = Vt ? Ia : ht, aa = l.getColorAdjustmentMatrix(W, oe, de, me), Zu = Sp(Wi.kind, Ln, No, je, d, rl, ro, oa, we, !1, Yn, [0, 0], !0, nt, Xt, Ve, Nr, Pa, ft.getProjection(), jr, aa, Xr), $c = dt.imageAtlasTexture ? dt.imageAtlasTexture : null, Hp = l.layout.get("icon-size").constantOr(0) !== 1 || ft.iconsNeedLinear, Wp = ft.sdfIcons || d.options.rotating || d.options.zooming || Hp || es ? xe.LINEAR : xe.NEAREST, Zp = ft.sdfIcons && l.paint.get("icon-halo-width").constantOr(1) !== 0, Hd = d.terrain && je && Kn ? s.bi(s.bz(), wi) : Pd; if (Kn && ft.icon) {
                    const Wn = ge.elevation, Xu = Wn ? Wn.getAtTileOffsetFunc(nt, ge.center.lat, ge.worldSize, ft.getProjection()) : null, B_ = Yf(Bt, dt.tileID.canonical, je, Se, ge, ft.getProjection(), Yt);
                    Bg(ft, Bt, d, !1, B_, as, je, G, Xu, nt);
                } return { program: sn, buffers: ft.icon, uniformValues: Zu, atlasTexture: $c, atlasTextureIcon: null, atlasInterpolation: Wp, atlasInterpolationIcon: null, isSDF: ft.sdfIcons, hasHalo: Zp, depthMode: mr, tile: dt, renderWithShadows: fn, labelPlaneMatrixInv: Hd }; }, xr = () => { const Kn = Ce && l.layout.get("symbol-placement") !== "point", Cr = [], qn = Kn || Le || or; d.terrainRenderModeElevated() && ze && Cr.push("PITCH_WITH_MAP_TERRAIN"), Vt && (Cr.push("PROJECTION_GLOBE_VIEW"), qn && Cr.push("PROJECTED_POS_ON_VIEWPORT")), ft.text.zOffsetVertexBuffer && Cr.push("Z_OFFSET"), ft.iconsInText && Cr.push("RENDER_TEXT_AND_SYMBOL"), Cr.push("RENDER_SDF"), fn && Cr.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), hi(Cr); const Xr = ft.text.programConfigurations.get(l.id), Hn = d.getOrCreateProgram("symbol", { config: Xr, defines: Cr }); let sn, Yn = [0, 0], Wi = null; const Ln = ft.textSizeData; ft.iconsInText && (Yn = dt.imageAtlasTexture ? dt.imageAtlasTexture.size : [0, 0], Wi = dt.imageAtlasTexture ? dt.imageAtlasTexture : null, sn = ze || ge.pitch !== 0 || d.options.rotating || d.options.zooming || Ln.kind === "composite" || Ln.kind === "camera" ? xe.LINEAR : xe.NEAREST); const es = dt.glyphAtlasTexture ? dt.glyphAtlasTexture.size : [0, 0], wi = l.layout.get("text-size-scale-range"), as = s.aD(d.scaleFactor, wi[0], wi[1]), oa = s.bH(Ln, ge.zoom, as), rl = xu(Bt, dt.tileID.canonical, ze, Ce, ge, ft.getProjection(), Yt), ro = Fg(Bt, dt.tileID.canonical, ze, Ce, ge, ft.getProjection(), Yt), No = d.translatePosMatrix(ro, dt, C, R, !0), Ia = d.translatePosMatrix(Bt, dt, C, R), Pa = qn ? Pd : rl, aa = Ce && !ze && !Kn; let Zu = ht; !st && !ge.mercatorFromTransition || Ce || (Zu = Md(ge)); const $c = Sp(Ln.kind, oa, aa, ze, d, Ia, Pa, No, we, !0, es, Yn, !0, nt, Xt, Ve, Nr, Vt ? Zu : ht, ft.getProjection(), jr, null, null, as), Hp = dt.glyphAtlasTexture ? dt.glyphAtlasTexture : null, Wp = xe.LINEAR, Zp = l.paint.get("text-halo-width").constantOr(1) !== 0, Hd = d.terrain && ze && Kn ? s.bi(s.bz(), rl) : Pd; if (Kn && ft.text) {
                    const Wn = ge.elevation, Xu = Wn ? Wn.getAtTileOffsetFunc(nt, ge.center.lat, ge.worldSize, ft.getProjection()) : null, B_ = Yf(Bt, dt.tileID.canonical, ze, Ce, ge, ft.getProjection(), Yt);
                    Bg(ft, Bt, d, !0, B_, ro, ze, K, Xu, nt);
                } return { program: Hn, buffers: ft.text, uniformValues: $c, atlasTexture: Hp, atlasTextureIcon: Wi, atlasInterpolation: Wp, atlasInterpolationIcon: sn, isSDF: !0, hasHalo: Zp, depthMode: mr, tile: dt, renderWithShadows: fn, labelPlaneMatrixInv: Hd }; }, Hr = ft.icon.segments.get().length, Qr = ft.text.segments.get().length, xn = Hr && !w.onlyText ? Jn() : null, Ii = Qr && !w.onlyIcons ? xr() : null, _i = l.paint.get("icon-opacity").constantOr(1), Ci = l.paint.get("text-opacity").constantOr(1);
                if (rt && ft.canOverlap) {
                    et = !0;
                    const Kn = _i && !w.onlyText ? ft.icon.segments.get() : [], Cr = Ci && !w.onlyIcons ? ft.text.segments.get() : [];
                    for (const qn of Kn)
                        He.push({ segments: new s.bd([qn]), sortKey: qn.sortKey, state: xn });
                    for (const qn of Cr)
                        He.push({ segments: new s.bd([qn]), sortKey: qn.sortKey, state: Ii });
                }
                else
                    w.onlyText || He.push({ segments: _i ? ft.icon.segments : new s.bd([]), sortKey: 0, state: xn }), w.onlyIcons || He.push({ segments: Ci ? ft.text.segments : new s.bd([]), sortKey: 0, state: Ii });
            } et && He.sort((nt, dt) => nt.sortKey - dt.sortKey); for (const nt of He) {
                const dt = nt.state;
                if (dt)
                    if (d.terrain ? d.terrain.setupElevationDraw(dt.tile, dt.program, { useDepthForOcclusion: ge.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: dt.labelPlaneMatrixInv }) : d.setupDepthForOcclusion(ge.depthOcclusionForSymbolsAndCircles, dt.program), ve.activeTexture.set(xe.TEXTURE0), dt.atlasTexture && dt.atlasTexture.bind(dt.atlasInterpolation, xe.CLAMP_TO_EDGE, !0), dt.atlasTextureIcon && (ve.activeTexture.set(xe.TEXTURE1), dt.atlasTextureIcon && dt.atlasTextureIcon.bind(dt.atlasInterpolationIcon, xe.CLAMP_TO_EDGE, !0)), dt.renderWithShadows && d.shadowRenderer.setupShadows(dt.tile.tileID.toUnwrapped(), dt.program, "vector-tile", dt.tile.tileID.overscaledZ), d.uploadCommonLightUniforms(d.context, dt.program), dt.hasHalo) {
                        const ft = dt.uniformValues;
                        ft.u_is_halo = 1, g_(dt.buffers, nt.segments, l, d, dt.program, dt.depthMode, _, v, ft, 2), ft.u_is_halo = 0;
                    }
                    else {
                        if (dt.isSDF) {
                            const ft = dt.uniformValues;
                            dt.hasHalo && (ft.u_is_halo = 1, g_(dt.buffers, nt.segments, l, d, dt.program, dt.depthMode, _, v, ft, 1)), ft.u_is_halo = 0;
                        }
                        g_(dt.buffers, nt.segments, l, d, dt.program, dt.depthMode, _, v, dt.uniformValues, 1);
                    }
            } }
            function g_(d, n, l, f, _, v, w, T, C, P) { const R = [d.dynamicLayoutVertexBuffer, d.opacityVertexBuffer, d.iconTransitioningVertexBuffer, d.globeExtVertexBuffer, d.zOffsetVertexBuffer]; _.draw(f, f.context.gl.TRIANGLES, v, w, T, fr.disabled, C, l.id, d.layoutVertexBuffer, d.indexBuffer, n, l.paint, f.transform.zoom, d.programConfigurations.get(l.id), R, P); }
            function Fu(d, n) { const l = 1 << d.canonical.z, f = (n.x * l - d.canonical.x - d.wrap * l) * s.aj, _ = (n.y * l - d.canonical.y) * s.aj, v = s.dS(n.z, n.y); return s.cS(f, _, v); }
            function Rd(d, n, l, f, _) { if (!l.layout || l.layout.get("fill-elevation-reference") === "none")
                return; const v = d.context.gl, w = new Ut(d.context.gl.LEQUAL, Ut.ReadWrite, d.depthRangeFor3D), T = new Ut(d.context.gl.GREATER, Ut.ReadWrite, d.depthRangeFor3D), C = function (B) { const q = s.cJ(B.pitch); let G = .01; return B.isOrthographic && (G = s.ai(1e-4, G, s.cO(q >= Rl ? 1 : q / Rl))), 2 * G; }(d.transform), P = d.transform.getFreeCameraOptions().position, R = "elevatedStructuresDepthReconstruct", O = d.getOrCreateProgram(R, { defines: ["DEPTH_RECONSTRUCTION"] }), D = d.getOrCreateProgram(R); for (const B of f) {
                const q = n.getTile(B), G = q.getBucket(l);
                if (!G)
                    continue;
                const K = G.elevatedStructures;
                if (!K)
                    continue;
                const W = G.elevationBufferData.heightRange, oe = Fu(B.toUnwrapped(), P), de = d.translatePosMatrix(B.projMatrix, q, l.paint.get("fill-translate"), l.paint.get("fill-translate-anchor"));
                let me, we, ve, xe;
                if (_ === "initialize") {
                    if (!W || W.min >= 1 || K.depthSegments.segments[0].primitiveLength === 0)
                        continue;
                    me = Id(de, oe, C, 1, 0), we = w, ve = K.depthSegments, xe = O;
                }
                else if (_ === "reset") {
                    if (!W || W.min >= 0 || K.maskSegments.segments[0].primitiveLength === 0)
                        continue;
                    me = Id(de, oe, 0, 0, 1), we = T, ve = K.maskSegments, xe = O;
                }
                else if (_ === "geometry") {
                    if (K.depthSegments.segments[0].primitiveLength === 0)
                        continue;
                    me = Id(de, oe, C, 1, 0), we = w, ve = K.depthSegments, xe = D;
                }
                xe.draw(d, v.TRIANGLES, we, dr.disabled, Rr.disabled, fr.disabled, me, l.id, K.vertexBuffer, K.indexBuffer, ve, l.paint, d.transform.zoom);
            } }
            function Nt(d, n, l) { const { painter: f, sourceCache: _, layer: v, coords: w, colorMode: T, elevationType: C, terrainEnabled: P, pass: R } = d, O = f.context.gl, D = v.paint.get("fill-pattern"), B = v.paint.get("fill-pattern-cross-fade"), q = D.constantOr(null); let G = C; C !== "road" || n && !P || (G = "none"); const K = G === "road", W = d.painter.shadowRenderer, oe = K && !!W && W.enabled, de = new Ut(f.context.gl.LEQUAL, Ut.ReadOnly, f.depthRangeFor3D); let me = [0, 0, 0]; if (oe) {
                const xe = f.style.directionalLight, ge = f.style.ambientLight;
                xe && ge && (me = Sa(f.style, xe, ge));
            } const we = D && D.constantOr(1), ve = (xe, ge) => { let Se, Ce, je, ze, rt; ge ? (Se = we && !v.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", je = O.LINES) : (Se = we ? "fillPattern" : "fill", je = O.TRIANGLES); for (const et of w) {
                const vt = _.getTile(et);
                if (we && !vt.patternsLoaded())
                    continue;
                const Fe = vt.getBucket(v);
                if (!Fe)
                    continue;
                const Ve = n ? Fe.elevationBufferData : Fe.bufferData;
                if (Ve.isEmpty())
                    continue;
                f.prepareDrawTile();
                const Le = Ve.programConfigurations.get(v.id), st = f.isTileAffectedByFog(et), He = [], ht = [];
                K && (He.push("ELEVATED_ROADS"), ht.push(Ve.elevatedLayoutVertexBuffer)), oe && He.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), we && (f.context.activeTexture.set(O.TEXTURE0), vt.imageAtlasTexture && vt.imageAtlasTexture.bind(O.LINEAR, O.CLAMP_TO_EDGE), Le.updatePaintBuffers());
                let nt = !1;
                if (q && vt.imageAtlas) {
                    const Bt = vt.imageAtlas, Yt = s.dN.from(q), $t = Yt.getPrimary().scaleSelf(s.q.devicePixelRatio).toString(), or = Yt.getSecondary(), mr = Bt.patternPositions.get($t), Nr = or ? Bt.patternPositions.get(or.scaleSelf(s.q.devicePixelRatio).toString()) : null;
                    nt = !!mr && !!Nr, mr && Le.setConstantPatternPositions(mr, Nr);
                }
                B > 0 && (nt || Le.getPatternTransitionVertexBuffer("fill-pattern")) && He.push("FILL_PATTERN_TRANSITION");
                const dt = f.getOrCreateProgram(Se, { config: Le, overrideFog: st, defines: He }), ft = f.translatePosMatrix(et.projMatrix, vt, v.paint.get("fill-translate"), v.paint.get("fill-translate-anchor"));
                oe && W.setupShadows(vt.tileID.toUnwrapped(), dt, "vector-tile", vt.tileID.overscaledZ);
                const Vt = v.paint.get("fill-emissive-strength");
                if (ge) {
                    ze = Ve.lineIndexBuffer, rt = Ve.lineSegments;
                    const Bt = f.terrain && f.terrain.renderingToTexture ? f.terrain.drapeBufferSize : [O.drawingBufferWidth, O.drawingBufferHeight];
                    Ce = Se === "fillOutlinePattern" && we ? cT(ft, Vt, f, vt, Bt, me, B) : lT(ft, Vt, Bt, me);
                }
                else
                    ze = Ve.indexBuffer, rt = Ve.triangleSegments, Ce = we ? F0(ft, Vt, f, vt, me, B) : z0(ft, Vt, me);
                f.uploadCommonUniforms(f.context, dt, et.toUnwrapped());
                let Xt = xe;
                (C === "road" && !P || C === "offset") && (Xt = de), dt.draw(f, je, Xt, l || f.stencilModeForClipping(et), T, fr.disabled, Ce, v.id, Ve.layoutVertexBuffer, ze, rt, v.paint, f.transform.zoom, Le, ht);
            } }; f.renderPass === R && ve(f.depthModeForSublayer(1, f.renderPass === "opaque" ? Ut.ReadWrite : Ut.ReadOnly), !1), G === "none" && f.renderPass === "translucent" && v.paint.get("fill-antialias") && ve(f.depthModeForSublayer(v.getPaintProperty("fill-outline-color") ? 2 : 0, Ut.ReadOnly), !0); }
            function kd(d, n, l, f, _, v, w, T) { l.resetLayerRenderingStats(d); const C = d.context, P = C.gl, R = d.transform, O = l.paint.get("fill-extrusion-pattern"), D = l.paint.get("fill-extrusion-pattern-cross-fade"), B = O.constantOr(null), q = O.constantOr(1), G = l.paint.get("fill-extrusion-opacity"), K = d.style.enable3dLights(), W = l.paint.get(K && !q ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), oe = [l.paint.get("fill-extrusion-ambient-occlusion-intensity"), W], de = l.layout.get("fill-extrusion-edge-radius"), me = de > 0 && !l.paint.get("fill-extrusion-rounded-roof"), we = me ? 0 : de, ve = R.projection.name === "globe" ? s.dT() : 0, xe = R.projection.name === "globe", ge = xe ? s.ah(R.zoom) : 0, Se = [s.ay(R.center.lng), s.aH(R.center.lat)], Ce = l.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default") === "none", je = l.paint.get("fill-extrusion-flood-light-color").toRenderColor(Ce ? null : l.lut).toArray01().slice(0, 3), ze = l.paint.get("fill-extrusion-flood-light-intensity"), rt = l.paint.get("fill-extrusion-vertical-scale"), et = l.paint.get("fill-extrusion-line-width").constantOr(1) !== 0, vt = l.paint.get("fill-extrusion-height-alignment"), Fe = l.paint.get("fill-extrusion-base-alignment"), Ve = Cc(d, l.paint.get("fill-extrusion-cutoff-fade-range")), Le = []; let st; xe && Le.push("PROJECTION_GLOBE_VIEW"), oe[0] > 0 && Le.push("FAUX_AO"), me && Le.push("ZERO_ROOF_RADIUS"), T && Le.push("HAS_CENTROID"), ze > 0 && Le.push("FLOOD_LIGHT"), Ve.shouldRenderCutoff && Le.push("RENDER_CUTOFF"), et && Le.push("RENDER_WALL_MODE"); const He = d.renderPass === "shadow", ht = d.shadowRenderer, nt = He && !!ht, dt = He ? fr.disabled : fr.backCCW; d.shadowRenderer && (d.shadowRenderer.useNormalOffset = !0); let ft = [0, 0, 0]; if (ht) {
                const Bt = d.style.directionalLight, Yt = d.style.ambientLight;
                Bt && Yt && (ft = Sa(d.style, Bt, Yt)), He || (Le.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), ht.useNormalOffset && Le.push("NORMAL_OFFSET")), st = Le.concat(["SHADOWS_SINGLE_CASCADE"]);
            } const Vt = nt ? "fillExtrusionDepth" : q ? "fillExtrusionPattern" : "fillExtrusion", Xt = l.getLayerRenderingStats(); for (const Bt of f) {
                const Yt = n.getTile(Bt), $t = Yt.getBucket(l);
                if (!$t || $t.projection.name !== R.projection.name)
                    continue;
                let or = !1;
                ht && (or = ht.getMaxCascadeForTile(Bt.toUnwrapped()) === 0);
                const mr = d.isTileAffectedByFog(Bt), Nr = $t.programConfigurations.get(l.id);
                let vn = !1;
                if (B && Yt.imageAtlas) {
                    const Qr = Yt.imageAtlas, xn = s.dN.from(B), Ii = xn.getPrimary().scaleSelf(s.q.devicePixelRatio).toString(), _i = xn.getSecondary(), Ci = Qr.patternPositions.get(Ii), Kn = _i ? Qr.patternPositions.get(_i.scaleSelf(s.q.devicePixelRatio).toString()) : null;
                    vn = !!Ci && !!Kn, Ci && Nr.setConstantPatternPositions(Ci, Kn);
                }
                D > 0 && (vn || Nr.getPatternTransitionVertexBuffer("fill-extrusion-pattern")) && Le.push("FILL_EXTRUSION_PATTERN_TRANSITION");
                const fn = d.getOrCreateProgram(Vt, { config: Nr, defines: or ? st : Le, overrideFog: mr });
                if (d.terrain && d.terrain.setupElevationDraw(Yt, fn, { useMeterToDem: !0 }), !$t.centroidVertexBuffer) {
                    const Qr = fn.attributes.a_centroid_pos;
                    Qr !== void 0 && P.vertexAttrib2f(Qr, 0, 0);
                }
                !He && ht && ht.setupShadows(Yt.tileID.toUnwrapped(), fn, "vector-tile", Yt.tileID.overscaledZ), q && (d.context.activeTexture.set(P.TEXTURE0), Yt.imageAtlasTexture && Yt.imageAtlasTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE), Nr.updatePaintBuffers());
                const jr = l.paint.get("fill-extrusion-vertical-gradient"), hi = 1 / $t.tileToMeter;
                let Jn;
                if (He && ht) {
                    if (dT(Yt.tileID, $t, d))
                        continue;
                    const Qr = ht.calculateShadowPassMatrixFromTile(Yt.tileID.toUnwrapped());
                    Jn = oT(Qr, we, hi, rt, vt, Fe);
                }
                else {
                    const Qr = d.translatePosMatrix(Bt.expandedProjMatrix, Yt, l.paint.get("fill-extrusion-translate"), l.paint.get("fill-extrusion-translate-anchor")), xn = R.projection.createInversionMatrix(R, Bt.canonical);
                    Jn = q ? aT(Qr, d, jr, G, oe, we, hi, Bt, Yt, ve, vt, Fe, ge, Se, xn, je, rt, D) : Mc(Qr, d, jr, G, oe, we, hi, Bt, ve, vt, Fe, ge, Se, xn, je, rt, ze, ft);
                }
                d.uploadCommonUniforms(C, fn, Bt.toUnwrapped(), null, Ve);
                let xr = $t.segments;
                if (R.projection.name === "mercator" && !He && (xr = $t.getVisibleSegments(Yt.tileID, d.terrain, d.transform.getFrustum(0)), !xr.get().length))
                    continue;
                if (Xt)
                    if (He)
                        for (const Qr of xr.get())
                            Xt.numRenderedVerticesInShadowPass += Qr.primitiveLength;
                    else
                        for (const Qr of xr.get())
                            Xt.numRenderedVerticesInTransparentPass += Qr.primitiveLength;
                const Hr = [];
                (d.terrain || T) && Hr.push($t.centroidVertexBuffer), xe && Hr.push($t.layoutVertexExtBuffer), et && Hr.push($t.wallVertexBuffer), fn.draw(d, C.gl.TRIANGLES, _, v, w, dt, Jn, l.id, $t.layoutVertexBuffer, $t.indexBuffer, xr, l.paint, d.transform.zoom, Nr, Hr);
            } d.shadowRenderer && (d.shadowRenderer.useNormalOffset = !1); }
            function Lc(d, n, l, f, _, v, w, T, C, P, R, O, D, B, q, G, K, W, oe) { const de = d.context, me = de.gl, we = d.transform, ve = d.transform.zoom, xe = [], ge = Cc(d, l.paint.get("fill-extrusion-cutoff-fade-range")); P === "clear" ? (xe.push("CLEAR_SUBPASS"), oe && (xe.push("CLEAR_FROM_TEXTURE"), de.activeTexture.set(me.TEXTURE0), oe.bind(me.LINEAR, me.CLAMP_TO_EDGE))) : P === "sdf" && xe.push("SDF_SUBPASS"), K && xe.push("HAS_CENTROID"), ge.shouldRenderCutoff && xe.push("RENDER_CUTOFF"); const Se = l.layout.get("fill-extrusion-edge-radius"), Ce = (je, ze, rt, et, vt) => { const Fe = ze.programConfigurations.get(l.id), Ve = d.isTileAffectedByFog(je), Le = d.getOrCreateProgram("fillExtrusionGroundEffect", { config: Fe, defines: xe, overrideFog: Ve }), st = ((ht, nt, dt, ft, Vt, Xt, Bt, Yt, $t, or, mr) => ({ u_matrix: nt, u_opacity: dt, u_ao_pass: ft ? 1 : 0, u_meter_to_tile: Vt, u_ao: Xt, u_flood_light_intensity: Bt, u_flood_light_color: Yt, u_attenuation: $t, u_edge_radius: or, u_fb: 0, u_fb_size: mr, u_dynamic_offset: 1 }))(0, et, R, C, vt, [O, D * vt], B, q, G, ve >= 17 ? 0 : Se * vt, oe ? oe.size[0] : 0), He = []; K && He.push(ze.hiddenByLandmarkVertexBuffer), d.uploadCommonUniforms(de, Le, je.toUnwrapped(), null, ge), Le.draw(d, de.gl.TRIANGLES, _, v, w, T, st, l.id, ze.vertexBuffer, ze.indexBuffer, rt, l.paint, ve, Fe, He); }; for (const je of f) {
                const ze = n.getTile(je), rt = ze.getBucket(l);
                if (!rt || rt.projection.name !== we.projection.name || !rt.groundEffect || rt.groundEffect && !rt.groundEffect.hasData())
                    continue;
                const et = rt.groundEffect, vt = 1 / rt.tileToMeter;
                {
                    const Fe = d.translatePosMatrix(je.projMatrix, ze, l.paint.get("fill-extrusion-translate"), l.paint.get("fill-extrusion-translate-anchor")), Ve = et.getDefaultSegment();
                    Ce(je, et, Ve, Fe, vt);
                }
                if (W)
                    for (let Fe = 0; Fe < 4; Fe++) {
                        const Ve = s.dU[Fe](je), Le = n.getTile(Ve);
                        if (!Le)
                            continue;
                        const st = Le.getBucket(l);
                        if (!st || st.projection.name !== we.projection.name || !st.groundEffect || st.groundEffect && !st.groundEffect.hasData())
                            continue;
                        const He = st.groundEffect;
                        let ht, nt;
                        Fe === 0 ? (ht = [-s.aj, 0, 0], nt = 1) : Fe === 1 ? (ht = [s.aj, 0, 0], nt = 0) : Fe === 2 ? (ht = [0, -s.aj, 0], nt = 3) : (ht = [0, s.aj, 0], nt = 2);
                        const dt = He.regionSegments[nt];
                        if (!dt)
                            continue;
                        const ft = new Float32Array(16);
                        s.bo(ft, je.projMatrix, ht), Ce(je, He, dt, d.translatePosMatrix(ft, ze, l.paint.get("fill-extrusion-translate"), l.paint.get("fill-extrusion-translate-anchor")), vt);
                    }
            } }
            function zl(d, n, l, f, _, v, w) { f.centroidVertexArray.length === 0 && f.createCentroidsBuffer(); const T = v ? v.findDEMTileFor(l) : null; if (!(T && T.dem || w))
                return; v && T && T.dem && f.selfDEMTileTimestamp !== T.dem._timestamp && (f.borderDoneWithNeighborZ = [-1, -1, -1, -1], f.selfDEMTileTimestamp = T.dem._timestamp); const C = W => new s.P(Math.ceil((W + s.dX) * s.dY), 0), P = W => { const oe = n.getSource().minzoom, de = we => { const ve = n.getTileByID(we); if (ve && ve.hasData())
                return ve.getBucket(_); }, me = [0, -1, 1]; for (const we of me) {
                if (W.overscaledZ + we < oe)
                    continue;
                const ve = de(W.calculateScaledKey(W.overscaledZ + we));
                if (ve)
                    return ve;
            } }, R = [0, 0, 0], O = (W, oe) => (R[0] = Math.min(W.min.y, oe.min.y), R[1] = Math.max(W.max.y, oe.max.y), R[2] = s.aj - oe.min.x > W.max.x ? oe.min.x - s.aj : W.max.x, R), D = (W, oe) => (R[0] = Math.min(W.min.x, oe.min.x), R[1] = Math.max(W.max.x, oe.max.x), R[2] = s.aj - oe.min.y > W.max.y ? oe.min.y - s.aj : W.max.y, R), B = [(W, oe) => O(W, oe), (W, oe) => O(oe, W), (W, oe) => D(W, oe), (W, oe) => D(oe, W)], q = (W, oe, de, me, we, ve, xe) => { if (!v)
                return 0; const ge = [[ve ? de : W, ve ? W : de, 0], [ve ? de : oe, ve ? oe : de, 0]], Se = xe < 0 ? s.aj + xe : xe, Ce = [ve ? Se : (W + oe) / 2, ve ? (W + oe) / 2 : Se, 0]; return de === 0 && xe < 0 || de !== 0 && xe > 0 ? v.getForTilePoints(we, [Ce], !0, me) : ge.push(Ce), v.getForTilePoints(l, ge, !0, T), Math.max(ge[0][2], ge[1][2], Ce[2]) / v.exaggeration(); }; for (let W = 0; W < 4; W++) {
                const oe = f.borderFeatureIndices[W];
                if (oe.length === 0)
                    continue;
                const de = s.dU[W](l), me = P(de);
                if (!(me && me instanceof s.dV))
                    continue;
                const we = v ? v.findDEMTileFor(de) : null;
                if (!(we && we.dem || w) || (v && we && we.dem && f.borderDEMTileTimestamp[W] !== we.dem._timestamp && (f.borderDoneWithNeighborZ[W] = -1, f.borderDEMTileTimestamp[W] = we.dem._timestamp), f.borderDoneWithNeighborZ[W] === me.canonical.z))
                    continue;
                me.centroidVertexArray.length === 0 && me.createCentroidsBuffer();
                const ve = (W < 2 ? 1 : 5) - W, xe = me.borderDoneWithNeighborZ[ve] !== f.canonical.z, ge = me.borderFeatureIndices[ve];
                let Se = 0;
                if (f.canonical.z !== me.canonical.z) {
                    for (const Ce of oe)
                        f.showCentroid(f.featuresOnBorder[Ce]);
                    if (xe)
                        for (const Ce of ge)
                            me.showCentroid(me.featuresOnBorder[Ce]);
                    f.borderDoneWithNeighborZ[W] = me.canonical.z, me.borderDoneWithNeighborZ[ve] = f.canonical.z;
                }
                for (const Ce of oe) {
                    const je = f.featuresOnBorder[Ce], ze = f.centroidData[je.centroidDataIndex], rt = je.borders[W];
                    let et;
                    for (; Se < ge.length;) {
                        et = me.featuresOnBorder[ge[Se]];
                        const vt = et.borders[ve];
                        if (vt[1] > rt[0] + 3 || vt[0] > rt[0] - 3)
                            break;
                        me.showCentroid(et), Se++;
                    }
                    if (et && Se < ge.length) {
                        const vt = Se;
                        let Fe = 0;
                        for (; !(et.borders[ve][0] > rt[1] - 3) && (Fe++, ++Se !== ge.length);)
                            et = me.featuresOnBorder[ge[Se]];
                        et = me.featuresOnBorder[ge[vt]];
                        let Ve = !1;
                        if (Fe >= 1) {
                            const He = et.borders[ve];
                            Math.abs(rt[0] - He[0]) < 3 && Math.abs(rt[1] - He[1]) < 3 && (Fe = 1, Ve = !0, Se = vt + 1);
                        }
                        else if (Fe === 0) {
                            f.showCentroid(je);
                            continue;
                        }
                        const Le = me.centroidData[et.centroidDataIndex];
                        w && Ve && (((G = ze).flags | (K = Le).flags) & s.dW ? (G.flags |= s.dW, K.flags |= s.dW) : (G.flags &= ~s.dW, K.flags &= ~s.dW));
                        const st = je.intersectsCount() > 1 || et.intersectsCount() > 1;
                        if (Fe > 1)
                            Se = vt, ze.centroidXY = Le.centroidXY = new s.P(0, 0);
                        else if (we && we.dem && !st) {
                            const He = B[W](ze, Le), ht = W % 2 ? s.aj - 1 : 0, nt = q(He[0], Math.min(s.aj - 1, He[1]), ht, we, de, W < 2, He[2]);
                            ze.centroidXY = Le.centroidXY = C(nt);
                        }
                        else
                            st ? ze.centroidXY = Le.centroidXY = new s.P(0, 0) : (ze.centroidXY = f.encodeBorderCentroid(je), Le.centroidXY = me.encodeBorderCentroid(et));
                        f.writeCentroidToBuffer(ze), me.writeCentroidToBuffer(Le);
                    }
                    else
                        f.showCentroid(je);
                }
                f.borderDoneWithNeighborZ[W] = me.canonical.z, me.borderDoneWithNeighborZ[ve] = f.canonical.z;
            } var G, K; (f.needsCentroidUpdate || !f.centroidVertexBuffer && f.centroidVertexArray.length !== 0) && f.uploadCentroid(d); }
            const Fl = [1, 0, 0], sr = [0, 1, 0], __ = [0, 0, 1];
            function dT(d, n, l) { const f = l.transform, _ = l.shadowRenderer; if (!_)
                return !0; const v = d.toUnwrapped(), w = f.tileSize * _._cascades[l.currentShadowCascade].scale; let T = n.maxHeight; if (f.elevation) {
                const G = f.elevation.getMinMaxForTile(d);
                G && (T += G.max);
            } const C = [..._.shadowDirection]; C[2] = -C[2]; const P = _.computeSimplifiedTileShadowVolume(v, T, w, C); if (!P)
                return !1; const R = [Fl, sr, __, C, [C[0], 0, C[2]], [0, C[1], C[2]]], O = f.projection.name === "globe", D = f.scaleZoom(w), B = s.cn.fromInvProjectionMatrix(f.invProjMatrix, f.worldSize, D, !O), q = _.getCurrentCascadeFrustum(); return B.intersectsPrecise(P.vertices, P.planes, R) === 0 || q.intersectsPrecise(P.vertices, P.planes, R) === 0; }
            function q0(d) { return [d[0] * s.dZ, d[1] * s.dZ, d[2] * s.dZ, 0]; }
            function Dd(d, n, l, f, _, v, w, T, C) { const P = f.getSource(), R = l.globeSharedBuffers; if (!R)
                return; let O, D, B; if (n && (O = f.getTile(n)), P instanceof s.aP ? (D = P.texture, B = s.ds(0, 0, l.transform)) : O && n && (D = O.texture, B = s.ds(n.canonical.z, n.canonical.x, l.transform)), !D || !B)
                return; d || (B = s.cE(s.bz(), B, [1, -1, 1])); const q = l.context, G = q.gl, K = _.paint.get("raster-resampling") === "nearest" ? G.NEAREST : G.LINEAR, W = l.colorModeForDrapableLayerRenderPass(v), oe = w.defines; oe.push("GLOBE_POLES"); const de = new Ut(G.LEQUAL, Ut.ReadWrite, l.depthRangeFor3D), me = Float32Array.from(l.transform.expandedFarZProjMatrix), we = Float32Array.from(s.bh(s.dr(new s.cp(0, 0, 0)))); l.terrain && l.terrain.prepareDrawTile(), q.activeTexture.set(G.TEXTURE0), D.bind(K, G.CLAMP_TO_EDGE), q.activeTexture.set(G.TEXTURE1), D.bind(K, G.CLAMP_TO_EDGE), "useMipmap" in D && q.extTextureFilterAnisotropic && l.transform.pitch > 20 && G.texParameterf(G.TEXTURE_2D, q.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, q.extTextureFilterAnisotropicMax); const [ve, xe, ge, Se] = n ? R.getPoleBuffers(n.canonical.z, !1) : R.getPoleBuffers(0, !0), Ce = _.paint.get("raster-elevation"); let je; d ? (je = ve, l.renderDefaultNorthPole = Ce !== 0) : (je = xe, l.renderDefaultSouthPole = Ce !== 0); const ze = q0(w.mix), rt = ((vt, Fe, Ve, Le, st, He, ht, nt, dt, ft, Vt, Xt, Bt) => Ol(vt, Fe, Ve, new Float32Array(16), new Float32Array(9), [0, 0], Le, [0, 0], [0, 0, 0, 0], 1, { opacity: 1, mix: 0 }, He, [0, 0], nt, 2, ft, Vt, Xt, 1, 0, Bt))(me, we, B, s.ah(l.transform.zoom), 0, _, 0, Ce, 0, ze, w.offset, w.range, v), et = l.getOrCreateProgram("raster", { defines: oe }); l.uploadCommonUniforms(q, et, null), et.draw(l, G.TRIANGLES, de, C, W, T, rt, _.id, je, ge, Se); }
            function H0(d) { const n = d._nearZ, l = d.projection.farthestPixelDistance(d), f = l - n, _ = .2 * d.height, v = n + _; return [n, l, (v - _ - n) / f, (v - n) / f]; }
            function fT(d, n, l, f) { if (d)
                return n instanceof _c && d instanceof ud ? n.getTextureDescriptor(d, l, !0) : { texture: d.texture, mix: q0(f.mix), offset: f.offset, buffer: 0, tileSize: 1 }; }
            var W0 = s.d_([{ name: "a_index", type: "Int16", components: 1 }]);
            class pT {
                constructor(n, l, f, _) { const v = { width: f[0], height: f[1], data: null }, w = n.gl; this.targetColorTexture = new s.T(n, v, w.RGBA8, { useMipmap: !1 }), this.backgroundColorTexture = new s.T(n, v, w.RGBA8, { useMipmap: !1 }), this.context = n, this.updateParticleTexture(l, _), this.lastInvalidatedAt = 0; }
                updateParticleTexture(n, l) { if (this.particleTextureDimension === l.width)
                    return; (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy()); const f = this.context.gl, _ = l.width * l.height; this.particleTexture0 = new s.T(this.context, l, f.RGBA8, { premultiply: !1, useMipmap: !1 }), this.particleTexture1 = new s.T(this.context, l, f.RGBA8, { premultiply: !1, useMipmap: !1 }); const v = new s.d$; v.reserve(_); for (let w = 0; w < _; w++)
                    v.emplaceBack(w); this.particleIndexBuffer = this.context.createVertexBuffer(v, W0.members, !0), this.particleSegment = s.bd.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = l.width; }
                update(n) { return !(this.lastInvalidatedAt < n && (this.lastInvalidatedAt = s.q.now(), 1)); }
                destroy() { this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy(); }
            }
            function mT(d, n, l) { if (!d)
                return null; const f = n.getTextureDescriptor(d, l, !0); if (!f)
                return null; let { texture: _, mix: v, offset: w, tileSize: T, buffer: C, format: P } = f; if (!_ || !P)
                return null; let R = !1; return P === "uint32" && (R = !0, v[3] = 0, v = h_(s.e0, v, [0, l.paint.get("raster-particle-max-speed")]), w = bp(s.e0, w, [0, l.paint.get("raster-particle-max-speed")])), { texture: _, textureOffset: [C / (T + 2 * C), T / (T + 2 * C)], tileSize: T, scalarData: R, scale: v, offset: w, defines: ["RASTER_ARRAY", { uint8: "DATA_FORMAT_UINT8", uint16: "DATA_FORMAT_UINT16", uint32: "DATA_FORMAT_UINT32" }[P]] }; }
            function y_(d) { const n = d._nearZ, l = d.projection.farthestPixelDistance(d), f = l - n, _ = .2 * d.height, v = n + _; return [n, l, (v - _ - n) / f, (v - n) / f]; }
            const v_ = new s.am(1, 0, 0, 1), x_ = new s.am(0, 1, 0, 1), w_ = new s.am(0, 0, 1, 1), to = new s.am(1, 0, 1, 1), Nl = new s.am(0, 1, 1, 1);
            function Oc(d, n, l, f, _, v, w) { const T = d.context, C = d.transform, P = T.gl, R = C.projection.name === "globe", O = R ? ["PROJECTION_GLOBE_VIEW"] : []; let D = s.bw(l.projMatrix); if (R && s.ah(C.zoom) > 0) {
                const ze = s.bg(l.canonical, C), rt = s.e1(ze);
                D = s.az(new Float32Array(16), C.globeMatrix, rt), s.az(D, C.projMatrix, D);
            } const B = s.bz(); B[12] += 2 * _ / (s.q.devicePixelRatio * C.width), B[13] += 2 * v / (s.q.devicePixelRatio * C.height), s.az(D, B, D); const q = d.getOrCreateProgram("debug", { defines: O }), G = n.getTileByID(l.key); d.terrain && d.terrain.setupElevationDraw(G, q); const K = Ut.disabled, W = dr.disabled, oe = d.colorModeForRenderPass(), de = "$debug"; T.activeTexture.set(P.TEXTURE0), d.emptyTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE), R ? G._makeGlobeTileDebugBuffers(d.context, C) : G._makeDebugTileBoundsBuffers(d.context, C.projection); const me = G._tileDebugBuffer || d.debugBuffer, we = G._tileDebugIndexBuffer || d.debugIndexBuffer, ve = G._tileDebugSegments || d.debugSegments; if (q.draw(d, P.LINE_STRIP, K, W, oe, fr.disabled, Rc(D, f), de, me, we, ve, null, null, null, [G._globeTileDebugBorderBuffer]), w) {
                const ze = G.latestRawTileData, rt = Math.floor((ze && ze.byteLength || 0) / 1024);
                let et = l.canonical.toString();
                l.overscaledZ !== l.canonical.z && (et += ` => ${l.overscaledZ}`), et += ` ${G.state}`, et += ` ${rt}kb`, function (vt, Fe) { vt.initDebugOverlayCanvas(); const Ve = vt.debugOverlayCanvas, Le = vt.context.gl, st = vt.debugOverlayCanvas.getContext("2d"); st.clearRect(0, 0, Ve.width, Ve.height), st.shadowColor = "white", st.shadowBlur = 2, st.lineWidth = 1.5, st.strokeStyle = "white", st.textBaseline = "top", st.font = "bold 36px Open Sans, sans-serif", st.fillText(Fe, 5, 5), st.strokeText(Fe, 5, 5), vt.debugOverlayTexture.update(Ve), vt.debugOverlayTexture.bind(Le.LINEAR, Le.CLAMP_TO_EDGE); }(d, et);
            } const xe = n.getTile(l).tileSize, ge = 512 / Math.min(xe, 512) * (l.overscaledZ / C.zoom) * .5, Se = G._tileDebugTextBuffer || d.debugBuffer, Ce = G._tileDebugTextIndexBuffer || d.quadTriangleIndexBuffer, je = G._tileDebugTextSegments || d.debugSegments; q.draw(d, P.TRIANGLES, K, W, Rr.alphaBlended, fr.disabled, Rc(D, s.am.transparent, ge), de, Se, Ce, je, null, null, null, [G._globeTileDebugTextBuffer]); }
            function Mp(d, n, l, f) { Nu(d, 0, n + l / 2, d.transform.width, l, f); }
            function Rp(d, n, l, f) { Nu(d, n - l / 2, 0, l, d.transform.height, f); }
            function Nu(d, n, l, f, _, v) { const w = d.context, T = w.gl; T.enable(T.SCISSOR_TEST), T.scissor(n * s.q.devicePixelRatio, l * s.q.devicePixelRatio, f * s.q.devicePixelRatio, _ * s.q.devicePixelRatio), w.clear({ color: v }), T.disable(T.SCISSOR_TEST); }
            const Z0 = s.d_([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: zo } = Z0;
            function yn(d, n, l, f) { d.emplaceBack(n, l, f); }
            class Ld {
                constructor(n) { this.vertexArray = new s.e2, this.indices = new s.a_, yn(this.vertexArray, -1, -1, 1), yn(this.vertexArray, 1, -1, 1), yn(this.vertexArray, -1, 1, 1), yn(this.vertexArray, 1, 1, 1), yn(this.vertexArray, -1, -1, -1), yn(this.vertexArray, 1, -1, -1), yn(this.vertexArray, -1, 1, -1), yn(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = n.createVertexBuffer(this.vertexArray, zo), this.indexBuffer = n.createIndexBuffer(this.indices), this.segment = s.bd.simpleSegment(0, 0, 36, 12); }
            }
            function Bl(d, n, l, f, _, v) { const w = d.context.gl, T = n.paint.get("sky-atmosphere-color"), C = n.paint.get("sky-atmosphere-halo-color"), P = n.paint.get("sky-atmosphere-sun-intensity"), R = ((O, D, B, q, G) => ({ u_matrix_3f: O, u_sun_direction: D, u_sun_intensity: B, u_color_tint_r: [q.r, q.g, q.b, q.a], u_color_tint_m: [G.r, G.g, G.b, G.a], u_luminance: 5e-5 }))(s.e4(s.dx(), f), _, P, T, C); w.framebufferTexture2D(w.FRAMEBUFFER, w.COLOR_ATTACHMENT0, w.TEXTURE_CUBE_MAP_POSITIVE_X + v, n.skyboxTexture, 0), l.draw(d, w.TRIANGLES, Ut.disabled, dr.disabled, Rr.unblended, fr.frontCW, R, "skyboxCapture", n.skyboxGeometry.vertexBuffer, n.skyboxGeometry.indexBuffer, n.skyboxGeometry.segment); }
            const X0 = s.d_([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
            class K0 {
                constructor(n) { const l = new s.e5; l.emplaceBack(-1, 1, 1, 0, 0), l.emplaceBack(1, 1, 1, 1, 0), l.emplaceBack(1, -1, 1, 1, 1), l.emplaceBack(-1, -1, 1, 0, 1); const f = new s.a_; f.emplaceBack(0, 1, 2), f.emplaceBack(2, 3, 0), this.vertexBuffer = n.createVertexBuffer(l, X0.members), this.indexBuffer = n.createIndexBuffer(f), this.segments = s.bd.simpleSegment(0, 0, 4, 2); }
                destroy() { this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(); }
            }
            const Y0 = s.d_([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_size_scale", components: 1 }, { type: "Float32", name: "a_fade_opacity", components: 1 }]);
            class gT {
                constructor() { this.starsCount = 16e3, this.sizeMultiplier = .15, this.sizeRange = 100, this.intensityRange = 200; }
            }
            class Bu {
                constructor(n) { this.colorModeAlphaBlendedWriteRGB = new Rr([1, Ms, 1, Ms], s.am.transparent, [!0, !0, !0, !1]), this.colorModeWriteAlpha = new Rr([1, 0, 1, 0], s.am.transparent, [!1, !1, !1, !0]), this.params = new gT, this.updateNeeded = !0, n.tp.registerParameter(this.params, ["Stars"], "starsCount", { min: 100, max: 16e3, step: 1 }, () => { this.updateNeeded = !0; }), n.tp.registerParameter(this.params, ["Stars"], "sizeMultiplier", { min: .01, max: 2, step: .01 }), n.tp.registerParameter(this.params, ["Stars"], "sizeRange", { min: 0, max: 200, step: 1 }, () => { this.updateNeeded = !0; }), n.tp.registerParameter(this.params, ["Stars"], "intensityRange", { min: 0, max: 200, step: 1 }, () => { this.updateNeeded = !0; }); }
                update(n) { const l = n.context; if (!this.atmosphereBuffer || this.updateNeeded) {
                    this.updateNeeded = !1, this.atmosphereBuffer = new K0(l);
                    const f = this.params.sizeRange, _ = this.params.intensityRange, v = function (R) { const O = s.ea(30), D = []; for (let B = 0; B < R; ++B) {
                        const q = 2 * Math.PI * O(), G = Math.acos(1 - 2 * O()) - .5 * Math.PI;
                        D.push(s.cS(Math.cos(G) * Math.cos(q), Math.cos(G) * Math.sin(q), Math.sin(G)));
                    } return D; }(this.params.starsCount), w = s.ea(300), T = new s.e6, C = new s.a_;
                    let P = 0;
                    for (let R = 0; R < v.length; ++R) {
                        const O = s.b$([], v[R], 200), D = Math.max(0, 1 + .01 * f * (1 * w() - .5)), B = Math.max(0, 1 + .01 * _ * (1 * w() - .5));
                        T.emplaceBack(O[0], O[1], O[2], -1, -1, D, B), T.emplaceBack(O[0], O[1], O[2], 1, -1, D, B), T.emplaceBack(O[0], O[1], O[2], 1, 1, D, B), T.emplaceBack(O[0], O[1], O[2], -1, 1, D, B), C.emplaceBack(P + 0, P + 1, P + 2), C.emplaceBack(P + 0, P + 2, P + 3), P += 4;
                    }
                    this.starsVx = l.createVertexBuffer(T, Y0.members), this.starsIdx = l.createIndexBuffer(C), this.starsSegments = s.bd.simpleSegment(0, 0, T.length, C.length);
                } }
                destroy() { this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy(); }
                drawAtmosphereGlow(n, l) { const f = n.context, _ = f.gl, v = n.transform, w = new Ut(_.LEQUAL, Ut.ReadOnly, [0, 1]), T = s.ah(v.zoom), C = n.style.getLut(l.scope), P = l.properties.get("color-use-theme") === "none", R = l.properties.get("color").toRenderColor(P ? null : C).toArray01(), O = l.properties.get("high-color-use-theme") === "none", D = l.properties.get("high-color").toRenderColor(O ? null : C).toArray01(), B = l.properties.get("space-color-use-theme") === "none", q = l.properties.get("space-color").toRenderColor(B ? null : C).toArray01PremultipliedAlpha(), G = 5e-4, K = s.e7(l.properties.get("horizon-blend"), 0, 1, G, .25), W = s.dl(n, f, v) && K === G ? v.worldSize / (2 * Math.PI * 1.025) - 1 : v.globeRadius, oe = n.frameCounter / 1e3 % 1, de = s.ae(v.globeCenterInViewSpace), me = Math.sqrt(Math.pow(de, 2) - Math.pow(W, 2)), we = Math.acos(me / de), ve = xe => { const ge = v.projection.name === "globe" ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"]; xe && ge.push("ALPHA_PASS"); const Se = n.getOrCreateProgram("globeAtmosphere", { defines: ge }), Ce = ((ze, rt, et, vt, Fe, Ve, Le, st, He, ht, nt, dt) => ({ u_frustum_tl: ze, u_frustum_tr: rt, u_frustum_br: et, u_frustum_bl: vt, u_horizon: Fe, u_transition: Ve, u_fadeout_range: Le, u_color: st, u_high_color: He, u_space_color: ht, u_temporal_offset: nt, u_horizon_angle: dt }))(v.frustumCorners.TL, v.frustumCorners.TR, v.frustumCorners.BR, v.frustumCorners.BL, v.frustumCorners.horizon, T, K, R, D, q, oe, we); n.uploadCommonUniforms(f, Se); const je = this.atmosphereBuffer; je && Se.draw(n, _.TRIANGLES, w, dr.disabled, xe ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, fr.backCW, Ce, xe ? "atmosphere_glow_alpha" : "atmosphere_glow", je.vertexBuffer, je.indexBuffer, je.segments); }; ve(!1), ve(!0); }
                drawStars(n, l) { const f = s.aD(l.properties.get("star-intensity"), 0, 1); if (f === 0)
                    return; const _ = n.context, v = _.gl, w = n.transform, T = n.getOrCreateProgram("stars"), C = s.bY([]); s.b_(C, C, -w._pitch), s.bZ(C, C, -w.angle), s.b_(C, C, s.al(w._center.lat)), s.e8(C, C, -s.al(w._center.lng)); const P = s.c3(new Float32Array(16), C), R = s.az([], w.starsProjMatrix, P), O = s.e4([], P), D = s.e9([], O), B = [0, 1, 0]; s.dz(B, B, D), s.b$(B, B, this.params.sizeMultiplier); const q = [1, 0, 0]; s.dz(q, q, D), s.b$(q, q, this.params.sizeMultiplier); const G = (K = B, W = q, oe = f, { u_matrix: Float32Array.from(R), u_up: K, u_right: W, u_intensity_multiplier: oe }); var K, W, oe; n.uploadCommonUniforms(_, T), this.starsVx && this.starsIdx && T.draw(n, v.TRIANGLES, Ut.disabled, dr.disabled, this.colorModeAlphaBlendedWriteRGB, fr.disabled, G, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments); }
            }
            function zc(d, n) { const l = [...d], f = n.cameraWorldSizeForFog / n.worldSize, _ = s.bx([]); return s.cE(_, _, [f, f, 1]), s.az(l, _, l), s.az(l, n.worldToFogMatrix, l), l; }
            function wt(d, n, l, f, _) { const v = l.material, w = f.context, { baseColorTexture: T, metallicRoughnessTexture: C } = v.pbrMetallicRoughness, { normalTexture: P, occlusionTexture: R, emissionTexture: O } = v; function D(q, G, K) { if (q && (d.push(G), w.activeTexture.set(w.gl.TEXTURE0 + K), q.gfxTexture)) {
                const { minFilter: W, magFilter: oe, wrapS: de, wrapT: me } = q.sampler;
                q.gfxTexture.bindExtraParam(W, oe, de, me);
            } } D(T, "HAS_TEXTURE_u_baseColorTexture", Rs.BaseColor), D(C, "HAS_TEXTURE_u_metallicRoughnessTexture", Rs.MetallicRoughness), D(P, "HAS_TEXTURE_u_normalTexture", Rs.Normal), D(R, "HAS_TEXTURE_u_occlusionTexture", Rs.Occlusion), D(O, "HAS_TEXTURE_u_emissionTexture", Rs.Emission), _ && (_.texture || (_.texture = new s.ed(f.context, _.image, [_.image.height, _.image.height, _.image.height], w.gl.RGBA8)), w.activeTexture.set(w.gl.TEXTURE0 + Rs.LUT), _.texture && _.texture.bind(w.gl.LINEAR, w.gl.CLAMP_TO_EDGE), d.push("APPLY_LUT_ON_GPU")), l.texcoordBuffer && (d.push("HAS_ATTRIBUTE_a_uv_2f"), n.push(l.texcoordBuffer)), l.colorBuffer && (d.push(l.colorBuffer.itemSize === 12 ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), n.push(l.colorBuffer)), l.normalBuffer && (d.push("HAS_ATTRIBUTE_a_normal_3f"), n.push(l.normalBuffer)), l.pbrBuffer && (d.push("HAS_ATTRIBUTE_a_pbr"), d.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), n.push(l.pbrBuffer)), v.alphaMode !== "OPAQUE" && v.alphaMode !== "MASK" || d.push("UNPREMULT_TEXTURE_IN_SHADER"), v.defined || d.push("DIFFUSE_SHADED"); const B = f.shadowRenderer; B && (d.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), B.useNormalOffset && d.push("NORMAL_OFFSET")); }
            function zt(d, n, l, f, _, v) { const w = l.paint.get("model-opacity").constantOr(1), T = n.context, C = new Ut(n.context.gl.LEQUAL, Ut.ReadWrite, n.depthRangeFor3D), P = n.transform, R = d.mesh, O = R.material, D = O.pbrMetallicRoughness, B = n.style.fog; let q; q = n.transform.projection.zAxisUnit === "pixels" ? [...d.nodeModelMatrix] : s.az([], f.zScaleMatrix, d.nodeModelMatrix), s.az(q, f.negCameraPosMatrix, q); const G = s.bi([], q); s.ee(G, G); const K = l.paint.get("model-color-use-theme").constantOr("default") === "none", W = l.paint.get("model-emissive-strength").constantOr(0), oe = kc(new Float32Array(d.worldViewProjection), new Float32Array(q), new Float32Array(G), null, n, w, D.baseColorFactor.toRenderColor(null), O.emissiveFactor, D.metallicFactor, D.roughnessFactor, O, W, l), de = { defines: [] }, me = [], we = n.shadowRenderer; we && (we.useNormalOffset = !1), wt(de.defines, me, R, n, K ? null : l.lut); let ve = null; if (B) {
                const Se = zc(d.nodeModelMatrix, n.transform);
                if (ve = new Float32Array(Se), P.projection.name !== "globe") {
                    const Ce = R.aabb.min, je = R.aabb.max, [ze, rt] = B.getOpacityForBounds(Se, Ce[0], Ce[1], je[0], je[1]);
                    de.overrideFog = ze >= Ot || rt >= Ot;
                }
            } const xe = Cc(n, l.paint.get("model-cutoff-fade-range")); xe.shouldRenderCutoff && de.defines.push("RENDER_CUTOFF"); const ge = n.getOrCreateProgram("model", de); n.uploadCommonUniforms(T, ge, null, ve, xe), n.renderPass !== "shadow" && we && we.setupShadowsFromMatrix(d.nodeModelMatrix, ge), ge.draw(n, T.gl.TRIANGLES, C, _, v, R.material.doubleSided ? fr.disabled : fr.backCCW, oe, l.id, R.vertexBuffer, R.indexBuffer, R.segments, l.paint, n.transform.zoom, void 0, me); }
            function Fc(d, n, l, f, _, v, w) { let T; T = d.projection.name === "globe" ? s.ef(l, d) : [...l], s.az(T, T, n.matrix); const C = s.az([], f, T); if (n.meshes)
                for (const P of n.meshes) {
                    if (P.material.alphaMode !== "BLEND") {
                        w.push({ mesh: P, depth: 0, modelIndex: _, worldViewProjection: C, nodeModelMatrix: T });
                        continue;
                    }
                    const R = s.ad([], P.centroid, C);
                    !d.isOrthographic && R[2] <= 0 || v.push({ mesh: P, depth: R[2], modelIndex: _, worldViewProjection: C, nodeModelMatrix: T });
                } if (n.children)
                for (const P of n.children)
                    Fc(d, P, l, f, _, v, w); }
            function gi(d, n, l, f) { const _ = l.shadowRenderer; if (!_)
                return; const v = _.getShadowPassDepthMode(), w = _.getShadowPassColorMode(), T = _.calculateShadowPassMatrixFromMatrix(n), C = G0(T); l.getOrCreateProgram("modelDepth", { defines: l._shadowMapDebug ? [] : ["DEPTH_TEXTURE"] }).draw(l, l.context.gl.TRIANGLES, v, dr.disabled, w, fr.backCCW, C, f.id, d.vertexBuffer, d.indexBuffer, d.segments, f.paint, l.transform.zoom, void 0, void 0); }
            function Ne(d, n, l) { const f = n.updateZoomBasedPaintProperties(), _ = function (v, w, T) { let C, P, R, O = v.terrain ? v.terrain.exaggeration() : 0; if (v.terrain && O > 0) {
                const D = v.terrain, B = D.findDEMTileFor(T);
                B && B.dem ? C = s.el.create(D, T, B) : O = 0;
            } if (O === 0 && (w.terrainElevationMin = 0, w.terrainElevationMax = 0), O === w.validForExaggeration && (O === 0 || C && C._demTile && C._demTile.tileID === w.validForDEMTile.id && C._dem._timestamp === w.validForDEMTile.timestamp))
                return !1; for (const D in w.instancesPerModel) {
                const B = w.instancesPerModel[D];
                for (let q = 0; q < B.instancedDataArray.length; ++q) {
                    const G = (C ? O * C.getElevationAt(0 | B.instancedDataArray.float32[16 * q], 0 | B.instancedDataArray.float32[16 * q + 1], !0, !0) : 0) + B.instancesEvaluatedElevation[q];
                    B.instancedDataArray.float32[16 * q + 6] = G, P = P ? Math.min(w.terrainElevationMin, G) : G, R = R ? Math.max(w.terrainElevationMax, G) : G;
                }
            } return w.terrainElevationMin = P || 0, w.terrainElevationMax = R || 0, w.validForExaggeration = O, w.validForDEMTile = C && C._demTile ? { id: C._demTile.tileID, timestamp: C._dem._timestamp } : { id: void 0, timestamp: 0 }, !0; }(d, n, l); (f || _) && (n.uploaded = !1, n.upload(d.context)); }
            const ra = { shadowUniformsInitialized: !1, useSingleShadowCascade: !1, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new s.cV([0, 0, 0], [s.aj, s.aj, 0]) };
            function kp(d, n) { const l = 1 << d.canonical.z, f = n.getFreeCameraOptions().position, _ = n.elevation, v = d.canonical.x / l, w = (d.canonical.x + 1) / l, T = d.canonical.y / l, C = (d.canonical.y + 1) / l; let P = n._centerAltitude; if (_) {
                const B = _.getMinMaxForTile(d);
                B && B.max > P && (P = B.max);
            } const R = s.aD(f.x, v, w) - f.x, O = s.aD(f.y, T, C) - f.y, D = s.c6(P, n.center.lat) - f.z; return n._zoomFromMercatorZ(Math.sqrt(R * R + O * O + D * D)); }
            function Dp(d, n, l, f, _, v, w) { const T = d.context, C = d.renderPass === "shadow", P = d.shadowRenderer, R = C && P ? P.getShadowPassDepthMode() : new Ut(T.gl.LEQUAL, Ut.ReadWrite, d.depthRangeFor3D), O = d.isTileAffectedByFog(v); if (l.meshes)
                for (const D of l.meshes) {
                    const B = ["MODEL_POSITION_ON_GPU"], q = [];
                    let G, K, W;
                    f.instancedDataArray.length > 20 && B.push("INSTANCED_ARRAYS");
                    const oe = Cc(d, n.paint.get("model-cutoff-fade-range"));
                    if (oe.shouldRenderCutoff && B.push("RENDER_CUTOFF"), C && P)
                        G = d.getOrCreateProgram("modelDepth", { defines: B }), K = G0(w.shadowTileMatrix, w.shadowTileMatrix, Float32Array.from(l.matrix)), W = P.getShadowPassColorMode();
                    else {
                        wt(B, q, D, d, n.paint.get("model-color-use-theme").constantOr("default") === "none" ? null : n.lut), G = d.getOrCreateProgram("model", { defines: B, overrideFog: O });
                        const me = D.material, we = me.pbrMetallicRoughness, ve = n.paint.get("model-opacity").constantOr(1), xe = n.paint.get("model-emissive-strength").constantOr(0);
                        K = kc(v.expandedProjMatrix, Float32Array.from(l.matrix), new Float32Array(16), null, d, ve, we.baseColorFactor.toRenderColor(null), me.emissiveFactor, we.metallicFactor, we.roughnessFactor, me, xe, n, _), P && (w.shadowUniformsInitialized ? G.setShadowUniformValues(T, P.getShadowUniformValues()) : (P.setupShadows(v.toUnwrapped(), G, "model-tile", v.overscaledZ), w.shadowUniformsInitialized = !0)), W = oe.shouldRenderCutoff || ve < 1 || me.alphaMode !== "OPAQUE" ? Rr.alphaBlended : Rr.unblended;
                    }
                    d.uploadCommonUniforms(T, G, v.toUnwrapped(), null, oe);
                    const de = D.material.doubleSided ? fr.disabled : fr.backCCW;
                    if (f.instancedDataArray.length > 20)
                        q.push(f.instancedDataBuffer), G.draw(d, T.gl.TRIANGLES, R, dr.disabled, W, de, K, n.id, D.vertexBuffer, D.indexBuffer, D.segments, n.paint, d.transform.zoom, void 0, q, f.instancedDataArray.length);
                    else {
                        const me = C ? "u_instance" : "u_normal_matrix";
                        for (let we = 0; we < f.instancedDataArray.length; ++we)
                            K[me] = new Float32Array(f.instancedDataArray.arrayBuffer, 64 * we, 16), G.draw(d, T.gl.TRIANGLES, R, dr.disabled, W, de, K, n.id, D.vertexBuffer, D.indexBuffer, D.segments, n.paint, d.transform.zoom, void 0, q);
                    }
                } if (l.children)
                for (const D of l.children)
                    Dp(d, n, D, f, _, v, w); }
            const b_ = [1, -1, 1];
            function Q0(d, n, l, f) { if (!l.modelManager)
                return !0; const _ = l.modelManager; if (!l.shadowRenderer)
                return !0; const v = l.shadowRenderer, w = n.aabb; let T = !0, C = d.maxHeight; if (C === 0) {
                let R = 0;
                for (const O in d.instancesPerModel) {
                    const D = _.getModel(O, f);
                    D ? R = Math.max(R, Math.max(Math.max(D.aabb.max[0], D.aabb.max[1]), D.aabb.max[2])) : T = !1;
                }
                C = d.maxScale * R * 1.41 + d.maxVerticalOffset, T && (d.maxHeight = C);
            } w.max[2] = C, w.min[2] += d.terrainElevationMin, w.max[2] += d.terrainElevationMax, s.ad(w.min, w.min, n.tileMatrix), s.ad(w.max, w.max, n.tileMatrix); const P = w.intersects(v.getCurrentCascadeFrustum()); return l.currentShadowCascade === 0 && (d.isInsideFirstShadowMapFrustum = P === 2), P === 0; }
            function J0(d, n) { const l = d.uniformValues.u_cutoff_params[0], f = d.uniformValues.u_cutoff_params[1], _ = d.uniformValues.u_cutoff_params[2], v = d.uniformValues.u_cutoff_params[3]; return f === l || v === _ ? 1 : s.aD(((n - l) / (f - l) - _) / (v - _), 0, 1); }
            function ju(d, n, l, f) { if (n.pitch < 20)
                return 1; const _ = n.getWorldToCameraMatrix(); s.az(_, _, d); const v = s.ei(l.min[0], l.min[1], l.min[2], 1); let w = s.aA(s.ej(), v, _), T = w, C = w; v[1] = l.max[1], w = s.aA(s.ej(), v, _), T = w[1] < T[1] ? w : T, C = w[1] > C[1] ? w : C, v[0] = l.max[0], w = s.aA(s.ej(), v, _), T = w[1] < T[1] ? w : T, C = w[1] > C[1] ? w : C, v[1] = l.min[1], w = s.aA(s.ej(), v, _), T = w[1] < T[1] ? w : T, C = w[1] > C[1] ? w : C; const P = s.aD(f[0], 0, 1), R = 100 * n.pixelsPerMeter * s.aD(f[1], 0, 1), O = s.aD(f[2], 0, 1), D = s.ek(s.ej(), T, C, P), B = Math.tan(.5 * n.fovX), q = -D[2] * B; if (R === 0)
                return D[1] < -Math.abs(q) ? O : 1; const G = (-Math.abs(q) - D[1]) / R, K = (oe, de, me) => (1 - me) * oe + me * de, W = s.aD(K(1, O, G), O, 1); return K(1, W, s.aD((n.pitch - 20) / 20, 0, 1)); }
            class _T {
            }
            class yT {
                constructor() { this._storage = new Map; }
                getLinesFromTrianglesBuffer(n, l, f) { {
                    const O = this._storage.get(l.id);
                    if (O)
                        return O.lastUsedFrameIdx = n, O.buf;
                } const _ = f.gl, v = _.getBufferParameter(_.ELEMENT_ARRAY_BUFFER, _.BUFFER_SIZE), w = new ArrayBuffer(v), T = new Int16Array(w); _.getBufferSubData(_.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(w)); const C = new s.en; for (let O = 0; O < v / 2; O += 3) {
                    const D = T[O], B = T[O + 1], q = T[O + 2];
                    C.emplaceBack(D, B), C.emplaceBack(B, q), C.emplaceBack(q, D);
                } const P = f.bindVertexArrayOES.current, R = new _T; return R.buf = new Qa(f, C), R.lastUsedFrameIdx = n, this._storage.set(l.id, R), f.bindVertexArrayOES.set(P), R.buf; }
                update(n) { for (const [l, f] of this._storage)
                    n - f.lastUsedFrameIdx > 30 && (f.buf.destroy(), this._storage.delete(l)); }
                destroy() { for (const [n, l] of this._storage)
                    l.buf.destroy(), this._storage.delete(n); }
            }
            class ex {
                constructor(n) { this.occluderSize = 30, this.depthOffset = -1e-4, n.registerParameter(this, ["Occlusion"], "occluderSize", { min: 1, max: 100, step: 1 }), n.registerParameter(this, ["Occlusion"], "depthOffset", { min: -.05, max: 0, step: 1e-5 }); }
            }
            const Lp = s.d_([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_rainParticleData", components: 4 }]);
            class T_ {
                registerParameter() { }
                registerButton() { }
                registerBinding() { }
                refreshUI() { }
            }
            class S_ {
                constructor(n, l) { this.revealStart = 11, this.revealRange = 2, n.registerParameter(this, [...l, "Reveal"], "revealStart", { min: 0, max: 17, step: .05 }), n.registerParameter(this, [...l, "Reveal"], "revealRange", { min: .1, max: 5.1, step: .05 }); }
            }
            const tx = s.d_([{ type: "Float32", name: "a_pos_2f", components: 2 }]);
            class Op {
                destroy() { this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy(); }
                draw(n, l) { const f = n.getOrCreateProgram("vignette"); if (!this.vignetteVx || !this.vignetteIdx) {
                    const w = new s.eo, T = new s.a_;
                    w.emplaceBack(-1, -1), w.emplaceBack(1, -1), w.emplaceBack(1, 1), w.emplaceBack(-1, 1), T.emplaceBack(0, 1, 2), T.emplaceBack(0, 2, 3), this.vignetteVx = n.context.createVertexBuffer(w, tx.members), this.vignetteIdx = n.context.createIndexBuffer(T);
                } const _ = s.bd.simpleSegment(0, 0, 4, 6); if (this.vignetteVx && this.vignetteIdx) {
                    n.uploadCommonUniforms(n.context, f);
                    const w = { u_vignetteShape: (v = { vignetteShape: [l.start, l.range, Math.pow(10, l.fadePower)], vignetteColor: [l.color.r, l.color.g, l.color.b, l.color.a * l.strength] }).vignetteShape, u_vignetteColor: v.vignetteColor };
                    f.draw(n, n.context.gl.TRIANGLES, Ut.disabled, dr.disabled, Rr.alphaBlended, fr.disabled, w, "vignette", this.vignetteVx, this.vignetteIdx, _);
                } var v; }
            }
            class Od {
                constructor() { this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0; }
                update(n, l) { const f = n.getFreeCameraOptions().position, _ = f.toAltitude(), v = f.toLngLat(), w = s.al(v.lng), T = s.al(v.lat), C = n.pixelsPerMeter / l, P = w * s.eq, R = s.eq * Math.log(Math.tan(Math.PI / 4 + T / 2)); if (this._offsetXPrev === void 0)
                    this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
                else {
                    const O = -this._offsetYPrev + R, D = -this._elevationPrev + _;
                    this._accumulatedOffsetX += (-this._offsetXPrev + P) * C, this._accumulatedOffsetY += O * C, this._accumulatedElevation += D * C, this._offsetXPrev = P, this._offsetYPrev = R, this._elevationPrev = _;
                } }
                getPosition() { return [this._accumulatedOffsetX, this._accumulatedOffsetY, this._accumulatedElevation]; }
            }
            function Nc(d, n) { return [-(d[0] - Math.floor(d[0] / n) * n), -(d[1] - Math.floor(d[1] / n) * n), -(d[2] - Math.floor(d[2] / n) * n)]; }
            function E_(d) { const n = s.ea(1323123451230), l = []; for (let f = 0; f < d; ++f) {
                const _ = 2 * n() - 1, v = 2 * n() - 1, w = 2 * n() - 1;
                l.push(s.cS(_, v, w));
            } return l; }
            function jl(d, n, l, f, _) { const v = s.aD((_ - l) / (f - l), 0, 1); return (1 - v) * d + v * n; }
            class Ds {
                constructor(n) { this._movement = new Od, this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new Op, this._ppmScaleFactor = n; }
                destroy() { this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy(); }
                updateOnRender(n, l) { const f = n.transform; this._movement.update(f, this._ppmScaleFactor); const _ = f.starsProjMatrix, v = s.bY([]); s.b_(v, v, s.al(90) - f._pitch), s.bZ(v, v, -f.angle); const w = s.c3(new Float32Array(16), v), T = s.ep(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1), C = s.ee([], T), P = s.az([], C, w), R = Date.now() / 1e3; return this._accumulatedTimeFromStart += (R - this._prevTime) * l, this._prevTime = R, { projectionMatrix: _, modelviewMatrix: P }; }
            }
            class vT extends Ds {
                constructor(n) { super(4.25), this._params = { overrideStyleParameters: !1, intensity: .5, timeFactor: 1, velocityConeAperture: 0, velocity: 300, boxSize: 2500, dropletSizeX: 1, dropletSizeYScale: 10, distortionStrength: 70, screenThinning: { intensity: .57, start: .46, range: 1.17, fadePower: .17, affectedRatio: 1, particleOffset: -.2 }, color: { r: .66, g: .68, b: .74, a: .7 }, direction: { x: -50, y: -35 }, shapeDirPower: 2, shapeNormalPower: 1 }, this._revealParams = new S_(n.tp, ["Precipitation", "Rain"]), this._vignetteParams = { strength: 1, start: .7, range: 1, fadePower: .4, color: { r: .27, g: .27, b: .27, a: 1 } }, this.particlesCount = 16e3; }
                update(n) { const l = n.context; if (!this.particlesVx) {
                    const f = E_(this.particlesCount), _ = new s.er, v = new s.a_;
                    let w = 0;
                    const T = s.ea(1323123451230);
                    for (let C = 0; C < f.length; ++C) {
                        const P = f[C], R = [2 * T() - 1, T(), T(), T()];
                        _.emplaceBack(P[0], P[1], P[2], -1, -1, ...R), _.emplaceBack(P[0], P[1], P[2], 1, -1, ...R), _.emplaceBack(P[0], P[1], P[2], 1, 1, ...R), _.emplaceBack(P[0], P[1], P[2], -1, 1, ...R), v.emplaceBack(w + 0, w + 1, w + 2), v.emplaceBack(w + 0, w + 2, w + 3), w += 4;
                    }
                    this.particlesVx = l.createVertexBuffer(_, Lp.members), this.particlesIdx = l.createIndexBuffer(v);
                } }
                draw(n) { if (!this._params.overrideStyleParameters && !n.style.rain)
                    return; const l = this._params.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: .01 }, f = n.transform.zoom; if (l.revealStart > f)
                    return; const _ = jl(0, 1, l.revealStart, l.revealStart + l.revealRange, f); if (!this.particlesVx || !this.particlesIdx)
                    return; const v = structuredClone(this._params); let w = [-v.direction.x, v.direction.y, -100]; s.au(w, w); const T = structuredClone(this._vignetteParams); T.strength *= _, v.overrideStyleParameters || (v.intensity = n.style.rain.state.density, v.timeFactor = n.style.rain.state.intensity, v.color = structuredClone(n.style.rain.state.color), w = structuredClone(n.style.rain.state.direction), v.screenThinning.intensity = n.style.rain.state.centerThinning, v.dropletSizeX = n.style.rain.state.dropletSize[0], v.dropletSizeYScale = n.style.rain.state.dropletSize[1] / n.style.rain.state.dropletSize[0], v.distortionStrength = 100 * n.style.rain.state.distortionStrength, T.strength = 1, T.color = structuredClone(n.style.rain.state.vignetteColor)); const C = this.updateOnRender(n, v.timeFactor), P = n.context, R = P.gl, O = n.transform; this.screenTexture && this.screenTexture.size[0] === n.width && this.screenTexture.size[1] === n.height || (this.screenTexture = new s.T(P, { width: n.width, height: n.height, data: null }, R.RGBA8)), v.distortionStrength > 0 && (P.activeTexture.set(R.TEXTURE0), this.screenTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE), R.copyTexSubImage2D(R.TEXTURE_2D, 0, 0, 0, 0, 0, n.width, n.height)); const D = n.getOrCreateProgram("rainParticle"); n.uploadCommonUniforms(P, D), P.activeTexture.set(R.TEXTURE0), this.screenTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE); const B = [v.color.r, v.color.g, v.color.b, v.color.a], q = (G, K) => { const W = Nc(this._movement.getPosition(), G), oe = v.dropletSizeX, de = v.dropletSizeX * v.dropletSizeYScale, me = n.width / 2, we = n.height / 2, ve = jl(0, v.screenThinning.start, 0, 1, v.screenThinning.intensity), xe = jl(.001, v.screenThinning.range, 0, 1, v.screenThinning.intensity), ge = jl(0, v.screenThinning.particleOffset, 0, 1, v.screenThinning.intensity), Se = (Ce = { modelview: C.modelviewMatrix, projection: C.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: W, velocityConeAperture: v.velocityConeAperture, velocity: v.velocity, boxSize: G, rainDropletSize: [oe, de], distortionStrength: v.distortionStrength, rainDirection: w, color: B, screenSize: [O.width, O.height], thinningCenterPos: [me, we], thinningShape: [ve, xe, Math.pow(10, v.screenThinning.fadePower)], thinningAffectedRatio: v.screenThinning.affectedRatio, thinningParticleOffset: ge, shapeDirectionalPower: v.shapeDirPower, shapeNormalPower: v.shapeNormalPower, mode: K ? 0 : 1 }, { u_modelview: Float32Array.from(Ce.modelview), u_projection: Float32Array.from(Ce.projection), u_time: Ce.time, u_cam_pos: Ce.camPos, u_texScreen: 0, u_velocityConeAperture: Ce.velocityConeAperture, u_velocity: Ce.velocity, u_boxSize: Ce.boxSize, u_rainDropletSize: Ce.rainDropletSize, u_distortionStrength: Ce.distortionStrength, u_rainDirection: Ce.rainDirection, u_color: Ce.color, u_screenSize: Ce.screenSize, u_thinningCenterPos: Ce.thinningCenterPos, u_thinningShape: Ce.thinningShape, u_thinningAffectedRatio: Ce.thinningAffectedRatio, u_thinningParticleOffset: Ce.thinningParticleOffset, u_shapeDirectionalPower: Ce.shapeDirectionalPower, u_shapeNormalPower: Ce.shapeNormalPower, u_mode: Ce.mode }); var Ce; const je = Math.round(v.intensity * this.particlesCount), ze = s.bd.simpleSegment(0, 0, 4 * je, 2 * je); D.draw(n, R.TRIANGLES, Ut.disabled, dr.disabled, Rr.alphaBlended, fr.disabled, Se, "rain_particles", this.particlesVx, this.particlesIdx, ze); }; v.distortionStrength > 0 && q(v.boxSize, !0), q(v.boxSize, !1), this._vignette.draw(n, T); }
            }
            const zd = s.d_([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_snowParticleData", components: 4 }, { type: "Float32", name: "a_snowParticleDataHorizontalOscillation", components: 2 }]);
            class Xn extends Ds {
                constructor(n) { super(2.25), this._params = { overrideStyleParameters: !1, intensity: .85, timeFactor: .75, velocityConeAperture: 70, velocity: 40, horizontalOscillationRadius: 4, horizontalOscillationRate: 1.5, boxSize: 2e3, billboardSize: 2, shapeFadeStart: .27, shapeFadePower: .21, screenThinning: { intensity: .4, start: .15, range: 1.4, fadePower: .24, affectedRatio: 1, particleOffset: -.2 }, color: { r: 1, g: 1, b: 1, a: 1 }, direction: { x: -50, y: -35 } }, this._revealParams = new S_(n.tp, ["Precipitation", "Snow"]), this._vignetteParams = { strength: .3, start: .78, range: .46, fadePower: .2, color: { r: 1, g: 1, b: 1, a: 1 } }, this.particlesCount = 16e3; }
                update(n) { const l = n.context; if (!this.particlesVx) {
                    const f = E_(this.particlesCount), _ = new s.es, v = new s.a_;
                    let w = 0;
                    const T = s.ea(1323123451230);
                    for (let C = 0; C < f.length; ++C) {
                        const P = f[C], R = T(), O = T(), D = T(), B = [C / f.length, R, O, D], q = [T(), T()];
                        _.emplaceBack(P[0], P[1], P[2], -1, -1, ...B, ...q), _.emplaceBack(P[0], P[1], P[2], 1, -1, ...B, ...q), _.emplaceBack(P[0], P[1], P[2], 1, 1, ...B, ...q), _.emplaceBack(P[0], P[1], P[2], -1, 1, ...B, ...q), v.emplaceBack(w + 0, w + 1, w + 2), v.emplaceBack(w + 0, w + 2, w + 3), w += 4;
                    }
                    this.particlesVx = l.createVertexBuffer(_, zd.members), this.particlesIdx = l.createIndexBuffer(v);
                } }
                draw(n) { if (!this._params.overrideStyleParameters && !n.style.snow)
                    return; const l = structuredClone(this._params); let f = [-l.direction.x, l.direction.y, -100]; s.au(f, f); const _ = structuredClone(this._vignetteParams), v = l.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: .01 }, w = n.transform.zoom; if (v.revealStart > w)
                    return; const T = jl(0, 1, v.revealStart, v.revealStart + v.revealRange, w); _.strength *= T, l.overrideStyleParameters || (l.intensity = n.style.snow.state.density, l.timeFactor = n.style.snow.state.intensity, l.color = structuredClone(n.style.snow.state.color), f = structuredClone(n.style.snow.state.direction), l.screenThinning.intensity = n.style.snow.state.centerThinning, l.billboardSize = 2.79 * n.style.snow.state.flakeSize, _.strength = 1, _.color = structuredClone(n.style.snow.state.vignetteColor)); const C = this.updateOnRender(n, l.timeFactor); if (!this.particlesVx || !this.particlesIdx)
                    return; const P = n.context, R = P.gl, O = n.transform, D = n.getOrCreateProgram("snowParticle"); n.uploadCommonUniforms(P, D), ((B, q, G) => { const K = Nc(this._movement.getPosition(), B), W = O.width / 2, oe = O.height / 2, de = jl(0, G.screenThinning.start, 0, 1, G.screenThinning.intensity), me = jl(.001, G.screenThinning.range, 0, 1, G.screenThinning.intensity), we = jl(0, G.screenThinning.particleOffset, 0, 1, G.screenThinning.intensity), ve = (xe = { modelview: C.modelviewMatrix, projection: C.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: K, velocityConeAperture: G.velocityConeAperture, velocity: G.velocity, horizontalOscillationRadius: G.horizontalOscillationRadius, horizontalOscillationRate: G.horizontalOscillationRate, boxSize: B, billboardSize: 1 * G.billboardSize, simpleShapeParameters: [G.shapeFadeStart, G.shapeFadePower], screenSize: [O.width, O.height], thinningCenterPos: [W, oe], thinningShape: [de, me, Math.pow(10, G.screenThinning.fadePower)], thinningAffectedRatio: G.screenThinning.affectedRatio, thinningParticleOffset: we, color: [G.color.r, G.color.g, G.color.b, G.color.a], direction: f }, { u_modelview: Float32Array.from(xe.modelview), u_projection: Float32Array.from(xe.projection), u_time: xe.time, u_cam_pos: xe.camPos, u_velocityConeAperture: xe.velocityConeAperture, u_velocity: xe.velocity, u_horizontalOscillationRadius: xe.horizontalOscillationRadius, u_horizontalOscillationRate: xe.horizontalOscillationRate, u_boxSize: xe.boxSize, u_billboardSize: xe.billboardSize, u_simpleShapeParameters: xe.simpleShapeParameters, u_screenSize: xe.screenSize, u_thinningCenterPos: xe.thinningCenterPos, u_thinningShape: xe.thinningShape, u_thinningAffectedRatio: xe.thinningAffectedRatio, u_thinningParticleOffset: xe.thinningParticleOffset, u_particleColor: xe.color, u_direction: xe.direction }); var xe; const ge = Math.round(G.intensity * this.particlesCount), Se = s.bd.simpleSegment(0, 0, 4 * ge, 2 * ge); this.particlesVx && this.particlesIdx && D.draw(n, R.TRIANGLES, Ut.disabled, dr.disabled, Rr.alphaBlended, fr.disabled, ve, "snow_particles", this.particlesVx, this.particlesIdx, Se); })(l.boxSize, 0, l), this._vignette.draw(n, _); }
            }
            const tn = { symbol: function (d, n, l, f, _) { if (d.renderPass !== "translucent")
                    return; const v = dr.disabled, w = d.colorModeForRenderPass(), T = l.layout.get("text-variable-anchor"), C = l.layout.get("text-size-scale-range"), P = s.aD(d.scaleFactor, C[0], C[1]); T && function (D, B, q, G, K, W, oe, de) { const me = B.transform, we = K === "map", ve = W === "map"; for (const xe of D) {
                    const ge = G.getTile(xe), Se = ge.getBucket(q);
                    if (!Se || !Se.text || !Se.text.segments.get().length)
                        continue;
                    const Ce = s.bH(Se.textSizeData, me.zoom, de), je = pd(xe, Se.getProjection(), me), ze = me.calculatePixelsToTileUnitsMatrix(ge), rt = xu(je, ge.tileID.canonical, ve, we, me, Se.getProjection(), ze), et = Se.hasIconTextFit() && Se.hasIconData();
                    Ce && m_(Se, we, ve, oe, me, rt, xe, Math.pow(2, me.zoom - ge.tileID.overscaledZ), Ce, et);
                } }(f, d, l, n, l.layout.get("text-rotation-alignment"), l.layout.get("text-pitch-alignment"), _, P); const R = l.paint.get("icon-opacity").constantOr(1) !== 0, O = l.paint.get("text-opacity").constantOr(1) !== 0; l.layout.get("symbol-sort-key").constantOr(1) !== void 0 && (R || O) ? Pp(d, n, l, f, v, w) : (R && Pp(d, n, l, f, v, w, { onlyIcons: !0 }), O && Pp(d, n, l, f, v, w, { onlyText: !0 })), n.map.showCollisionBoxes && (zu(d, n, l, f, l.paint.get("text-translate"), l.paint.get("text-translate-anchor"), !0), zu(d, n, l, f, l.paint.get("icon-translate"), l.paint.get("icon-translate-anchor"), !1)); }, circle: function (d, n, l, f) { if (d.renderPass !== "translucent")
                    return; const _ = l.paint.get("circle-opacity"), v = l.paint.get("circle-stroke-width"), w = l.paint.get("circle-stroke-opacity"), T = l.layout.get("circle-sort-key").constantOr(1) !== void 0, C = l.paint.get("circle-emissive-strength"); if (_.constantOr(1) === 0 && (v.constantOr(1) === 0 || w.constantOr(1) === 0))
                    return; const P = d.context, R = P.gl, O = d.transform, D = d.depthModeForSublayer(0, Ut.ReadOnly), B = dr.disabled, q = d.colorModeForDrapableLayerRenderPass(C), G = O.projection.name === "globe", K = [s.ay(O.center.lng), s.aH(O.center.lat)], W = []; for (let de = 0; de < f.length; de++) {
                    const me = f[de], we = n.getTile(me), ve = we.getBucket(l);
                    if (!ve || ve.projection.name !== O.projection.name)
                        continue;
                    const xe = ve.programConfigurations.get(l.id), ge = s.dK(l), Se = d.isTileAffectedByFog(me);
                    G && ge.push("PROJECTION_GLOBE_VIEW"), ge.push("DEPTH_D24"), d.terrain && O.depthOcclusionForSymbolsAndCircles && ge.push("DEPTH_OCCLUSION");
                    const Ce = d.getOrCreateProgram("circle", { config: xe, defines: ge, overrideFog: Se }), je = ve.layoutVertexBuffer, ze = ve.globeExtVertexBuffer, rt = ve.indexBuffer, et = O.projection.createInversionMatrix(O, me.canonical), vt = { programConfiguration: xe, program: Ce, layoutVertexBuffer: je, globeExtVertexBuffer: ze, indexBuffer: rt, uniformValues: s.dL(d, me, we, et, K, l), tile: we };
                    if (T) {
                        const Fe = ve.segments.get();
                        for (const Ve of Fe)
                            W.push({ segments: new s.bd([Ve]), sortKey: Ve.sortKey, state: vt });
                    }
                    else
                        W.push({ segments: ve.segments, sortKey: 0, state: vt });
                } T && W.sort((de, me) => de.sortKey - me.sortKey); const oe = { useDepthForOcclusion: O.depthOcclusionForSymbolsAndCircles }; for (const de of W) {
                    const { programConfiguration: me, program: we, layoutVertexBuffer: ve, globeExtVertexBuffer: xe, indexBuffer: ge, uniformValues: Se, tile: Ce } = de.state, je = de.segments;
                    d.terrain && d.terrain.setupElevationDraw(Ce, we, oe), d.uploadCommonUniforms(P, we, Ce.tileID.toUnwrapped()), we.draw(d, R.TRIANGLES, D, B, q, fr.disabled, Se, l.id, ve, ge, je, l.paint, O.zoom, me, [xe]);
                } }, heatmap: function (d, n, l, f) { if (l.paint.get("heatmap-opacity") !== 0)
                    if (d.renderPass === "offscreen") {
                        const _ = d.context, v = _.gl, w = dr.disabled, T = new Rr([v.ONE, v.ONE, v.ONE, v.ONE], s.am.transparent, [!0, !0, !0, !0]);
                        (function (B, q, G, K) { const W = B.gl, oe = q.width * K, de = q.height * K; B.activeTexture.set(W.TEXTURE1), B.viewport.set([0, 0, oe, de]); let me = G.heatmapFbo; if (!me || me && (me.width !== oe || me.height !== de)) {
                            me && me.destroy();
                            const we = W.createTexture();
                            W.bindTexture(W.TEXTURE_2D, we), W.texParameteri(W.TEXTURE_2D, W.TEXTURE_WRAP_S, W.CLAMP_TO_EDGE), W.texParameteri(W.TEXTURE_2D, W.TEXTURE_WRAP_T, W.CLAMP_TO_EDGE), W.texParameteri(W.TEXTURE_2D, W.TEXTURE_MIN_FILTER, W.LINEAR), W.texParameteri(W.TEXTURE_2D, W.TEXTURE_MAG_FILTER, W.LINEAR), me = G.heatmapFbo = B.createFramebuffer(oe, de, !0, null), function (ve, xe, ge, Se, Ce, je) { const ze = ve.gl; ze.texImage2D(ze.TEXTURE_2D, 0, ve.extRenderToTextureHalfFloat ? ze.RGBA16F : ze.RGBA, Ce, je, 0, ze.RGBA, ve.extRenderToTextureHalfFloat ? ze.HALF_FLOAT : ze.UNSIGNED_BYTE, null), Se.colorAttachment.set(ge); }(B, 0, we, me, oe, de);
                        }
                        else
                            W.bindTexture(W.TEXTURE_2D, me.colorAttachment.get()), B.bindFramebuffer.set(me.framebuffer); })(_, d, l, d.transform.projection.name === "globe" ? .5 : .25), _.clear({ color: s.am.transparent });
                        const C = d.transform, P = C.projection.name === "globe", R = P ? ["PROJECTION_GLOBE_VIEW"] : [], O = P ? fr.frontCCW : fr.disabled, D = [s.ay(C.center.lng), s.aH(C.center.lat)];
                        for (let B = 0; B < f.length; B++) {
                            const q = f[B];
                            if (n.hasRenderableParent(q))
                                continue;
                            const G = n.getTile(q), K = G.getBucket(l);
                            if (!K || K.projection.name !== C.projection.name)
                                continue;
                            const W = d.isTileAffectedByFog(q), oe = K.programConfigurations.get(l.id), de = d.getOrCreateProgram("heatmap", { config: oe, defines: R, overrideFog: W }), { zoom: me } = d.transform;
                            d.terrain && d.terrain.setupElevationDraw(G, de), d.uploadCommonUniforms(_, de, q.toUnwrapped());
                            const we = C.projection.createInversionMatrix(C, q.canonical);
                            de.draw(d, v.TRIANGLES, Ut.disabled, w, T, O, j0(d, q, G, we, D, me, l.paint.get("heatmap-intensity")), l.id, K.layoutVertexBuffer, K.indexBuffer, K.segments, l.paint, d.transform.zoom, oe, P ? [K.globeExtVertexBuffer] : null);
                        }
                        _.viewport.set([0, 0, d.width, d.height]);
                    }
                    else
                        d.renderPass === "translucent" && (d.context.setColorMode(d.colorModeForRenderPass()), function (_, v) { const w = _.context, T = w.gl, C = v.heatmapFbo; if (!C)
                            return; w.activeTexture.set(T.TEXTURE0), T.bindTexture(T.TEXTURE_2D, C.colorAttachment.get()), w.activeTexture.set(T.TEXTURE1); let P = v.colorRampTexture; P || (P = v.colorRampTexture = new s.T(w, v.colorRamp, T.RGBA8)), P.bind(T.LINEAR, T.CLAMP_TO_EDGE), _.getOrCreateProgram("heatmapTexture").draw(_, T.TRIANGLES, Ut.disabled, dr.disabled, _.colorModeForRenderPass(), fr.disabled, ((R, O, D, B) => ({ u_image: 0, u_color_ramp: 1, u_opacity: O.paint.get("heatmap-opacity") }))(0, v), v.id, _.viewportBuffer, _.quadTriangleIndexBuffer, _.viewportSegments, v.paint, _.transform.zoom); }(d, l)); }, line: function (d, n, l, f) { if (d.renderPass !== "translucent")
                    return; const _ = l.paint.get("line-opacity"), v = l.paint.get("line-width"); if (_.constantOr(1) === 0 || v.constantOr(1) === 0)
                    return; const w = l.paint.get("line-emissive-strength"), T = l.paint.get("line-occlusion-opacity"), C = l.layout.get("line-elevation-reference"), P = l.layout.get("line-width-unit") === "meters", R = C === "sea", O = !(!d.terrain || !d.terrain.enabled), D = d.context, B = D.gl; if (l.hasElevatedBuckets && d.transform.projection.name === "globe")
                    return; const q = l.layout.get("line-cross-slope"), G = q !== void 0, K = q < 1, W = d.colorModeForDrapableLayerRenderPass(w), oe = d.terrain && d.terrain.renderingToTexture, de = oe ? 1 : s.q.devicePixelRatio, me = l.paint.get("line-dasharray"), we = me.constantOr(1), ve = l.layout.get("line-cap"), xe = me.constantOr(null), ge = ve.constantOr(null), Se = l.paint.get("line-pattern"), Ce = Se.constantOr(1), je = l.paint.get("line-pattern-cross-fade"), ze = Se.constantOr(null), rt = l.paint.get("line-opacity").constantOr(1); let et = !Ce && rt !== 1 || d.depthOcclusion && T > 0 && T < 1; const vt = l.paint.get("line-gradient"), Fe = Ce ? "linePattern" : "line", Ve = s.dM(l); let Le; if (oe && d.terrain && d.terrain.clipOrMaskOverlapStencilType() && (et = !1), T !== 0 && d.depthOcclusion) {
                    const nt = l.paint._values["line-opacity"];
                    nt && nt.value && nt.value.kind === "constant" ? Le = nt.value : s.w(`Occlusion opacity for layer ${l.id} is supported only when line-opacity isn't data-driven.`);
                } v.value.kind !== "constant" && v.value.isLineProgressConstant === !1 && Ve.push("VARIABLE_LINE_WIDTH"); const st = (nt, dt, ft, Vt, Xt, Bt) => { for (const Yt of nt) {
                    const $t = n.getTile(Yt);
                    if (Ce && !$t.patternsLoaded())
                        continue;
                    const or = $t.getBucket(l);
                    if (!or || or.elevationType !== "none" && !Xt || or.elevationType === "none" && Xt)
                        continue;
                    d.prepareDrawTile();
                    const mr = [...dt], Nr = d.shadowRenderer, vn = or.elevationType === "road" && !!Nr && Nr.enabled;
                    let fn = [0, 0, 0];
                    if (vn) {
                        const Cr = d.style.directionalLight, qn = d.style.ambientLight;
                        Cr && qn && (fn = Sa(d.style, Cr, qn)), mr.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
                    }
                    const jr = or.programConfigurations.get(l.id);
                    let hi = !1;
                    if (ze && $t.imageAtlas) {
                        const Cr = s.dN.from(ze), qn = Cr.getPrimary().scaleSelf(de).toString(), Xr = $t.imageAtlas.patternPositions.get(qn), Hn = Cr.getSecondary(), sn = Hn ? $t.imageAtlas.patternPositions.get(Hn.scaleSelf(de).toString()) : null;
                        hi = !!Xr && !!sn, Xr && jr.setConstantPatternPositions(Xr, sn);
                    }
                    je > 0 && (hi || jr.getPatternTransitionVertexBuffer("line-pattern")) && mr.push("LINE_PATTERN_TRANSITION");
                    const Jn = d.isTileAffectedByFog(Yt), xr = d.getOrCreateProgram(Fe, { config: jr, defines: mr, overrideFog: Jn, overrideRtt: !Xt && void 0 });
                    if (!Ce && xe && ge && $t.lineAtlas) {
                        const Cr = $t.lineAtlas.getDash(xe, ge);
                        Cr && jr.setConstantPatternPositions(Cr);
                    }
                    vn && Nr.setupShadows($t.tileID.toUnwrapped(), xr, "vector-tile", $t.tileID.overscaledZ);
                    let [Hr, Qr] = l.paint.get("line-trim-offset");
                    (ge === "round" || ge === "square") && Hr !== Qr && (Hr === 0 && (Hr -= 1), Qr === 1 && (Qr += 1));
                    const xn = oe ? Yt.projMatrix : null, Ii = P ? 1 / or.tileToMeter / s.aw($t, 1, d.transform.zoom) : 1, _i = P ? 1 / or.tileToMeter / s.aw($t, 1, Math.floor(d.transform.zoom)) : 1, Ci = Ce ? s.dO(d, $t, l, xn, de, Ii, _i, [Hr, Qr], fn, je) : s.dP(d, $t, l, xn, or.lineClipsArray.length, de, Ii, _i, [Hr, Qr], fn);
                    if (vt) {
                        const Cr = or.gradients[l.id];
                        let qn = Cr.texture;
                        if (l.gradientVersion !== Cr.version) {
                            let Xr = 256;
                            if (l.stepInterpolant) {
                                const Hn = n.getSource().maxzoom, sn = Yt.canonical.z === Hn ? Math.ceil(1 << d.transform.maxZoom - Yt.canonical.z) : 1;
                                Xr = s.aD(s.dQ(or.maxLineLength / s.aj * 1024 * sn), 256, D.maxTextureSize);
                            }
                            Cr.gradient = s.dR({ expression: l.gradientExpression(), evaluationKey: "lineProgress", resolution: Xr, image: Cr.gradient || void 0, clips: or.lineClipsArray }), Cr.texture ? Cr.texture.update(Cr.gradient) : Cr.texture = new s.T(D, Cr.gradient, B.RGBA8), Cr.version = l.gradientVersion, qn = Cr.texture;
                        }
                        D.activeTexture.set(B.TEXTURE1), qn.bind(l.stepInterpolant ? B.NEAREST : B.LINEAR, B.CLAMP_TO_EDGE);
                    }
                    we && (D.activeTexture.set(B.TEXTURE0), $t.lineAtlasTexture && $t.lineAtlasTexture.bind(B.LINEAR, B.REPEAT), jr.updatePaintBuffers()), Ce && (D.activeTexture.set(B.TEXTURE0), $t.imageAtlasTexture && $t.imageAtlasTexture.bind(B.LINEAR, B.CLAMP_TO_EDGE), jr.updatePaintBuffers()), Xt && !R && d.terrain.setupElevationDraw($t, xr), d.uploadCommonUniforms(D, xr, Yt.toUnwrapped());
                    const Kn = Cr => { Le != null && (Le.value = rt * T), xr.draw(d, B.TRIANGLES, ft, Cr, W, fr.disabled, Ci, l.id, or.layoutVertexBuffer, or.indexBuffer, or.segments, l.paint, d.transform.zoom, jr, [or.layoutVertexBuffer2, or.patternVertexBuffer, or.zOffsetVertexBuffer]), Le != null && (Le.value = rt); };
                    if (et && !Xt) {
                        const Cr = d.stencilModeForClipping(Yt).ref;
                        Cr === 0 && oe && D.clear({ stencil: 0 });
                        const qn = { func: B.EQUAL, mask: 255 };
                        Ci.u_alpha_discard_threshold = .8, Kn(new dr(qn, Cr, 255, B.KEEP, B.KEEP, B.INVERT)), Ci.u_alpha_discard_threshold = 0, Kn(new dr(qn, Cr, 255, B.KEEP, B.KEEP, B.KEEP));
                    }
                    else
                        Ci.u_alpha_discard_threshold = et && Xt && Bt ? .8 : 0, Kn(Xt ? Vt : d.stencilModeForClipping(Yt));
                } }; let He = d.depthModeForSublayer(0, Ut.ReadOnly); const ht = new Ut(d.depthOcclusion ? B.GREATER : B.LEQUAL, Ut.ReadOnly, d.depthRangeFor3D); if (l.hasNonElevatedBuckets) {
                    const nt = !oe && d.terrain;
                    T !== 0 && nt ? s.w(`Occlusion opacity for layer ${l.id} is supported on terrain only if the layer has line-z-offset enabled.`) : nt ? s.w(`Cannot render non-elevated lines in immediate mode when terrain is enabled. Layer: ${l.id}.`) : st(f, Ve, He, dr.disabled, !1, !0);
                } if (l.hasElevatedBuckets) {
                    C === "hd-road-markup" ? O || (He = ht, Ve.push("ELEVATED_ROADS")) : (Ve.push("ELEVATED"), He = ht, G && Ve.push(K ? "CROSS_SLOPE_HORIZONTAL" : "CROSS_SLOPE_VERTICAL"), R && Ve.push("ELEVATION_REFERENCE_SEA"));
                    const nt = et ? d.stencilModeFor3D() : dr.disabled;
                    d.forceTerrainMode = !0, st(f, Ve, He, nt, !0, !0), et && st(f, Ve, He, nt, !0, !1), d.forceTerrainMode = !1;
                } et && (d.resetStencilClippingMasks(), oe && D.clear({ stencil: 0 })), T === 0 || d.depthOcclusion || oe || d.layersWithOcclusionOpacity.push(d.currentLayer); }, fill: function (d, n, l, f) { const _ = l.paint.get("fill-color"), v = l.paint.get("fill-opacity"); if (v.constantOr(1) === 0)
                    return; const w = l.paint.get("fill-emissive-strength"), T = d.colorModeForDrapableLayerRenderPass(w), C = l.paint.get("fill-pattern"), P = d.opaquePassEnabledForLayer() && !C.constantOr(1) && _.constantOr(s.am.transparent).a === 1 && v.constantOr(0) === 1 ? "opaque" : "translucent"; let R = "none"; l.layout.get("fill-elevation-reference") !== "none" ? R = "road" : l.paint.get("fill-z-offset").constantOr(1) !== 0 && (R = "offset"); const O = !(!d.terrain || !d.terrain.enabled), D = { painter: d, sourceCache: n, layer: l, coords: f, colorMode: T, elevationType: R, terrainEnabled: O, pass: P }; if (d.renderPass !== "shadow")
                    if (R !== "offset") {
                        if (Nt(D, !1), R === "road") {
                            const B = !O && d.renderPass === "translucent";
                            B && Rd(d, n, l, f, "geometry"), Nt(D, !0, dr.disabled), B && function (q) { const { painter: G, sourceCache: K, layer: W, coords: oe, colorMode: de } = q, me = G.context.gl, we = q.painter.shadowRenderer, ve = !!we && we.enabled, xe = new Ut(G.context.gl.LEQUAL, Ut.ReadOnly, G.depthRangeFor3D); let ge = [0, 0, 0]; if (ve) {
                                const Se = G.style.directionalLight, Ce = G.style.ambientLight;
                                Se && Ce && (ge = Sa(G.style, Se, Ce));
                            } for (const Se of oe) {
                                const Ce = K.getTile(Se), je = Ce.getBucket(W);
                                if (!je)
                                    continue;
                                const ze = je.elevatedStructures;
                                if (!ze || !ze.renderableSegments || ze.renderableSegments.segments[0].primitiveLength === 0)
                                    continue;
                                G.prepareDrawTile();
                                const rt = je.bufferData.programConfigurations.get(W.id), et = G.isTileAffectedByFog(Se), vt = [];
                                ve && vt.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
                                const Fe = G.getOrCreateProgram("elevatedStructures", { config: rt, overrideFog: et, defines: vt }), Ve = G.translatePosMatrix(Se.projMatrix, Ce, W.paint.get("fill-translate"), W.paint.get("fill-translate-anchor"));
                                ve && we.setupShadows(Ce.tileID.toUnwrapped(), Fe, "vector-tile", Ce.tileID.overscaledZ);
                                const Le = u_(Ve, ge);
                                G.uploadCommonUniforms(G.context, Fe, Se.toUnwrapped()), Fe.draw(G, me.TRIANGLES, xe, dr.disabled, de, fr.backCCW, Le, W.id, ze.vertexBuffer, ze.indexBuffer, ze.renderableSegments, W.paint, G.transform.zoom, rt, [ze.vertexBufferNormal]);
                            } }(D);
                        }
                    }
                    else
                        Nt(D, !1, d.stencilModeFor3D());
                else
                    d.shadowRenderer && R === "road" && !O && function (B) { const { painter: q, sourceCache: G, layer: K, coords: W } = B, oe = q.context.gl, de = B.painter.shadowRenderer; for (const me of W) {
                        const we = G.getTile(me), ve = we.getBucket(K);
                        if (!ve)
                            continue;
                        const xe = ve.elevatedStructures;
                        if (!xe || !xe.shadowCasterSegments || xe.shadowCasterSegments.segments[0].primitiveLength === 0)
                            continue;
                        q.prepareDrawTile();
                        const ge = ve.bufferData.programConfigurations.get(K.id), Se = q.isTileAffectedByFog(me), Ce = q.getOrCreateProgram("elevatedStructuresDepth", { config: ge, overrideFog: Se }), je = de.calculateShadowPassMatrixFromTile(we.tileID.toUnwrapped());
                        q.uploadCommonUniforms(q.context, Ce, me.toUnwrapped());
                        const ze = { u_matrix: je, u_depth_bias: .001 };
                        Ce.draw(q, oe.TRIANGLES, de.getShadowPassDepthMode(), dr.disabled, de.getShadowPassColorMode(), fr.disabled, ze, K.id, xe.vertexBuffer, xe.indexBuffer, xe.shadowCasterSegments, K.paint, q.transform.zoom, ge);
                    } }(D); }, "fill-extrusion": function (d, n, l, f) { const _ = l.paint.get("fill-extrusion-opacity"), v = d.context, w = v.gl, T = d.terrain, C = T && T.renderingToTexture; if (_ === 0)
                    return; const P = d.conflationActive && d.style.isLayerClipped(l, n.getSource()), R = d.style.order.indexOf(l.fqid); if (P && function (O, D, B, q, G) { for (const K of q) {
                    const W = D.getTile(K).getBucket(B);
                    W && (W.updateReplacement(K, O.replacementSource, G), W.uploadCentroid(O.context));
                } }(d, n, l, f, R), T || P)
                    for (const O of f) {
                        const D = n.getTile(O).getBucket(l);
                        D && zl(d.context, n, O, D, l, T, P);
                    } if (d.renderPass === "shadow" && d.shadowRenderer) {
                    const O = d.shadowRenderer;
                    if (T && _ < .65 && l._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof s.ab)
                        return;
                    const D = O.getShadowPassDepthMode(), B = O.getShadowPassColorMode();
                    kd(d, n, l, f, D, dr.disabled, B, P);
                }
                else if (d.renderPass === "translucent") {
                    const O = !l.paint.get("fill-extrusion-pattern").constantOr(1), D = l.paint.get("fill-extrusion-color").constantOr(s.am.white);
                    if (!C && D.a !== 0) {
                        const B = new Ut(d.context.gl.LEQUAL, Ut.ReadWrite, d.depthRangeFor3D);
                        _ === 1 && O ? kd(d, n, l, f, B, dr.disabled, Rr.unblended, P) : (kd(d, n, l, f, B, dr.disabled, Rr.disabled, P), kd(d, n, l, f, B, d.stencilModeFor3D(), d.colorModeForRenderPass(), P), d.resetStencilClippingMasks());
                    }
                    if (d.style.enable3dLights() && O && (!T && d.transform.projection.name !== "globe" || C)) {
                        const B = l.paint.get("fill-extrusion-opacity"), q = l.paint.get("fill-extrusion-ambient-occlusion-intensity"), G = l.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), K = l.paint.get("fill-extrusion-flood-light-intensity"), W = l.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default") === "none", oe = l.paint.get("fill-extrusion-flood-light-color").toRenderColor(W ? null : l.lut).toArray01().slice(0, 3), de = q > 0 && G > 0, me = K > 0, we = (xe, ge, Se) => (1 - Se) * xe + Se * ge, ve = xe => { const ge = d.depthModeForSublayer(1, Ut.ReadOnly, w.LEQUAL, !0), Se = l.paint.get(xe ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), Ce = we(.1, 3, Se), je = d._showOverdrawInspector; if (!je) {
                            const ze = new dr({ func: w.ALWAYS, mask: 255 }, 255, 255, w.KEEP, w.KEEP, w.REPLACE), rt = new Rr([w.ONE, w.ONE, w.ONE, w.ONE], s.am.transparent, [!1, !1, !1, !0], w.MIN);
                            Lc(d, n, l, f, ge, ze, rt, fr.disabled, xe, "sdf", B, q, G, K, oe, Ce, P, !1);
                        } {
                            const ze = je ? dr.disabled : new dr({ func: w.EQUAL, mask: 255 }, 255, 255, w.KEEP, w.DECR, w.DECR), rt = je ? d.colorModeForRenderPass() : new Rr([w.ONE_MINUS_DST_ALPHA, w.DST_ALPHA, w.ONE, w.ONE], s.am.transparent, [!0, !0, !0, !0]);
                            Lc(d, n, l, f, ge, ze, rt, fr.disabled, xe, "color", B, q, G, K, oe, Ce, P, !1);
                        } };
                        if (C) {
                            const xe = (ge, Se, Ce) => { const je = d.depthModeForSublayer(1, Ut.ReadOnly, w.LEQUAL, !1), ze = l.paint.get(ge ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), rt = we(.1, 3, ze); {
                                const et = new Rr([w.ONE, w.ONE, w.ONE, w.ONE], s.am.transparent, [!1, !1, !1, !0]);
                                Lc(d, n, l, f, je, dr.disabled, et, fr.disabled, ge, "clear", B, q, G, K, oe, rt, P, Se);
                            } {
                                const et = new dr({ func: w.ALWAYS, mask: 255 }, 255, 255, w.KEEP, w.KEEP, w.REPLACE), vt = new Rr([w.ONE, w.ONE, w.ONE, w.ONE], s.am.transparent, [!1, !1, !1, !0], w.MIN);
                                Lc(d, n, l, f, je, et, vt, fr.disabled, ge, "sdf", B, q, G, K, oe, rt, P, Se);
                            } {
                                const et = ge ? w.ZERO : w.ONE_MINUS_DST_ALPHA, vt = new dr({ func: w.EQUAL, mask: 255 }, 255, 255, w.KEEP, w.DECR, w.DECR), Fe = new Rr([et, w.DST_ALPHA, w.ONE_MINUS_DST_ALPHA, w.ZERO], s.am.transparent, [!0, !0, !0, !0]);
                                Lc(d, n, l, f, je, vt, Fe, fr.disabled, ge, "color", B, q, G, K, oe, rt, P, Se);
                            } {
                                const et = new Rr([w.ONE, w.ONE, w.ONE, ge ? w.ZERO : w.ONE], s.am.transparent, [!1, !1, !1, !0], ge ? w.FUNC_ADD : w.MAX);
                                Lc(d, n, l, f, je, dr.disabled, et, fr.disabled, ge, "clear", B, q, G, K, oe, rt, P, Se, Ce);
                            } };
                            if (de || me) {
                                let ge;
                                if (d.prepareDrawTile(), T) {
                                    const Se = T.drapeBufferSize[0], Ce = T.drapeBufferSize[1];
                                    ge = T.framebufferCopyTexture, ge && (!ge || ge.size[0] === Se && ge.size[1] === Ce) || (ge && ge.destroy(), ge = T.framebufferCopyTexture = new s.T(v, new s.r({ width: Se, height: Ce }), w.RGBA8)), ge.bind(w.LINEAR, w.CLAMP_TO_EDGE), w.copyTexSubImage2D(w.TEXTURE_2D, 0, 0, 0, 0, 0, Se, Ce);
                                }
                                de && xe(!0, !1, ge), me && xe(!1, !0, ge);
                            }
                        }
                        else
                            de && ve(!0), me && ve(!1), (de || me) && d.resetStencilClippingMasks();
                    }
                } }, hillshade: function (d, n, l, f) { if (d.renderPass !== "offscreen" && d.renderPass !== "translucent" || d.style.disableElevatedTerrain)
                    return; const _ = d.context, v = d.terrain && d.terrain.renderingToTexture, [w, T] = d.renderPass !== "translucent" || v ? [{}, f] : d.stencilConfigForOverlap(f); for (const C of T) {
                    const P = n.getTile(C);
                    if (P.needsHillshadePrepare && d.renderPass === "offscreen")
                        Kg(d, P, l);
                    else if (d.renderPass === "translucent") {
                        const R = d.depthModeForSublayer(0, Ut.ReadOnly), O = l.paint.get("hillshade-emissive-strength"), D = d.colorModeForDrapableLayerRenderPass(O), B = v && d.terrain ? d.terrain.stencilModeForRTTOverlap(C) : w[C.overscaledZ];
                        E0(d, C, P, l, R, B, D);
                    }
                } _.viewport.set([0, 0, d.width, d.height]), d.resetStencilClippingMasks(); }, raster: function (d, n, l, f, _, v) { if (d.renderPass !== "translucent" || l.paint.get("raster-opacity") === 0)
                    return; const w = d.transform.projection.name === "globe", T = l.paint.get("raster-elevation") !== 0, C = T && w; if (d.renderElevatedRasterBackface && !C)
                    return; const P = d.context, R = P.gl, O = n.getSource(), D = function (ve, xe, ge, Se) { const Ce = xe.paint.get("raster-color"), je = ve.type === "raster-array", ze = [], rt = xe.paint.get("raster-resampling"), et = xe.paint.get("raster-color-mix"); let vt = xe.paint.get("raster-color-range"); const Fe = [et[0], et[1], et[2], 0], Ve = et[3]; let Le = rt === "nearest" ? Se.NEAREST : Se.LINEAR; if (je && (ze.push("RASTER_ARRAY"), Ce || ze.push("RASTER_COLOR"), rt === "linear" && ze.push("RASTER_ARRAY_LINEAR"), Le = Se.NEAREST, !vt && ve.rasterLayers)) {
                    const st = ve.rasterLayers.find(({ id: He }) => He === xe.sourceLayer);
                    st && st.fields && st.fields.range && (vt = st.fields.range);
                } if (vt = vt || [0, 1], Ce) {
                    ze.push("RASTER_COLOR"), ge.activeTexture.set(Se.TEXTURE2), xe.updateColorRamp(vt);
                    let st = xe.colorRampTexture;
                    st || (st = xe.colorRampTexture = new s.T(ge, xe.colorRamp, Se.RGBA8)), st.bind(Se.LINEAR, Se.CLAMP_TO_EDGE);
                } return { mix: Fe, range: vt, offset: Ve, defines: ze, resampling: Le }; }(O, l, P, R); if (O instanceof s.aP && !f.length && !w)
                    return; const B = l.paint.get("raster-emissive-strength"), q = d.colorModeForDrapableLayerRenderPass(B), G = d.terrain && d.terrain.renderingToTexture, K = !d.options.moving, W = l.paint.get("raster-resampling") === "nearest" ? R.NEAREST : R.LINEAR; if (O instanceof s.aP && !f.length && (O.onNorthPole || O.onSouthPole)) {
                    const ve = T ? d.stencilModeFor3D() : dr.disabled;
                    return void Dd(!!O.onNorthPole, null, d, n, l, B, D, fr.disabled, ve);
                } if (!f.length)
                    return; const [oe, de] = O instanceof s.aP || G ? [{}, f] : d.stencilConfigForOverlap(f), me = de[de.length - 1].overscaledZ; C && D.defines.push("PROJECTION_GLOBE_VIEW"), T && D.defines.push("RENDER_CUTOFF"); const we = (ve, xe, ge) => { for (const Se of ve) {
                    const Ce = Se.toUnwrapped(), je = n.getTile(Se);
                    if (G && (!je || !je.hasData()))
                        continue;
                    P.activeTexture.set(R.TEXTURE0);
                    const ze = fT(je, O, l, D);
                    if (!ze || !ze.texture)
                        continue;
                    const { texture: rt, mix: et, offset: vt, tileSize: Fe, buffer: Ve } = ze;
                    let Le, st;
                    G ? (Le = Ut.disabled, st = Se.projMatrix) : T ? (Le = new Ut(R.LEQUAL, Ut.ReadWrite, d.depthRangeFor3D), st = w ? Float32Array.from(d.transform.expandedFarZProjMatrix) : d.transform.calculateProjMatrix(Ce, K)) : (Le = d.depthModeForSublayer(Se.overscaledZ - me, l.paint.get("raster-opacity") === 1 ? Ut.ReadWrite : Ut.ReadOnly, R.LESS), st = d.transform.calculateProjMatrix(Ce, K));
                    const He = d.terrain && G ? d.terrain.stencilModeForRTTOverlap(Se) : oe[Se.overscaledZ], ht = v ? 0 : l.paint.get("raster-fade-duration");
                    je.registerFadeDuration(ht);
                    const nt = n.findLoadedParent(Se, 0), dt = Ed(je, nt, n, d.transform, ht);
                    let ft, Vt;
                    d.terrain && d.terrain.prepareDrawTile(), P.activeTexture.set(R.TEXTURE0), rt.bind(W, R.CLAMP_TO_EDGE), P.activeTexture.set(R.TEXTURE1), nt ? (nt.texture && nt.texture.bind(W, R.CLAMP_TO_EDGE), ft = Math.pow(2, nt.tileID.overscaledZ - je.tileID.overscaledZ), Vt = [je.tileID.canonical.x * ft % 1, je.tileID.canonical.y * ft % 1]) : rt.bind(W, R.CLAMP_TO_EDGE), "useMipmap" in rt && P.extTextureFilterAnisotropic && d.transform.pitch > 20 && R.texParameterf(R.TEXTURE_2D, P.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, P.extTextureFilterAnisotropicMax);
                    const Xt = d.transform;
                    let Bt;
                    const Yt = T ? H0(Xt) : [0, 0, 0, 0];
                    let $t, or, mr, Nr, vn, fn = 0;
                    if (C && O instanceof s.aP && O.coordinates.length > 3)
                        $t = Float32Array.from(s.bh(s.dr(new s.cp(0, 0, 0)))), or = Float32Array.from(Xt.globeMatrix), mr = Float32Array.from(s.dm(Xt)), Nr = [s.ay(Xt.center.lng), s.aH(Xt.center.lat)], Bt = O.elevatedGlobePerspectiveTransform, vn = O.elevatedGlobeGridMatrix || new Float32Array(9);
                    else if (C) {
                        const xr = s.dn(Se.canonical);
                        fn = s.dp(xr.getCenter().lat), $t = Float32Array.from(s.bh(s.dr(Se.canonical))), or = Float32Array.from(Xt.globeMatrix), mr = Float32Array.from(s.dm(Xt)), Nr = [s.ay(Xt.center.lng), s.aH(Xt.center.lat)], Bt = [0, 0], vn = Float32Array.from(s.dq(Se.canonical, xr, fn, Xt.worldSize / Xt._pixelsPerMercatorPixel));
                    }
                    else
                        Bt = O instanceof s.aP ? O.perspectiveTransform : [0, 0], $t = new Float32Array(16), or = new Float32Array(9), mr = new Float32Array(16), Nr = [0, 0], vn = new Float32Array(9);
                    const jr = Ol(st, $t, or, mr, vn, Vt || [0, 0], s.ah(d.transform.zoom), Nr, Yt, ft || 1, dt, l, Bt, T ? l.paint.get("raster-elevation") : 0, 2, et, vt, D.range, Fe, Ve, B), hi = d.isTileAffectedByFog(Se), Jn = d.getOrCreateProgram("raster", { defines: D.defines, overrideFog: hi });
                    if (d.uploadCommonUniforms(P, Jn, Ce), O instanceof s.aP) {
                        const xr = O.elevatedGlobeVertexBuffer, Hr = O.elevatedGlobeIndexBuffer;
                        if (G || !w)
                            O.boundsBuffer && O.boundsSegments && Jn.draw(d, R.TRIANGLES, Le, dr.disabled, q, fr.disabled, jr, l.id, O.boundsBuffer, d.quadTriangleIndexBuffer, O.boundsSegments);
                        else if (xr && Hr) {
                            const Qr = Xt.zoom <= s.cL ? O.elevatedGlobeSegments : O.getSegmentsForLongitude(Xt.center.lng);
                            Qr && Jn.draw(d, R.TRIANGLES, Le, dr.disabled, q, xe, jr, l.id, xr, Hr, Qr);
                        }
                    }
                    else if (C) {
                        Le = new Ut(R.LEQUAL, Ut.ReadOnly, d.depthRangeFor3D);
                        const xr = d.globeSharedBuffers;
                        if (xr) {
                            const [Hr, Qr, xn] = xr.getGridBuffers(fn, !1);
                            Jn.draw(d, R.TRIANGLES, Le, ge || He, d.colorModeForRenderPass(), xe, jr, l.id, Hr, Qr, xn);
                        }
                    }
                    else {
                        const { tileBoundsBuffer: xr, tileBoundsIndexBuffer: Hr, tileBoundsSegments: Qr } = d.getTileBoundsBuffers(je);
                        Jn.draw(d, R.TRIANGLES, Le, He, q, fr.disabled, jr, l.id, xr, Hr, Qr);
                    }
                } if (!(O instanceof s.aP) && C)
                    for (const Se of ve) {
                        const Ce = Se.canonical.y === (1 << Se.canonical.z) - 1;
                        Se.canonical.y === 0 && Dd(!0, Se, d, n, l, B, D, xe, ge || dr.disabled), Ce && Dd(!1, Se, d, n, l, B, D, xe === fr.frontCW ? fr.backCW : fr.frontCW, ge || dr.disabled);
                    } }; C ? we(de, d.renderElevatedRasterBackface ? fr.backCW : fr.frontCW, d.stencilModeFor3D()) : we(de, fr.disabled, void 0), d.resetStencilClippingMasks(); }, "raster-particle": function (d, n, l, f, _, v) { d.renderPass === "offscreen" && function (w, T, C, P) { if (!P.length)
                    return; const R = w.context, O = R.gl, D = T.getSource(); if (!(D instanceof _c))
                    return; const B = Math.ceil(Math.sqrt(C.paint.get("raster-particle-count"))); let q = C.particlePositionRGBAImage; if (!q || q.width !== B) {
                    const de = function (me) { const we = me * me, ve = new Uint8Array(4 * we), xe = function (Se) { return Se |= 0, Se = Math.imul(2747636419 ^ Se, 2654435769), Se = Math.imul(Se ^ Se >>> 16, 2654435769), ((Se = Math.imul(Se ^ Se >>> 16, 2654435769)) >>> 0) / 4294967296; }, ge = 1 / 1.1; for (let Se = 0; Se < we; Se++) {
                        const Ce = ge * (xe(2 * Se + 0) + mo), je = ge * (xe(2 * Se + 1) + mo), ze = 255 * Ce % 1, rt = 255 * je % 1, et = ze, vt = je - rt / 255, Fe = rt;
                        ve[4 * Se + 0] = 255 * (Ce - ze / 255), ve[4 * Se + 1] = 255 * et, ve[4 * Se + 2] = 255 * vt, ve[4 * Se + 3] = 255 * Fe;
                    } return ve; }(B);
                    q = C.particlePositionRGBAImage = new s.r({ width: B, height: B }, de);
                } let G = C.particleFramebuffer; G ? G.width !== B && (G.destroy(), G = C.particleFramebuffer = R.createFramebuffer(B, B, !0, null)) : G = C.particleFramebuffer = R.createFramebuffer(B, B, !0, null); const K = []; for (const de of P) {
                    const me = T.getTile(de);
                    if (!(me instanceof ud))
                        continue;
                    const we = mT(me, D, C);
                    if (!we)
                        continue;
                    const ve = [me.tileSize, me.tileSize];
                    let xe = C.tileFramebuffer;
                    xe || (xe = C.tileFramebuffer = R.createFramebuffer(ve[0], ve[1], !0, null));
                    let ge = me.rasterParticleState;
                    ge || (ge = me.rasterParticleState = new pT(R, de, ve, q));
                    const Se = ge.update(C.lastInvalidatedAt);
                    ge.particleTextureDimension !== B && ge.updateParticleTexture(de, q);
                    const Ce = ge.targetColorTexture;
                    ge.targetColorTexture = ge.backgroundColorTexture, ge.backgroundColorTexture = Ce;
                    const je = ge.particleTexture0;
                    ge.particleTexture0 = ge.particleTexture1, ge.particleTexture1 = je, K.push([de, we, ge, Se]);
                } if (K.length === 0)
                    return; const W = s.q.now(), oe = C.previousDrawTimestamp ? .001 * (W - C.previousDrawTimestamp) : .0167; if (C.previousDrawTimestamp = W, C.hasColorMap()) {
                    R.activeTexture.set(O.TEXTURE0 + 2);
                    let de = C.colorRampTexture;
                    de || (de = C.colorRampTexture = new s.T(R, C.colorRamp, O.RGBA8)), de.bind(O.LINEAR, O.CLAMP_TO_EDGE);
                } R.bindFramebuffer.set(C.tileFramebuffer.framebuffer), function (de, me, we) { const ve = de.context, xe = ve.gl, ge = me.tileFramebuffer; ve.activeTexture.set(xe.TEXTURE0); const Se = { u_texture: 0, u_opacity: 1.05 * (je = me.paint.get("raster-particle-fade-opacity-factor")) / (je + .05) }, Ce = de.getOrCreateProgram("rasterParticleTexture", { defines: [], overrideFog: !1 }); var je; for (const ze of we) {
                    const [, , rt, et] = ze;
                    ge.colorAttachment.set(rt.targetColorTexture.texture), ve.viewport.set([0, 0, ge.width, ge.height]), ve.clear({ color: s.am.transparent }), et && (rt.backgroundColorTexture.bind(xe.NEAREST, xe.CLAMP_TO_EDGE), Ce.draw(de, xe.TRIANGLES, Ut.disabled, dr.disabled, Rr.alphaBlended, fr.disabled, Se, me.id, de.viewportBuffer, de.quadTriangleIndexBuffer, de.viewportSegments));
                } }(w, C, K), function (de, me, we, ve) { const xe = de.context, ge = xe.gl, Se = we.tileFramebuffer, Ce = de.transform.projection.name === "globe", je = we.paint.get("raster-particle-max-speed"); for (const ze of ve) {
                    const [rt, et, vt] = ze;
                    xe.activeTexture.set(ge.TEXTURE0 + 0), et.texture.bind(ge.LINEAR, ge.CLAMP_TO_EDGE), Se.colorAttachment.set(vt.targetColorTexture.texture);
                    const Fe = de.getOrCreateProgram("rasterParticleDraw", { defines: et.defines, overrideFog: !1 });
                    xe.activeTexture.set(ge.TEXTURE0 + 1);
                    const Ve = et.scalarData ? [] : [0, 1, 2, 3].map(He => s.dU[He](rt));
                    Ve.push(rt);
                    const Le = rt.canonical.x, st = rt.canonical.y;
                    for (const He of Ve) {
                        const ht = me.getTile(Ce ? He.wrapped() : He);
                        if (!ht)
                            continue;
                        const nt = ht.rasterParticleState;
                        if (!nt)
                            continue;
                        const dt = He.canonical.x + (1 << He.canonical.z) * (He.wrap - rt.wrap), ft = He.canonical.y;
                        nt.particleTexture0.bind(ge.NEAREST, ge.CLAMP_TO_EDGE);
                        const Vt = Tp(1, nt.particleTexture0.size[0], [dt - Le, ft - st], 0, et.texture.size, 2, je, et.textureOffset, et.scale, et.offset);
                        Fe.draw(de, ge.POINTS, Ut.disabled, dr.disabled, Rr.alphaBlended, fr.disabled, Vt, we.id, nt.particleIndexBuffer, void 0, nt.particleSegment);
                    }
                } }(w, T, C, K), R.bindFramebuffer.set(C.particleFramebuffer.framebuffer), function (de, me, we, ve) { const xe = de.context, ge = xe.gl, Se = me.paint.get("raster-particle-max-speed"), Ce = ve * me.paint.get("raster-particle-speed-factor") * .15, je = function (rt) { return Math.pow(rt, 6); }(.01 + 1 * me.paint.get("raster-particle-reset-rate-factor")), ze = me.particleFramebuffer; xe.viewport.set([0, 0, ze.width, ze.height]); for (const rt of we) {
                    const [, et, vt] = rt;
                    xe.activeTexture.set(ge.TEXTURE0 + 0), et.texture.bind(ge.LINEAR, ge.CLAMP_TO_EDGE), xe.activeTexture.set(ge.TEXTURE0 + 1);
                    const Fe = vt.particleTexture0;
                    Fe.bind(ge.NEAREST, ge.CLAMP_TO_EDGE);
                    const Ve = U0(1, Fe.size[0], 0, et.texture.size, Se, Ce, je, et.textureOffset, et.scale, et.offset);
                    ze.colorAttachment.set(vt.particleTexture1.texture), xe.clear({ color: s.am.transparent }), de.getOrCreateProgram("rasterParticleUpdate", { defines: et.defines }).draw(de, ge.TRIANGLES, Ut.disabled, dr.disabled, Rr.unblended, fr.disabled, Ve, me.id, de.viewportBuffer, de.quadTriangleIndexBuffer, de.viewportSegments);
                } }(w, C, K, oe); }(d, n, l, f), d.renderPass === "translucent" && (function (w, T, C, P, R) { const O = w.context, D = O.gl, B = T.getSource().tileSize, q = 5 * (1 - s.af(s.cx, s.cx + 1, w.transform.zoom)) * B + C.paint.get("raster-particle-elevation"), G = !w.options.moving, K = w.transform.projection.name === "globe"; if (!P.length)
                    return; const [W, oe] = w.stencilConfigForOverlap(P), de = []; K && de.push("PROJECTION_GLOBE_VIEW"); const me = w.stencilModeFor3D(); for (const we of oe) {
                    const ve = we.toUnwrapped(), xe = T.getTile(we);
                    if (!xe.rasterParticleState)
                        continue;
                    const ge = xe.rasterParticleState, Se = 100;
                    xe.registerFadeDuration(Se);
                    const Ce = T.findLoadedParent(we, 0), je = Ed(xe, Ce, T, w.transform, Se);
                    let ze, rt;
                    w.terrain && w.terrain.prepareDrawTile(), O.activeTexture.set(D.TEXTURE0), ge.targetColorTexture.bind(D.LINEAR, D.CLAMP_TO_EDGE), O.activeTexture.set(D.TEXTURE1), Ce && Ce.rasterParticleState ? (Ce.rasterParticleState.targetColorTexture.bind(D.LINEAR, D.CLAMP_TO_EDGE), ze = Math.pow(2, Ce.tileID.overscaledZ - xe.tileID.overscaledZ), rt = [xe.tileID.canonical.x * ze % 1, xe.tileID.canonical.y * ze % 1]) : ge.targetColorTexture.bind(D.LINEAR, D.CLAMP_TO_EDGE);
                    const et = K ? Float32Array.from(w.transform.expandedFarZProjMatrix) : w.transform.calculateProjMatrix(ve, G), vt = w.transform, Fe = y_(vt), Ve = s.dn(we.canonical), Le = s.dp(Ve.getCenter().lat);
                    let st, He, ht, nt, dt;
                    K ? (st = Float32Array.from(s.bh(s.dr(we.canonical))), He = Float32Array.from(vt.globeMatrix), ht = Float32Array.from(s.dm(vt)), nt = [s.ay(vt.center.lng), s.aH(vt.center.lat)], dt = Float32Array.from(s.dq(we.canonical, Ve, Le, vt.worldSize / vt._pixelsPerMercatorPixel))) : (st = new Float32Array(16), He = new Float32Array(9), ht = new Float32Array(16), nt = [0, 0], dt = new Float32Array(9));
                    const ft = d_(et, st, He, ht, dt, rt || [0, 0], s.ah(w.transform.zoom), nt, Fe, ze || 1, je, q), Vt = w.isTileAffectedByFog(we), Xt = w.getOrCreateProgram("rasterParticle", { defines: de, overrideFog: Vt });
                    if (w.uploadCommonUniforms(O, Xt, ve), K) {
                        const Bt = new Ut(D.LEQUAL, Ut.ReadOnly, w.depthRangeFor3D), Yt = 0, $t = w.globeSharedBuffers;
                        if ($t) {
                            const [or, mr, Nr] = $t.getGridBuffers(Le, Yt !== 0);
                            Xt.draw(w, D.TRIANGLES, Bt, me, Rr.alphaBlended, w.renderElevatedRasterBackface ? fr.frontCCW : fr.backCCW, ft, C.id, or, mr, Nr);
                        }
                    }
                    else {
                        const Bt = w.depthModeForSublayer(0, Ut.ReadOnly), Yt = W[we.overscaledZ], { tileBoundsBuffer: $t, tileBoundsIndexBuffer: or, tileBoundsSegments: mr } = w.getTileBoundsBuffers(xe);
                        Xt.draw(w, D.TRIANGLES, Bt, Yt, Rr.alphaBlended, fr.disabled, ft, C.id, $t, or, mr);
                    }
                } w.resetStencilClippingMasks(); }(d, n, l, f), d.style.map.triggerRepaint()); }, background: function (d, n, l, f) { const _ = l.paint.get("background-color"), v = l.paint.get("background-color-use-theme").constantOr("default") === "none", w = l.paint.get("background-opacity"), T = l.paint.get("background-emissive-strength"), C = l.paint.get("background-pitch-alignment") === "viewport"; if (w === 0)
                    return; const P = d.context, R = P.gl, O = d.transform, D = O.tileSize, B = l.paint.get("background-pattern"); let q; if (B !== void 0 && (B === null || (q = d.imageManager.getPattern(s.I.from(B.toString()), l.scope, d.style.getLut(l.scope)), !q)))
                    return; const G = !B && _.a === 1 && w === 1 && d.opaquePassEnabledForLayer() ? "opaque" : "translucent"; if (d.renderPass !== G)
                    return; const K = dr.disabled, W = d.depthModeForSublayer(0, G === "opaque" ? Ut.ReadWrite : Ut.ReadOnly), oe = d.colorModeForDrapableLayerRenderPass(T), de = B ? "backgroundPattern" : "background"; let me, we = f; if (we || (me = d.getBackgroundTiles(), we = Object.values(me).map(ve => ve.tileID)), B && (P.activeTexture.set(R.TEXTURE0), d.imageManager.bind(d.context, l.scope)), C) {
                    const ve = d.getOrCreateProgram(de, { overrideFog: !1, overrideRtt: !0 }), xe = new Float32Array(s.bx([])), ge = new s.aM(0, 0, 0, 0, 0), Se = B ? $0(xe, T, w, d, 0, l.scope, q, C, { tileID: ge, tileSize: D }) : Ep(xe, T, w, _.toRenderColor(v ? null : l.lut));
                    ve.draw(d, R.TRIANGLES, W, K, oe, fr.disabled, Se, l.id, d.viewportBuffer, d.quadTriangleIndexBuffer, d.viewportSegments);
                }
                else
                    for (const ve of we) {
                        const xe = d.isTileAffectedByFog(ve), ge = d.getOrCreateProgram(de, { overrideFog: xe }), Se = ve.toUnwrapped(), Ce = f ? ve.projMatrix : d.transform.calculateProjMatrix(Se);
                        d.prepareDrawTile();
                        const je = n ? n.getTile(ve) : me ? me[ve.key] : new Xa(ve, D, O.zoom, d), ze = B ? $0(Ce, T, w, d, 0, l.scope, q, C, { tileID: ve, tileSize: D }) : Ep(Ce, T, w, _.toRenderColor(v ? null : l.lut));
                        d.uploadCommonUniforms(P, ge, Se);
                        const { tileBoundsBuffer: rt, tileBoundsIndexBuffer: et, tileBoundsSegments: vt } = d.getTileBoundsBuffers(je);
                        ge.draw(d, R.TRIANGLES, W, K, oe, fr.disabled, ze, l.id, rt, et, vt);
                    } }, sky: function (d, n, l) { const f = d._atmosphere ? s.ah(d.transform.zoom) : 1, _ = l.paint.get("sky-opacity") * f; if (_ === 0)
                    return; const v = d.context, w = l.paint.get("sky-type"), T = new Ut(v.gl.LEQUAL, Ut.ReadOnly, [0, 1]), C = d.frameCounter / 1e3 % 1; w === "atmosphere" ? d.renderPass === "offscreen" ? l.needsSkyboxCapture(d) && (function (P, R, O, D) { const B = P.context, q = B.gl; let G = R.skyboxFbo; if (!G) {
                    G = R.skyboxFbo = B.createFramebuffer(32, 32, !0, null), R.skyboxGeometry = new Ld(B), R.skyboxTexture = B.gl.createTexture(), q.bindTexture(q.TEXTURE_CUBE_MAP, R.skyboxTexture), q.texParameteri(q.TEXTURE_CUBE_MAP, q.TEXTURE_WRAP_S, q.CLAMP_TO_EDGE), q.texParameteri(q.TEXTURE_CUBE_MAP, q.TEXTURE_WRAP_T, q.CLAMP_TO_EDGE), q.texParameteri(q.TEXTURE_CUBE_MAP, q.TEXTURE_MIN_FILTER, q.LINEAR), q.texParameteri(q.TEXTURE_CUBE_MAP, q.TEXTURE_MAG_FILTER, q.LINEAR);
                    for (let de = 0; de < 6; ++de)
                        q.texImage2D(q.TEXTURE_CUBE_MAP_POSITIVE_X + de, 0, q.RGBA, 32, 32, 0, q.RGBA, q.UNSIGNED_BYTE, null);
                } B.bindFramebuffer.set(G.framebuffer), B.viewport.set([0, 0, 32, 32]); const K = R.getCenter(P, !0), W = P.getOrCreateProgram("skyboxCapture"), oe = new Float64Array(16); s.bx(oe), s.e3(oe, oe, .5 * -Math.PI), Bl(P, R, W, oe, K, 0), s.bx(oe), s.e3(oe, oe, .5 * Math.PI), Bl(P, R, W, oe, K, 1), s.bx(oe), s.cG(oe, oe, .5 * -Math.PI), Bl(P, R, W, oe, K, 2), s.bx(oe), s.cG(oe, oe, .5 * Math.PI), Bl(P, R, W, oe, K, 3), s.bx(oe), Bl(P, R, W, oe, K, 4), s.bx(oe), s.e3(oe, oe, Math.PI), Bl(P, R, W, oe, K, 5), B.viewport.set([0, 0, P.width, P.height]); }(d, l), l.markSkyboxValid(d)) : d.renderPass === "sky" && function (P, R, O, D, B) { const q = P.context, G = q.gl, K = P.transform, W = P.getOrCreateProgram("skybox"); q.activeTexture.set(G.TEXTURE0), G.bindTexture(G.TEXTURE_CUBE_MAP, R.skyboxTexture); const oe = ((de, me, we, ve, xe) => ({ u_matrix: de, u_sun_direction: me, u_cubemap: 0, u_opacity: ve, u_temporal_offset: xe }))(K.skyboxMatrix, R.getCenter(P, !1), 0, D, B); P.uploadCommonUniforms(q, W), W.draw(P, G.TRIANGLES, O, dr.disabled, P.colorModeForRenderPass(), fr.backCW, oe, "skybox", R.skyboxGeometry.vertexBuffer, R.skyboxGeometry.indexBuffer, R.skyboxGeometry.segment); }(d, l, T, _, C) : w === "gradient" && d.renderPass === "sky" && function (P, R, O, D, B) { const q = P.context, G = q.gl, K = P.transform, W = P.getOrCreateProgram("skyboxGradient"); R.skyboxGeometry || (R.skyboxGeometry = new Ld(q)), q.activeTexture.set(G.TEXTURE0); let oe = R.colorRampTexture; oe || (oe = R.colorRampTexture = new s.T(q, R.colorRamp, G.RGBA8)), oe.bind(G.LINEAR, G.CLAMP_TO_EDGE); const de = ((me, we, ve, xe, ge) => ({ u_matrix: me, u_color_ramp: 0, u_center_direction: we, u_radius: s.al(ve), u_opacity: xe, u_temporal_offset: ge }))(K.skyboxMatrix, R.getCenter(P, !1), R.paint.get("sky-gradient-radius"), D, B); P.uploadCommonUniforms(q, W), W.draw(P, G.TRIANGLES, O, dr.disabled, P.colorModeForRenderPass(), fr.backCW, de, "skyboxGradient", R.skyboxGeometry.vertexBuffer, R.skyboxGeometry.indexBuffer, R.skyboxGeometry.segment); }(d, l, T, _, C); }, debug: function (d, n, l, f, _, v) { for (let w = 0; w < l.length; w++)
                    if (_) {
                        const P = new s.am(f.r * .8, f.g * .8, f.b * .8, 1);
                        Oc(d, n, l[w], f, -1, -1, v), Oc(d, n, l[w], f, -1, 1, v), Oc(d, n, l[w], f, 1, 1, v), Oc(d, n, l[w], f, 1, -1, v), Oc(d, n, l[w], P, 0, 0, v);
                    }
                    else
                        Oc(d, n, l[w], f, 0, 0, v); }, custom: function (d, n, l, f) { const _ = d.context, v = l.implementation; if (!d.transform.projection.unsupportedLayers || !d.transform.projection.unsupportedLayers.includes("custom") || d.terrain && (d.terrain.renderingToTexture || d.renderPass === "offscreen") && l.isDraped(n)) {
                    if (d.renderPass === "offscreen") {
                        const w = v.prerender;
                        if (w) {
                            if (d.setCustomLayerDefaults(), _.setColorMode(d.colorModeForRenderPass()), d.transform.projection.name === "globe") {
                                const T = d.transform.pointMerc;
                                w.call(v, _.gl, d.transform.customLayerMatrix(), d.transform.getProjection(), d.transform.globeToMercatorMatrix(), s.ah(d.transform.zoom), [T.x, T.y], d.transform.pixelsPerMeterRatio);
                            }
                            else
                                w.call(v, _.gl, d.transform.customLayerMatrix());
                            _.setDirty(), d.setBaseState();
                        }
                    }
                    else if (d.renderPass === "translucent") {
                        if (d.terrain && d.terrain.renderingToTexture) {
                            const T = v.renderToTile;
                            if (T) {
                                const C = f[0].canonical, P = { x: C.x + f[0].wrap * (v.wrapTileId ? 0 : 1 << C.z), y: C.y, z: C.z };
                                _.setDepthMode(Ut.disabled), _.setStencilMode(dr.disabled), _.setColorMode(d.colorModeForRenderPass()), d.setCustomLayerDefaults(), T.call(v, _.gl, P), _.setDirty(), d.setBaseState();
                            }
                            return;
                        }
                        d.setCustomLayerDefaults(), _.setColorMode(d.colorModeForRenderPass()), _.setStencilMode(dr.disabled);
                        const w = v.renderingMode === "3d" ? new Ut(d.context.gl.LEQUAL, Ut.ReadWrite, d.depthRangeFor3D) : d.depthModeForSublayer(0, Ut.ReadOnly);
                        if (_.setDepthMode(w), d.transform.projection.name === "globe") {
                            const T = d.transform.pointMerc;
                            v.render(_.gl, d.transform.customLayerMatrix(), d.transform.getProjection(), d.transform.globeToMercatorMatrix(), s.ah(d.transform.zoom), [T.x, T.y], d.transform.pixelsPerMeterRatio);
                        }
                        else
                            v.render(_.gl, d.transform.customLayerMatrix());
                        _.setDirty(), d.setBaseState(), _.bindFramebuffer.set(null);
                    }
                }
                else
                    s.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers."); }, model: function (d, n, l, f) { if (d.renderPass === "opaque")
                    return; const _ = l.paint.get("model-opacity").constantOr(1); if (_ === 0)
                    return; const v = l.paint.get("model-cast-shadows"); if (d.renderPass === "shadow" && (!v || d.terrain && _ < .65 && l._transitionablePaint._values["model-opacity"].value.expression instanceof s.ab))
                    return; const w = d.shadowRenderer, T = l.paint.get("model-receive-shadows"); w && (w.useNormalOffset = !0, T || (w.enabled = !1)); const C = () => { w && (w.useNormalOffset = !0, T || (w.enabled = !0)); }, P = n.getSource(); if (d.renderPass === "light-beam" && P.type !== "batched-model")
                    return; if (P.type === "vector" || P.type === "geojson")
                    return function (W, oe, de, me, we) { const ve = W.transform; if (ve.projection.name !== "mercator")
                        return void s.w(`Drawing 3D models for ${ve.projection.name} projection is not yet implemented`); const xe = ve.getFreeCameraOptions().position; if (!W.modelManager)
                        return; const ge = W.modelManager; de.modelManager = ge; const Se = W.shadowRenderer; if (!de._unevaluatedLayout._values.hasOwnProperty("model-id"))
                        return; const Ce = de._unevaluatedLayout._values["model-id"], je = Object.assign({}, de.layout.get("model-id").parameters), ze = W.style.order.indexOf(de.fqid); for (const rt of me) {
                        const et = oe.getTile(rt).getBucket(de);
                        if (!et || et.projection.name !== ve.projection.name)
                            continue;
                        const vt = et.getModelUris();
                        vt && !et.modelsRequested && (ge.addModelsFromBucket(vt, we), et.modelsRequested = !0);
                        const Fe = kp(rt, ve);
                        je.zoom = Fe;
                        const Ve = Ce.possiblyEvaluate(je);
                        if (Ne(W, et, rt), ra.shadowUniformsInitialized = !1, ra.useSingleShadowCascade = !!Se && Se.getMaxCascadeForTile(rt.toUnwrapped()) === 0, W.renderPass === "shadow" && Se) {
                            if (W.currentShadowCascade === 1 && et.isInsideFirstShadowMapFrustum)
                                continue;
                            const He = ve.calculatePosMatrix(rt.toUnwrapped(), ve.worldSize);
                            if (ra.tileMatrix.set(He), ra.shadowTileMatrix = Float32Array.from(Se.calculateShadowPassMatrixFromMatrix(He)), ra.aabb.min.fill(0), ra.aabb.max[0] = ra.aabb.max[1] = s.aj, ra.aabb.max[2] = 0, Q0(et, ra, W, de.scope))
                                continue;
                        }
                        const Le = 1 << rt.canonical.z, st = [((xe.x - rt.wrap) * Le - rt.canonical.x) * s.aj, (xe.y * Le - rt.canonical.y) * s.aj, xe.z * Le * s.aj];
                        W.conflationActive && Object.keys(et.instancesPerModel).length > 0 && W.style.isLayerClipped(de, oe.getSource()) && et.updateReplacement(rt, W.replacementSource, ze, we) && (et.uploaded = !1, et.upload(W.context));
                        for (let He in et.instancesPerModel) {
                            const ht = et.instancesPerModel[He];
                            ht.features.length > 0 && (He = Ve.evaluate(ht.features[0].feature, {}));
                            const nt = ge.getModel(He, we);
                            if (nt || ge.hasURLBeenRequested(He) || et.modelUris.includes(He) || (et.modelUris.push(He), et.modelsRequested = !1), nt && nt.uploaded)
                                for (const dt of nt.nodes)
                                    Dp(W, de, dt, ht, st, rt, ra);
                        }
                    } }(d, n, l, f, P.type === "vector" ? l.scope : ""), void C(); if (!P.loaded())
                    return; if (P.type === "batched-model")
                    return function (W, oe, de, me) { de.resetLayerRenderingStats(W); const we = W.context, ve = W.transform, xe = W.style.fog, ge = W.shadowRenderer; if (ve.projection.name !== "mercator")
                        return void s.w(`Drawing 3D landmark models for ${ve.projection.name} projection is not yet implemented`); const Se = W.transform.getFreeCameraOptions().position, Ce = s.b$([], [Se.x, Se.y, Se.z], W.transform.worldSize), je = s.eb([], Ce), ze = s.bx([]), rt = s.ec(ve.center.lat, ve.zoom), et = s.bn([], [1, 1, 1 / rt]); s.bo(ze, ze, je); const vt = de.paint.get("model-opacity").constantOr(1), Fe = new Ut(we.gl.LEQUAL, Ut.ReadWrite, W.depthRangeFor3D), Ve = new Ut(we.gl.LEQUAL, Ut.ReadOnly, W.depthRangeFor3D), Le = new s.cV([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), st = W.renderPass === "shadow", He = st && ge ? ge.getCurrentCascadeFrustum() : ve.getFrustum(ve.scaleZoom(ve.worldSize)), ht = de.paint.get("model-front-cutoff"), nt = ht[2] < 1, dt = Cc(W, de.paint.get("model-cutoff-fade-range")), ft = de.getLayerRenderingStats(); (function (Vt, Xt, Bt, Yt) { const $t = Vt.terrain ? Vt.terrain.exaggeration() : 0, or = Vt.transform.zoom; for (const mr of Yt) {
                        const Nr = Xt.getTile(mr).getBucket(Bt);
                        Nr && (Nr.setFilter(Bt.filter), Vt.conflationActive && Nr.updateReplacement(mr, Vt.replacementSource), Nr.evaluateScale(Vt, Bt), Vt.terrain && $t > 0 && Nr.elevationUpdate(Vt.terrain, $t, mr, Bt.source), Nr.needsReEvaluation(Vt, or, Bt) && Nr.evaluate(Bt));
                    } })(W, oe, de, me), function () { let Vt, Xt, Bt; nt ? (Vt = me.length - 1, Xt = -1, Bt = -1) : (Vt = 0, Xt = me.length, Bt = 1); const Yt = new Float64Array(16), $t = s.eg(), or = new s.P(0, 0); for (let mr = Vt; mr !== Xt; mr += Bt) {
                        const Nr = me[mr], vn = oe.getTile(Nr).getBucket(de);
                        if (!vn || !vn.uploaded)
                            continue;
                        let fn = !1;
                        ge && (fn = ge.getMaxCascadeForTile(Nr.toUnwrapped()) === 0);
                        const jr = ve.calculatePosMatrix(Nr.toUnwrapped(), ve.worldSize), hi = vn.modelTraits;
                        !st && nt && (s.bi(Yt, jr), s.ad($t, Ce, Yt), or.x = $t[0], or.y = $t[1]);
                        const Jn = [];
                        vn.setFilter(de.filter);
                        for (const xr of vn.getNodesInfo()) {
                            if (xr.hiddenByReplacement || !xr.node.meshes)
                                continue;
                            const Hr = xr.node;
                            let Qr = 0;
                            W.terrain && Hr.elevation && (Qr = Hr.elevation * W.terrain.exaggeration());
                            const xn = (() => { const Yn = xr.aabb; return Le.min = [...Yn.min], Le.max = [...Yn.max], Le.min[2] += Qr, Le.max[2] += Qr, s.ad(Le.min, Le.min, jr), s.ad(Le.max, Le.max, jr), Le; })(), Ii = xr.evaluatedScale;
                            if (Ii[0] <= 1 && Ii[1] <= 1 && Ii[2] <= 1 && xn.intersects(He) === 0)
                                continue;
                            if (!st && nt) {
                                const Yn = .16666666666666666;
                                xr.cameraCollisionOpacity = Ce[0] > xn.min[0] && Ce[0] < xn.max[0] && Ce[1] > xn.min[1] && Ce[1] < xn.max[1] && Ce[2] * rt < xn.max[2] && Hr.footprint && s.bS(or, Hr.footprint) ? Math.max(xr.cameraCollisionOpacity - Yn, 0) : Math.min(1, xr.cameraCollisionOpacity + Yn);
                            }
                            const _i = [...jr], Ci = Hr.anchor ? Hr.anchor[0] : 0, Kn = Hr.anchor ? Hr.anchor[1] : 0;
                            s.bo(_i, _i, [Ci * (Ii[0] - 1), Kn * (Ii[1] - 1), Qr]), s.ci(Ii, s.eh) || s.cE(_i, _i, Ii);
                            const Cr = s.az([], _i, Hr.matrix), qn = s.az([], ve.expandedFarZProjMatrix, Cr), Xr = s.az([], ve.expandedFarZProjMatrix, _i), Hn = s.aA([], [Ci, Kn, Qr, 1], qn)[2];
                            Hr.hidden = !1;
                            let sn = vt;
                            st || (nt && (sn *= xr.cameraCollisionOpacity, sn *= ju(_i, ve, xr.aabb, ht)), sn *= J0(dt, Hn)), sn !== 0 ? Jn.push({ nodeInfo: xr, depth: Hn, opacity: sn, wvpForNode: qn, wvpForTile: Xr, nodeModelMatrix: Cr, tileModelMatrix: _i }) : Hr.hidden = !0;
                        }
                        st || Jn.sort((xr, Hr) => !nt || xr.opacity === 1 && Hr.opacity === 1 ? xr.depth < Hr.depth ? -1 : 1 : xr.opacity === 1 ? -1 : Hr.opacity === 1 ? 1 : xr.depth > Hr.depth ? -1 : 1);
                        for (const xr of Jn) {
                            const Hr = xr.nodeInfo, Qr = Hr.node;
                            let xn = s.az([], et, xr.tileModelMatrix);
                            s.az(xn, ze, xn);
                            const Ii = s.bi([], xn);
                            s.ee(Ii, Ii), s.cE(Ii, Ii, b_), xn = s.az(xn, xn, Qr.matrix);
                            const _i = W.renderPass === "light-beam", Ci = de.paint.get("model-color-use-theme").constantOr("default") === "none", Kn = hi & s.em.HasMapboxMeshFeatures, Cr = Kn ? 0 : Hr.evaluatedRMEA[0][2];
                            for (let qn = 0; qn < Qr.meshes.length; ++qn) {
                                const Xr = Qr.meshes[qn], Hn = qn === Qr.lightMeshIndex;
                                let sn = xr.wvpForNode;
                                if (Hn) {
                                    if (!_i && !W.terrain && W.shadowRenderer) {
                                        W.currentLayer < W.firstLightBeamLayer && (W.firstLightBeamLayer = W.currentLayer);
                                        continue;
                                    }
                                    sn = xr.wvpForTile;
                                }
                                else if (_i)
                                    continue;
                                const Yn = { defines: [] }, Wi = [];
                                if (!st && ge && (ge.useNormalOffset = !!Xr.normalBuffer), wt(Yn.defines, Wi, Xr, W, Ci ? null : de.lut), Kn || Yn.defines.push("DIFFUSE_SHADED"), fn && Yn.defines.push("SHADOWS_SINGLE_CASCADE"), ft && (st ? ft.numRenderedVerticesInShadowPass += Xr.vertexArray.length : ft.numRenderedVerticesInTransparentPass += Xr.vertexArray.length), st) {
                                    gi(Xr, xr.nodeModelMatrix, W, de);
                                    continue;
                                }
                                let Ln = null;
                                if (xe) {
                                    const ro = zc(xr.nodeModelMatrix, W.transform);
                                    if (Ln = new Float32Array(ro), ve.projection.name !== "globe") {
                                        const No = Xr.aabb.min, Ia = Xr.aabb.max, [Pa, aa] = xe.getOpacityForBounds(ro, No[0], No[1], Ia[0], Ia[1]);
                                        Yn.overrideFog = Pa >= Ot || aa >= Ot;
                                    }
                                }
                                const es = Xr.material;
                                let wi;
                                es.occlusionTexture && es.occlusionTexture.offsetScale && (wi = es.occlusionTexture.offsetScale, Yn.defines.push("OCCLUSION_TEXTURE_TRANSFORM"));
                                const as = W.getOrCreateProgram("model", Yn);
                                !st && ge && ge.setupShadowsFromMatrix(xr.tileModelMatrix, as, ge.useNormalOffset), W.uploadCommonUniforms(we, as, null, Ln);
                                const oa = es.pbrMetallicRoughness;
                                oa.metallicFactor = .9, oa.roughnessFactor = .5;
                                const rl = kc(new Float32Array(sn), new Float32Array(xn), new Float32Array(Ii), new Float32Array(Qr.matrix), W, xr.opacity, oa.baseColorFactor.toRenderColor(null), es.emissiveFactor, oa.metallicFactor, oa.roughnessFactor, es, Cr, de, [0, 0, 0], wi);
                                !Hn && (Hr.hasTranslucentParts || xr.opacity < 1) && as.draw(W, we.gl.TRIANGLES, Fe, dr.disabled, Rr.disabled, fr.backCCW, rl, de.id, Xr.vertexBuffer, Xr.indexBuffer, Xr.segments, de.paint, W.transform.zoom, void 0, Wi), as.draw(W, we.gl.TRIANGLES, Hn ? Ve : Fe, dr.disabled, Hn || xr.opacity < 1 || Hr.hasTranslucentParts ? Rr.alphaBlended : Rr.unblended, fr.backCCW, rl, de.id, Xr.vertexBuffer, Xr.indexBuffer, Xr.segments, de.paint, W.transform.zoom, void 0, Wi);
                            }
                        }
                    } }(); }(d, n, l, f), void C(); if (P.type !== "model")
                    return; const R = P.getModels(), O = [], D = d.transform.getFreeCameraOptions().position, B = s.b$([], [D.x, D.y, D.z], d.transform.worldSize); s.eb(B, B); const q = [], G = []; let K = 0; for (const W of R) {
                    const oe = l.paint.get("model-rotation").constantOr(null), de = l.paint.get("model-scale").constantOr(null), me = l.paint.get("model-translation").constantOr(null);
                    W.computeModelMatrix(d, oe, de, me, !0, !0, !1);
                    const we = s.bx([]), ve = s.ec(W.position.lat, d.transform.zoom), xe = s.bn([], [1, 1, 1 / ve]);
                    s.bo(we, we, B), O.push({ zScaleMatrix: xe, negCameraPosMatrix: we });
                    for (const ge of W.nodes)
                        Fc(d.transform, ge, W.matrix, d.transform.expandedFarZProjMatrix, K, q, G);
                    K++;
                } if (q.sort((W, oe) => oe.depth - W.depth), d.renderPass !== "shadow") {
                    if (_ === 1)
                        for (const W of G)
                            zt(W, d, l, O[W.modelIndex], dr.disabled, d.colorModeForRenderPass());
                    else {
                        for (const W of G)
                            zt(W, d, l, O[W.modelIndex], dr.disabled, Rr.disabled);
                        for (const W of G)
                            zt(W, d, l, O[W.modelIndex], d.stencilModeFor3D(), d.colorModeForRenderPass());
                        d.resetStencilClippingMasks();
                    }
                    for (const W of q)
                        zt(W, d, l, O[W.modelIndex], dr.disabled, d.colorModeForRenderPass());
                    C();
                }
                else {
                    for (const W of G)
                        gi(W.mesh, W.nodeModelMatrix, d, l);
                    for (const W of q)
                        gi(W.mesh, W.nodeModelMatrix, d, l);
                    C();
                } } }, C_ = { line: function (d, n, l) { if (d.hasElevatedBuckets = !1, d.hasNonElevatedBuckets = !1, d._unevaluatedLayout.getValue("line-elevation-reference") !== void 0 || d._unevaluatedLayout.getValue("line-z-offset") !== void 0) {
                    if (n) {
                        const f = n.getVisibleCoordinates();
                        for (const _ of f) {
                            const v = n.getTile(_).getBucket(d);
                            if (v && (v.elevationType !== "none" ? d.hasElevatedBuckets = !0 : d.hasNonElevatedBuckets = !0, d.hasElevatedBuckets && d.hasNonElevatedBuckets))
                                break;
                        }
                    }
                }
                else
                    d.hasNonElevatedBuckets = !0; }, model: function (d, n, l) { const f = n.getSource(); if (!f.loaded())
                    return; if (f.type === "vector" || f.type === "geojson")
                    return void (l.modelManager && l.modelManager.upload(l, f.type === "vector" ? d.scope : "")); if (f.type === "batched-model" || f.type !== "model")
                    return; const _ = f.getModels(); for (const v of _)
                    v.upload(l.context); }, raster: function (d, n, l) { const f = n.getSource(); if (!(f instanceof _c && f.loaded()))
                    return; const _ = d.sourceLayer || f.rasterLayerIds && f.rasterLayerIds[0]; if (!_)
                    return; const v = d.paint.get("raster-array-band") || f.getInitialBand(_); if (v == null)
                    return; const w = n.getIds().map(T => n.getTileByID(T)); for (const T of w)
                    T.updateNeeded(_, v) && f.prepareTile(T, _, v); }, "raster-particle": function (d, n, l) { const f = n.getSource(); if (!(f instanceof _c && f.loaded()))
                    return; const _ = d.sourceLayer || f.rasterLayerIds && f.rasterLayerIds[0]; if (!_)
                    return; const v = d.paint.get("raster-particle-array-band") || f.getInitialBand(_); if (v == null)
                    return; const w = n.getIds().map(T => n.getTileByID(T)); for (const T of w)
                    T.updateNeeded(_, v) && f.prepareTile(T, _, v); } }, Ja = { fill: Rd };
            class zp {
                constructor(n, l, f, _, v) { this.context = new Ou(n, l), this.transform = f, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = v, this._timeStamp = s.q.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = { forceEnablePrecipitation: !1, showTerrainProxyTiles: !1, fpsWindow: 30, continousRedraw: !1, enabledLayers: {} }; const w = ["fill", "line", "symbol", "circle", "heatmap", "fill-extrusion", "raster", "raster-particle", "hillshade", "model", "background", "sky"]; for (const C of w)
                    this._debugParams.enabledLayers[C] = !0; v.registerParameter(this._debugParams, ["Terrain"], "showTerrainProxyTiles", {}, () => { this.style.map.triggerRepaint(); }), v.registerParameter(this._debugParams, ["Precipitation"], "forceEnablePrecipitation"), v.registerParameter(this._debugParams, ["FPS"], "fpsWindow", { min: 1, max: 100, step: 1 }), v.registerBinding(this._debugParams, ["FPS"], "continousRedraw", { readonly: !0, label: "continuous redraw" }), v.registerBinding(this, ["FPS"], "_averageFPS", { readonly: !0, label: "value" }), v.registerBinding(this, ["FPS"], "_averageFPS", { readonly: !0, label: "graph", view: "graph", min: 0, max: 200 }); for (const C of w)
                    v.registerParameter(this._debugParams.enabledLayers, ["Debug", "Layers"], C); this.occlusionParams = new ex(v), this.setup(), this.numSublayers = As.maxUnderzooming + As.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = !1, this.replacementSource = new s.et, this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = !1, this._cachedTileFogOpacities = {}, this._shadowRenderer = new Zb(this), this._wireframeDebugCache = new yT, this.renderDefaultNorthPole = !0, this.renderDefaultSouthPole = !0, this.layersWithOcclusionOpacity = []; const T = new s.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)); this.emptyDepthTexture = new s.T(this.context, T, n.RGBA8), this._clippingActiveLastFrame = !1, this.scaleFactor = _; }
                updateTerrain(n, l) { const f = !!n && !!n.terrain && this.transform.projection.supportsTerrain; if (!(f || this._terrain && this._terrain.enabled))
                    return; this._terrain || (this._terrain = new vp(this, n)); const _ = this._terrain; this.transform.elevation = f ? _ : null, _.update(n, this.transform, l), this.transform.elevation && !_.enabled && (this.transform.elevation = null); }
                _updateFog(n) { const l = n.fog; if (!l || this.transform.projection.name === "globe" || l.getOpacity(this.transform.pitch) < 1 || l.properties.get("horizon-blend") < .03)
                    return void (this.transform.fogCullDistSq = null); const [f, _] = l.getFovAdjustedRange(this.transform._fov); if (f > _)
                    return void (this.transform.fogCullDistSq = null); const v = f + .78 * (_ - f); this.transform.fogCullDistSq = v * v; }
                get terrain() { return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null; }
                get forceTerrainMode() { return this._forceTerrainMode; }
                set forceTerrainMode(n) { n && !this._terrain && (this._terrain = new vp(this, this.style)), this._forceTerrainMode = n; }
                get shadowRenderer() { return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null; }
                get wireframeDebugCache() { return this._wireframeDebugCache; }
                resize(n, l) { if (this.width = n * s.q.devicePixelRatio, this.height = l * s.q.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
                    for (const f of this.style.order)
                        this.style._mergedLayers[f].resize(); }
                setup() { const n = this.context, l = new s.ba; l.emplaceBack(0, 0), l.emplaceBack(s.aj, 0), l.emplaceBack(0, s.aj), l.emplaceBack(s.aj, s.aj), this.tileExtentBuffer = n.createVertexBuffer(l, s.bc.members), this.tileExtentSegments = s.bd.simpleSegment(0, 0, 4, 2); const f = new s.ba; f.emplaceBack(0, 0), f.emplaceBack(s.aj, 0), f.emplaceBack(0, s.aj), f.emplaceBack(s.aj, s.aj), this.debugBuffer = n.createVertexBuffer(f, s.bc.members), this.debugSegments = s.bd.simpleSegment(0, 0, 4, 5); const _ = new s.ba; _.emplaceBack(-1, -1), _.emplaceBack(1, -1), _.emplaceBack(-1, 1), _.emplaceBack(1, 1), this.viewportBuffer = n.createVertexBuffer(_, s.bc.members), this.viewportSegments = s.bd.simpleSegment(0, 0, 4, 2); const v = new s.aZ; v.emplaceBack(0, 0, 0, 0), v.emplaceBack(s.aj, 0, s.aj, 0), v.emplaceBack(0, s.aj, 0, s.aj), v.emplaceBack(s.aj, s.aj, s.aj, s.aj), this.mercatorBoundsBuffer = n.createVertexBuffer(v, s.bf.members), this.mercatorBoundsSegments = s.bd.simpleSegment(0, 0, 4, 2); const w = new s.a_; w.emplaceBack(0, 1, 2), w.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = n.createIndexBuffer(w); const T = new s.bb; for (const P of [0, 1, 3, 2, 0])
                    T.emplaceBack(P); this.debugIndexBuffer = n.createIndexBuffer(T), this.emptyTexture = new s.T(n, new s.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), n.gl.RGBA8), this.identityMat = s.bz(); const C = this.context.gl; this.stencilClearMode = new dr({ func: C.ALWAYS, mask: 0 }, 0, 255, C.ZERO, C.ZERO, C.ZERO), this.loadTimeStamps.push(performance.now()); }
                getMercatorTileBoundsBuffers() { return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments }; }
                getTileBoundsBuffers(n) { return n._makeTileBoundsBuffers(this.context, this.transform.projection), n._tileBoundsBuffer ? { tileBoundsBuffer: n._tileBoundsBuffer, tileBoundsIndexBuffer: n._tileBoundsIndexBuffer, tileBoundsSegments: n._tileBoundsSegments } : this.getMercatorTileBoundsBuffers(); }
                clearStencil() { const n = this.context.gl; this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, n.TRIANGLES, Ut.disabled, this.stencilClearMode, Rr.disabled, fr.disabled, $s(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments); }
                resetStencilClippingMasks() { this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}); }
                _renderTileClippingMasks(n, l, f) { if (!l || this.currentStencilSource === l.id || !n.isTileClipped() || !f || f.length === 0)
                    return; if (this._tileClippingMaskIDs && !this.terrain) {
                    let T = !1;
                    for (const C of f)
                        if (this._tileClippingMaskIDs[C.key] === void 0) {
                            T = !0;
                            break;
                        }
                    if (!T)
                        return;
                } this.currentStencilSource = l.id; const _ = this.context, v = _.gl; this.nextStencilID + f.length > 256 && this.clearStencil(), _.setColorMode(Rr.disabled), _.setDepthMode(Ut.disabled); const w = this.getOrCreateProgram("clippingMask"); this._tileClippingMaskIDs = {}; for (const T of f) {
                    const C = l.getTile(T), P = this._tileClippingMaskIDs[T.key] = this.nextStencilID++, { tileBoundsBuffer: R, tileBoundsIndexBuffer: O, tileBoundsSegments: D } = this.getTileBoundsBuffers(C);
                    w.draw(this, v.TRIANGLES, Ut.disabled, new dr({ func: v.ALWAYS, mask: 0 }, P, 255, v.KEEP, v.KEEP, v.REPLACE), Rr.disabled, fr.disabled, $s(T.projMatrix), "$clipping", R, O, D);
                } }
                stencilModeFor3D() { this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil(); const n = this.nextStencilID++, l = this.context.gl; return new dr({ func: l.NOTEQUAL, mask: 255 }, n, 255, l.KEEP, l.KEEP, l.REPLACE); }
                stencilModeForClipping(n) { if (this.terrain)
                    return this.terrain.stencilModeForRTTOverlap(n); const l = this.context.gl; return new dr({ func: l.EQUAL, mask: 255 }, this._tileClippingMaskIDs[n.key], 0, l.KEEP, l.KEEP, l.REPLACE); }
                stencilConfigForOverlap(n) { const l = this.context.gl, f = n.sort((w, T) => T.overscaledZ - w.overscaledZ), _ = f[f.length - 1].overscaledZ, v = f[0].overscaledZ - _ + 1; if (v > 1) {
                    this.currentStencilSource = void 0, this.nextStencilID + v > 256 && this.clearStencil();
                    const w = {};
                    for (let T = 0; T < v; T++)
                        w[T + _] = new dr({ func: l.GEQUAL, mask: 255 }, T + this.nextStencilID, 255, l.KEEP, l.KEEP, l.REPLACE);
                    return this.nextStencilID += v, [w, f];
                } return [{ [_]: dr.disabled }, f]; }
                colorModeForRenderPass() { const n = this.context.gl; return this._showOverdrawInspector ? new Rr([n.CONSTANT_COLOR, n.ONE, n.CONSTANT_COLOR, n.ONE], new s.am(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Rr.unblended : Rr.alphaBlended; }
                colorModeForDrapableLayerRenderPass(n) { const l = this.context.gl; return this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture && this.renderPass === "translucent" ? new Rr([l.ONE, l.ONE_MINUS_SRC_ALPHA, l.CONSTANT_ALPHA, l.ONE_MINUS_SRC_ALPHA], new s.am(0, 0, 0, n === void 0 ? 0 : n), [!0, !0, !0, !0]) : this.colorModeForRenderPass(); }
                depthModeForSublayer(n, l, f, _ = !1) { if (this.depthOcclusion)
                    return new Ut(this.context.gl.GREATER, Ut.ReadOnly, this.depthRangeFor3D); if (!this.opaquePassEnabledForLayer() && !_)
                    return Ut.disabled; const v = 1 - ((1 + this.currentLayer) * this.numSublayers + n) * this.depthEpsilon; return new Ut(f || this.context.gl.LEQUAL, l, [v, v]); }
                opaquePassEnabledForLayer() { return this.currentLayer < this.opaquePassCutoff; }
                blitDepth() { const n = this.context.gl, l = Math.ceil(this.width), f = Math.ceil(this.height), _ = this.context.bindFramebuffer.get(), v = n.getParameter(n.TEXTURE_BINDING_2D); this.depthFBO && this.depthFBO.width === l && this.depthFBO.height === f || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), l !== 0 && f !== 0 && (this.depthFBO = new Ap(this.context, l, f, !1, "texture"), this.depthTexture = new s.T(this.context, { width: l, height: f, data: null }, n.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(_), n.bindTexture(n.TEXTURE_2D, v), this.depthFBO && (n.bindFramebuffer(n.READ_FRAMEBUFFER, null), n.bindFramebuffer(n.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), n.blitFramebuffer(0, 0, l, f, 0, 0, l, f, n.DEPTH_BUFFER_BIT, n.NEAREST), n.bindFramebuffer(n.FRAMEBUFFER, this.context.bindFramebuffer.current)); }
                updateAverageFPS() { this._fpsHistory.push(this._dt === 0 ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((n, l) => n + l / this._fpsHistory.length, 0)); }
                render(n, l) { const f = s.q.now(); this._dt = f - this._timeStamp, this._timeStamp = f, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = n.map.repaint, this.style = n, this.options = l; const _ = this.style._mergedLayers, v = !(!this.terrain || !this.terrain.enabled), w = () => this.style._getOrder(v).filter(Fe => { const Ve = _[Fe]; return !(Ve.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[Ve.type]; }); let T = w(), C = !1, P = !1; for (const Fe of T) {
                    const Ve = _[Fe];
                    Ve.type === "circle" && (C = !0), Ve.type === "symbol" && (Ve.hasInitialOcclusionOpacityProperties ? P = !0 : C = !0);
                } let R = T.map(Fe => _[Fe]); const O = this.style._mergedSourceCaches; this.imageManager = n.imageManager, this.modelManager = n.modelManager, this.symbolFadeChange = n.placement.symbolFadeChange(s.q.now()), this.imageManager.beginFrame(); let D = 0, B = !1; for (const Fe in O) {
                    const Ve = O[Fe];
                    Ve.used && (Ve.prepare(this.context), Ve.getSource().usedInConflation && ++D);
                } let q = !1; for (const Fe of R)
                    Fe.isHidden(this.transform.zoom) || (Fe.type === "clip" && (q = !0), this.prepareLayer(Fe)); const G = {}, K = {}, W = {}, oe = {}, de = {}; for (const Fe in O) {
                    const Ve = O[Fe];
                    G[Fe] = Ve.getVisibleCoordinates(), K[Fe] = G[Fe].slice().reverse(), W[Fe] = Ve.getVisibleCoordinates(!0).reverse(), oe[Fe] = Ve.getShadowCasterCoordinates(), de[Fe] = Ve.sortCoordinatesByDistance(G[Fe]);
                } const me = Fe => { const Ve = this.style.getLayerSourceCache(Fe); return Ve && Ve.used ? Ve.getSource() : null; }; if (D || q || this._clippingActiveLastFrame) {
                    const Fe = [], Ve = [];
                    let Le = 0;
                    for (const st of R)
                        this.isSourceForClippingOrConflation(st, me(st)) && (Fe.push(st), Ve.push(Le)), Le++;
                    if (Fe && (q || Fe.length > 1) || this._clippingActiveLastFrame) {
                        q = !1;
                        const st = [];
                        for (let He = 0; He < Fe.length; He++) {
                            const ht = Fe[He], nt = Ve[He], dt = this.style.getLayerSourceCache(ht);
                            if (!dt || !dt.used || !dt.getSource().usedInConflation && ht.type !== "clip")
                                continue;
                            let ft = s.ev, Vt = s.bQ.None;
                            const Xt = [];
                            let Bt = !0;
                            if (ht.type === "clip") {
                                ft = nt;
                                for (const Yt of ht.layout.get("clip-layer-types"))
                                    Vt |= Yt === "model" ? s.bQ.Model : Yt === "symbol" ? s.bQ.Symbol : s.bQ.FillExtrusion;
                                for (const Yt of ht.layout.get("clip-layer-scope"))
                                    Xt.push(Yt);
                                ht.isHidden(this.transform.zoom) ? Bt = !1 : q = !0;
                            }
                            Bt && st.push({ layer: ht.fqid, cache: dt, order: ft, clipMask: Vt, clipScope: Xt });
                        }
                        this.replacementSource.setSources(st), B = !0;
                    }
                } this._clippingActiveLastFrame = q, B || this.replacementSource.clear(), this.conflationActive = B, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = []; for (let Fe = 0; Fe < R.length; Fe++) {
                    const Ve = R[Fe], Le = Ve.cutoffRange();
                    if (this.longestCutoffRange = Math.max(Le, this.longestCutoffRange), Le > 0) {
                        const st = me(Ve);
                        st && (this.minCutoffZoom = Math.max(st.minzoom, this.minCutoffZoom)), Ve.minzoom && (this.minCutoffZoom = Math.max(Ve.minzoom, this.minCutoffZoom));
                    }
                    Ve.is3D(v) && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = Fe), this._lastOcclusionLayer = Fe);
                } const we = this.style && this.style.fog; we ? (this._fogVisible = we.getOpacity(this.transform.pitch) !== 0, this._fogVisible && this.transform.projection.name !== "globe" && (this._fogVisible = we.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(W), this.opaquePassCutoff = 0, T = w(), R = T.map(Fe => _[Fe])); const ve = this._shadowRenderer; if (ve) {
                    ve.updateShadowParameters(this.transform, this.style.directionalLight);
                    for (const Fe in O)
                        for (const Ve of G[Fe]) {
                            let Le = { min: 0, max: 0 };
                            this.terrain && (Le = this.terrain.getMinMaxForTile(Ve) || Le), ve.addShadowReceiver(Ve.toUnwrapped(), Le.min, Le.max);
                        }
                } this.transform.projection.name !== "globe" || this.globeSharedBuffers || (this.globeSharedBuffers = new s.eu(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new Bu(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0); const xe = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow), ge = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain); if (xe && !this._snow && (this._snow = new Xn(this)), !xe && this._snow && (this._snow.destroy(), delete this._snow), ge && !this._rain && (this._rain = new vT(this)), !ge && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), !js.has(this.context.gl))
                    return; this.renderPass = "offscreen"; for (const Fe of R) {
                    const Ve = n.getLayerSourceCache(Fe);
                    if (!Fe.hasOffscreenPass() || Fe.isHidden(this.transform.zoom))
                        continue;
                    const Le = Ve ? K[Ve.id] : void 0;
                    (Fe.type === "custom" || Fe.type === "raster" || Fe.type === "raster-particle" || Fe.isSky() || Le && Le.length) && this.renderLayer(this, Ve, Fe, Le);
                } this.depthRangeFor3D = [0, 1 - (R.length + 2) * this.numSublayers * this.depthEpsilon], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, oe)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]); const Se = this.transform.projection.name === "globe" || this.transform.isHorizonVisible(), Ce = (() => { if (l.showOverdrawInspector)
                    return s.am.black; const Fe = this.style.fog; if (Fe && this.transform.projection.supportsFog) {
                    const Ve = this.style.getLut(Fe.scope);
                    if (!Se) {
                        const Le = Fe.properties.get("color-use-theme") === "none", st = Fe.properties.get("color").toRenderColor(Le ? null : Ve).toArray01();
                        return new s.am(...st);
                    }
                    if (Se) {
                        const Le = Fe.properties.get("space-color-use-theme") === "none", st = Fe.properties.get("space-color").toRenderColor(Le ? null : Ve).toArray01();
                        return new s.am(...st);
                    }
                } return s.am.transparent; })(); if (this.context.clear({ color: Ce, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = l.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && Se && this._atmosphere.drawStars(this, this.style.fog), !this.terrain)
                    for (this.currentLayer = T.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                        const Fe = R[this.currentLayer], Ve = n.getLayerSourceCache(Fe);
                        if (Fe.isSky())
                            continue;
                        const Le = Ve ? (Fe.is3D(v) ? de : K)[Ve.id] : void 0;
                        this._renderTileClippingMasks(Fe, Ve, Le), this.renderLayer(this, Ve, Fe, Le);
                    } if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && Se && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || s.ah(this.transform.zoom) > 0) && (this.transform.projection.name === "globe" || this.transform.isHorizonVisible()))
                    for (this.currentLayer = 0; this.currentLayer < T.length; this.currentLayer++) {
                        const Fe = R[this.currentLayer], Ve = n.getLayerSourceCache(Fe);
                        Fe.isSky() && this.renderLayer(this, Ve, Fe, Ve ? K[Ve.id] : void 0);
                    } function je(Fe, Ve) { let Le; return Ve && (Le = (Fe.type === "symbol" ? W : Fe.is3D(v) ? de : K)[Ve.id]), Le; } if (this.renderPass = "translucent", this.transform.projection.name === "globe") {
                    for (this.renderElevatedRasterBackface = !0, this.currentLayer = 0; this.currentLayer < T.length;) {
                        const Fe = R[this.currentLayer];
                        if (Fe.type === "raster" || Fe.type === "raster-particle") {
                            const Ve = n.getLayerSourceCache(Fe);
                            this.renderLayer(this, Ve, Fe, je(Fe, Ve));
                        }
                        ++this.currentLayer;
                    }
                    this.renderElevatedRasterBackface = !1;
                } this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER; let ze = 0; ve && (ze = ve.getShadowCastingLayerCount()); let rt = !1, et = -1; for (let Fe = 0; Fe < T.length; ++Fe) {
                    const Ve = R[Fe];
                    Ve.isHidden(this.transform.zoom) || Ve.is3D(v) && (et = Fe);
                } P && et === -1 && (C = !0); let vt = !1; for (; this.currentLayer < T.length;) {
                    const Fe = R[this.currentLayer], Ve = n.getLayerSourceCache(Fe);
                    if (Fe.isSky())
                        ++this.currentLayer;
                    else if (this.terrain && this.style.isLayerDraped(Fe)) {
                        if (Fe.isHidden(this.transform.zoom)) {
                            ++this.currentLayer;
                            continue;
                        }
                        this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
                    }
                    else {
                        if (!vt && Fe.is3D(v) && !v) {
                            const Le = this.currentLayer, st = He => { for (this.currentLayer = 0; this.currentLayer < R.length; this.currentLayer++) {
                                const ht = R[this.currentLayer];
                                if (Ja[ht.type]) {
                                    const nt = this.style.getLayerSourceCache(ht);
                                    Ja[ht.type](this, nt, ht, je(ht, nt), He);
                                }
                            } };
                            st("initialize"), st("reset"), this.currentLayer = Le, vt = !0;
                        }
                        if (C && !rt && this.terrain && !this.transform.isOrthographic && (rt = !0, this.blitDepth()), P && et !== -1 && this.currentLayer === et + 1 && !this.transform.isOrthographic && this.blitDepth(), this.terrain || this._renderTileClippingMasks(Fe, Ve, Ve ? G[Ve.id] : void 0), this.renderLayer(this, Ve, Fe, je(Fe, Ve)), !this.terrain && ve && ze > 0 && Fe.hasShadowPass() && --ze == 0 && (ve.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
                            const Le = this.currentLayer;
                            for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= Le; this.currentLayer++) {
                                const st = R[this.currentLayer];
                                if (!st.hasLightBeamPass())
                                    continue;
                                const He = n.getLayerSourceCache(st);
                                this.renderLayer(this, He, st, He ? K[He.id] : void 0);
                            }
                            this.currentLayer = Le, this.renderPass = "translucent";
                        }
                        if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                            const Le = this.currentLayer;
                            this.depthOcclusion = !0;
                            for (const st of this.layersWithOcclusionOpacity) {
                                this.currentLayer = st;
                                const He = R[this.currentLayer], ht = n.getLayerSourceCache(He), nt = ht ? K[ht.id] : void 0;
                                this.terrain || this._renderTileClippingMasks(He, ht, ht ? G[ht.id] : void 0), this.renderLayer(this, ht, He, nt);
                            }
                            this.depthOcclusion = !1, this.currentLayer = Le, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
                        }
                        ++this.currentLayer;
                    }
                } if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                    let Fe = null;
                    R.forEach(Ve => { const Le = n.getLayerSourceCache(Ve); Le && !Ve.isHidden(this.transform.zoom) && Le.getVisibleCoordinates().length && (!Fe || Fe.getSource().maxzoom < Le.getSource().maxzoom) && (Fe = Le); }), Fe && this.options.showTileBoundaries && tn.debug(this, Fe, Fe.getVisibleCoordinates(), s.am.red, !1, this.options.showParseStatus);
                } this.terrain && this._debugParams.showTerrainProxyTiles && tn.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new s.am(1, .8, .1, 1), !0, this.options.showParseStatus), this.options.showPadding && function (Fe) { const Ve = Fe.transform.padding; Mp(Fe, Fe.transform.height - (Ve.top || 0), 3, v_), Mp(Fe, Ve.bottom || 0, 3, x_), Rp(Fe, Ve.left || 0, 3, w_), Rp(Fe, Fe.transform.width - (Ve.right || 0), 3, to); const Le = Fe.transform.centerPoint; (function (st, He, ht, nt) { Nu(st, He - 1, ht - 10, 2, 20, nt), Nu(st, He - 10, ht - 1, 20, 2, nt); })(Fe, Le.x, Fe.transform.height - Le.y, Nl); }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), B || (this.conflationActive = !1); }
                prepareLayer(n) { this.gpuTimingStart(n); const { unsupportedLayers: l } = this.transform.projection, f = !l || !l.includes(n.type); if (C_[n.type] && (f || this.terrain && n.type === "custom")) {
                    const _ = this.style.getLayerSourceCache(n);
                    C_[n.type](n, _, this);
                } this.gpuTimingEnd(); }
                renderLayer(n, l, f, _) { f.isHidden(this.transform.zoom) || (f.type === "background" || f.type === "sky" || f.type === "custom" || f.type === "model" || f.type === "raster" || f.type === "raster-particle" || _ && _.length) && (this.id = f.id, this.gpuTimingStart(f), n.transform.projection.unsupportedLayers && n.transform.projection.unsupportedLayers.includes(f.type) && (!n.terrain || f.type !== "custom") || f.type === "clip" || tn[f.type](n, l, f, _, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd()); }
                gpuTimingStart(n) { if (!this.options.gpuTiming)
                    return; const l = this.context.extTimerQuery, f = this.context.gl; let _ = this.gpuTimers[n.id]; _ || (_ = this.gpuTimers[n.id] = { calls: 0, cpuTime: 0, query: f.createQuery() }), _.calls++, f.beginQuery(l.TIME_ELAPSED_EXT, _.query); }
                gpuTimingDeferredRenderStart() { if (this.options.gpuTimingDeferredRender) {
                    const n = this.context.extTimerQuery, l = this.context.gl, f = l.createQuery();
                    this.deferredRenderGpuTimeQueries.push(f), l.beginQuery(n.TIME_ELAPSED_EXT, f);
                } }
                gpuTimingDeferredRenderEnd() { this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT); }
                gpuTimingEnd() { this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT); }
                collectGpuTimers() { const n = this.gpuTimers; return this.gpuTimers = {}, n; }
                collectDeferredRenderGpuQueries() { const n = this.deferredRenderGpuTimeQueries; return this.deferredRenderGpuTimeQueries = [], n; }
                queryGpuTimers(n) { const l = {}; for (const f in n) {
                    const _ = n[f], v = this.context.extTimerQuery, w = v.getQueryParameter(_.query, this.context.gl.QUERY_RESULT) / 1e6;
                    v.deleteQueryEXT(_.query), l[f] = w;
                } return l; }
                queryGpuTimeDeferredRender(n) { if (!this.options.gpuTimingDeferredRender)
                    return 0; const l = this.context.gl; let f = 0; for (const _ of n)
                    f += l.getQueryParameter(_, l.QUERY_RESULT) / 1e6, l.deleteQuery(_); return f; }
                translatePosMatrix(n, l, f, _, v) { if (!f[0] && !f[1])
                    return n; const w = v ? _ === "map" ? this.transform.angle : 0 : _ === "viewport" ? -this.transform.angle : 0; if (w) {
                    const P = Math.sin(w), R = Math.cos(w);
                    f = [f[0] * R - f[1] * P, f[0] * P + f[1] * R];
                } const T = [v ? f[0] : s.aw(l, f[0], this.transform.zoom), v ? f[1] : s.aw(l, f[1], this.transform.zoom), 0], C = new Float32Array(16); return s.bo(C, n, T), C; }
                saveTileTexture(n) { const l = n.size[0], f = this._tileTextures[l]; f ? f.push(n) : this._tileTextures[l] = [n]; }
                getTileTexture(n) { const l = this._tileTextures[n]; return l && l.length > 0 ? l.pop() : null; }
                terrainRenderModeElevated() { return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode; }
                linearFloatFilteringSupported() { return this.context.extTextureFloatLinear != null; }
                currentGlobalDefines(n, l, f) { const _ = f === void 0 ? this.terrain && this.terrain.renderingToTexture : f, v = []; return this.style && this.style.enable3dLights() && (n === "globeRaster" || n === "terrainRaster" ? (v.push("LIGHTING_3D_MODE"), v.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : _ || v.push("LIGHTING_3D_MODE")), this.renderPass === "shadow" && (this._shadowMapDebug || v.push("DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (v.push("TERRAIN"), this.linearFloatFilteringSupported() && v.push("TERRAIN_DEM_FLOAT_FORMAT")), this.transform.projection.name === "globe" && v.push("GLOBE"), !this._fogVisible || _ || l !== void 0 && !l || v.push("FOG", "FOG_DITHERING"), _ && v.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && v.push("OVERDRAW_INSPECTOR"), v; }
                getOrCreateProgram(n, l) { this.cache = this.cache || {}; const f = l && l.defines || [], _ = l && l.config, v = this.currentGlobalDefines(n, l && l.overrideFog, l && l.overrideRtt).concat(f), w = wp.cacheKey(Ic[n], n, v, _); return this.cache[w] || (this.cache[w] = new wp(this.context, n, Ic[n], _, uT[n], v)), this.cache[w]; }
                setCustomLayerDefaults() { this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault(); }
                setBaseState() { const n = this.context.gl; this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(n.FUNC_ADD); }
                initDebugOverlayCanvas() { this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new s.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8)); }
                destroy() { this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy(); }
                prepareDrawTile() { this.terrain && this.terrain.prepareDrawTile(); }
                uploadCommonLightUniforms(n, l) { if (this.style.enable3dLights()) {
                    const f = this.style.directionalLight, _ = this.style.ambientLight;
                    if (f && _) {
                        const v = ((w, T, C) => { const P = w.properties.get("direction"), R = w.properties.get("color-use-theme") === "none", O = w.properties.get("color").toRenderColor(R ? null : C.getLut(w.scope)).toArray01(), D = w.properties.get("intensity"), B = T.properties.get("color-use-theme") === "none", q = T.properties.get("color").toRenderColor(B ? null : C.getLut(T.scope)).toArray01(), G = T.properties.get("intensity"), K = [P.x, P.y, P.z], W = s.dw(q, G), oe = s.dw(O, D); return { u_lighting_ambient_color: W, u_lighting_directional_dir: K, u_lighting_directional_color: oe, u_ground_radiance: l_(K, oe, W) }; })(f, _, this.style);
                        l.setLightsUniformValues(n, v);
                    }
                } }
                uploadCommonUniforms(n, l, f, _, v) { if (this.uploadCommonLightUniforms(n, l), this.terrain && this.terrain.renderingToTexture)
                    return; const w = this.style.fog; if (w) {
                    const T = w.getOpacity(this.transform.pitch), C = ((P, R, O, D, B, q, G, K, W, oe, de, me) => { const we = P.transform, ve = R.properties.get("color-use-theme") === "none", xe = R.properties.get("color").toRenderColor(ve ? null : P.style.getLut(R.scope)).toArray01(); xe[3] = D; const ge = P.frameCounter / 1e3 % 1, [Se, Ce] = R.properties.get("vertical-range"); return { u_fog_matrix: O ? we.calculateFogTileMatrix(O) : me || P.identityMat, u_fog_range: R.getFovAdjustedRange(we._fov), u_fog_color: xe, u_fog_horizon_blend: R.properties.get("horizon-blend"), u_fog_vertical_limit: [Math.min(Se, Ce), Ce], u_fog_temporal_offset: ge, u_frustum_tl: B, u_frustum_tr: q, u_frustum_br: G, u_frustum_bl: K, u_globe_pos: W, u_globe_radius: oe, u_viewport: de, u_globe_transition: s.ah(we.zoom), u_is_globe: +(we.projection.name === "globe") }; })(this, w, f, T, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * s.q.devicePixelRatio, this.transform.height * s.q.devicePixelRatio], _);
                    l.setFogUniformValues(n, C);
                } v && l.setCutoffUniformValues(n, v.uniformValues); }
                setTileLoadedFlag(n) { this.tileLoaded = n; }
                saveCanvasCopy() { const n = this.canvasCopy(); n && (this.frameCopies.push(n), this.tileLoaded = !1); }
                canvasCopy() { const n = this.context.gl, l = n.createTexture(); return n.bindTexture(n.TEXTURE_2D, l), n.copyTexImage2D(n.TEXTURE_2D, 0, n.RGBA, 0, 0, n.drawingBufferWidth, n.drawingBufferHeight, 0), l; }
                getCanvasCopiesAndTimestamps() { return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps }; }
                averageElevationNeedsEasing() { if (!this.transform._elevation)
                    return !1; const n = this.style && this.style.fog; return !!n && n.getOpacity(this.transform.pitch) !== 0; }
                getBackgroundTiles() { const n = this._backgroundTiles, l = this._backgroundTiles = {}, f = this.transform.coveringTiles({ tileSize: 512 }); for (const _ of f)
                    l[_.key] = n[_.key] || new Xa(_, 512, this.transform.tileZoom, this); return l; }
                clearBackgroundTiles() { this._backgroundTiles = {}; }
                isSourceForClippingOrConflation(n, l) { return !(!n.is3D(!(!this.terrain || !this.terrain.enabled)) || n.type !== "clip" && (n.minzoom && n.minzoom > this.transform.zoom || (this.style._clipLayerPresent || n.sourceLayer !== "building") && (!l || l.type !== "batched-model"))); }
                isTileAffectedByFog(n) { if (!this.style || !this.style.fog)
                    return !1; if (this.transform.projection.name === "globe")
                    return !0; let l = this._cachedTileFogOpacities[n.key]; return l || (this._cachedTileFogOpacities[n.key] = l = this.style.fog.getOpacityForTile(n)), l[0] >= Ot || l[1] >= Ot; }
                setupDepthForOcclusion(n, l, f) { const _ = this.context, v = _.gl, w = !!f; var T; f || (f = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 }), _.activeTexture.set(v.TEXTURE3), n && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(v.NEAREST, v.CLAMP_TO_EDGE), f.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height], f.u_depth_range_unpack = [2 / ((T = this.depthRangeFor3D)[1] - T[0]), -1 - 2 * T[0] / (T[1] - T[0])], f.u_occluder_half_size = .5 * this.occlusionParams.occluderSize, f.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(v.NEAREST, v.CLAMP_TO_EDGE), _.activeTexture.set(v.TEXTURE0), w || l.setTerrainUniformValues(_, f); }
            }
            function Bc(d, n) { let l = !1, f = null; const _ = () => { f = null, l && (d(), f = setTimeout(_, n), l = !1); }; return () => (l = !0, f || _(), f); }
            class Vu {
                constructor(n) { this._hashName = n && encodeURIComponent(n), s.aV(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Bc(this._updateHashUnthrottled.bind(this), 300); }
                addTo(n) { return this._map = n, window.addEventListener("hashchange", this._onHashChange, !1), n.on("moveend", this._updateHash), this; }
                remove() { return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this; }
                getHashString() { const n = this._map; if (!n)
                    return ""; const l = Fp(n); if (this._hashName) {
                    const f = this._hashName;
                    let _ = !1;
                    const v = location.hash.slice(1).split("&").map(w => { const T = w.split("=")[0]; return T === f ? (_ = !0, `${T}=${l}`) : w; }).filter(w => w);
                    return _ || v.push(`${f}=${l}`), `#${v.join("&")}`;
                } return `#${l}`; }
                _getCurrentHash() { const n = location.hash.replace("#", ""); if (this._hashName) {
                    let l;
                    return n.split("&").map(f => f.split("=")).forEach(f => { f[0] === this._hashName && (l = f); }), (l && l[1] || "").split("/");
                } return n.split("/"); }
                _onHashChange() { const n = this._map; if (!n)
                    return !1; const l = this._getCurrentHash(); if (l.length >= 3 && !l.some(f => isNaN(Number(f)))) {
                    const f = n.dragRotate.isEnabled() && n.touchZoomRotate.isEnabled() ? +(l[3] || 0) : n.getBearing();
                    return n.jumpTo({ center: [+l[2], +l[1]], zoom: +l[0], bearing: f, pitch: +(l[4] || 0) }), !0;
                } return !1; }
                _updateHashUnthrottled() { history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString())); }
            }
            function Fp(d, n) { const l = d.getCenter(), f = Math.round(100 * d.getZoom()) / 100, _ = Math.ceil((f * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), v = Math.pow(10, _), w = Math.round(l.lng * v) / v, T = Math.round(l.lat * v) / v, C = d.getBearing(), P = d.getPitch(); let R = n ? `/${w}/${T}/${f}` : `${f}/${T}/${w}`; return (C || P) && (R += "/" + Math.round(10 * C) / 10), P && (R += `/${Math.round(P)}`), R; }
            const Uu = { linearity: .3, easing: s.ew(0, 0, .3, 1) }, A_ = s.l({ deceleration: 2500, maxSpeed: 1400 }, Uu), I_ = s.l({ deceleration: 20, maxSpeed: 1400 }, Uu), Ea = s.l({ deceleration: 1e3, maxSpeed: 360 }, Uu), el = s.l({ deceleration: 1e3, maxSpeed: 90 }, Uu);
            class Np {
                constructor(n) { this._map = n, this.clear(); }
                clear() { this._inertiaBuffer = []; }
                record(n) { this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: s.q.now(), settings: n }); }
                _drainInertiaBuffer() { const n = this._inertiaBuffer, l = s.q.now(); for (; n.length > 0 && l - n[0].time > 160;)
                    n.shift(); }
                _onMoveEnd(n) { if (this._map._prefersReducedMotion() || (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2))
                    return; const l = { zoom: 0, bearing: 0, pitch: 0, pan: new s.P(0, 0), pinchAround: void 0, around: void 0 }; for (const { settings: v } of this._inertiaBuffer)
                    l.zoom += v.zoomDelta || 0, l.bearing += v.bearingDelta || 0, l.pitch += v.pitchDelta || 0, v.panDelta && l.pan._add(v.panDelta), v.around && (l.around = v.around), v.pinchAround && (l.pinchAround = v.pinchAround); const f = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, _ = {}; if (l.pan.mag()) {
                    const v = $u(l.pan.mag(), f, s.l({}, A_, n || {}));
                    _.offset = l.pan.mult(v.amount / l.pan.mag()), _.center = this._map.transform.center, jc(_, v);
                } if (l.zoom) {
                    const v = $u(l.zoom, f, I_);
                    _.zoom = this._map.transform.zoom + v.amount, jc(_, v);
                } if (l.bearing) {
                    const v = $u(l.bearing, f, Ea);
                    _.bearing = this._map.transform.bearing + s.aD(v.amount, -179, 179), jc(_, v);
                } if (l.pitch) {
                    const v = $u(l.pitch, f, el);
                    _.pitch = this._map.transform.pitch + v.amount, jc(_, v);
                } if (_.zoom || _.bearing) {
                    const v = l.pinchAround === void 0 ? l.around : l.pinchAround;
                    _.around = v ? this._map.unproject(v) : this._map.getCenter();
                } return this.clear(), _.noMoveStart = !0, _; }
            }
            function jc(d, n) { (!d.duration || d.duration < n.duration) && (d.duration = n.duration, d.easing = n.easing); }
            function $u(d, n, l) { const { maxSpeed: f, linearity: _, deceleration: v } = l, w = s.aD(d * _ / (n / 1e3), -f, f), T = Math.abs(w) / (v * _); return { easing: l.easing, duration: 1e3 * T, amount: w * (T / 2) }; }
            class Gs extends s.A {
                preventDefault() { this._defaultPrevented = !0; }
                get defaultPrevented() { return this._defaultPrevented; }
                constructor(n, l, f, _ = {}) { const v = ot(l.getCanvasContainer(), f), w = l.unproject(v); super(n, s.l({ point: v, lngLat: w, originalEvent: f }, _)), this._defaultPrevented = !1, this.target = l; }
            }
            class Ca extends s.A {
                preventDefault() { this._defaultPrevented = !0; }
                get defaultPrevented() { return this._defaultPrevented; }
                constructor(n, l, f) { const _ = n === "touchend" ? f.changedTouches : f.touches, v = At(l.getCanvasContainer(), _), w = v.map(C => l.unproject(C)), T = v.reduce((C, P, R, O) => C.add(P.div(O.length)), new s.P(0, 0)); super(n, { points: v, point: T, lngLats: w, lngLat: l.unproject(T), originalEvent: f }), this._defaultPrevented = !1; }
            }
            class P_ extends s.A {
                preventDefault() { this._defaultPrevented = !0; }
                get defaultPrevented() { return this._defaultPrevented; }
                constructor(n, l) { super("wheel", { originalEvent: l }), this._defaultPrevented = !1; }
            }
            class Vl {
                constructor(n, l) { this._map = n, this._clickTolerance = l.clickTolerance; }
                reset() { this._mousedownPos = void 0; }
                wheel(n) { return this._firePreventable(new P_(this._map, n)); }
                mousedown(n, l) { return this._mousedownPos = l, this._firePreventable(new Gs(n.type, this._map, n)); }
                mouseup(n) { this._map.fire(new Gs(n.type, this._map, n)); }
                preclick(n) { const l = s.l({}, n); l.type = "preclick", this._map.fire(new Gs(l.type, this._map, l)); }
                click(n, l) { this._mousedownPos && this._mousedownPos.dist(l) >= this._clickTolerance || (this.preclick(n), this._map.fire(new Gs(n.type, this._map, n))); }
                dblclick(n) { return this._firePreventable(new Gs(n.type, this._map, n)); }
                mouseover(n) { this._map.fire(new Gs(n.type, this._map, n)); }
                mouseout(n) { this._map.fire(new Gs(n.type, this._map, n)); }
                touchstart(n) { return this._firePreventable(new Ca(n.type, this._map, n)); }
                touchmove(n) { this._map.fire(new Ca(n.type, this._map, n)); }
                touchend(n) { this._map.fire(new Ca(n.type, this._map, n)); }
                touchcancel(n) { this._map.fire(new Ca(n.type, this._map, n)); }
                _firePreventable(n) { if (this._map.fire(n), n.defaultPrevented)
                    return {}; }
                isEnabled() { return !0; }
                isActive() { return !1; }
                enable() { }
                disable() { }
            }
            class M_ {
                constructor(n) { this._map = n; }
                reset() { this._delayContextMenu = !1, this._contextMenuEvent = void 0; }
                mousemove(n) { this._map.fire(new Gs(n.type, this._map, n)); }
                mousedown() { this._delayContextMenu = !0; }
                mouseup() { this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Gs("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent); }
                contextmenu(n) { this._delayContextMenu ? this._contextMenuEvent = n : this._map.fire(new Gs(n.type, this._map, n)), this._map.listens("contextmenu") && n.preventDefault(); }
                isEnabled() { return !0; }
                isActive() { return !1; }
                enable() { }
                disable() { }
            }
            class Bp {
                constructor(n, l) { this._map = n, this._el = n.getCanvasContainer(), this._container = n.getContainer(), this._clickTolerance = l.clickTolerance || 1; }
                isEnabled() { return !!this._enabled; }
                isActive() { return !!this._active; }
                enable() { this.isEnabled() || (this._enabled = !0); }
                disable() { this.isEnabled() && (this._enabled = !1); }
                mousedown(n, l) { this.isEnabled() && n.shiftKey && n.button === 0 && (be(), this._startPos = this._lastPos = l, this._active = !0); }
                mousemoveWindow(n, l) { if (!this._active)
                    return; const f = l, _ = this._startPos, v = this._lastPos; if (!_ || !v || v.equals(f) || !this._box && f.dist(_) < this._clickTolerance)
                    return; this._lastPos = f, this._box || (this._box = J("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", n)); const w = Math.min(_.x, f.x), T = Math.max(_.x, f.x), C = Math.min(_.y, f.y), P = Math.max(_.y, f.y); this._map._requestDomTask(() => { this._box && (this._box.style.transform = `translate(${w}px,${C}px)`, this._box.style.width = T - w + "px", this._box.style.height = P - C + "px"); }); }
                mouseupWindow(n, l) { if (!this._active)
                    return; const f = this._startPos, _ = l; if (f && n.button === 0) {
                    if (this.reset(), Ze(), f.x !== _.x || f.y !== _.y)
                        return this._map.fire(new s.A("boxzoomend", { originalEvent: n })), { cameraAnimation: v => v.fitScreenCoordinates(f, _, this._map.getBearing(), { linear: !1 }) };
                    this._fireEvent("boxzoomcancel", n);
                } }
                keydown(n) { this._active && n.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", n)); }
                blur() { this.reset(); }
                reset() { this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), Ie(), delete this._startPos, delete this._lastPos; }
                _fireEvent(n, l) { return this._map.fire(new s.A(n, { originalEvent: l })); }
            }
            function Fd(d, n) { const l = {}; for (let f = 0; f < d.length; f++)
                l[d[f].identifier] = n[f]; return l; }
            class R_ {
                constructor(n) { this.reset(), this.numTouches = n.numTouches; }
                reset() { this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1; }
                touchstart(n, l, f) { (this.centroid || f.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === 0 && (this.startTime = n.timeStamp), f.length === this.numTouches && (this.centroid = function (_) { const v = new s.P(0, 0); for (const w of _)
                    v._add(w); return v.div(_.length); }(l), this.touches = Fd(f, l))); }
                touchmove(n, l, f) { if (this.aborted || !this.centroid)
                    return; const _ = Fd(f, l); for (const v in this.touches) {
                    const w = _[v];
                    (!w || w.dist(this.touches[v]) > 30) && (this.aborted = !0);
                } }
                touchend(n, l, f) { if ((!this.centroid || n.timeStamp - this.startTime > 500) && (this.aborted = !0), f.length === 0) {
                    const _ = !this.aborted && this.centroid;
                    if (this.reset(), _)
                        return _;
                } }
            }
            class Hi {
                constructor(n) { this.singleTap = new R_(n), this.numTaps = n.numTaps, this.reset(); }
                reset() { this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset(); }
                touchstart(n, l, f) { this.singleTap.touchstart(n, l, f); }
                touchmove(n, l, f) { this.singleTap.touchmove(n, l, f); }
                touchend(n, l, f) { const _ = this.singleTap.touchend(n, l, f); if (_) {
                    const v = n.timeStamp - this.lastTime < 500, w = !this.lastTap || this.lastTap.dist(_) < 30;
                    if (v && w || this.reset(), this.count++, this.lastTime = n.timeStamp, this.lastTap = _, this.count === this.numTaps)
                        return this.reset(), _;
                } }
            }
            class k_ {
                constructor() { this._zoomIn = new Hi({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Hi({ numTouches: 2, numTaps: 1 }), this.reset(); }
                reset() { this._active = !1, this._zoomIn.reset(), this._zoomOut.reset(); }
                touchstart(n, l, f) { this._zoomIn.touchstart(n, l, f), this._zoomOut.touchstart(n, l, f); }
                touchmove(n, l, f) { this._zoomIn.touchmove(n, l, f), this._zoomOut.touchmove(n, l, f); }
                touchend(n, l, f) { const _ = this._zoomIn.touchend(n, l, f), v = this._zoomOut.touchend(n, l, f); return _ ? (this._active = !0, n.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: w => w.easeTo({ duration: 300, zoom: w.getZoom() + 1, around: w.unproject(_) }, { originalEvent: n }) }) : v ? (this._active = !0, n.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: w => w.easeTo({ duration: 300, zoom: w.getZoom() - 1, around: w.unproject(v) }, { originalEvent: n }) }) : void 0; }
                touchcancel() { this.reset(); }
                enable() { this._enabled = !0; }
                disable() { this._enabled = !1, this.reset(); }
                isEnabled() { return this._enabled; }
                isActive() { return this._active; }
            }
            const D_ = { 0: 1, 2: 2 }, Ul = { Control: "ctrlKey", Alt: "altKey", Shift: "shiftKey", Meta: "metaKey" };
            class Nd {
                constructor(n) { this.reset(), this._clickTolerance = n.clickTolerance || 1; }
                blur() { this.reset(); }
                reset() { this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0; }
                _correctButton(n, l) { return !1; }
                _move(n, l) { return {}; }
                mousedown(n, l) { if (this._lastPoint)
                    return; const f = kt(n); this._correctButton(n, f) && (this._lastPoint = l, this._eventButton = f); }
                mousemoveWindow(n, l) { const f = this._lastPoint; if (f) {
                    if (n.preventDefault(), this._eventButton != null && function (_, v) { const w = D_[v]; return _.buttons === void 0 || (_.buttons & w) !== w; }(n, this._eventButton))
                        this.reset();
                    else if (this._moved || !(l.dist(f) < this._clickTolerance))
                        return this._moved = !0, this._lastPoint = l, this._move(f, l);
                } }
                mouseupWindow(n) { this._lastPoint && kt(n) === this._eventButton && (this._moved && Ze(), this.reset()); }
                enable() { this._enabled = !0; }
                disable() { this._enabled = !1, this.reset(); }
                isEnabled() { return this._enabled; }
                isActive() { return this._active; }
            }
            class L_ extends Nd {
                mousedown(n, l) { super.mousedown(n, l), this._lastPoint && (this._active = !0); }
                _correctButton(n, l) { return l === 0 && !n.ctrlKey; }
                _move(n, l) { return { around: l, panDelta: l.sub(n) }; }
            }
            class jp extends Nd {
                constructor(n) { super(n), this._pitchRotateKey = n.pitchRotateKey ? Ul[n.pitchRotateKey] : void 0; }
                _correctButton(n, l) { return this._pitchRotateKey ? l === 0 && n[this._pitchRotateKey] : l === 0 && n.ctrlKey || l === 2; }
                _move(n, l) { const f = .8 * (l.x - n.x); if (f)
                    return this._active = !0, { bearingDelta: f }; }
                contextmenu(n) { this._pitchRotateKey || n.preventDefault(); }
            }
            class Vc extends Nd {
                constructor(n) { super(n), this._pitchRotateKey = n.pitchRotateKey ? Ul[n.pitchRotateKey] : void 0; }
                _correctButton(n, l) { return this._pitchRotateKey ? l === 0 && n[this._pitchRotateKey] : l === 0 && n.ctrlKey || l === 2; }
                _move(n, l) { const f = -.5 * (l.y - n.y); if (f)
                    return this._active = !0, { pitchDelta: f }; }
                contextmenu(n) { this._pitchRotateKey || n.preventDefault(); }
            }
            class O_ {
                constructor(n, l) { this._map = n, this._el = n.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = l.clickTolerance || 1, this.reset(), s.aV(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this); }
                reset() { this._active = !1, this._touches = {}, this._sum = new s.P(0, 0); }
                touchstart(n, l, f) { return this._calculateTransform(n, l, f); }
                touchmove(n, l, f) { if (this._active && !(f.length < this._minTouches)) {
                    if (this._map._cooperativeGestures && !this._map.isMoving()) {
                        if (f.length === 1 && !s.ex())
                            return void this._showTouchPanBlockerAlert();
                        this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                    }
                    return n.cancelable && n.preventDefault(), this._calculateTransform(n, l, f);
                } }
                touchend(n, l, f) { this._calculateTransform(n, l, f), this._active && f.length < this._minTouches && this.reset(); }
                touchcancel() { this.reset(); }
                _calculateTransform(n, l, f) { f.length > 0 && (this._active = !0); const _ = Fd(f, l), v = new s.P(0, 0), w = new s.P(0, 0); let T = 0; for (const P in _) {
                    const R = _[P], O = this._touches[P];
                    O && (v._add(R), w._add(R.sub(O)), T++, _[P] = R);
                } if (this._touches = _, T < this._minTouches || !w.mag())
                    return; const C = w.div(T); return this._sum._add(C), this._sum.mag() < this._clickTolerance ? void 0 : { around: v.div(T), panDelta: C }; }
                enable() { this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")); }
                disable() { this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset(); }
                isEnabled() { return !!this._enabled; }
                isActive() { return !!this._active; }
                _addTouchPanBlocker() { this._map && !this._alertContainer && (this._alertContainer = J("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`); }
                _showTouchPanBlockerAlert() { this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => { this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role"); }, 500); }
            }
            class Bd {
                constructor() { this.reset(); }
                reset() { this._active = !1, this._firstTwoTouches = void 0; }
                _start(n) { }
                _move(n, l, f) { return {}; }
                touchstart(n, l, f) { this._firstTwoTouches || f.length < 2 || (this._firstTwoTouches = [f[0].identifier, f[1].identifier], this._start([l[0], l[1]])); }
                touchmove(n, l, f) { const _ = this._firstTwoTouches; if (!_)
                    return; n.preventDefault(); const [v, w] = _, T = Gu(f, l, v), C = Gu(f, l, w); if (!T || !C)
                    return; const P = this._aroundCenter ? null : T.add(C).div(2); return this._move([T, C], P, n); }
                touchend(n, l, f) { if (!this._firstTwoTouches)
                    return; const [_, v] = this._firstTwoTouches, w = Gu(f, l, _), T = Gu(f, l, v); w && T || (this._active && Ze(), this.reset()); }
                touchcancel() { this.reset(); }
                enable(n) { this._enabled = !0, this._aroundCenter = !!n && n.around === "center"; }
                disable() { this._enabled = !1, this.reset(); }
                isEnabled() { return this._enabled; }
                isActive() { return this._active; }
            }
            function Gu(d, n, l) { for (let f = 0; f < d.length; f++)
                if (d[f].identifier === l)
                    return n[f]; }
            function jd(d, n) { return Math.log(d / n) / Math.LN2; }
            class z_ extends Bd {
                reset() { super.reset(), this._distance = 0, this._startDistance = 0; }
                _start(n) { this._startDistance = this._distance = n[0].dist(n[1]); }
                _move(n, l) { const f = this._distance; if (this._distance = n[0].dist(n[1]), this._active || !(Math.abs(jd(this._distance, this._startDistance)) < .1))
                    return this._active = !0, { zoomDelta: jd(this._distance, f), pinchAround: l }; }
            }
            function Vp(d, n) { return 180 * d.angleWith(n) / Math.PI; }
            class rx extends Bd {
                reset() { super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0; }
                _start(n) { this._startVector = this._vector = n[0].sub(n[1]), this._minDiameter = n[0].dist(n[1]); }
                _move(n, l) { const f = this._vector; if (this._vector = n[0].sub(n[1]), f && (this._active || !this._isBelowThreshold(this._vector)))
                    return this._active = !0, { bearingDelta: Vp(this._vector, f), pinchAround: l }; }
                _isBelowThreshold(n) { this._minDiameter = Math.min(this._minDiameter, n.mag()); const l = 25 / (Math.PI * this._minDiameter) * 360, f = this._startVector; if (!f)
                    return !1; const _ = Vp(n, f); return Math.abs(_) < l; }
            }
            function Up(d) { return Math.abs(d.y) > Math.abs(d.x); }
            class nx extends Bd {
                constructor(n) { super(), this._map = n; }
                reset() { super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0; }
                _start(n) { this._lastPoints = n, Up(n[0].sub(n[1])) && (this._valid = !1); }
                _move(n, l, f) { const _ = this._lastPoints; if (!_)
                    return; const v = n[0].sub(_[0]), w = n[1].sub(_[1]); return this._map._cooperativeGestures && !s.ex() && f.touches.length < 3 || (this._valid = this.gestureBeginsVertically(v, w, f.timeStamp), !this._valid) ? void 0 : (this._lastPoints = n, this._active = !0, { pitchDelta: (v.y + w.y) / 2 * -.5 }); }
                gestureBeginsVertically(n, l, f) { if (this._valid !== void 0)
                    return this._valid; const _ = n.mag() >= 2, v = l.mag() >= 2; if (!_ && !v)
                    return; if (!_ || !v)
                    return this._firstMove == null && (this._firstMove = f), f - this._firstMove < 100 && void 0; const w = n.y > 0 == l.y > 0; return Up(n) && Up(l) && w; }
            }
            const ix = { panStep: 100, bearingStep: 15, pitchStep: 10 };
            class sx {
                constructor() { const n = ix; this._panStep = n.panStep, this._bearingStep = n.bearingStep, this._pitchStep = n.pitchStep, this._rotationDisabled = !1; }
                blur() { this.reset(); }
                reset() { this._active = !1; }
                keydown(n) { if (n.altKey || n.ctrlKey || n.metaKey)
                    return; let l = 0, f = 0, _ = 0, v = 0, w = 0; switch (n.keyCode) {
                    case 61:
                    case 107:
                    case 171:
                    case 187:
                        l = 1;
                        break;
                    case 189:
                    case 109:
                    case 173:
                        l = -1;
                        break;
                    case 37:
                        n.shiftKey ? f = -1 : (n.preventDefault(), v = -1);
                        break;
                    case 39:
                        n.shiftKey ? f = 1 : (n.preventDefault(), v = 1);
                        break;
                    case 38:
                        n.shiftKey ? _ = 1 : (n.preventDefault(), w = -1);
                        break;
                    case 40:
                        n.shiftKey ? _ = -1 : (n.preventDefault(), w = 1);
                        break;
                    default: return;
                } return this._rotationDisabled && (f = 0, _ = 0), { cameraAnimation: T => { const C = T.getZoom(); T.easeTo({ duration: 300, easeId: "keyboardHandler", easing: ox, zoom: l ? Math.round(C) + l * (n.shiftKey ? 2 : 1) : C, bearing: T.getBearing() + f * this._bearingStep, pitch: T.getPitch() + _ * this._pitchStep, offset: [-v * this._panStep, -w * this._panStep], center: T.getCenter() }, { originalEvent: n }); } }; }
                enable() { this._enabled = !0; }
                disable() { this._enabled = !1, this.reset(); }
                isEnabled() { return this._enabled; }
                isActive() { return this._active; }
                disableRotation() { this._rotationDisabled = !0; }
                enableRotation() { this._rotationDisabled = !1; }
            }
            function ox(d) { return d * (2 - d); }
            const F_ = 4.000244140625, ax = 1 / 450;
            class lx {
                constructor(n, l) { this._map = n, this._el = n.getCanvasContainer(), this._handler = l, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = ax, s.aV(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this); }
                setZoomRate(n) { this._defaultZoomRate = n; }
                setWheelZoomRate(n) { this._wheelZoomRate = n; }
                isEnabled() { return !!this._enabled; }
                isActive() { return this._active || this._finishTimeout !== void 0; }
                isZooming() { return !!this._zooming; }
                enable(n) { this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!n && n.around === "center", this._map._cooperativeGestures && this._addScrollZoomBlocker()); }
                disable() { this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove())); }
                wheel(n) { if (!this.isEnabled())
                    return; if (this._map._cooperativeGestures) {
                    if (!(n.ctrlKey || n.metaKey || this.isZooming() || s.ex()))
                        return void this._showBlockerAlert();
                    this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                } let l = n.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * n.deltaY : n.deltaY; const f = s.q.now(), _ = f - (this._lastWheelEventTime || 0); this._lastWheelEventTime = f, l !== 0 && l % F_ == 0 ? this._type = "wheel" : l !== 0 && Math.abs(l) < 4 ? this._type = "trackpad" : _ > 400 ? (this._type = null, this._lastValue = l, this._timeout = window.setTimeout(this._onTimeout, 40, n)) : this._type || (this._type = Math.abs(_ * l) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, l += this._lastValue)), n.shiftKey && l && (l /= 4), this._type && (this._lastWheelEvent = n, this._delta -= l, this._active || this._start(n)), n.preventDefault(); }
                _onTimeout(n) { this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(n); }
                _start(n) { if (!this._delta)
                    return; this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout); const l = ot(this._el, n); this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : l, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame()); }
                renderFrame() { if (!this._frameId || (this._frameId = null, !this.isActive()))
                    return; const n = this._map.transform; this._type === "wheel" && n.projection.wrap && (n._center.lng >= 180 || n._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0); const l = () => n._terrainEnabled() && this._aroundCoord ? n.computeZoomRelativeTo(this._aroundCoord) : n.zoom; if (this._delta !== 0) {
                    const P = this._type === "wheel" && Math.abs(this._delta) > F_ ? this._wheelZoomRate : this._defaultZoomRate;
                    let R = 2 / (1 + Math.exp(-Math.abs(this._delta * P)));
                    this._delta < 0 && R !== 0 && (R = 1 / R);
                    const O = l(), D = Math.pow(2, O), B = typeof this._targetZoom == "number" ? n.zoomScale(this._targetZoom) : D;
                    this._targetZoom = Math.min(n.maxZoom, Math.max(n.minZoom, n.scaleZoom(B * R))), this._type === "wheel" && (this._startZoom = O, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
                } const f = typeof this._targetZoom == "number" ? this._targetZoom : l(), _ = this._startZoom, v = this._easing; let w, T = !1; if (this._type === "wheel" && _ && v) {
                    const P = Math.min((s.q.now() - this._lastWheelEventTime) / 200, 1), R = v(P);
                    w = s.ai(_, f, R), P < 1 ? this._frameId || (this._frameId = !0) : T = !0;
                }
                else
                    w = f, T = !0; this._active = !0, T && (this._active = !1, this._finishTimeout = window.setTimeout(() => { this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout; }, 200)); let C = w - l(); return C * this._lastDelta < 0 && (C = 0), { noInertia: !0, needsRenderFrame: !T, zoomDelta: C, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent }; }
                _smoothOutEasing(n) { let l = s.ey; if (this._prevEase) {
                    const f = this._prevEase, _ = (s.q.now() - f.start) / f.duration, v = f.easing(_ + .01) - f.easing(_), w = .27 / Math.sqrt(v * v + 1e-4) * .01, T = Math.sqrt(.0729 - w * w);
                    l = s.ew(w, T, .25, 1);
                } return this._prevEase = { start: s.q.now(), duration: n, easing: l }, l; }
                blur() { this.reset(); }
                reset() { this._active = !1; }
                _addScrollZoomBlocker() { this._map && !this._alertContainer && (this._alertContainer = J("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`); }
                _showBlockerAlert() { this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => { this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role"); }, 200); }
            }
            class cx {
                constructor(n, l) { this._clickZoom = n, this._tapZoom = l; }
                enable() { this._clickZoom.enable(), this._tapZoom.enable(); }
                disable() { this._clickZoom.disable(), this._tapZoom.disable(); }
                isEnabled() { return this._clickZoom.isEnabled() && this._tapZoom.isEnabled(); }
                isActive() { return this._clickZoom.isActive() || this._tapZoom.isActive(); }
            }
            class ux {
                constructor() { this.reset(); }
                reset() { this._active = !1; }
                blur() { this.reset(); }
                dblclick(n, l) { return n.preventDefault(), { cameraAnimation: f => { f.easeTo({ duration: 300, zoom: f.getZoom() + (n.shiftKey ? -1 : 1), around: f.unproject(l) }, { originalEvent: n }); } }; }
                enable() { this._enabled = !0; }
                disable() { this._enabled = !1, this.reset(); }
                isEnabled() { return this._enabled; }
                isActive() { return this._active; }
            }
            class hx {
                constructor() { this._tap = new Hi({ numTouches: 1, numTaps: 1 }), this.reset(); }
                reset() { this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset(); }
                touchstart(n, l, f) { this._swipePoint || (this._tapTime && n.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? f.length > 0 && (this._swipePoint = l[0], this._swipeTouch = f[0].identifier) : this._tap.touchstart(n, l, f)); }
                touchmove(n, l, f) { if (this._tapTime) {
                    if (this._swipePoint) {
                        if (f[0].identifier !== this._swipeTouch)
                            return;
                        const _ = l[0], v = _.y - this._swipePoint.y;
                        return this._swipePoint = _, n.preventDefault(), this._active = !0, { zoomDelta: v / 128 };
                    }
                }
                else
                    this._tap.touchmove(n, l, f); }
                touchend(n, l, f) { this._tapTime ? this._swipePoint && f.length === 0 && this.reset() : this._tap.touchend(n, l, f) && (this._tapTime = n.timeStamp); }
                touchcancel() { this.reset(); }
                enable() { this._enabled = !0; }
                disable() { this._enabled = !1, this.reset(); }
                isEnabled() { return this._enabled; }
                isActive() { return this._active; }
            }
            class dx {
                constructor(n, l, f) { this._el = n, this._mousePan = l, this._touchPan = f; }
                enable(n) { this._inertiaOptions = n || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan"); }
                disable() { this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan"); }
                isEnabled() { return this._mousePan.isEnabled() && this._touchPan.isEnabled(); }
                isActive() { return this._mousePan.isActive() || this._touchPan.isActive(); }
            }
            class xT {
                constructor(n, l, f) { this._pitchWithRotate = n.pitchWithRotate, this._mouseRotate = l, this._mousePitch = f; }
                enable() { this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(); }
                disable() { this._mouseRotate.disable(), this._mousePitch.disable(); }
                isEnabled() { return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()); }
                isActive() { return this._mouseRotate.isActive() || this._mousePitch.isActive(); }
            }
            class wT {
                constructor(n, l, f, _) { this._el = n, this._touchZoom = l, this._touchRotate = f, this._tapDragZoom = _, this._rotationDisabled = !1, this._enabled = !0; }
                enable(n) { this._touchZoom.enable(n), this._rotationDisabled || this._touchRotate.enable(n), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate"); }
                disable() { this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate"); }
                isEnabled() { return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled(); }
                isActive() { return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive(); }
                disableRotation() { this._rotationDisabled = !0, this._touchRotate.disable(); }
                enableRotation() { this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable(); }
            }
            const ti = d => d.zoom || d.drag || d.pitch || d.rotate;
            class fx extends s.A {
            }
            class bT {
                constructor() { this.constants = [1, 1, .01], this.radius = 0; }
                setup(n, l) { const f = s.at([], l, n); this.radius = s.ae(f[2] < 0 ? s.eA([], f, this.constants) : [f[0], f[1], 0]); }
                projectRay(n) { s.eA(n, n, this.constants), s.au(n, n), s.eB(n, n, this.constants); const l = s.b$([], n, this.radius); if (l[2] > 0) {
                    const f = s.b$([], [0, 0, 1], s.bE(l, [0, 0, 1])), _ = s.b$([], s.au([], [l[0], l[1], 0]), this.radius), v = s.cU([], l, s.b$([], s.at([], s.cU([], _, f), l), 2));
                    l[0] = v[0], l[1] = v[1];
                } return l; }
            }
            function qu(d) { return d.panDelta && d.panDelta.mag() || d.zoomDelta || d.bearingDelta || d.pitchDelta; }
            class TT {
                constructor(n, l) { this._map = n, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Np(n), this._bearingSnap = l.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new bT, this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(l), s.aV(["handleEvent", "handleWindowEvent"], this); const f = this._el; this._listeners = [[f, "touchstart", { passive: !0 }], [f, "touchmove", { passive: !1 }], [f, "touchend", void 0], [f, "touchcancel", void 0], [f, "mousedown", void 0], [f, "mousemove", void 0], [f, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [f, "mouseover", void 0], [f, "mouseout", void 0], [f, "dblclick", void 0], [f, "click", void 0], [f, "keydown", { capture: !1 }], [f, "keyup", void 0], [f, "wheel", { passive: !1 }], [f, "contextmenu", void 0], [window, "blur", void 0]]; for (const [_, v, w] of this._listeners) {
                    const T = _ === document ? this.handleWindowEvent : this.handleEvent;
                    _.addEventListener(v, T, w);
                } }
                destroy() { for (const [n, l, f] of this._listeners) {
                    const _ = n === document ? this.handleWindowEvent : this.handleEvent;
                    n.removeEventListener(l, _, f);
                } }
                _addDefaultHandlers(n) { const l = this._map, f = l.getCanvasContainer(); this._add("mapEvent", new Vl(l, n)); const _ = l.boxZoom = new Bp(l, n); this._add("boxZoom", _); const v = new k_, w = new ux; l.doubleClickZoom = new cx(w, v), this._add("tapZoom", v), this._add("clickZoom", w); const T = new hx; this._add("tapDragZoom", T); const C = l.touchPitch = new nx(l); this._add("touchPitch", C); const P = new jp(n), R = new Vc(n); l.dragRotate = new xT(n, P, R), this._add("mouseRotate", P, ["mousePitch"]), this._add("mousePitch", R, ["mouseRotate"]); const O = new L_(n), D = new O_(l, n); l.dragPan = new dx(f, O, D), this._add("mousePan", O), this._add("touchPan", D, ["touchZoom", "touchRotate"]); const B = new rx, q = new z_; l.touchZoomRotate = new wT(f, q, B, T), this._add("touchRotate", B, ["touchPan", "touchZoom"]), this._add("touchZoom", q, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new M_(l)); const G = l.scrollZoom = new lx(l, this); this._add("scrollZoom", G, ["mousePan"]); const K = l.keyboard = new sx; this._add("keyboard", K); for (const W of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
                    n.interactive && n[W] && l[W].enable(n[W]); }
                _add(n, l, f) { this._handlers.push({ handlerName: n, handler: l, allowed: f }), this._handlersById[n] = l; }
                stop(n) { if (!this._updatingCamera) {
                    for (const { handler: l } of this._handlers)
                        l.reset();
                    this._inertia.clear(), this._fireEvents({}, {}, n), this._changes = [], this._originalZoom = void 0;
                } }
                isActive() { for (const { handler: n } of this._handlers)
                    if (n.isActive())
                        return !0; return !1; }
                isZooming() { return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming(); }
                isRotating() { return !!this._eventsInProgress.rotate; }
                isMoving() { return !!ti(this._eventsInProgress) || this.isZooming(); }
                _isDragging() { return !!this._eventsInProgress.drag; }
                _blockedByActive(n, l, f) { for (const _ in n)
                    if (_ !== f && (!l || l.indexOf(_) < 0))
                        return !0; return !1; }
                handleWindowEvent(n) { this.handleEvent(n, `${n.type}Window`); }
                _getMapTouches(n) { const l = []; for (const f of n)
                    this._el.contains(f.target) && l.push(f); return l; }
                handleEvent(n, l) { this._updatingCamera = !0; const f = n.type === "renderFrame", _ = f ? void 0 : n, v = { needsRenderFrame: !1 }, w = {}, T = {}, C = n.touches ? this._getMapTouches(n.touches) : void 0, P = C ? At(this._el, C) : f ? void 0 : ot(this._el, n); for (const { handlerName: D, handler: B, allowed: q } of this._handlers) {
                    if (!B.isEnabled())
                        continue;
                    let G;
                    this._blockedByActive(T, q, D) ? B.reset() : B[l || n.type] && (G = B[l || n.type](n, P, C), this.mergeHandlerResult(v, w, G, D, _), G && G.needsRenderFrame && this._triggerRenderFrame()), (G || B.isActive()) && (T[D] = B);
                } const R = {}; for (const D in this._previousActiveHandlers)
                    T[D] || (R[D] = _); this._previousActiveHandlers = T, (Object.keys(R).length || qu(v)) && (this._changes.push([v, w, R]), this._triggerRenderFrame()), (Object.keys(T).length || qu(v)) && this._map._stop(!0), this._updatingCamera = !1; const { cameraAnimation: O } = v; O && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], O(this._map)); }
                mergeHandlerResult(n, l, f, _, v) { if (!f)
                    return; s.l(n, f); const w = { handlerName: _, originalEvent: f.originalEvent || v }; f.zoomDelta !== void 0 && (l.zoom = w), f.panDelta !== void 0 && (l.drag = w), f.pitchDelta !== void 0 && (l.pitch = w), f.bearingDelta !== void 0 && (l.rotate = w); }
                _applyChanges() { const n = {}, l = {}, f = {}; for (const [_, v, w] of this._changes)
                    _.panDelta && (n.panDelta = (n.panDelta || new s.P(0, 0))._add(_.panDelta)), _.zoomDelta && (n.zoomDelta = (n.zoomDelta || 0) + _.zoomDelta), _.bearingDelta && (n.bearingDelta = (n.bearingDelta || 0) + _.bearingDelta), _.pitchDelta && (n.pitchDelta = (n.pitchDelta || 0) + _.pitchDelta), _.around !== void 0 && (n.around = _.around), _.aroundCoord !== void 0 && (n.aroundCoord = _.aroundCoord), _.pinchAround !== void 0 && (n.pinchAround = _.pinchAround), _.noInertia && (n.noInertia = _.noInertia), s.l(l, v), s.l(f, w); this._updateMapTransform(n, l, f), this._changes = []; }
                _updateMapTransform(n, l, f) { const _ = this._map, v = _.transform, w = oe => [oe.x, oe.y, oe.z]; if ((oe => { const de = this._eventsInProgress.drag; return de && !this._handlersById[de.handlerName].isActive(); })() && !qu(n)) {
                    const oe = v.zoom;
                    v.cameraElevationReference = "sea", this._originalZoom != null && v._orthographicProjectionAtLowPitch && v.projection.name !== "globe" && v.pitch === 0 ? (v.cameraElevationReference = "ground", v.zoom = this._originalZoom) : (v.recenterOnTerrain(), v.cameraElevationReference = "ground"), oe !== v.zoom && this._map._update(!0);
                } if (v._isCameraConstrained && _._stop(!0), !qu(n))
                    return void this._fireEvents(l, f, !0); let { panDelta: T, zoomDelta: C, bearingDelta: P, pitchDelta: R, around: O, aroundCoord: D, pinchAround: B } = n; v._isCameraConstrained && (C > 0 && (C = 0), v._isCameraConstrained = !1), B !== void 0 && (O = B), (C || (oe => l[oe] && !this._eventsInProgress[oe])("drag")) && O && (this._dragOrigin = w(v.pointCoordinate3D(O)), this._originalZoom = v.zoom, this._trackingEllipsoid.setup(v._camera.position, this._dragOrigin)), v.cameraElevationReference = "sea", _._stop(!0), O = O || _.transform.centerPoint, P && (v.bearing += P), R && (v.pitch += R), v._updateCameraState(); const q = [0, 0, 0]; if (T)
                    if (v.projection.name === "mercator") {
                        const oe = this._trackingEllipsoid.projectRay(v.screenPointToMercatorRay(O).dir), de = this._trackingEllipsoid.projectRay(v.screenPointToMercatorRay(O.sub(T)).dir);
                        q[0] = de[0] - oe[0], q[1] = de[1] - oe[1];
                    }
                    else {
                        const oe = v.pointCoordinate(O);
                        if (v.projection.name === "globe") {
                            T = T.rotate(-v.angle);
                            const de = v._pixelsPerMercatorPixel / v.worldSize;
                            q[0] = -T.x * s.ez(s.aY(oe.y)) * de, q[1] = -T.y * s.ez(v.center.lat) * de;
                        }
                        else {
                            const de = v.pointCoordinate(O.sub(T));
                            oe && de && (q[0] = de.x - oe.x, q[1] = de.y - oe.y);
                        }
                    } const G = v.zoom, K = [0, 0, 0]; if (C) {
                    const oe = w(D || v.pointCoordinate3D(O)), de = { dir: s.au([], s.at([], oe, v._camera.position)) };
                    if (de.dir[2] < 0) {
                        const me = v.zoomDeltaToMovement(oe, C);
                        s.b$(K, de.dir, me);
                    }
                } const W = s.cU(q, q, K); v._translateCameraConstrained(W), C && Math.abs(v.zoom - G) > 1e-4 && v.recenterOnTerrain(), v.cameraElevationReference = "ground", this._map._update(), n.noInertia || this._inertia.record(n), this._fireEvents(l, f, !0); }
                _fireEvents(n, l, f) { const _ = ti(this._eventsInProgress), v = ti(n), w = {}; for (const R in n) {
                    const { originalEvent: O } = n[R];
                    this._eventsInProgress[R] || (w[`${R}start`] = O), this._eventsInProgress[R] = n[R];
                } !_ && v && this._fireEvent("movestart", v.originalEvent); for (const R in w)
                    this._fireEvent(R, w[R]); v && this._fireEvent("move", v.originalEvent); for (const R in n) {
                    const { originalEvent: O } = n[R];
                    this._fireEvent(R, O);
                } const T = {}; let C; for (const R in this._eventsInProgress) {
                    const { handlerName: O, originalEvent: D } = this._eventsInProgress[R];
                    this._handlersById[O].isActive() || (delete this._eventsInProgress[R], C = l[O] || D, T[`${R}end`] = C);
                } for (const R in T)
                    this._fireEvent(R, T[R]); const P = ti(this._eventsInProgress); if (f && (_ || v) && !P) {
                    this._updatingCamera = !0;
                    const R = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), O = D => D !== 0 && -this._bearingSnap < D && D < this._bearingSnap;
                    R ? (O(R.bearing || this._map.getBearing()) && (R.bearing = 0), this._map.easeTo(R, { originalEvent: C })) : (this._map.fire(new s.A("moveend", { originalEvent: C })), O(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
                } }
                _fireEvent(n, l) { this._map.fire(new s.A(n, l ? { originalEvent: l } : {})); }
                _requestFrame() { return this._map.triggerRepaint(), this._map._renderTaskQueue.add(n => { this._frameId = void 0, this.handleEvent(new fx("renderFrame", { timeStamp: n })), this._applyChanges(); }); }
                _triggerRenderFrame() { this._frameId === void 0 && (this._frameId = this._requestFrame()); }
            }
            const Hu = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
            class px extends s.E {
                constructor(n, l) { super(), this._moving = !1, this._zooming = !1, this.transform = n, this._bearingSnap = l.bearingSnap, this._respectPrefersReducedMotion = l.respectPrefersReducedMotion !== !1, s.aV(["_renderFrameCallback"], this); }
                getCenter() { return new s.cd(this.transform.center.lng, this.transform.center.lat); }
                setCenter(n, l) { return this.jumpTo({ center: n }, l); }
                panBy(n, l, f) { return n = s.P.convert(n).mult(-1), this.panTo(this.transform.center, s.l({ offset: n }, l), f); }
                panTo(n, l, f) { return this.easeTo(s.l({ center: n }, l), f); }
                getZoom() { return this.transform.zoom; }
                setZoom(n, l) { return this.jumpTo({ zoom: n }, l), this; }
                zoomTo(n, l, f) { return this.easeTo(s.l({ zoom: n }, l), f); }
                zoomIn(n, l) { return this.zoomTo(this.getZoom() + 1, n, l), this; }
                zoomOut(n, l) { return this.zoomTo(this.getZoom() - 1, n, l), this; }
                getBearing() { return this.transform.bearing; }
                setBearing(n, l) { return this.jumpTo({ bearing: n }, l), this; }
                getPadding() { return this.transform.padding; }
                setPadding(n, l) { return this.jumpTo({ padding: n }, l), this; }
                rotateTo(n, l, f) { return this.easeTo(s.l({ bearing: n }, l), f); }
                resetNorth(n, l) { return this.rotateTo(0, s.l({ duration: 1e3 }, n), l), this; }
                resetNorthPitch(n, l) { return this.easeTo(s.l({ bearing: 0, pitch: 0, duration: 1e3 }, n), l), this; }
                snapToNorth(n, l) { return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(n, l) : this; }
                getPitch() { return this.transform.pitch; }
                setPitch(n, l) { return this.jumpTo({ pitch: n }, l), this; }
                cameraForBounds(n, l) { n = s.aG.convert(n); const f = l && l.bearing || 0, _ = l && l.pitch || 0, v = n.getNorthWest(), w = n.getSouthEast(); return this._cameraForBounds(this.transform, v, w, f, _, l); }
                _extendPadding(n) { const l = { top: 0, right: 0, bottom: 0, left: 0 }; return n == null ? s.l({}, l, this.transform.padding) : typeof n == "number" ? { top: n, bottom: n, right: n, left: n } : s.l({}, l, n); }
                _extendCameraOptions(n) { return (n = s.l({ offset: [0, 0], maxZoom: this.transform.maxZoom }, n)).padding = this._extendPadding(n.padding), n; }
                _minimumAABBFrustumDistance(n, l) { const f = l.max[0] - l.min[0], _ = l.max[1] - l.min[1]; return f / _ > n.aspect ? f / (2 * Math.tan(.5 * n.fovX) * n.aspect) : _ / (2 * Math.tan(.5 * n.fovY) * n.aspect); }
                _cameraForBoundsOnGlobe(n, l, f, _, v, w) { const T = n.clone(), C = this._extendCameraOptions(w); T.bearing = _, T.pitch = v; const P = s.cd.convert(l), R = s.cd.convert(f), O = .5 * (P.lat + R.lat), D = .5 * (P.lng + R.lng), B = s.eC(O, D), q = s.au([], B), G = s.au([], s.bG([], q, [0, 1, 0])), K = s.bG([], G, q), W = [G[0], G[1], G[2], 0, K[0], K[1], K[2], 0, q[0], q[1], q[2], 0, 0, 0, 0, 1], oe = [B, s.eC(P.lat, P.lng), s.eC(R.lat, P.lng), s.eC(R.lat, R.lng), s.eC(P.lat, R.lng), s.eC(O, P.lng), s.eC(O, R.lng), s.eC(P.lat, D), s.eC(R.lat, D)]; let de = s.cV.fromPoints(oe.map(He => [s.bE(G, He), s.bE(K, He), s.bE(q, He)])); const me = s.ad([], de.center, W); s.eD(me) === 0 && s.eE(me, 0, 0, 1), s.au(me, me), s.b$(me, me, s.aE), T.center = s.eF(me); const we = T.getWorldToCameraMatrix(), ve = s.bi(new Float64Array(16), we); de = s.cV.applyTransform(de, s.az([], we, W)); const xe = this._extendAABB(de, T, C, _); if (!xe)
                    return void s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset."); de = xe, s.ad(me, me, we); const ge = .5 * (de.max[2] - de.min[2]), Se = this._minimumAABBFrustumDistance(T, de), Ce = s.b$([], [0, 0, 1], ge), je = s.cU(Ce, me, Ce), ze = Se + (T.pitch === 0 ? 0 : s.bD(me, je)), rt = T.globeCenterInViewSpace, et = s.at([], me, [rt[0], rt[1], rt[2]]); s.au(et, et), s.b$(et, et, ze); const vt = s.cU([], me, et); s.ad(vt, vt, ve); const Fe = s.eq / s.aE, Ve = s.ae(vt), Le = s.c6(Math.max(Ve * Fe - s.eq, Number.EPSILON), 0), st = Math.min(T.zoomFromMercatorZAdjusted(Le), C.maxZoom); return st > .5 * (s.cL + s.cx) ? (T.setProjection({ name: "mercator" }), T.zoom = st, this._cameraForBounds(T, l, f, _, v, w)) : { center: T.center, zoom: st, bearing: _, pitch: v }; }
                _extendAABB(n, l, f, _) { const v = .5 * ((f.padding.left || 0) + (f.padding.right || 0)), w = .5 * ((f.padding.top || 0) + (f.padding.bottom || 0)), T = w, C = v, P = v, R = w, O = l.width - (C + P), D = l.height - (T + R), B = s.at([], n.max, n.min), q = Math.min(O / B[0], D / B[1]), G = Math.min(l.scaleZoom(l.scale * q), f.maxZoom); if (isNaN(G))
                    return null; const K = l.scale / l.zoomScale(G), W = new s.cV([n.min[0] - C * K, n.min[1] - R * K, n.min[2]], [n.max[0] + P * K, n.max[1] + T * K, n.max[2]]), oe = (typeof f.offset.x == "number" && typeof f.offset.y == "number" ? new s.P(f.offset.x, f.offset.y) : s.P.convert(f.offset)).rotate(-s.al(_)); return W.center[0] -= oe.x * K, W.center[1] += oe.y * K, W; }
                queryTerrainElevation(n, l) { const f = this.transform.elevation; return f ? (l = s.l({}, { exaggerated: !0 }, l), f.getAtPoint(s.ac.fromLngLat(n), null, l.exaggerated)) : null; }
                _cameraForBounds(n, l, f, _, v, w) { if (n.projection.name === "globe")
                    return this._cameraForBoundsOnGlobe(n, l, f, _, v, w); const T = n.clone(), C = this._extendCameraOptions(w); T.bearing = _, T.pitch = v; const P = s.cd.convert(l), R = s.cd.convert(f), O = new s.cd(P.lng, R.lat), D = new s.cd(R.lng, P.lat), B = T.project(P), q = T.project(R), G = this.queryTerrainElevation(P), K = this.queryTerrainElevation(R), W = this.queryTerrainElevation(O), oe = this.queryTerrainElevation(D), de = [[B.x, B.y, Math.min(G || 0, K || 0, W || 0, oe || 0)], [q.x, q.y, Math.max(G || 0, K || 0, W || 0, oe || 0)]]; let me = s.cV.fromPoints(de); const we = T.getWorldToCameraMatrix(), ve = s.bi(new Float64Array(16), we); me = s.cV.applyTransform(me, we); const xe = this._extendAABB(me, T, C, _); if (!xe)
                    return void s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset."); me = xe; const ge = .5 * s.at([], me.max, me.min)[2], Se = this._minimumAABBFrustumDistance(T, me), Ce = [0, 0, 1, 0]; s.aA(Ce, Ce, we), s.eG(Ce, Ce); const je = s.b$([], Ce, Se + ge), ze = s.cU([], me.center, je); s.ad(me.center, me.center, ve), s.ad(ze, ze, ve); const rt = T.unproject(new s.P(me.center[0], me.center[1])), et = s.eH(T.projection, rt), vt = Math.pow(2, et), Fe = Math.min(T._zoomFromMercatorZ(ze[2] * T.pixelsPerMeter * vt / T.worldSize), C.maxZoom); return T.mercatorFromTransition && Fe < .5 * (s.cL + s.cx) ? (T.setProjection({ name: "globe" }), T.zoom = Fe, this._cameraForBounds(T, l, f, _, v, w)) : { center: rt, zoom: Fe, bearing: _, pitch: v }; }
                fitBounds(n, l, f) { const _ = this.cameraForBounds(n, l); return this._fitInternal(_, l, f); }
                fitScreenCoordinates(n, l, f, _, v) { const w = s.P.convert(n), T = s.P.convert(l), C = new s.P(Math.min(w.x, T.x), Math.min(w.y, T.y)), P = new s.P(Math.max(w.x, T.x), Math.max(w.y, T.y)); if (this.transform.projection.name === "mercator" && this.transform.anyCornerOffEdge(w, T))
                    return this; const R = this.transform.pointLocation3D(C), O = this.transform.pointLocation3D(P), D = this.transform.pointLocation3D(new s.P(C.x, P.y)), B = this.transform.pointLocation3D(new s.P(P.x, C.y)), q = [Math.min(R.lng, O.lng, D.lng, B.lng), Math.min(R.lat, O.lat, D.lat, B.lat)], G = [Math.max(R.lng, O.lng, D.lng, B.lng), Math.max(R.lat, O.lat, D.lat, B.lat)], K = _ && _.pitch ? _.pitch : this.getPitch(), W = this._cameraForBounds(this.transform, q, G, f, K, _); return this._fitInternal(W, _, v); }
                _fitInternal(n, l, f) { return n ? (l = s.l(n, l)).linear ? this.easeTo(l, f) : this.flyTo(l, f) : this; }
                jumpTo(n, l) { this.stop(); const f = n.preloadOnly ? this.transform.clone() : this.transform; let _ = !1, v = !1, w = !1; "zoom" in n && f.zoom !== +n.zoom && (_ = !0, f.zoom = +n.zoom), n.center !== void 0 && (f.center = s.cd.convert(n.center)), "bearing" in n && f.bearing !== +n.bearing && (v = !0, f.bearing = +n.bearing), "pitch" in n && f.pitch !== +n.pitch && (w = !0, f.pitch = +n.pitch); const T = typeof n.padding == "number" ? this._extendPadding(n.padding) : n.padding; if (n.padding != null && !f.isPaddingEqual(T))
                    if (n.retainPadding === !1) {
                        const C = f.clone();
                        C.padding = T, f.setLocationAtPoint(f.center, C.centerPoint);
                    }
                    else
                        f.padding = T; return n.preloadOnly ? (this._preloadTiles(f), this) : (this.fire(new s.A("movestart", l)).fire(new s.A("move", l)), _ && this.fire(new s.A("zoomstart", l)).fire(new s.A("zoom", l)).fire(new s.A("zoomend", l)), v && this.fire(new s.A("rotatestart", l)).fire(new s.A("rotate", l)).fire(new s.A("rotateend", l)), w && this.fire(new s.A("pitchstart", l)).fire(new s.A("pitch", l)).fire(new s.A("pitchend", l)), this.fire(new s.A("moveend", l))); }
                getFreeCameraOptions() { return this.transform.projection.supportsFreeCamera || s.w(Hu), this.transform.getFreeCameraOptions(); }
                setFreeCameraOptions(n, l) { const f = this.transform; if (!f.projection.supportsFreeCamera)
                    return s.w(Hu), this; this.stop(); const _ = f.zoom, v = f.pitch, w = f.bearing; f.setFreeCameraOptions(n); const T = _ !== f.zoom, C = v !== f.pitch, P = w !== f.bearing; return this.fire(new s.A("movestart", l)).fire(new s.A("move", l)), T && this.fire(new s.A("zoomstart", l)).fire(new s.A("zoom", l)).fire(new s.A("zoomend", l)), P && this.fire(new s.A("rotatestart", l)).fire(new s.A("rotate", l)).fire(new s.A("rotateend", l)), C && this.fire(new s.A("pitchstart", l)).fire(new s.A("pitch", l)).fire(new s.A("pitchend", l)), this.fire(new s.A("moveend", l)), this; }
                easeTo(n, l) { this._stop(!1, n.easeId), ((n = s.l({ offset: [0, 0], duration: 500, easing: s.ey }, n)).animate === !1 || this._prefersReducedMotion(n)) && (n.duration = 0); const f = this.transform, _ = this.getZoom(), v = this.getBearing(), w = this.getPitch(), T = this.getPadding(), C = "zoom" in n ? +n.zoom : _, P = "bearing" in n ? this._normalizeBearing(n.bearing, v) : v, R = "pitch" in n ? +n.pitch : w, O = this._extendPadding(n.padding), D = s.P.convert(n.offset); let B, q, G; if (f.projection.name === "globe") {
                    const Ce = s.ac.fromLngLat(f.center), je = D.rotate(-f.angle);
                    Ce.x += je.x / f.worldSize, Ce.y += je.y / f.worldSize;
                    const ze = Ce.toLngLat(), rt = s.cd.convert(n.center || ze);
                    this._normalizeCenter(rt), B = f.centerPoint.add(je), q = new s.P(Ce.x, Ce.y).mult(f.worldSize), G = new s.P(s.ay(rt.lng), s.aH(rt.lat)).mult(f.worldSize).sub(q);
                }
                else {
                    B = f.centerPoint.add(D);
                    const Ce = f.pointLocation(B), je = s.cd.convert(n.center || Ce);
                    this._normalizeCenter(je), q = f.project(Ce), G = f.project(je).sub(q);
                } const K = f.zoomScale(C - _); let W, oe; n.around && (W = s.cd.convert(n.around), oe = f.locationPoint(W)); const de = this._zooming || C !== _, me = this._rotating || v !== P, we = this._pitching || R !== w, ve = !f.isPaddingEqual(O), xe = n.retainPadding === !1 ? f.clone() : f, ge = Ce => je => { if (de && (Ce.zoom = s.ai(_, C, je)), me && (Ce.bearing = s.ai(v, P, je)), we && (Ce.pitch = s.ai(w, R, je)), ve && (xe.interpolatePadding(T, O, je), B = xe.centerPoint.add(D)), W)
                    Ce.setLocationAtPoint(W, oe);
                else {
                    const ze = Ce.zoomScale(Ce.zoom - _), rt = C > _ ? Math.min(2, K) : Math.max(.5, K), et = Math.pow(rt, 1 - je), vt = Ce.unproject(q.add(G.mult(je * et)).mult(ze));
                    Ce.setLocationAtPoint(Ce.renderWorldCopies ? vt.wrap() : vt, B);
                } return n.preloadOnly || this._fireMoveEvents(l), Ce; }; if (n.preloadOnly) {
                    const Ce = this._emulate(ge, n.duration, f);
                    return this._preloadTiles(Ce), this;
                } const Se = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching }; return this._zooming = de, this._rotating = me, this._pitching = we, this._padding = ve, this._easeId = n.easeId, this._prepareEase(l, n.noMoveStart, Se), this._ease(ge(f), Ce => { f.cameraElevationReference === "sea" && f.recenterOnTerrain(), this._afterEase(l, Ce); }, n), this; }
                _prepareEase(n, l, f = {}) { this._moving = !0, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && this.transform.pitch === 0 && this.transform.projection.name !== "globe" && (this.transform.cameraElevationReference = "ground"), l || f.moving || this.fire(new s.A("movestart", n)), this._zooming && !f.zooming && this.fire(new s.A("zoomstart", n)), this._rotating && !f.rotating && this.fire(new s.A("rotatestart", n)), this._pitching && !f.pitching && this.fire(new s.A("pitchstart", n)); }
                _fireMoveEvents(n) { this.fire(new s.A("move", n)), this._zooming && this.fire(new s.A("zoom", n)), this._rotating && this.fire(new s.A("rotate", n)), this._pitching && this.fire(new s.A("pitch", n)); }
                _afterEase(n, l) { if (this._easeId && l && this._easeId === l)
                    return; this._easeId = void 0, this.transform.cameraElevationReference = "ground"; const f = this._zooming, _ = this._rotating, v = this._pitching; this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, f && this.fire(new s.A("zoomend", n)), _ && this.fire(new s.A("rotateend", n)), v && this.fire(new s.A("pitchend", n)), this.fire(new s.A("moveend", n)); }
                flyTo(n, l) { if (this._prefersReducedMotion(n)) {
                    const He = s.aF(n, ["center", "zoom", "bearing", "pitch", "around", "padding", "retainPadding"]);
                    return this.jumpTo(He, l);
                } this.stop(), n = s.l({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: s.ey }, n); const f = this.transform, _ = this.getZoom(), v = this.getBearing(), w = this.getPitch(), T = this.getPadding(), C = "zoom" in n ? s.aD(+n.zoom, f.minZoom, f.maxZoom) : _, P = "bearing" in n ? this._normalizeBearing(n.bearing, v) : v, R = "pitch" in n ? +n.pitch : w, O = this._extendPadding(n.padding), D = f.zoomScale(C - _), B = s.P.convert(n.offset); let q = f.centerPoint.add(B); const G = f.pointLocation(q), K = s.cd.convert(n.center || G); this._normalizeCenter(K); const W = f.project(G), oe = f.project(K).sub(W); let de = n.curve; const me = Math.max(f.width, f.height), we = me / D, ve = oe.mag(); if ("minZoom" in n) {
                    const He = s.aD(Math.min(n.minZoom, _, C), f.minZoom, f.maxZoom), ht = me / f.zoomScale(He - _);
                    de = Math.sqrt(ht / ve * 2);
                } const xe = de * de; function ge(He) { const ht = (we * we - me * me + (He ? -1 : 1) * xe * xe * ve * ve) / (2 * (He ? we : me) * xe * ve); return Math.log(Math.sqrt(ht * ht + 1) - ht); } function Se(He) { return (Math.exp(He) - Math.exp(-He)) / 2; } function Ce(He) { return (Math.exp(He) + Math.exp(-He)) / 2; } const je = ge(0); let ze = function (He) { return Ce(je) / Ce(je + de * He); }, rt = function (He) { return me * ((Ce(je) * (Se(ht = je + de * He) / Ce(ht)) - Se(je)) / xe) / ve; var ht; }, et = (ge(1) - je) / de; if (Math.abs(ve) < 1e-6 || !isFinite(et)) {
                    if (Math.abs(me - we) < 1e-6)
                        return this.easeTo(n, l);
                    const He = we < me ? -1 : 1;
                    et = Math.abs(Math.log(we / me)) / de, rt = function () { return 0; }, ze = function (ht) { return Math.exp(He * de * ht); };
                } n.duration = "duration" in n ? +n.duration : 1e3 * et / ("screenSpeed" in n ? +n.screenSpeed / de : +n.speed), n.maxDuration && n.duration > n.maxDuration && (n.duration = 0); const vt = v !== P, Fe = R !== w, Ve = !f.isPaddingEqual(O), Le = n.retainPadding === !1 ? f.clone() : f, st = He => ht => { const nt = ht * et, dt = 1 / ze(nt); He.zoom = ht === 1 ? C : _ + He.scaleZoom(dt), vt && (He.bearing = s.ai(v, P, ht)), Fe && (He.pitch = s.ai(w, R, ht)), Ve && (Le.interpolatePadding(T, O, ht), q = Le.centerPoint.add(B)); const ft = ht === 1 ? K : He.unproject(W.add(oe.mult(rt(nt))).mult(dt)); return He.setLocationAtPoint(He.renderWorldCopies ? ft.wrap() : ft, q), He._updateCameraOnTerrain(), n.preloadOnly || this._fireMoveEvents(l), He; }; if (n.preloadOnly) {
                    const He = this._emulate(st, n.duration, f);
                    return this._preloadTiles(He), this;
                } return this._zooming = !0, this._rotating = vt, this._pitching = Fe, this._padding = Ve, this._prepareEase(l, !1), this._ease(st(f), () => this._afterEase(l), n), this; }
                isEasing() { return !!this._easeFrameId; }
                stop() { return this._stop(); }
                _requestRenderFrame(n) { }
                _cancelRenderFrame(n) { }
                _stop(n, l) { if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
                    const f = this._onEaseEnd;
                    this._onEaseEnd = void 0, f.call(this, l);
                } if (!n) {
                    const f = this.handlers;
                    f && f.stop(!1);
                } return this; }
                _ease(n, l, f) { f.animate === !1 || f.duration === 0 ? (n(1), l()) : (this._easeStart = s.q.now(), this._easeOptions = f, this._onEaseFrame = n, this._onEaseEnd = l, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback)); }
                _renderFrameCallback() { const n = Math.min((s.q.now() - this._easeStart) / this._easeOptions.duration, 1), l = this._onEaseFrame; l && l(this._easeOptions.easing(n)), n < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop(); }
                _normalizeBearing(n, l) { n = s.bX(n, -180, 180); const f = Math.abs(n - l); return Math.abs(n - 360 - l) < f && (n -= 360), Math.abs(n + 360 - l) < f && (n += 360), n; }
                _normalizeCenter(n) { const l = this.transform; if (l.maxBounds || l.projection.name !== "globe" && !l.renderWorldCopies)
                    return; const f = n.lng - l.center.lng; n.lng += f > 180 ? -360 : f < -180 ? 360 : 0; }
                _prefersReducedMotion(n) { return this._respectPrefersReducedMotion && s.q.prefersReducedMotion && !(n && n.essential); }
                _emulate(n, l, f) { const _ = Math.ceil(15 * l / 1e3), v = [], w = n(f.clone()); for (let T = 0; T <= _; T++) {
                    const C = w(T / _);
                    v.push(C.clone());
                } return v; }
                _preloadTiles(n, l) { }
            }
            class $p {
                constructor(n = {}) { this.options = n, s.aV(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this); }
                getDefaultPosition() { return "bottom-right"; }
                onAdd(n) { const l = this.options && this.options.compact, f = n._getUIString("AttributionControl.ToggleAttribution"); this._map = n, this._container = J("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = J("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", f); const _ = J("span", "mapboxgl-ctrl-icon", this._compactButton); return _.setAttribute("aria-hidden", "true"), _.setAttribute("title", f), this._innerContainer = J("div", "mapboxgl-ctrl-attrib-inner", this._container), l && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), l === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container; }
                onRemove() { this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0; }
                _toggleAttribution() { this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true")); }
                _updateEditLink() { let n = this._editLink; n || (n = this._editLink = this._container.querySelector(".mapbox-improve-map")); const l = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || s.e.ACCESS_TOKEN }]; if (n) {
                    const f = l.reduce((_, v, w) => (v.value && (_ += `${v.key}=${v.value}${w < l.length - 1 ? "&" : ""}`), _), "?");
                    n.href = `${s.e.FEEDBACK_URL}/${f}#${Fp(this._map, !0)}`, n.rel = "noopener nofollow";
                } }
                _updateData(n) { !n || n.sourceDataType !== "metadata" && n.sourceDataType !== "visibility" && n.dataType !== "style" || (this._updateAttributions(), this._updateEditLink()); }
                _updateAttributions() { if (!this._map.style)
                    return; let n = []; if (this._map.style.stylesheet) {
                    const _ = this._map.style.stylesheet;
                    this.styleOwner = _.owner, this.styleId = _.id;
                } const l = this._map.style._mergedSourceCaches; for (const _ in l) {
                    const v = l[_];
                    if (v.used) {
                        const w = v.getSource();
                        w.attribution && n.indexOf(w.attribution) < 0 && n.push(w.attribution);
                    }
                } n.sort((_, v) => _.length - v.length), n = n.filter((_, v) => { for (let w = v + 1; w < n.length; w++)
                    if (n[w].indexOf(_) >= 0)
                        return !1; return !0; }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? n = [...this.options.customAttribution, ...n] : n.unshift(this.options.customAttribution)); const f = n.join(" | "); f !== this._attribHTML && (this._attribHTML = f, n.length ? (this._innerContainer.innerHTML = f, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null); }
                _updateCompact() { this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show"); }
            }
            class Vd {
                constructor() { s.aV(["_updateLogo", "_updateCompact"], this); }
                onAdd(n) { this._map = n, this._container = J("div", "mapboxgl-ctrl"); const l = J("a", "mapboxgl-ctrl-logo"); return l.target = "_blank", l.rel = "noopener nofollow", l.href = "https://www.mapbox.com/", l.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), l.setAttribute("rel", "noopener nofollow"), this._container.appendChild(l), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container; }
                onRemove() { this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact); }
                getDefaultPosition() { return "bottom-left"; }
                _updateLogo(n) { n && n.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none"); }
                _logoRequired() { if (!this._map.style)
                    return !0; const n = this._map.style._sourceCaches; if (Object.entries(n).length === 0)
                    return !0; for (const l in n) {
                    const f = n[l].getSource();
                    if (f.hasOwnProperty("mapbox_logo") && !f.mapbox_logo)
                        return !1;
                } return !0; }
                _updateCompact() { const n = this._container.children; if (n.length) {
                    const l = n[0];
                    this._map.getCanvasContainer().offsetWidth < 250 ? l.classList.add("mapboxgl-compact") : l.classList.remove("mapboxgl-compact");
                } }
            }
            class Aa {
                constructor() { this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1; }
                add(n) { const l = ++this._id; return this._queue.push({ callback: n, id: l, cancelled: !1 }), l; }
                remove(n) { const l = this._currentlyRunning, f = l ? this._queue.concat(l) : this._queue; for (const _ of f)
                    if (_.id === n)
                        return void (_.cancelled = !0); }
                run(n = 0) { const l = this._currentlyRunning = this._queue; this._queue = []; for (const f of l)
                    if (!f.cancelled && (f.callback(n), this._cleared))
                        break; this._cleared = !1, this._currentlyRunning = !1; }
                clear() { this._currentlyRunning && (this._cleared = !0), this._queue = []; }
            }
            class Gp {
                constructor(n) { this.jumpTo(n); }
                getValue(n) { if (n <= this._startTime)
                    return this._start; if (n >= this._endTime)
                    return this._end; const l = s.dk((n - this._startTime) / (this._endTime - this._startTime)); return this._start * (1 - l) + this._end * l; }
                isEasing(n) { return n >= this._startTime && n <= this._endTime; }
                jumpTo(n) { this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = n, this._end = n; }
                easeTo(n, l, f) { this._start = this.getValue(l), this._end = n, this._startTime = l, this._endTime = l + f; }
            }
            const Ei = { "AttributionControl.ToggleAttribution": "Toggle attribution", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox homepage", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use  + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" };
            class na extends s.A {
                constructor(n, l, f, _) { const { point: v, lngLat: w, originalEvent: T, target: C } = n; super(n.type, { point: v, lngLat: w, originalEvent: T, target: C }), this.preventDefault = () => { n.preventDefault(); }, this.id = l, this.interaction = f, this.feature = _; }
            }
            class Ud {
                constructor(n) { this.map = n, this.interactionsByType = new Map, this.delegatedInteractions = new Map, this.typeById = new Map, this.filters = new Map, this.handleType = this.handleType.bind(this), this.handleMove = this.handleMove.bind(this), this.handleOut = this.handleOut.bind(this), this.hoveredFeatures = new Map, this.prevHoveredFeatures = new Map; }
                add(n, l) { if (this.typeById.has(n))
                    throw new Error(`Interaction id "${n}" already exists.`); const f = l.filter; let _ = l.type; f && this.filters.set(n, s.b3(f)), _ === "mouseover" && (_ = "mouseenter"), _ === "mouseout" && (_ = "mouseleave"); const v = this.interactionsByType.get(_) || new Map; _ === "mouseenter" || _ === "mouseleave" ? (this.delegatedInteractions.size === 0 && (this.map.on("mousemove", this.handleMove), this.map.on("mouseout", this.handleOut)), this.delegatedInteractions.set(n, l)) : v.size === 0 && this.map.on(_, this.handleType), v.size === 0 && this.interactionsByType.set(_, v), v.set(n, l), this.typeById.set(n, _); }
                get(n) { const l = this.typeById.get(n); if (!l)
                    return; const f = this.interactionsByType.get(l); return f ? f.get(n) : void 0; }
                remove(n) { const l = this.typeById.get(n); if (!l)
                    return; this.typeById.delete(n), this.filters.delete(n); const f = this.interactionsByType.get(l); f && (f.delete(n), l === "mouseenter" || l === "mouseleave" ? (this.delegatedInteractions.delete(n), this.delegatedInteractions.size === 0 && (this.map.off("mousemove", this.handleMove), this.map.off("mouseout", this.handleOut))) : f.size === 0 && this.map.off(l, this.handleType)); }
                queryTargets(n, l) { const f = []; for (const [_, v] of l)
                    v.target && f.push({ targetId: _, target: v.target, filter: this.filters.get(_) }); return this.map.style.queryRenderedTargets(n, f, this.map.transform); }
                handleMove(n) { this.prevHoveredFeatures = this.hoveredFeatures, this.hoveredFeatures = new Map; const l = this.queryTargets(n.point, Array.from(this.delegatedInteractions).reverse()); l.length && (n.type = "mouseenter", this.handleType(n, l)); const f = new Map; for (const [_, { feature: v }] of this.prevHoveredFeatures)
                    this.hoveredFeatures.has(_) || f.set(v.id, v); f.size && (n.type = "mouseleave", this.handleType(n, Array.from(f.values()))); }
                handleOut(n) { const l = Array.from(this.hoveredFeatures.values()).map(({ feature: f }) => f); l.length && (n.type = "mouseleave", this.handleType(n, l)), this.hoveredFeatures.clear(); }
                handleType(n, l) { const f = Array.from(this.interactionsByType.get(n.type)).reverse(), _ = !!l; l = l || this.queryTargets(n.point, f); const v = n.type === "mouseenter"; let w = !1; const T = new Set; for (const C of l) {
                    for (const [P, R] of f) {
                        if (!R.target)
                            continue;
                        const O = C.variants ? C.variants[P] : null;
                        if (O) {
                            for (const D of O) {
                                if (ad(D, C, T, P))
                                    continue;
                                const B = new s.df(C, D), q = Hf(D, C, P);
                                _ && (B.state = this.map.getFeatureState(B));
                                const G = v ? this.prevHoveredFeatures.get(q) : null, K = new na(n, P, R, B), W = G ? G.stop : R.handler(K);
                                if (v && this.hoveredFeatures.set(q, { feature: C, stop: W }), W !== !1) {
                                    w = !0;
                                    break;
                                }
                            }
                            if (w)
                                break;
                        }
                    }
                    if (w)
                        break;
                } if (!w)
                    for (const [C, P] of f) {
                        const { handler: R, target: O } = P;
                        if (!O && R(new na(n, C, P, null)) !== !1)
                            break;
                    } }
            }
            function qp(d, n) { if (Array.isArray(d) && Array.isArray(n)) {
                const l = new Set(d), f = new Set(n);
                return l.size === f.size && d.every(_ => f.has(_));
            } return s.bv(d, n); }
            const mx = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, performanceMetricsCollection: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, antialias: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: !0, crossSourceCollisions: !0, collectResourceTiming: !1, testMode: !1, precompilePrograms: !0, scaleFactor: 1, spriteFormat: "auto" }, ST = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
            class $d {
                constructor(n, l, f = !1) { this._clickTolerance = 10, this.element = l, this.mouseRotate = new jp({ clickTolerance: n.dragRotate._mouseRotate._clickTolerance }), this.map = n, f && (this.mousePitch = new Vc({ clickTolerance: n.dragRotate._mousePitch._clickTolerance })), s.aV(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), l.addEventListener("mousedown", this.mousedown), l.addEventListener("touchstart", this.touchstart, { passive: !1 }), l.addEventListener("touchmove", this.touchmove), l.addEventListener("touchend", this.touchend), l.addEventListener("touchcancel", this.reset); }
                down(n, l) { this.mouseRotate.mousedown(n, l), this.mousePitch && this.mousePitch.mousedown(n, l), be(); }
                move(n, l) { const f = this.map, _ = this.mouseRotate.mousemoveWindow(n, l), v = _ && _.bearingDelta; if (v && f.setBearing(f.getBearing() + v), this.mousePitch) {
                    const w = this.mousePitch.mousemoveWindow(n, l), T = w && w.pitchDelta;
                    T && f.setPitch(f.getPitch() + T);
                } }
                off() { const n = this.element; n.removeEventListener("mousedown", this.mousedown), n.removeEventListener("touchstart", this.touchstart), n.removeEventListener("touchmove", this.touchmove), n.removeEventListener("touchend", this.touchend), n.removeEventListener("touchcancel", this.reset), this.offTemp(); }
                offTemp() { Ie(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup); }
                mousedown(n) { this.down(s.l({}, n, { ctrlKey: !0, preventDefault: () => n.preventDefault() }), ot(this.element, n)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup); }
                mousemove(n) { this.move(n, ot(this.element, n)); }
                mouseup(n) { this.mouseRotate.mouseupWindow(n), this.mousePitch && this.mousePitch.mouseupWindow(n), this.offTemp(); }
                touchstart(n) { n.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = At(this.element, n.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: () => n.preventDefault() }, this._startPos)); }
                touchmove(n) { n.targetTouches.length !== 1 ? this.reset() : (this._lastPos = At(this.element, n.targetTouches)[0], this.move({ preventDefault: () => n.preventDefault() }, this._lastPos)); }
                touchend(n) { n.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset(); }
                reset() { this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp(); }
            }
            function gx(d, n, l) { if (d = new s.cd(d.lng, d.lat), n) {
                const f = new s.cd(d.lng - 360, d.lat), _ = new s.cd(d.lng + 360, d.lat), v = 360 * Math.ceil(Math.abs(d.lng - l.center.lng) / 360), w = l.locationPoint3D(d).distSqr(n), T = n.x < 0 || n.y < 0 || n.x > l.width || n.y > l.height;
                l.locationPoint3D(f).distSqr(n) < w && (T || Math.abs(f.lng - l.center.lng) < v) ? d = f : l.locationPoint3D(_).distSqr(n) < w && (T || Math.abs(_.lng - l.center.lng) < v) && (d = _);
            } for (; Math.abs(d.lng - l.center.lng) > 180;) {
                const f = l.locationPoint3D(d);
                if (f.x >= 0 && f.y >= 0 && f.x <= l.width && f.y <= l.height)
                    break;
                d.lng > l.center.lng ? d.lng -= 360 : d.lng += 360;
            } return d; }
            const N_ = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" }, Fo = { rotation: 0, rotationAlignment: "auto", pitchAlignment: "auto", occludedOpacity: .2, altitude: 0 };
            class Gd extends s.E {
                constructor(n, l) { super(), (n instanceof HTMLElement || l) && (n = s.l({ element: n }, l)), s.aV(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this); const { anchor: f = "center", color: _ = "#3FB1CE", scale: v = 1, draggable: w = !1, clickTolerance: T = 0, rotation: C = Fo.rotation, rotationAlignment: P = Fo.rotationAlignment, pitchAlignment: R = Fo.pitchAlignment, occludedOpacity: O = Fo.occludedOpacity, altitude: D = Fo.altitude } = n || {}; this._anchor = f, this._color = _, this._scale = v, this._draggable = w, this._clickTolerance = T, this._rotation = C, this._rotationAlignment = P, this._pitchAlignment = R, this._occludedOpacity = O, this._altitude = D, this._state = "inactive", this._isDragging = !1, this._updateMoving = () => this._update(!0), n && n.element ? (this._element = n.element, this._offset = s.P.convert(n && n.offset || [0, 0])) : (this._defaultMarker = !0, this._element = this._createDefaultMarker(), this._offset = s.P.convert(n && n.offset || [0, -14])), this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", G => { G.preventDefault(); }), this._element.addEventListener("mousedown", G => { G.preventDefault(); }); const B = this._element.classList; for (const G in N_)
                    B.remove(`mapboxgl-marker-anchor-${G}`); B.add(`mapboxgl-marker-anchor-${this._anchor}`); const q = n && n.className ? n.className.trim().split(/\s+/) : []; B.add(...q), this._popup = null; }
                _createDefaultMarker() { const n = J("div"), l = ye("svg", { display: "block", height: 41 * this._scale + "px", width: 27 * this._scale + "px", viewBox: "0 0 27 41" }, n); if (this._altitude === 0) {
                    const f = ye("radialGradient", { id: "shadowGradient" }, ye("defs", {}, l));
                    ye("stop", { offset: "10%", "stop-opacity": .4 }, f), ye("stop", { offset: "100%", "stop-opacity": .05 }, f), ye("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, l);
                } return ye("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, l), ye("path", { opacity: .25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, l), ye("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, l), n; }
                addTo(n) { return n === this._map || (this.remove(), this._map = n, n.getCanvasContainer().appendChild(this._element), n.on("move", this._updateMoving), n.on("moveend", this._update), n.on("remove", this._clearFadeTimer), n._addMarker(this), this.setDraggable(this._draggable), this._update(), n.on("click", this._onMapClick)), this; }
                remove() { const n = this._map; return n && (n.off("click", this._onMapClick), n.off("move", this._updateMoving), n.off("moveend", this._update), n.off("mousedown", this._addDragHandler), n.off("touchstart", this._addDragHandler), n.off("mouseup", this._onUp), n.off("touchend", this._onUp), n.off("mousemove", this._onMove), n.off("touchmove", this._onMove), n.off("remove", this._clearFadeTimer), n._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this; }
                getLngLat() { return this._lngLat; }
                setLngLat(n) { return this._lngLat = s.cd.convert(n), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this; }
                setAltitude(n) { return n === this._altitude || (this._defaultMarker && (this._altitude === 0 && n !== 0 || this._altitude !== 0 && n === 0) && (this._element = this._createDefaultMarker()), this._altitude = n || Fo.altitude, this._update()), this; }
                getAltitude() { return this._altitude; }
                getElement() { return this._element; }
                setPopup(n) { if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), n) {
                    if (!("offset" in n.options)) {
                        const _ = Math.sqrt(Math.pow(13.5, 2) / 2);
                        n.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [_, -1 * (38.1 - 13.5 + _)], "bottom-right": [-_, -1 * (38.1 - 13.5 + _)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
                    }
                    this._popup = n, n._marker = this, n._altitude = this._altitude, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
                } return this; }
                _onKeyPress(n) { const l = n.code, f = n.charCode || n.keyCode; l !== "Space" && l !== "Enter" && f !== 32 && f !== 13 || this.togglePopup(); }
                _onMapClick(n) { const l = n.originalEvent.target, f = this._element; this._popup && (l === f || f.contains(l)) && this.togglePopup(); }
                getPopup() { return this._popup; }
                togglePopup() { const n = this._popup; return n ? (n.isOpen() ? (n.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (n.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this; }
                _behindTerrain() { const n = this._map, l = this._pos; if (!n || !l)
                    return !1; const f = n.unproject(l, this._altitude), _ = n.getFreeCameraOptions(); if (!_.position)
                    return !1; const v = _.position.toLngLat(); return v.distanceTo(f) < .9 * v.distanceTo(this._lngLat); }
                _evaluateOpacity() { const n = this._map; if (!n)
                    return; const l = this._pos; if (!l || l.x < 0 || l.x > n.transform.width || l.y < 0 || l.y > n.transform.height)
                    return void this._clearFadeTimer(); const f = n.unproject(l, this._altitude); let _; n._showingGlobe() && s.eK(n.transform, this._lngLat) ? _ = 0 : (_ = 1 - n._queryFogOpacity(f), n.transform._terrainEnabled() && n.getTerrain() && this._behindTerrain() && (_ *= this._occludedOpacity)), this._element.style.opacity = `${_}`, this._element.style.pointerEvents = _ > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(_), this._fadeTimer = null; }
                _clearFadeTimer() { this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null); }
                _updateDOM() {
                    const n = this._pos;
                    if (!n || !this._map)
                        return;
                    const l = this._offset.mult(this._scale);
                    this._element.style.transform = `
            translate(${n.x}px,${n.y}px)
            ${N_[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${l.x}px,${l.y}px)
        `;
                }
                _calculateXYTransform() { const n = this._pos, l = this._map, f = this.getPitchAlignment(); if (!l || !n || f !== "map")
                    return ""; if (!l._showingGlobe()) {
                    const C = l.getPitch();
                    return C ? `rotateX(${C}deg)` : "";
                } const _ = s.cJ(s.eL(l.transform, this._lngLat)), v = n.sub(s.eM(l.transform)), w = Math.abs(v.x) + Math.abs(v.y); if (w === 0)
                    return ""; const T = _ / w; return `rotateX(${-v.y * T}deg) rotateY(${v.x * T}deg)`; }
                _calculateZTransform() { const n = this._pos, l = this._map; if (!l || !n)
                    return ""; let f = 0; const _ = this.getRotationAlignment(); if (_ === "map")
                    if (l._showingGlobe()) {
                        const v = l.project(new s.cd(this._lngLat.lng, this._lngLat.lat + .001), this._altitude), w = l.project(new s.cd(this._lngLat.lng, this._lngLat.lat - .001), this._altitude).sub(v);
                        f = s.cJ(Math.atan2(w.y, w.x)) - 90;
                    }
                    else
                        f = -l.getBearing();
                else if (_ === "horizon") {
                    const v = s.af(4, 6, l.getZoom()), w = s.eM(l.transform);
                    w.y += v * l.transform.height;
                    const T = n.sub(w), C = s.cJ(Math.atan2(T.y, T.x));
                    f = (C > 90 ? C - 270 : C + 90) * (1 - v);
                } return f += this._rotation, f ? `rotateZ(${f}deg)` : ""; }
                _update(n) { cancelAnimationFrame(this._updateFrameId); const l = this._map; l && (l.transform.renderWorldCopies && (this._lngLat = gx(this._lngLat, this._pos, l.transform)), this._pos = l.project(this._lngLat, this._altitude), n === !0 ? this._updateFrameId = requestAnimationFrame(() => { this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM()); }) : this._pos = this._pos.round(), l._requestDomTask(() => { this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (l._showingGlobe() || l.getTerrain() || l.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60))); })); }
                getOffset() { return this._offset; }
                setOffset(n) { return this._offset = s.P.convert(n), this._update(), this; }
                addClassName(n) { return this._element.classList.add(n), this; }
                removeClassName(n) { return this._element.classList.remove(n), this; }
                toggleClassName(n) { return this._element.classList.toggle(n); }
                _onMove(n) { const l = this._map; if (!l)
                    return; const f = this._pointerdownPos, _ = this._positionDelta; if (f && _) {
                    if (!this._isDragging) {
                        const v = this._clickTolerance || l._clickTolerance;
                        if (n.point.dist(f) < v)
                            return;
                        this._isDragging = !0;
                    }
                    this._pos = n.point.sub(_), this._lngLat = l.unproject(this._pos, this._altitude), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new s.A("dragstart"))), this.fire(new s.A("drag"));
                } }
                _onUp() { this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1; const n = this._map; n && (n.off("mousemove", this._onMove), n.off("touchmove", this._onMove)), this._state === "active" && this.fire(new s.A("dragend")), this._state = "inactive"; }
                _addDragHandler(n) { const l = this._map, f = this._pos; l && f && this._element.contains(n.originalEvent.target) && (n.preventDefault(), this._positionDelta = n.point.sub(f), this._pointerdownPos = n.point, this._state = "pending", l.on("mousemove", this._onMove), l.on("touchmove", this._onMove), l.once("mouseup", this._onUp), l.once("touchend", this._onUp)); }
                setDraggable(n) { this._draggable = !!n; const l = this._map; return l && (n ? (l.on("mousedown", this._addDragHandler), l.on("touchstart", this._addDragHandler)) : (l.off("mousedown", this._addDragHandler), l.off("touchstart", this._addDragHandler))), this; }
                isDraggable() { return this._draggable; }
                setRotation(n) { return this._rotation = n || Fo.rotation, this._update(), this; }
                getRotation() { return this._rotation; }
                setRotationAlignment(n) { return this._rotationAlignment = n || Fo.rotationAlignment, this._update(), this; }
                getRotationAlignment() { return this._rotationAlignment === "auto" || this._rotationAlignment === "horizon" && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment; }
                setPitchAlignment(n) { return this._pitchAlignment = n || Fo.pitchAlignment, this._update(), this; }
                getPitchAlignment() { return this._pitchAlignment === "auto" ? this.getRotationAlignment() : this._pitchAlignment; }
                setOccludedOpacity(n) { return this._occludedOpacity = n || Fo.occludedOpacity, this._update(), this; }
                getOccludedOpacity() { return this._occludedOpacity; }
            }
            const qd = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0, showUserHeading: !1 }, Wu = { maxWidth: 100, unit: "metric" }, tl = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, ia = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", altitude: 0 }, sa = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
            function $l(d = new s.P(0, 0), n = "bottom") { if (typeof d == "number") {
                const l = Math.round(Math.sqrt(.5 * Math.pow(d, 2)));
                switch (n) {
                    case "top": return new s.P(0, d);
                    case "top-left": return new s.P(l, l);
                    case "top-right": return new s.P(-l, l);
                    case "bottom": return new s.P(0, -d);
                    case "bottom-left": return new s.P(l, -l);
                    case "bottom-right": return new s.P(-l, -l);
                    case "left": return new s.P(d, 0);
                    case "right": return new s.P(-d, 0);
                }
                return new s.P(0, 0);
            } return d instanceof s.P || Array.isArray(d) ? s.P.convert(d) : s.P.convert(d[n] || [0, 0]); }
            return { version: k, supported: ce.supported, setRTLTextPlugin: s.eN, getRTLTextPluginStatus: s.eO, Map: class extends px {
                    constructor(d) { N.mark(L.create); const n = d; if ((d = s.l({}, mx, d)).minZoom != null && d.maxZoom != null && d.minZoom > d.maxZoom)
                        throw new Error("maxZoom must be greater than or equal to minZoom"); if (d.minPitch != null && d.maxPitch != null && d.minPitch > d.maxPitch)
                        throw new Error("maxPitch must be greater than or equal to minPitch"); if (d.minPitch != null && d.minPitch < 0)
                        throw new Error("minPitch must be greater than or equal to 0"); if (d.maxPitch != null && d.maxPitch > 85)
                        throw new Error("maxPitch must be less than or equal to 85"); if (d.antialias && s.eI(window) && (d.antialias = !1, s.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Ec(d.minZoom, d.maxZoom, d.minPitch, d.maxPitch, d.renderWorldCopies, null, null), d), this._repaint = !!d.repaint, this._interactive = d.interactive, this._minTileCacheSize = d.minTileCacheSize, this._maxTileCacheSize = d.maxTileCacheSize, this._failIfMajorPerformanceCaveat = d.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = d.preserveDrawingBuffer, this._antialias = d.antialias, this._trackResize = d.trackResize, this._bearingSnap = d.bearingSnap, this._refreshExpiredTiles = d.refreshExpiredTiles, this._fadeDuration = d.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = d.crossSourceCollisions, this._collectResourceTiming = d.collectResourceTiming, this._language = this._parseLanguage(d.language), this._worldview = d.worldview, this._renderTaskQueue = new Aa, this._domRenderTaskQueue = new Aa, this._controls = [], this._markers = [], this._popups = [], this._mapId = s.a$(), this._locale = s.l({}, Ei, d.locale), this._clickTolerance = d.clickTolerance, this._cooperativeGestures = d.cooperativeGestures, this._performanceMetricsCollection = d.performanceMetricsCollection, this._tessellationStep = d.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = !0, this._precompilePrograms = d.precompilePrograms, this._scaleFactorChanged = !1, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new Gp(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._frameId = 0, this._scaleFactor = d.scaleFactor, this._requestManager = new bt(d.transformRequest, d.accessToken, d.testMode), this._silenceAuthErrors = !!d.testMode, this._contextCreateOptions = d.contextCreateOptions ? Object.assign({}, d.contextCreateOptions) : {}, typeof d.container == "string") {
                        const l = document.getElementById(d.container);
                        if (!l)
                            throw new Error(`Container '${d.container.toString()}' not found.`);
                        this._container = l;
                    }
                    else {
                        if (!(d.container instanceof HTMLElement))
                            throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                        this._container = d.container;
                    } if (this._container.childNodes.length > 0 && s.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), d.maxBounds && this.setMaxBounds(d.maxBounds), this._spriteFormat = d.spriteFormat, s.aV(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._tp || (this._tp = new T_), this._tp.registerParameter(this, ["Debug"], "showOverdrawInspector"), this._tp.registerParameter(this, ["Debug"], "showTileBoundaries"), this._tp.registerParameter(this, ["Debug"], "showParseStatus"), this._tp.registerParameter(this, ["Debug"], "repaint"), this._tp.registerParameter(this, ["Debug"], "showTileAABBs"), this._tp.registerParameter(this, ["Debug"], "showPadding"), this._tp.registerParameter(this, ["Debug"], "showCollisionBoxes", { noSave: !0 }), this._tp.registerParameter(this.transform, ["Debug"], "freezeTileCoverage", { noSave: !0 }, () => { this._update(); }), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showTerrainWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers2DWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers3DWireframe"), this._tp.registerParameter(this, ["Scaling"], "_scaleFactor", { min: .1, max: 10, step: .1 }, () => { this.setScaleFactor(this._scaleFactor); }), this._setupPainter(), this.painter === void 0)
                        throw new Error("Failed to initialize WebGL."); if (this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, !1), window.addEventListener("resize", this._onWindowResize, !1), window.addEventListener("orientationchange", this._onWindowResize, !1), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.addEventListener("visibilitychange", this._onVisibilityChange, !1), this.handlers = new TT(this, d), this._localFontFamily = d.localFontFamily, this._localIdeographFontFamily = d.localIdeographFontFamily, (d.style || !d.testMode) && this.setStyle(d.style || s.e.DEFAULT_STYLE, { config: d.config, localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), d.projection && this.setProjection(d.projection), this.indoor = new w0(this), d.hash && (this._hash = new Vu(typeof d.hash == "string" && d.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
                        n.center == null && n.zoom == null || (this.transform._unmodified = !1), this.jumpTo({ center: d.center, zoom: d.zoom, bearing: d.bearing, pitch: d.pitch });
                        const l = d.bounds;
                        l && (this.resize(), this.fitBounds(l, s.l({}, d.fitBoundsOptions, { duration: 0 })));
                    } this.resize(), d.attributionControl && this.addControl(new $p({ customAttribution: d.customAttribution })), this._logoControl = new Vd, this.addControl(this._logoControl, d.logoPosition), this.on("style.load", () => { this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent(); }), this.on("data", l => { this._update(l.dataType === "style"), this.fire(new s.A(`${l.dataType}data`, l)); }), this.on("dataloading", l => { this.fire(new s.A(`${l.dataType}dataloading`, l)); }), this._interactions = new Ud(this); }
                    _getMapId() { return this._mapId; }
                    addControl(d, n) { if (n === void 0 && (n = d.getDefaultPosition ? d.getDefaultPosition() : "top-right"), !d || !d.onAdd)
                        return this.fire(new s.z(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods."))); const l = d.onAdd(this); this._controls.push(d); const f = this._controlPositions[n]; return n.indexOf("bottom") !== -1 ? f.insertBefore(l, f.firstChild) : f.appendChild(l), this; }
                    removeControl(d) { if (!d || !d.onRemove)
                        return this.fire(new s.z(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods."))); const n = this._controls.indexOf(d); return n > -1 && this._controls.splice(n, 1), d.onRemove(this), this; }
                    hasControl(d) { return this._controls.indexOf(d) > -1; }
                    getContainer() { return this._container; }
                    getCanvasContainer() { return this._canvasContainer; }
                    getCanvas() { return this._canvas; }
                    resize(d) { if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
                        return this; this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight)); const n = !this._moving; return n && this.fire(new s.A("movestart", d)).fire(new s.A("move", d)), this.fire(new s.A("resize", d)), n && this.fire(new s.A("moveend", d)), this; }
                    getBounds() { return this.transform.getBounds(); }
                    getMaxBounds() { return this.transform.getMaxBounds() || null; }
                    setMaxBounds(d) { return this.transform.setMaxBounds(s.aG.convert(d)), this._update(); }
                    setMinZoom(d) { if ((d = d ?? -2) >= -2 && d <= this.transform.maxZoom)
                        return this.transform.minZoom = d, this._update(), this.getZoom() < d ? this.setZoom(d) : this.fire(new s.A("zoomstart")).fire(new s.A("zoom")).fire(new s.A("zoomend")), this; throw new Error("minZoom must be between -2 and the current maxZoom, inclusive"); }
                    getMinZoom() { return this.transform.minZoom; }
                    setMaxZoom(d) { if ((d = d ?? 22) >= this.transform.minZoom)
                        return this.transform.maxZoom = d, this._update(), this.getZoom() > d ? this.setZoom(d) : this.fire(new s.A("zoomstart")).fire(new s.A("zoom")).fire(new s.A("zoomend")), this; throw new Error("maxZoom must be greater than the current minZoom"); }
                    getMaxZoom() { return this.transform.maxZoom; }
                    setMinPitch(d) { if ((d = d ?? 0) < 0)
                        throw new Error("minPitch must be greater than or equal to 0"); if (d >= 0 && d <= this.transform.maxPitch)
                        return this.transform.minPitch = d, this._update(), this.getPitch() < d ? this.setPitch(d) : this.fire(new s.A("pitchstart")).fire(new s.A("pitch")).fire(new s.A("pitchend")), this; throw new Error("minPitch must be between 0 and the current maxPitch, inclusive"); }
                    getMinPitch() { return this.transform.minPitch; }
                    setMaxPitch(d) { if ((d = d ?? 85) > 85)
                        throw new Error("maxPitch must be less than or equal to 85"); if (d >= this.transform.minPitch)
                        return this.transform.maxPitch = d, this._update(), this.getPitch() > d ? this.setPitch(d) : this.fire(new s.A("pitchstart")).fire(new s.A("pitch")).fire(new s.A("pitchend")), this; throw new Error("maxPitch must be greater than or equal to minPitch"); }
                    getMaxPitch() { return this.transform.maxPitch; }
                    getScaleFactor() { return this._scaleFactor; }
                    setScaleFactor(d) { return this._scaleFactor = d, this.painter.scaleFactor = d, this._tp.refreshUI(), this._scaleFactorChanged = !0, this.style._updateFilteredLayers(n => n.type === "symbol"), this._update(!0), this; }
                    getRenderWorldCopies() { return this.transform.renderWorldCopies; }
                    setRenderWorldCopies(d) { return this.transform.renderWorldCopies = d, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update(); }
                    getLanguage() { return this._language; }
                    _parseLanguage(d) { return d === "auto" ? navigator.language : Array.isArray(d) ? d.length === 0 ? void 0 : d.map(n => n === "auto" ? navigator.language : n) : d; }
                    setLanguage(d) { const n = this._parseLanguage(d); if (!this.style || n === this._language)
                        return this; this._language = n, this.style.reloadSources(); for (const l of this._controls)
                        l._setLanguage && l._setLanguage(this._language); return this; }
                    getWorldview() { return this._worldview; }
                    setWorldview(d) { return this.style && d !== this._worldview ? (this._worldview = d, this.style.reloadSources(), this) : this; }
                    getProjection() { return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection(); }
                    _showingGlobe() { return this.transform.projection.name === "globe"; }
                    setProjection(d) { return this._lazyInitEmptyStyle(), d ? typeof d == "string" && (d = { name: d }) : d = null, this._useExplicitProjection = !!d, this._prioritizeAndUpdateProjection(d, this.style.projection); }
                    _updateProjectionTransition() { if (this.getProjection().name !== "globe")
                        return; const d = this.transform, n = d.projection.name; let l; n === "globe" && d.zoom >= s.cx ? (d.setMercatorFromTransition(), l = !0) : n === "mercator" && d.zoom < s.cx && (d.setProjection({ name: "globe" }), l = !0), l && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate()); }
                    _prioritizeAndUpdateProjection(d, n) { return this._updateProjection(d || n || { name: "mercator" }); }
                    _updateProjection(d) { let n; return n = d.name === "globe" && this.transform.zoom >= s.cx ? this.transform.setMercatorFromTransition() : this.transform.setProjection(d), this.style.applyProjectionUpdate(), n && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this; }
                    project(d, n) { return this.transform.locationPoint3D(s.cd.convert(d), n); }
                    unproject(d, n) { return this.transform.pointLocation3D(s.P.convert(d), n); }
                    isMoving() { return this._moving || this.handlers && this.handlers.isMoving() || !1; }
                    isZooming() { return this._zooming || this.handlers && this.handlers.isZooming() || !1; }
                    isRotating() { return this._rotating || this.handlers && this.handlers.isRotating() || !1; }
                    _isDragging() { return this.handlers && this.handlers._isDragging() || !1; }
                    _createDelegatedListener(d, n, l) { const f = _ => { let v = []; if (Array.isArray(n)) {
                        const w = n.filter(T => this.getLayer(T));
                        v = w.length ? this.queryRenderedFeatures(_, { layers: w }) : [];
                    }
                    else
                        v = this.queryRenderedFeatures(_, { target: n }); return v; }; if (d === "mouseenter" || d === "mouseover") {
                        let _ = !1;
                        return { listener: l, targets: n, delegates: { mousemove: w => { const T = f(w.point); T.length ? _ || (_ = !0, l.call(this, new Gs(d, this, w.originalEvent, { features: T }))) : _ = !1; }, mouseout: () => { _ = !1; } } };
                    } if (d === "mouseleave" || d === "mouseout") {
                        let _ = !1;
                        return { listener: l, targets: n, delegates: { mousemove: T => { f(T.point).length ? _ = !0 : _ && (_ = !1, l.call(this, new Gs(d, this, T.originalEvent))); }, mouseout: T => { _ && (_ = !1, l.call(this, new Gs(d, this, T.originalEvent))); } } };
                    } {
                        const _ = v => { const w = f(v.point); w.length && (v.features = w, l.call(this, v), delete v.features); };
                        return { listener: l, targets: n, delegates: { [d]: _ } };
                    } }
                    on(d, n, l) { if (typeof n == "function" || l === void 0)
                        return super.on(d, n); if (typeof n == "string" && (n = [n]), !this._areTargetsValid(n))
                        return this; const f = this._createDelegatedListener(d, n, l); this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[d] = this._delegatedListeners[d] || [], this._delegatedListeners[d].push(f); for (const _ in f.delegates)
                        this.on(_, f.delegates[_]); return this; }
                    once(d, n, l) { if (typeof n == "function" || l === void 0)
                        return super.once(d, n); if (typeof n == "string" && (n = [n]), !this._areTargetsValid(n))
                        return this; const f = this._createDelegatedListener(d, n, l); for (const _ in f.delegates)
                        this.once(_, f.delegates[_]); return this; }
                    off(d, n, l) { if (typeof n == "function" || l === void 0)
                        return super.off(d, n); if (typeof n == "string" && (n = [n]), !this._areTargetsValid(n))
                        return this; const f = this._delegatedListeners ? this._delegatedListeners[d] : void 0; return f && (_ => { for (let v = 0; v < _.length; v++) {
                        const w = _[v];
                        if (w.listener === l && qp(w.targets, n)) {
                            for (const T in w.delegates)
                                this.off(T, w.delegates[T]);
                            return _.splice(v, 1), this;
                        }
                    } })(f), this; }
                    queryRenderedFeatures(d, n) { if (!this.style)
                        return []; if (d === void 0 || d instanceof s.P || Array.isArray(d) || n !== void 0 || (n = d, d = void 0), d = d || [[0, 0], [this.transform.width, this.transform.height]], !n) {
                        const v = this.style.queryRenderedFeatures(d, void 0, this.transform), w = this.style.queryRenderedFeatureset(d, void 0, this.transform);
                        return v.concat(w);
                    } let l = !0; if (n.target && (l = this._isTargetValid(n.target), l && !n.layers))
                        return this.style.queryRenderedFeatureset(d, n, this.transform); let f = !0; if (n.layers && Array.isArray(n.layers)) {
                        for (const v of n.layers)
                            if (!this._isValidId(v)) {
                                f = !1;
                                break;
                            }
                        if (f && !n.target)
                            return this.style.queryRenderedFeatures(d, n, this.transform);
                    } let _ = []; return f && (_ = _.concat(this.style.queryRenderedFeatures(d, n, this.transform))), l && (_ = _.concat(this.style.queryRenderedFeatureset(d, n, this.transform))), _; }
                    querySourceFeatures(d, n) { return !d || typeof d == "string" && !this._isValidId(d) ? [] : this.style.querySourceFeatures(d, n); }
                    isPointOnSurface(d) { const { name: n } = this.transform.projection; return n !== "globe" && n !== "mercator" && s.w(`${n} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(s.P.convert(d)); }
                    addInteraction(d, n) { return this._interactions.add(d, n), this; }
                    removeInteraction(d) { return this._interactions.remove(d), this; }
                    getCooperativeGestures() { return this._cooperativeGestures; }
                    setCooperativeGestures(d) { return this._cooperativeGestures = d, this; }
                    setStyle(d, n) { return n = s.l({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, n), this.style && d && n.diff !== !1 && n.localFontFamily === this._localFontFamily && n.localIdeographFontFamily === this._localIdeographFontFamily && !n.config ? (this.style._diffStyle(d, (l, f) => { if (l) {
                        const _ = typeof l == "string" ? l : l instanceof Error ? l.message : l.error;
                        s.w(`Unable to perform style diff: ${_}. Rebuilding the style from scratch.`), this._updateStyle(d, n);
                    }
                    else
                        f && this._update(!0); }, () => this._postStyleLoadEvent()), this) : (this._localIdeographFontFamily = n.localIdeographFontFamily, this._localFontFamily = n.localFontFamily, this._updateStyle(d, n)); }
                    _getUIString(d) { const n = this._locale[d]; if (n == null)
                        throw new Error(`Missing UI string '${d}'`); return n; }
                    _updateStyle(d, n) { if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), d) {
                        const l = s.l({}, n);
                        n && n.config && (l.initialConfig = n.config, delete l.config), this.style = new Lo(this, l).load(d), this.style.setEventedParent(this, { style: this.style });
                    } return this._updateTerrain(), this; }
                    _lazyInitEmptyStyle() { this.style || (this.style = new Lo(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty()); }
                    getStyle() { if (this.style)
                        return this.style.serialize(); }
                    isStyleLoaded() { return this.style ? this.style.loaded() : (s.w("There is no style added to the map."), !1); }
                    _isValidId(d) { return d == null ? (this.fire(new s.z(new Error("IDs can't be empty."))), !1) : !s.d9(d) || (this.fire(new s.z(new Error(`IDs can't contain special symbols: "${d}".`))), !1); }
                    _isTargetValid(d) { return "featuresetId" in d ? this._isValidId("importId" in d ? d.importId : d.featuresetId) : "layerId" in d && this._isValidId(d.layerId); }
                    _areTargetsValid(d) { if (Array.isArray(d)) {
                        for (const n of d)
                            if (!this._isValidId(n))
                                return !1;
                        return !0;
                    } return this._isTargetValid(d); }
                    addSource(d, n) { return this._isValidId(d) ? (this._lazyInitEmptyStyle(), this.style.addSource(d, n), this._update(!0)) : this; }
                    isSourceLoaded(d) { return !!this._isValidId(d) && !!this.style && this.style._isSourceCacheLoaded(d); }
                    areTilesLoaded() { return this.style.areTilesLoaded(); }
                    addSourceType(d, n, l) { this._lazyInitEmptyStyle(), this.style.addSourceType(d, n, l); }
                    removeSource(d) { return this._isValidId(d) ? (this.style.removeSource(d), this._updateTerrain(), this._update(!0)) : this; }
                    getSource(d) { return this._isValidId(d) ? this.style.getOwnSource(d) : null; }
                    addImage(d, n, { pixelRatio: l = 1, sdf: f = !1, stretchX: _, stretchY: v, content: w } = {}) { this._lazyInitEmptyStyle(); const T = s.I.from(d); if (n instanceof HTMLImageElement || ImageBitmap && n instanceof ImageBitmap) {
                        const { width: C, height: P, data: R } = s.q.getImageData(n);
                        this.style.addImage(T, { data: new s.r({ width: C, height: P }, R), pixelRatio: l, stretchX: _, stretchY: v, content: w, sdf: f, version: 0, usvg: !1 });
                    }
                    else if (n.width === void 0 || n.height === void 0)
                        this.fire(new s.z(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    else {
                        const { width: C, height: P } = n, R = n;
                        this.style.addImage(T, { data: new s.r({ width: C, height: P }, new Uint8Array(R.data)), pixelRatio: l, stretchX: _, stretchY: v, content: w, sdf: f, usvg: !1, version: 0, userImage: R }), R.onAdd && R.onAdd(this, d);
                    } }
                    updateImage(d, n) {
                        this._lazyInitEmptyStyle();
                        const l = s.I.from(d), f = this.style.getImage(l);
                        if (!f)
                            return void this.fire(new s.z(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                        const _ = n instanceof HTMLImageElement || ImageBitmap && n instanceof ImageBitmap ? s.q.getImageData(n) : n, { width: v, height: w, data: T } = _;
                        if (v === void 0 || w === void 0)
                            return void this.fire(new s.z(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                        if (v !== (f.usvg ? f.icon.usvg_tree.width : f.data.width) || w !== (f.usvg ? f.icon.usvg_tree.height : f.data.height))
                            return void this.fire(new s.z(new Error(`The width and height of the updated image (${v}, ${w})
                must be that same as the previous version of the image
                (${f.data.width}, ${f.data.height})`)));
                        const C = !(n instanceof HTMLImageElement || ImageBitmap && n instanceof ImageBitmap);
                        let P = !1;
                        f.usvg ? (f.data = new s.r({ width: v, height: w }, new Uint8Array(T)), f.usvg = !1, f.icon = void 0, P = !0) : f.data.replace(T, C), this.style.updateImage(l, f, P);
                    }
                    hasImage(d) { return d ? !!this.style && !!this.style.getImage(s.I.from(d)) : (this.fire(new s.z(new Error("Missing required image id"))), !1); }
                    removeImage(d) { this.style.removeImage(s.I.from(d)); }
                    loadImage(d, n) { s.o(this._requestManager.transformRequest(d, s.R.Image), (l, f) => { n(l, f instanceof HTMLImageElement ? s.q.getImageData(f) : f); }); }
                    listImages() { return this.style.listImages().map(d => d.name); }
                    addModel(d, n) { this._lazyInitEmptyStyle(), this.style.addModel(d, n); }
                    hasModel(d) { return d ? this.style.hasModel(d) : (this.fire(new s.z(new Error("Missing required model id"))), !1); }
                    removeModel(d) { this.style.removeModel(d); }
                    listModels() { return this.style.listModels(); }
                    addLayer(d, n) { return this._isValidId(d.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(d, n), this._update(!0)) : this; }
                    getSlot(d) { const n = this.getLayer(d); return n && n.slot || null; }
                    setSlot(d, n) { return this.style.setSlot(d, n), this.style.mergeLayers(), this._update(!0); }
                    addImport(d, n) { return this.style.addImport(d, n).catch(l => this.fire(new s.z(new Error("Failed to add import", l)))), this; }
                    updateImport(d, n) { return typeof n != "string" && n.id !== d ? (this.removeImport(d), this.addImport(n)) : (this.style.updateImport(d, n), this._update(!0)); }
                    removeImport(d) { return this.style.removeImport(d), this; }
                    moveImport(d, n) { return this.style.moveImport(d, n), this._update(!0); }
                    moveLayer(d, n) { return this._isValidId(d) ? (this.style.moveLayer(d, n), this._update(!0)) : this; }
                    removeLayer(d) { return this._isValidId(d) ? (this.style.removeLayer(d), this._update(!0)) : this; }
                    getLayer(d) { if (!this._isValidId(d))
                        return null; const n = this.style.getOwnLayer(d); return n ? n.type === "custom" ? n.implementation : n.serialize() : void 0; }
                    getSlots() { return this.style.getSlots(); }
                    setLayerZoomRange(d, n, l) { return this._isValidId(d) ? (this.style.setLayerZoomRange(d, n, l), this._update(!0)) : this; }
                    setFilter(d, n, l = {}) { return this._isValidId(d) ? (this.style.setFilter(d, n, l), this._update(!0)) : this; }
                    getFilter(d) { return this._isValidId(d) ? this.style.getFilter(d) : null; }
                    setPaintProperty(d, n, l, f = {}) { return this._isValidId(d) ? (this.style.setPaintProperty(d, n, l, f), this._update(!0)) : this; }
                    getPaintProperty(d, n) { return this._isValidId(d) ? this.style.getPaintProperty(d, n) : null; }
                    setLayoutProperty(d, n, l, f = {}) { return this._isValidId(d) ? (this.style.setLayoutProperty(d, n, l, f), this._update(!0)) : this; }
                    getLayoutProperty(d, n) { return this._isValidId(d) ? this.style.getLayoutProperty(d, n) : null; }
                    getGlyphsUrl() { return this.style.getGlyphsUrl(); }
                    setGlyphsUrl(d) { return this.style.setGlyphsUrl(d), this._update(!0); }
                    getSchema(d) { return this.style.getSchema(d); }
                    setSchema(d, n) { return this.style.setSchema(d, n), this._update(!0); }
                    getConfig(d) { return this.style.getConfig(d); }
                    setConfig(d, n) { return this.style.setConfig(d, n), this._update(!0); }
                    getConfigProperty(d, n) { return this.style.getConfigProperty(d, n); }
                    setConfigProperty(d, n, l) { return this.style.setConfigProperty(d, n, l), this._update(!0); }
                    getFeaturesetDescriptors(d) { return this.style.getFeaturesetDescriptors(d); }
                    setLights(d) { if (this._lazyInitEmptyStyle(), d && d.length === 1 && d[0].type === "flat") {
                        const n = d[0];
                        n.properties ? this.style.setFlatLight(n.properties, n.id, {}) : this.style.setFlatLight({}, "flat");
                    }
                    else
                        this.style.setLights(d), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0); return this._update(!0); }
                    getLights() { const d = this.style.getLights() || []; return d.length === 0 && d.push({ id: this.style.light.id, type: "flat", properties: this.style.getFlatLight() }), d; }
                    setLight(d, n = {}) { return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{ id: "flat", type: "flat", properties: d }]); }
                    getLight() { return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight(); }
                    setTerrain(d) { return this._lazyInitEmptyStyle(), !d && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(d), this._averageElevationLastSampledAt = -1 / 0, this._update(!0); }
                    getTerrain() { return this.style ? this.style.getTerrain() : null; }
                    setFog(d) { return this._lazyInitEmptyStyle(), this.style.setFog(d), this._update(!0); }
                    getFog() { return this.style ? this.style.getFog() : null; }
                    setSnow(d) { return this._lazyInitEmptyStyle(), this.style.setSnow(d), this._update(!0); }
                    getSnow() { return this.style ? this.style.getSnow() : null; }
                    setRain(d) { return this._lazyInitEmptyStyle(), this.style.setRain(d), this._update(!0); }
                    getRain() { return this.style ? this.style.getRain() : null; }
                    setColorTheme(d) { return this._lazyInitEmptyStyle(), this.style.setColorTheme(d), this._update(!0); }
                    setImportColorTheme(d, n) { return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(d, n), this._update(!0); }
                    setCamera(d) { return this.style.setCamera(d), this._triggerCameraUpdate(d); }
                    _triggerCameraUpdate(d) { return this._update(this.transform.setOrthographicProjectionAtLowPitch(d["camera-projection"] === "orthographic")); }
                    getCamera() { return this.style.camera; }
                    _queryFogOpacity(d) { return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(s.cd.convert(d), this.transform) : 0; }
                    setFeatureState(d, n) { return d.source && !this._isValidId(d.source) ? this : (this.style.setFeatureState(d, n), this._update()); }
                    removeFeatureState(d, n) { return d.source && !this._isValidId(d.source) ? this : (this.style.removeFeatureState(d, n), this._update()); }
                    getFeatureState(d) { return d.source && !this._isValidId(d.source) ? null : this.style.getFeatureState(d); }
                    _updateContainerDimensions() { if (!this._container)
                        return; const d = this._container.getBoundingClientRect().width || 400, n = this._container.getBoundingClientRect().height || 300; let l, f, _, v = this._container; for (; v && (!f || !_);) {
                        const w = window.getComputedStyle(v).transform;
                        w && w !== "none" && (l = w.match(/matrix.*\((.+)\)/)[1].split(", "), l[0] && l[0] !== "0" && l[0] !== "1" && (f = l[0]), l[3] && l[3] !== "0" && l[3] !== "1" && (_ = l[3])), v = v.parentElement;
                    } this._containerWidth = f ? Math.abs(d / f) : d, this._containerHeight = _ ? Math.abs(n / _) : n; }
                    _detectMissingCSS() { window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && s.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/."); }
                    _setupContainer() { const d = this._container; d.classList.add("mapboxgl-map"), (this._missingCSSCanary = J("div", "mapboxgl-canary", d)).style.visibility = "hidden", this._detectMissingCSS(); const n = this._canvasContainer = J("div", "mapboxgl-canvas-container", d); this._canvas = J("canvas", "mapboxgl-canvas", n), this._interactive && (n.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight); const l = this._controlContainer = J("div", "mapboxgl-control-container", d), f = this._controlPositions = {}; ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"].forEach(_ => { f[_] = J("div", `mapboxgl-ctrl-${_}`, l); }), this._container.addEventListener("scroll", this._onMapScroll, !1); }
                    _resizeCanvas(d, n) { const l = s.q.devicePixelRatio || 1; this._canvas.width = l * Math.ceil(d), this._canvas.height = l * Math.ceil(n), this._canvas.style.width = `${d}px`, this._canvas.style.height = `${n}px`; }
                    _addMarker(d) { this._markers.push(d); }
                    _removeMarker(d) { const n = this._markers.indexOf(d); n !== -1 && this._markers.splice(n, 1); }
                    _addPopup(d) { this._popups.push(d); }
                    _removePopup(d) { const n = this._popups.indexOf(d); n !== -1 && this._popups.splice(n, 1); }
                    _setupPainter() { const d = s.l({}, ce.supported.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), n = this._canvas.getContext("webgl2", d); n ? (ss(n, !0), this.painter = new zp(n, this._contextCreateOptions, this.transform, this._scaleFactor, this._tp), this.on("data", l => { l.dataType === "source" && this.painter.setTileLoadedFlag(!0); }), s.m.testSupport(n)) : this.fire(new s.z(new Error("Failed to initialize WebGL"))); }
                    _contextLost(d) { d.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new s.A("webglcontextlost", { originalEvent: d })); }
                    _contextRestored(d) { this._setupPainter(), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight)), this._updateTerrain(), this.style && (this.style.reloadModels(), this.style.clearSources()), this._update(), this.fire(new s.A("webglcontextrestored", { originalEvent: d })); }
                    _onMapScroll(d) { if (d.target === this._container)
                        return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1; }
                    idle() { return !this.isMoving() && this.loaded(); }
                    loaded() { return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded(); }
                    frameReady() { return this.loaded() && !this._placementDirty; }
                    _update(d) { return this.style ? (this._styleDirty = this._styleDirty || d, this._sourcesDirty = !0, this.triggerRepaint(), this) : this; }
                    _requestRenderFrame(d) { return this._update(), this._renderTaskQueue.add(d); }
                    _cancelRenderFrame(d) { this._renderTaskQueue.remove(d); }
                    _requestDomTask(d) { !this.loaded() || this.loaded() && !this.isMoving() ? d() : this._domRenderTaskQueue.add(d); }
                    _render(d) { let n; this.fire(new s.A("renderstart")), ++this._frameId; const l = this.painter.context.extTimerQuery, f = s.q.now(), _ = this.painter.context.gl; if (this.listens("gpu-timing-frame") && (n = _.createQuery(), _.beginQuery(l.TIME_ELAPSED_EXT, n)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(d), this._domRenderTaskQueue.run(d), this._removed)
                        return; this._updateProjectionTransition(); const v = this._isInitialLoad ? 0 : this._fadeDuration; if (this.style && this._styleDirty) {
                        this._styleDirty = !1;
                        const P = this.transform.zoom, R = this.transform.pitch, O = s.q.now(), D = new s.aa(P, { now: O, fadeDuration: v, pitch: R, transition: this.style.transition });
                        this.style.update(D);
                    } this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0); let w = !1; this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), w = this._updateAverageElevation(f), this.style.updateSources(this.transform), this.style.updateImageProviders(), this.isMoving() || this._forceMarkerAndPopupUpdate()) : w = this._updateAverageElevation(f); const T = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, v, this._crossSourceCollisions, this.painter.replacementSource, this._scaleFactorChanged); if (this._scaleFactorChanged && (this._scaleFactorChanged = !1), T && (this._placementDirty = T.needsRerender), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showParseStatus: this.showParseStatus, wireframe: { terrain: this.showTerrainWireframe, layers2D: this.showLayers2DWireframe, layers3D: this.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: v, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new s.A("render")), this.loaded() && !this._loaded && (this._loaded = !0, N.mark(L.load), this.fire(new s.A("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = !0), this.style && this.style.imageManager.hasPatternsInFlight() && (this._styleDirty = !0), this.style && !this.style.modelManager.isLoaded() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), n) {
                        const P = s.q.now() - f;
                        _.endQuery(l.TIME_ELAPSED_EXT), setTimeout(() => { const R = _.getQueryParameter(n, _.QUERY_RESULT) / 1e6; _.deleteQuery(n), this.fire(new s.A("gpu-timing-frame", { cpuTime: P, gpuTime: R })); }, 50);
                    } if (this.listens("gpu-timing-layer")) {
                        const P = this.painter.collectGpuTimers();
                        setTimeout(() => { const R = this.painter.queryGpuTimers(P); this.fire(new s.A("gpu-timing-layer", { layerTimes: R })); }, 50);
                    } if (this.listens("gpu-timing-deferred-render")) {
                        const P = this.painter.collectDeferredRenderGpuQueries();
                        setTimeout(() => { const R = this.painter.queryGpuTimeDeferredRender(P); this.fire(new s.A("gpu-timing-deferred-render", { gpuTime: R })); }, 50);
                    } const C = this._sourcesDirty || this._styleDirty || this._placementDirty || w; if (C || this._repaint)
                        this.triggerRepaint();
                    else {
                        const P = this.idle();
                        if (P && (w = this._updateAverageElevation(f, !0)), w)
                            this.triggerRepaint();
                        else if (this._triggerFrame(!1), P && (this.fire(new s.A("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
                            const R = this._calculateSpeedIndex();
                            this.fire(new s.A("speedindexcompleted", { speedIndex: R })), this.speedIndexTiming = !1;
                        }
                    } !this._loaded || this._fullyLoaded || C || (this._fullyLoaded = !0, N.mark(L.fullLoad), this._performanceMetricsCollection && Xs(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate()); }
                    _forceMarkerAndPopupUpdate(d) { for (const n of this._markers)
                        d && !this.getRenderWorldCopies() && (n._lngLat = n._lngLat.wrap()), n._update(); for (const n of this._popups)
                        !d || this.getRenderWorldCopies() || n._trackPointer || (n._lngLat = n._lngLat.wrap()), n._update(); }
                    _updateAverageElevation(d, n = !1) { const l = _ => (this.transform.averageElevation = _, this._update(!1), !0); if (!this.painter.averageElevationNeedsEasing())
                        return this.transform.averageElevation !== 0 && l(0); const f = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration; if (f || (n || d - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(d)) {
                        const _ = this.transform.averageElevation;
                        let v = this.transform.sampleAverageElevation();
                        this.transform.elevation != null && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(v) ? v = 0 : this._averageElevationLastSampledAt = d;
                        const w = Math.abs(_ - v);
                        if (w > 1) {
                            if (this._isInitialLoad || f)
                                return this._averageElevation.jumpTo(v), l(v);
                            this._averageElevation.easeTo(v, d, 300);
                        }
                        else if (w > 1e-4)
                            return this._averageElevation.jumpTo(v), l(v);
                    } return !!this._averageElevation.isEasing(d) && l(this._averageElevation.getValue(d)); }
                    _authenticate() { Bs(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, d => { if (d && (d.message === Kt || d.status === 401)) {
                        const n = this.painter.context.gl;
                        ss(n, !1), this._logoControl instanceof Vd && this._logoControl._updateLogo(), n && n.clear(n.DEPTH_BUFFER_BIT | n.COLOR_BUFFER_BIT | n.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new s.z(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
                    } }), Si(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => { }); }
                    _postStyleLoadEvent() { this.style.globalId && Kr(this._requestManager._customAccessToken, { map: this, style: this.style.globalId, importedStyles: this.style.getImportGlobalIds() }); }
                    _updateTerrain() { const d = this._isDragging(); this.painter.updateTerrain(this.style, d); }
                    _calculateSpeedIndex() { const d = this.painter.canvasCopy(), n = this.painter.getCanvasCopiesAndTimestamps(); n.timeStamps.push(performance.now()); const l = this.painter.context.gl, f = l.createFramebuffer(); function _(v) { l.framebufferTexture2D(l.FRAMEBUFFER, l.COLOR_ATTACHMENT0, l.TEXTURE_2D, v, 0); const w = new Uint8Array(l.drawingBufferWidth * l.drawingBufferHeight * 4); return l.readPixels(0, 0, l.drawingBufferWidth, l.drawingBufferHeight, l.RGBA, l.UNSIGNED_BYTE, w), w; } return l.bindFramebuffer(l.FRAMEBUFFER, f), this._canvasPixelComparison(_(d), n.canvasCopies.map(_), n.timeStamps); }
                    _canvasPixelComparison(d, n, l) { let f = l[1] - l[0]; const _ = d.length / 4; for (let v = 0; v < n.length; v++) {
                        const w = n[v];
                        let T = 0;
                        for (let C = 0; C < w.length; C += 4)
                            w[C] === d[C] && w[C + 1] === d[C + 1] && w[C + 2] === d[C + 2] && w[C + 3] === d[C + 3] && (T += 1);
                        f += (l[v + 2] - l[v + 1]) * (1 - T / _);
                    } return f; }
                    remove() { this._hash && this._hash.remove(); for (const n of this._controls)
                        n.onRemove(this); this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.indoor.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, !1), window.removeEventListener("orientationchange", this._onWindowResize, !1), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.removeEventListener("online", this._onWindowOnline, !1), window.removeEventListener("visibilitychange", this._onVisibilityChange, !1); const d = this.painter.context.gl.getExtension("WEBGL_lose_context"); d && d.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), js.delete(this.painter.context.gl), ln.remove(), pi.remove(), this._removed = !0, this.fire(new s.A("remove")); }
                    triggerRepaint() { this._triggerFrame(!0); }
                    _triggerFrame(d) { this._renderNextFrame = this._renderNextFrame || d, this.style && !this._frame && (this._frame = s.q.frame(n => { const l = !!this._renderNextFrame; this._frame = null, this._renderNextFrame = null, l && this._render(n); })); }
                    _preloadTiles(d) { const n = this.style ? this.style.getSourceCaches() : []; return s.bt(n, (l, f) => l._preloadTiles(d, f), () => { this.triggerRepaint(); }), this; }
                    _onWindowOnline() { this._update(); }
                    _onWindowResize(d) { this._trackResize && this.resize({ originalEvent: d })._update(); }
                    _onVisibilityChange() { document.visibilityState === "hidden" && this._visibilityHidden++; }
                    get showTileBoundaries() { return !!this._showTileBoundaries; }
                    set showTileBoundaries(d) { this._showTileBoundaries !== d && (this._showTileBoundaries = d, this._tp.refreshUI(), this._update()); }
                    get showParseStatus() { return !!this._showParseStatus; }
                    set showParseStatus(d) { this._showParseStatus !== d && (this._showParseStatus = d, this._tp.refreshUI(), this._update()); }
                    get showTerrainWireframe() { return !!this._showTerrainWireframe; }
                    set showTerrainWireframe(d) { this._showTerrainWireframe !== d && (this._showTerrainWireframe = d, this._tp.refreshUI(), this._update()); }
                    get showLayers2DWireframe() { return !!this._showLayers2DWireframe; }
                    set showLayers2DWireframe(d) { this._showLayers2DWireframe !== d && (this._showLayers2DWireframe = d, this._tp.refreshUI(), this._update()); }
                    get showLayers3DWireframe() { return !!this._showLayers3DWireframe; }
                    set showLayers3DWireframe(d) { this._showLayers3DWireframe !== d && (this._showLayers3DWireframe = d, this._tp.refreshUI(), this._update()); }
                    get speedIndexTiming() { return !!this._speedIndexTiming; }
                    set speedIndexTiming(d) { this._speedIndexTiming !== d && (this._speedIndexTiming = d, this._update()); }
                    get showPadding() { return !!this._showPadding; }
                    set showPadding(d) { this._showPadding !== d && (this._showPadding = d, this._tp.refreshUI(), this._update()); }
                    get showCollisionBoxes() { return !!this._showCollisionBoxes; }
                    set showCollisionBoxes(d) { this._showCollisionBoxes !== d && (this._showCollisionBoxes = d, this._tp.refreshUI(), d ? this.style._generateCollisionBoxes() : this._update()); }
                    get showOverdrawInspector() { return !!this._showOverdrawInspector; }
                    set showOverdrawInspector(d) { this._showOverdrawInspector !== d && (this._showOverdrawInspector = d, this._tp.refreshUI(), this._update()); }
                    get repaint() { return !!this._repaint; }
                    set repaint(d) { this._repaint !== d && (this._repaint = d, this._tp.refreshUI(), this.triggerRepaint()); }
                    get vertices() { return !!this._vertices; }
                    set vertices(d) { this._vertices = d, this._update(); }
                    get showTileAABBs() { return !!this._showTileAABBs; }
                    set showTileAABBs(d) { this._showTileAABBs !== d && (this._showTileAABBs = d, this._tp.refreshUI(), d && this._update()); }
                    _setCacheLimits(d, n) { s.eJ(d, n); }
                    get version() { return k; }
                }, NavigationControl: class {
                    constructor(d = {}) { this.options = s.l({}, ST, d), this._container = J("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", n => n.preventDefault()), this.options.showZoom && (s.aV(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", n => { this._map && this._map.zoomIn({}, { originalEvent: n }); }), J("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", n => { this._map && this._map.zoomOut({}, { originalEvent: n }); }), J("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (s.aV(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", n => { const l = this._map; l && (this.options.visualizePitch ? l.resetNorthPitch({}, { originalEvent: n }) : l.resetNorth({}, { originalEvent: n })); }), this._compassIcon = J("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true")); }
                    _updateZoomButtons() { const d = this._map; if (!d)
                        return; const n = d.getZoom(), l = n === d.getMaxZoom(), f = n === d.getMinZoom(); this._zoomInButton.disabled = l, this._zoomOutButton.disabled = f, this._zoomInButton.setAttribute("aria-disabled", l.toString()), this._zoomOutButton.setAttribute("aria-disabled", f.toString()); }
                    _rotateCompassArrow() { const d = this._map; if (!d)
                        return; const n = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(d.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${d.transform.pitch}deg) rotateZ(${d.transform.angle * (180 / Math.PI)}deg)` : `rotate(${d.transform.angle * (180 / Math.PI)}deg)`; d._requestDomTask(() => { this._compassIcon && (this._compassIcon.style.transform = n); }); }
                    onAdd(d) { return this._map = d, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), d.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && d.on("pitch", this._rotateCompassArrow), d.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new $d(d, this._compass, this.options.visualizePitch)), this._container; }
                    onRemove() { const d = this._map; d && (this._container.remove(), this.options.showZoom && d.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && d.off("pitch", this._rotateCompassArrow), d.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0); }
                    _createButton(d, n) { const l = J("button", d, this._container); return l.type = "button", l.addEventListener("click", n), l; }
                    _setButtonTitle(d, n) { if (!this._map)
                        return; const l = this._map._getUIString(`NavigationControl.${n}`); d.setAttribute("aria-label", l), d.firstElementChild && d.firstElementChild.setAttribute("title", l); }
                }, GeolocateControl: class extends s.E {
                    constructor(d = {}) { super(); const n = navigator.geolocation; this.options = s.l({ geolocation: n }, qd, d), s.aV(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Bc(this._updateMarkerRotation, 20), this._numberOfWatches = 0; }
                    onAdd(d) { return this._map = d, this._container = J("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container; }
                    onRemove() { this._geolocationWatchID !== void 0 && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1; }
                    _checkGeolocationSupport(d) { const n = (l = !!this.options.geolocation) => { this._supportsGeolocation = l, d(l); }; this._supportsGeolocation !== void 0 ? d(this._supportsGeolocation) : navigator.permissions !== void 0 ? navigator.permissions.query({ name: "geolocation" }).then(l => n(l.state !== "denied")).catch(() => n()) : n(); }
                    _isOutOfMapMaxBounds(d) { const n = this._map.getMaxBounds(), l = d.coords; return !!n && (l.longitude < n.getWest() || l.longitude > n.getEast() || l.latitude < n.getSouth() || l.latitude > n.getNorth()); }
                    _setErrorState() { switch (this._watchState) {
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND": this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                    } }
                    _onSuccess(d) { if (this._map) {
                        if (this._isOutOfMapMaxBounds(d))
                            return this._setErrorState(), this.fire(new s.A("outofmaxbounds", d)), this._updateMarker(), void this._finish();
                        if (this.options.trackUserLocation)
                            switch (this._lastKnownPosition = d, this._watchState) {
                                case "WAITING_ACTIVE":
                                case "ACTIVE_LOCK":
                                case "ACTIVE_ERROR":
                                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                    break;
                                case "BACKGROUND":
                                case "BACKGROUND_ERROR": this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                            }
                        this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(d), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(d), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new s.A("geolocate", d)), this._finish();
                    } }
                    _updateCamera(d) { const n = new s.cd(d.coords.longitude, d.coords.latitude), l = d.coords.accuracy, f = this._map.getBearing(), _ = s.l({ bearing: f }, this.options.fitBoundsOptions); this._map.fitBounds(n.toBounds(l), _, { geolocateSource: !0 }); }
                    _updateMarker(d) { if (d) {
                        const n = new s.cd(d.coords.longitude, d.coords.latitude);
                        this._accuracyCircleMarker.setLngLat(n).addTo(this._map), this._userLocationDotMarker.setLngLat(n).addTo(this._map), this._accuracy = d.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                    }
                    else
                        this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove(); }
                    _updateCircleRadius() { const d = this._map.transform, n = s.c6(1, d._center.lat) * d.worldSize, l = Math.ceil(2 * this._accuracy * n); this._circleElement.style.width = `${l}px`, this._circleElement.style.height = `${l}px`; }
                    _onZoom() { this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius(); }
                    _updateMarkerRotation() { this._userLocationDotMarker && typeof this._heading == "number" ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0)); }
                    _onError(d) { if (this._map) {
                        if (this.options.trackUserLocation)
                            if (d.code === 1) {
                                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                                const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                this._geolocateButton.setAttribute("aria-label", n), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", n), this._geolocationWatchID !== void 0 && this._clearWatch();
                            }
                            else {
                                if (d.code === 3 && this._noTimeout)
                                    return;
                                this._setErrorState();
                            }
                        this._watchState !== "OFF" && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new s.A("error", d)), this._finish();
                    } }
                    _finish() { this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0; }
                    _setupUI(d) { if (this._map !== void 0) {
                        if (this._container.addEventListener("contextmenu", n => n.preventDefault()), this._geolocateButton = J("button", "mapboxgl-ctrl-geolocate", this._container), J("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", d === !1) {
                            s.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                            const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                            this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", n), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", n);
                        }
                        else {
                            const n = this._map._getUIString("GeolocateControl.FindMyLocation");
                            this._geolocateButton.setAttribute("aria-label", n), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", n);
                        }
                        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = J("div", "mapboxgl-user-location"), this._dotElement.appendChild(J("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(J("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Gd({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = J("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Gd({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", n => { n.geolocateSource || this._watchState !== "ACTIVE_LOCK" || n.originalEvent && n.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new s.A("trackuserlocationend"))); });
                    } }
                    _onDeviceOrientation(d) { this._userLocationDotMarker && (d.webkitCompassHeading ? this._heading = d.webkitCompassHeading : d.absolute === !0 && (this._heading = -1 * d.alpha), this._updateMarkerRotationThrottled()); }
                    trigger() { if (!this._setup)
                        return s.w("Geolocate control triggered before added to a map"), !1; if (this.options.trackUserLocation) {
                        switch (this._watchState) {
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE", this.fire(new s.A("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new s.A("trackuserlocationend"));
                                break;
                            case "BACKGROUND": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new s.A("trackuserlocationstart"));
                        }
                        switch (this._watchState) {
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                break;
                            case "BACKGROUND":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                                break;
                            case "BACKGROUND_ERROR": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
                        }
                        if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
                            this._clearWatch();
                        else if (this._geolocationWatchID === void 0) {
                            let d;
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (d = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = !0) : (d = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, d), this.options.showUserHeading && this._addDeviceOrientationListener();
                        }
                    }
                    else
                        this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4); return !0; }
                    _addDeviceOrientationListener() { const d = () => { "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation); }; typeof DeviceMotionEvent < "u" && typeof DeviceMotionEvent.requestPermission == "function" ? DeviceOrientationEvent.requestPermission().then(n => { n === "granted" && d(); }).catch(console.error) : d(); }
                    _clearWatch() { this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null); }
                }, AttributionControl: $p, ScaleControl: class {
                    constructor(d = {}) { this.options = s.l({}, Wu, d), this._isNumberFormatSupported = function () { try {
                        return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), !0;
                    }
                    catch {
                        return !1;
                    } }(), s.aV(["_update", "_setScale", "setUnit"], this); }
                    getDefaultPosition() { return "bottom-left"; }
                    _update() { const d = this.options.maxWidth || 100, n = this._map, l = n._containerHeight / 2, f = n._containerWidth / 2 - d / 2, _ = n.unproject([f, l]), v = n.unproject([f + d, l]), w = _.distanceTo(v); if (this.options.unit === "imperial") {
                        const T = 3.2808 * w;
                        T > 5280 ? this._setScale(d, T / 5280, "mile") : this._setScale(d, T, "foot");
                    }
                    else
                        this.options.unit === "nautical" ? this._setScale(d, w / 1852, "nautical-mile") : w >= 1e3 ? this._setScale(d, w / 1e3, "kilometer") : this._setScale(d, w, "meter"); }
                    _setScale(d, n, l) { this._map._requestDomTask(() => { const f = function (v) { const w = Math.pow(10, `${Math.floor(v)}`.length - 1); let T = v / w; return T = T >= 10 ? 10 : T >= 5 ? 5 : T >= 3 ? 3 : T >= 2 ? 2 : T >= 1 ? 1 : function (C) { const P = Math.pow(10, Math.ceil(-Math.log(C) / Math.LN10)); return Math.round(C * P) / P; }(T), w * T; }(n), _ = f / n; this._container.innerHTML = this._isNumberFormatSupported && l !== "nautical-mile" ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: l }).format(f) : `${f}&nbsp;${tl[l]}`, this._container.style.width = d * _ + "px"; }); }
                    onAdd(d) { return this._map = d, this._language = d.getLanguage(), this._container = J("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", d.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container; }
                    onRemove() { this._container.remove(), this._map.off("move", this._update), this._map = void 0; }
                    _setLanguage(d) { this._language = d, this._update(); }
                    setUnit(d) { this.options.unit = d, this._update(); }
                }, FullscreenControl: class {
                    constructor(d = {}) { this._fullscreen = !1, d && d.container && (d.container instanceof HTMLElement ? this._container = d.container : s.w("Full screen control 'container' must be a DOM element.")), s.aV(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange"); }
                    onAdd(d) { return this._map = d, this._container || (this._container = this._map.getContainer()), this._controlContainer = J("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", s.w("This device does not support fullscreen mode.")), this._controlContainer; }
                    onRemove() { this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon); }
                    _checkFullscreenSupport() { return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled); }
                    _setupUI() { const d = this._fullscreenButton = J("button", "mapboxgl-ctrl-fullscreen", this._controlContainer); J("span", "mapboxgl-ctrl-icon", d).setAttribute("aria-hidden", "true"), d.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon); }
                    _updateTitle() { const d = this._getTitle(); this._fullscreenButton.setAttribute("aria-label", d), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", d); }
                    _getTitle() { return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter"); }
                    _isFullscreen() { return this._fullscreen; }
                    _changeIcon() { (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle()); }
                    _onClickFullscreen() { this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen(); }
                }, Popup: class extends s.E {
                    constructor(d) { super(), this.options = s.l(Object.create(ia), d), this._altitude = this.options.altitude, s.aV(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(d && d.className ? d.className.trim().split(/\s+/) : []); }
                    addTo(d) { return this._map && this.remove(), this._map = d, this.options.closeOnClick && d.on("preclick", this._onClose), this.options.closeOnMove && d.on("move", this._onClose), d.on("remove", this.remove), this._update(), d._addPopup(this), this._focusFirstElement(), this._trackPointer ? (d.on("mousemove", this._onMouseEvent), d.on("mouseup", this._onMouseEvent), d._canvasContainer.classList.add("mapboxgl-track-pointer")) : d.on("move", this._update), this.fire(new s.A("open")), this; }
                    isOpen() { return !!this._map; }
                    remove() { this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0); const d = this._map; return d && (d.off("move", this._update), d.off("move", this._onClose), d.off("preclick", this._onClose), d.off("click", this._onClose), d.off("remove", this.remove), d.off("mousemove", this._onMouseEvent), d.off("mouseup", this._onMouseEvent), d.off("drag", this._onMouseEvent), d._canvasContainer && d._canvasContainer.classList.remove("mapboxgl-track-pointer"), d._removePopup(this), this._map = void 0), this.fire(new s.A("close")), this; }
                    getLngLat() { return this._lngLat; }
                    setLngLat(d) { this._lngLat = s.cd.convert(d), this._pos = null, this._trackPointer = !1, this._update(); const n = this._map; return n && (n.on("move", this._update), n.off("mousemove", this._onMouseEvent), n._canvasContainer.classList.remove("mapboxgl-track-pointer")), this; }
                    getAltitude() { return this._altitude; }
                    setAltitude(d) { return this._altitude = d, this._update(), this; }
                    trackPointer() { this._trackPointer = !0, this._pos = null, this._update(); const d = this._map; return d && (d.off("move", this._update), d.on("mousemove", this._onMouseEvent), d.on("drag", this._onMouseEvent), d._canvasContainer.classList.add("mapboxgl-track-pointer")), this; }
                    getElement() { return this._container; }
                    setText(d) { return this.setDOMContent(document.createTextNode(d)); }
                    setHTML(d) { const n = document.createDocumentFragment(), l = document.createElement("body"); let f; for (l.innerHTML = d; f = l.firstChild, f;)
                        n.appendChild(f); return this.setDOMContent(n); }
                    getMaxWidth() { return this._container && this._container.style.maxWidth; }
                    setMaxWidth(d) { return this.options.maxWidth = d, this._update(), this; }
                    setDOMContent(d) { let n = this._content; if (n)
                        for (; n.hasChildNodes();)
                            n.firstChild && n.removeChild(n.firstChild);
                    else
                        n = this._content = J("div", "mapboxgl-popup-content", this._container || void 0); if (n.appendChild(d), this.options.closeButton) {
                        const l = this._closeButton = J("button", "mapboxgl-popup-close-button", n);
                        l.type = "button", l.setAttribute("aria-label", "Close popup"), l.innerHTML = "<span aria-hidden=\"true\">&#215;</span>", l.addEventListener("click", this._onClose);
                    } return this._update(), this._focusFirstElement(), this; }
                    addClassName(d) { return this._classList.add(d), this._updateClassList(), this; }
                    removeClassName(d) { return this._classList.delete(d), this._updateClassList(), this; }
                    setOffset(d) { return this.options.offset = d, this._update(), this; }
                    toggleClassName(d) { let n; return this._classList.delete(d) ? n = !1 : (this._classList.add(d), n = !0), this._updateClassList(), n; }
                    _onMouseEvent(d) { this._update(d.point); }
                    _getAnchor(d) { if (this.options.anchor)
                        return this.options.anchor; const n = this._map, l = this._container, f = this._pos; if (!n || !l || !f)
                        return "bottom"; const _ = l.offsetWidth, v = l.offsetHeight, w = f.x < _ / 2, T = f.x > n.transform.width - _ / 2; if (f.y + d < v)
                        return w ? "top-left" : T ? "top-right" : "top"; if (f.y > n.transform.height - v) {
                        if (w)
                            return "bottom-left";
                        if (T)
                            return "bottom-right";
                    } return w ? "left" : T ? "right" : "bottom"; }
                    _updateClassList() { const d = this._container; if (!d)
                        return; const n = [...this._classList]; n.push("mapboxgl-popup"), this._anchor && n.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && n.push("mapboxgl-popup-track-pointer"), d.className = n.join(" "); }
                    _update(d) { const n = this._map, l = this._content; if (!n || !this._lngLat && !this._trackPointer || !l)
                        return; let f = this._container; if (f || (f = this._container = J("div", "mapboxgl-popup", n.getContainer()), this._tip = J("div", "mapboxgl-popup-tip", f), f.appendChild(l)), this.options.maxWidth && f.style.maxWidth !== this.options.maxWidth && (f.style.maxWidth = this.options.maxWidth), n.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = gx(this._lngLat, this._pos, n.transform)), !this._trackPointer || d) {
                        const _ = this._pos = this._trackPointer && d instanceof s.P ? d : n.project(this._lngLat, this._altitude), v = $l(this.options.offset), w = this._anchor = this._getAnchor(v.y), T = $l(this.options.offset, w), C = _.add(T).round();
                        n._requestDomTask(() => { this._container && w && (this._container.style.transform = `${N_[w]} translate(${C.x}px,${C.y}px)`); });
                    } if (!this._marker && n._showingGlobe()) {
                        const _ = s.eK(n.transform, this._lngLat) ? 0 : 1;
                        this._setOpacity(_);
                    } this._updateClassList(); }
                    _focusFirstElement() { if (!this.options.focusAfterOpen || !this._container)
                        return; const d = this._container.querySelector(sa); d && d.focus(); }
                    _onClose() { this.remove(); }
                    _setOpacity(d) { this._container && (this._container.style.opacity = `${d}`), this._content && (this._content.style.pointerEvents = d ? "auto" : "none"); }
                }, Marker: Gd, Style: Lo, LngLat: s.cd, LngLatBounds: s.aG, Point: s.P, MercatorCoordinate: s.ac, FreeCameraOptions: np, Evented: s.E, config: s.e, prewarm: s.eP, clearPrewarmedResources: s.eQ, get accessToken() { return s.e.ACCESS_TOKEN; }, set accessToken(d) { s.e.ACCESS_TOKEN = d; }, get baseApiUrl() { return s.e.API_URL; }, set baseApiUrl(d) { s.e.API_URL = d; }, get workerCount() { return s.eR.workerCount; }, set workerCount(d) { s.eR.workerCount = d; }, get maxParallelImageRequests() { return s.e.MAX_PARALLEL_IMAGE_REQUESTS; }, set maxParallelImageRequests(d) { s.e.MAX_PARALLEL_IMAGE_REQUESTS = d; }, clearStorage(d) { s.eS(d); }, get workerUrl() { return s.eT.workerUrl; }, set workerUrl(d) { s.eT.workerUrl = d; }, get workerClass() { return s.eT.workerClass; }, set workerClass(d) { s.eT.workerClass = d; }, get workerParams() { return s.eT.workerParams; }, set workerParams(d) { s.eT.workerParams = d; }, get dracoUrl() { return s.eU(); }, set dracoUrl(d) { s.eV(d); }, get meshoptUrl() { return s.eW(); }, set meshoptUrl(d) { s.eX(d); }, setNow: s.q.setNow, restoreNow: s.q.restoreNow };
        });
        var E = g;
        return E;
    });
})(gB);
var MK = gB.exports;
const Fy = TC(MK), OE = "pk.eyJ1IjoicmV0bW91c2VyIiwiYSI6ImNtOXJtOHZ0MjA0dTgycG9ocDA3dXNpMGIifQ.WHYwcRzR3g8djNiBsVw1vg";
function sI() { const t = ne.useRef(null), r = ne.useRef({}), [o, u] = ne.useState(!1), g = ne.useCallback(async (N, V, H) => { if (!t.current)
    try {
        Fy.accessToken = OE;
        const ee = new Fy.Map({ container: N, style: XZ, center: V, zoom: H, attributionControl: !1 });
        ee.addControl(new Fy.NavigationControl, "bottom-right"), await new Promise(ce => { ee.on("load", () => { ce(); }); }), t.current = ee, u(!0);
        return;
    }
    catch (ee) {
        throw console.error("Error initializing Mapbox:", ee), ee;
    } }, []), y = ne.useCallback((N, V) => { if (!t.current || !o)
    return; Object.values(r.current).forEach(ee => ee.remove()), r.current = {}; const H = ee => { const ce = document.createElement("div"); return ce.className = "flex items-center justify-center", ce.style.width = "32px", ce.style.height = "32px", ce.style.borderRadius = "50%", ce.style.backgroundColor = "hsl(16, 100%, 50%)", ce.style.color = "white", ce.style.fontWeight = "bold", ce.style.display = "flex", ce.style.alignItems = "center", ce.style.justifyContent = "center", ce.style.boxShadow = "0 2px 4px rgba(0,0,0,0.3)", ce.innerHTML = ee, ce; }; if (N.forEach((ee, ce) => { const { id: J, latitude: ye, longitude: ie, label: Q } = ee, ue = (ce + 1).toString(), be = H(ue), Ie = new Fy.Marker({ element: be }).setLngLat([ie, ye]).addTo(t.current); V && Ie.getElement().addEventListener("click", () => { V(ee); }), r.current[J] = Ie; }), N.length > 0) {
    const ee = new Fy.LngLatBounds;
    N.forEach(ce => { ee.extend([ce.longitude, ce.latitude]); }), t.current.fitBounds(ee, { padding: 60, maxZoom: 15 });
} }, [o]), E = ne.useCallback(N => { !t.current || !o || (N.forEach((V, H) => { t.current.getLayer(`route-${H}`) && t.current.removeLayer(`route-${H}`), t.current.getSource(`route-${H}`) && t.current.removeSource(`route-${H}`); }), N.forEach((V, H) => { !V.coordinates || V.coordinates.length < 2 || (t.current.getSource(`route-${H}`) ? t.current.getSource(`route-${H}`).setData({ type: "Feature", properties: {}, geometry: { type: "LineString", coordinates: V.coordinates } }) : t.current.addSource(`route-${H}`, { type: "geojson", data: { type: "Feature", properties: {}, geometry: { type: "LineString", coordinates: V.coordinates } } }), t.current.getLayer(`route-${H}`) || t.current.addLayer({ id: `route-${H}`, type: "line", source: `route-${H}`, layout: { "line-join": "round", "line-cap": "round" }, paint: { "line-color": "#4571E6", "line-width": 4, "line-opacity": .8 } })); })); }, [o]), s = ne.useCallback(() => { const V = window.location.pathname.match(/\/trip\/(\d+)/); if (V && V[1]) {
    const H = localStorage.getItem(`trip_${V[1]}`);
    if (H)
        try {
            const ee = JSON.parse(H);
            if (ee.longitude && ee.latitude)
                return { longitude: parseFloat(ee.longitude), latitude: parseFloat(ee.latitude), city: ee.city };
        }
        catch (ee) {
            console.error("Error parsing trip data from localStorage:", ee);
        }
} return { longitude: -73.9857, latitude: 40.7484, city: "New York City" }; }, []), k = ne.useCallback(async (N) => { var V, H, ee, ce, J, ye; try {
    const ie = s();
    let Q = N;
    if (ie.city) {
        const kt = ie.city.toLowerCase().split(/[ ,]+/), ct = Q.toLowerCase();
        !kt.some(Kt => Kt.length > 2 && ct.includes(Kt)) && Q.split(",").length === 1 && (Q = `${Q}, ${ie.city}`);
    }
    let ue;
    ie.longitude && ie.latitude && (ue = [ie.longitude - .18, ie.latitude - .18, ie.longitude + .18, ie.latitude + .18].join(","));
    const be = new URLSearchParams({ access_token: OE, types: "poi,address", limit: "10", language: "en" });
    ue ? be.append("bbox", ue) : ie.longitude && ie.latitude && be.append("proximity", `${ie.longitude},${ie.latitude}`);
    const Ie = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(Q)}.json?${be.toString()}`, Be = new URLSearchParams({ access_token: OE, types: "poi,place,address", limit: "8", language: "en", fuzzyMatch: "false", autocomplete: "true" });
    ie.longitude && ie.latitude && Be.append("proximity", `${ie.longitude},${ie.latitude}`);
    const Ze = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(Q)}.json?${Be.toString()}`;
    console.log("GEOCODE DEBUG - POI Query:", { searchTerm: Q, url: Ie, params: Object.fromEntries(be.entries()), tripContext: ie });
    let ot = await fetch(Ie), At = await ot.json();
    if (console.log("GEOCODE RESPONSE - POI Result:", { features: ((V = At.features) == null ? void 0 : V.length) || 0, firstResult: ((H = At.features) == null ? void 0 : H.length) > 0 ? At.features[0].place_name : "none", allTypes: ((ee = At.features) == null ? void 0 : ee.map(kt => kt.place_type).flat().filter((kt, ct, St) => St.indexOf(kt) === ct)) || [] }), (!At.features || At.features.length === 0) && (console.log("GEOCODE DEBUG - Fallback Query:", { searchTerm: Q, url: Ze, params: Object.fromEntries(Be.entries()) }), ot = await fetch(Ze), At = await ot.json(), console.log("GEOCODE RESPONSE - Fallback Result:", { features: ((ce = At.features) == null ? void 0 : ce.length) || 0, firstResult: ((J = At.features) == null ? void 0 : J.length) > 0 ? At.features[0].place_name : "none", allTypes: ((ye = At.features) == null ? void 0 : ye.map(kt => kt.place_type).flat().filter((kt, ct, St) => St.indexOf(kt) === ct)) || [] })), At.features && At.features.length > 0) {
        const kt = At.features.map(ir => { var Ft, gr, Jr; let tr = 0; const Or = Q.toLowerCase().replace(/\b(the|a|an|in|of|at|by|for|with|hotel|inn|motel)\b/g, "").split(/[ ,]+/).filter(pi => pi.length > 2), xt = ir.text.toLowerCase(), Pt = ((Ft = ir.place_type) == null ? void 0 : Ft[0]) || ""; return Pt === "poi" && (tr += 25), Pt === "place" && (tr += 15), ir.relevance > .8 && (tr += ir.relevance * 20), (Jr = (gr = ir.properties) == null ? void 0 : gr.category) != null && Jr.includes("landmark") && (tr += 20), Or.forEach(pi => { xt.includes(pi) && (tr += 5, xt.startsWith(pi) && (tr += 10)); }), ie.city && ir.place_name.toLowerCase().includes(ie.city.toLowerCase()) && (tr += 10), { feature: ir, score: tr }; });
        kt.sort((ir, tr) => tr.score - ir.score);
        const ct = kt[0].feature, [St, Kt] = ct.center, bt = ct.place_name;
        return console.log("Location found:", { input: Q, matched: bt, coordinates: [St, Kt], allResults: At.features.slice(0, 5).map(ir => ir.place_name), score: kt[0].score }), { longitude: St, latitude: Kt, fullAddress: bt };
    }
    return null;
}
catch (ie) {
    return console.error("Error geocoding location:", ie), null;
} }, [s]), L = ne.useCallback((N, V) => { !t.current || !o || t.current.flyTo({ center: N, zoom: V, essential: !0 }); }, [o]); return ne.useEffect(() => () => { t.current && (t.current.remove(), t.current = null); }, []), { initializeMap: g, addMarkers: y, addRoutes: E, geocodeLocation: k, flyToLocation: L, isInitialized: o }; }
var zE = "focusScope.autoFocusOnMount", FE = "focusScope.autoFocusOnUnmount", XL = { bubbles: !1, cancelable: !0 }, RK = "FocusScope", oI = ne.forwardRef((t, r) => { const { loop: o = !1, trapped: u = !1, onMountAutoFocus: g, onUnmountAutoFocus: y, ...E } = t, [s, k] = ne.useState(null), L = To(g), N = To(y), V = ne.useRef(null), H = is(r, J => k(J)), ee = ne.useRef({ paused: !1, pause() { this.paused = !0; }, resume() { this.paused = !1; } }).current; ne.useEffect(() => { if (u) {
    let J = function (ue) { if (ee.paused || !s)
        return; const be = ue.target; s.contains(be) ? V.current = be : fh(V.current, { select: !0 }); }, ye = function (ue) { if (ee.paused || !s)
        return; const be = ue.relatedTarget; be !== null && (s.contains(be) || fh(V.current, { select: !0 })); }, ie = function (ue) { if (document.activeElement === document.body)
        for (const Ie of ue)
            Ie.removedNodes.length > 0 && fh(s); };
    document.addEventListener("focusin", J), document.addEventListener("focusout", ye);
    const Q = new MutationObserver(ie);
    return s && Q.observe(s, { childList: !0, subtree: !0 }), () => { document.removeEventListener("focusin", J), document.removeEventListener("focusout", ye), Q.disconnect(); };
} }, [u, s, ee.paused]), ne.useEffect(() => { if (s) {
    YL.add(ee);
    const J = document.activeElement;
    if (!s.contains(J)) {
        const ie = new CustomEvent(zE, XL);
        s.addEventListener(zE, L), s.dispatchEvent(ie), ie.defaultPrevented || (kK(FK(yB(s)), { select: !0 }), document.activeElement === J && fh(s));
    }
    return () => { s.removeEventListener(zE, L), setTimeout(() => { const ie = new CustomEvent(FE, XL); s.addEventListener(FE, N), s.dispatchEvent(ie), ie.defaultPrevented || fh(J ?? document.body, { select: !0 }), s.removeEventListener(FE, N), YL.remove(ee); }, 0); };
} }, [s, L, N, ee]); const ce = ne.useCallback(J => { if (!o && !u || ee.paused)
    return; const ye = J.key === "Tab" && !J.altKey && !J.ctrlKey && !J.metaKey, ie = document.activeElement; if (ye && ie) {
    const Q = J.currentTarget, [ue, be] = DK(Q);
    ue && be ? !J.shiftKey && ie === be ? (J.preventDefault(), o && fh(ue, { select: !0 })) : J.shiftKey && ie === ue && (J.preventDefault(), o && fh(be, { select: !0 })) : ie === Q && J.preventDefault();
} }, [o, u, ee.paused]); return j.jsx(si.div, { tabIndex: -1, ...E, ref: H, onKeyDown: ce }); });
oI.displayName = RK;
function kK(t, { select: r = !1 } = {}) { const o = document.activeElement; for (const u of t)
    if (fh(u, { select: r }), document.activeElement !== o)
        return; }
function DK(t) { const r = yB(t), o = KL(r, t), u = KL(r.reverse(), t); return [o, u]; }
function yB(t) { const r = [], o = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, { acceptNode: u => { const g = u.tagName === "INPUT" && u.type === "hidden"; return u.disabled || u.hidden || g ? NodeFilter.FILTER_SKIP : u.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; } }); for (; o.nextNode();)
    r.push(o.currentNode); return r; }
function KL(t, r) { for (const o of t)
    if (!LK(o, { upTo: r }))
        return o; }
function LK(t, { upTo: r }) { if (getComputedStyle(t).visibility === "hidden")
    return !0; for (; t;) {
    if (r !== void 0 && t === r)
        return !1;
    if (getComputedStyle(t).display === "none")
        return !0;
    t = t.parentElement;
} return !1; }
function OK(t) { return t instanceof HTMLInputElement && "select" in t; }
function fh(t, { select: r = !1 } = {}) { if (t && t.focus) {
    const o = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== o && OK(t) && r && t.select();
} }
var YL = zK();
function zK() { let t = []; return { add(r) { const o = t[0]; r !== o && (o == null || o.pause()), t = QL(t, r), t.unshift(r); }, remove(r) { var o; t = QL(t, r), (o = t[0]) == null || o.resume(); } }; }
function QL(t, r) { const o = [...t], u = o.indexOf(r); return u !== -1 && o.splice(u, 1), o; }
function FK(t) { return t.filter(r => r.tagName !== "A"); }
var NE = 0;
function vB() { ne.useEffect(() => { const t = document.querySelectorAll("[data-radix-focus-guard]"); return document.body.insertAdjacentElement("afterbegin", t[0] ?? JL()), document.body.insertAdjacentElement("beforeend", t[1] ?? JL()), NE++, () => { NE === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(r => r.remove()), NE--; }; }, []); }
function JL() { const t = document.createElement("span"); return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.outline = "none", t.style.opacity = "0", t.style.position = "fixed", t.style.pointerEvents = "none", t; }
var nc = function () { return nc = Object.assign || function (r) { for (var o, u = 1, g = arguments.length; u < g; u++) {
    o = arguments[u];
    for (var y in o)
        Object.prototype.hasOwnProperty.call(o, y) && (r[y] = o[y]);
} return r; }, nc.apply(this, arguments); };
function xB(t, r) { var o = {}; for (var u in t)
    Object.prototype.hasOwnProperty.call(t, u) && r.indexOf(u) < 0 && (o[u] = t[u]); if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var g = 0, u = Object.getOwnPropertySymbols(t); g < u.length; g++)
        r.indexOf(u[g]) < 0 && Object.prototype.propertyIsEnumerable.call(t, u[g]) && (o[u[g]] = t[u[g]]); return o; }
function NK(t, r, o) { if (o || arguments.length === 2)
    for (var u = 0, g = r.length, y; u < g; u++)
        (y || !(u in r)) && (y || (y = Array.prototype.slice.call(r, 0, u)), y[u] = r[u]); return t.concat(y || Array.prototype.slice.call(r)); }
var nw = "right-scroll-bar-position", iw = "width-before-scroll-bar", BK = "with-scroll-bars-hidden", jK = "--removed-body-scroll-bar-size";
function BE(t, r) { return typeof t == "function" ? t(r) : t && (t.current = r), t; }
function VK(t, r) { var o = ne.useState(function () { return { value: t, callback: r, facade: { get current() { return o.value; }, set current(u) { var g = o.value; g !== u && (o.value = u, o.callback(u, g)); } } }; })[0]; return o.callback = r, o.facade; }
var UK = typeof window < "u" ? ne.useLayoutEffect : ne.useEffect, eO = new WeakMap;
function $K(t, r) { var o = VK(null, function (u) { return t.forEach(function (g) { return BE(g, u); }); }); return UK(function () { var u = eO.get(o); if (u) {
    var g = new Set(u), y = new Set(t), E = o.current;
    g.forEach(function (s) { y.has(s) || BE(s, null); }), y.forEach(function (s) { g.has(s) || BE(s, E); });
} eO.set(o, t); }, [t]), o; }
function GK(t) { return t; }
function qK(t, r) { r === void 0 && (r = GK); var o = [], u = !1, g = { read: function () { if (u)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."); return o.length ? o[o.length - 1] : t; }, useMedium: function (y) { var E = r(y, u); return o.push(E), function () { o = o.filter(function (s) { return s !== E; }); }; }, assignSyncMedium: function (y) { for (u = !0; o.length;) {
        var E = o;
        o = [], E.forEach(y);
    } o = { push: function (s) { return y(s); }, filter: function () { return o; } }; }, assignMedium: function (y) { u = !0; var E = []; if (o.length) {
        var s = o;
        o = [], s.forEach(y), E = o;
    } var k = function () { var N = E; E = [], N.forEach(y); }, L = function () { return Promise.resolve().then(k); }; L(), o = { push: function (N) { E.push(N), L(); }, filter: function (N) { return E = E.filter(N), o; } }; } }; return g; }
function HK(t) { t === void 0 && (t = {}); var r = qK(null); return r.options = nc({ async: !0, ssr: !1 }, t), r; }
var wB = function (t) { var r = t.sideCar, o = xB(t, ["sideCar"]); if (!r)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car"); var u = r.read(); if (!u)
    throw new Error("Sidecar medium not found"); return ne.createElement(u, nc({}, o)); };
wB.isSideCarExport = !0;
function WK(t, r) { return t.useMedium(r), wB; }
var bB = HK(), jE = function () { }, jb = ne.forwardRef(function (t, r) { var o = ne.useRef(null), u = ne.useState({ onScrollCapture: jE, onWheelCapture: jE, onTouchMoveCapture: jE }), g = u[0], y = u[1], E = t.forwardProps, s = t.children, k = t.className, L = t.removeScrollBar, N = t.enabled, V = t.shards, H = t.sideCar, ee = t.noIsolation, ce = t.inert, J = t.allowPinchZoom, ye = t.as, ie = ye === void 0 ? "div" : ye, Q = t.gapMode, ue = xB(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), be = H, Ie = $K([o, r]), Be = nc(nc({}, ue), g); return ne.createElement(ne.Fragment, null, N && ne.createElement(be, { sideCar: bB, removeScrollBar: L, shards: V, noIsolation: ee, inert: ce, setCallbacks: y, allowPinchZoom: !!J, lockRef: o, gapMode: Q }), E ? ne.cloneElement(ne.Children.only(s), nc(nc({}, Be), { ref: Ie })) : ne.createElement(ie, nc({}, Be, { className: k, ref: Ie }), s)); });
jb.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 };
jb.classNames = { fullWidth: iw, zeroRight: nw };
var ZK = function () { if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__; };
function XK() { if (!document)
    return null; var t = document.createElement("style"); t.type = "text/css"; var r = ZK(); return r && t.setAttribute("nonce", r), t; }
function KK(t, r) { t.styleSheet ? t.styleSheet.cssText = r : t.appendChild(document.createTextNode(r)); }
function YK(t) { var r = document.head || document.getElementsByTagName("head")[0]; r.appendChild(t); }
var QK = function () { var t = 0, r = null; return { add: function (o) { t == 0 && (r = XK()) && (KK(r, o), YK(r)), t++; }, remove: function () { t--, !t && r && (r.parentNode && r.parentNode.removeChild(r), r = null); } }; }, JK = function () { var t = QK(); return function (r, o) { ne.useEffect(function () { return t.add(r), function () { t.remove(); }; }, [r && o]); }; }, TB = function () { var t = JK(), r = function (o) { var u = o.styles, g = o.dynamic; return t(u, g), null; }; return r; }, eY = { left: 0, top: 0, right: 0, gap: 0 }, VE = function (t) { return parseInt(t || "", 10) || 0; }, tY = function (t) { var r = window.getComputedStyle(document.body), o = r[t === "padding" ? "paddingLeft" : "marginLeft"], u = r[t === "padding" ? "paddingTop" : "marginTop"], g = r[t === "padding" ? "paddingRight" : "marginRight"]; return [VE(o), VE(u), VE(g)]; }, rY = function (t) { if (t === void 0 && (t = "margin"), typeof window > "u")
    return eY; var r = tY(t), o = document.documentElement.clientWidth, u = window.innerWidth; return { left: r[0], top: r[1], right: r[2], gap: Math.max(0, u - o + r[2] - r[0]) }; }, nY = TB(), qm = "data-scroll-locked", iY = function (t, r, o, u) {
    var g = t.left, y = t.top, E = t.right, s = t.gap;
    return o === void 0 && (o = "margin"), `
  .`.concat(BK, ` {
   overflow: hidden `).concat(u, `;
   padding-right: `).concat(s, "px ").concat(u, `;
  }
  body[`).concat(qm, `] {
    overflow: hidden `).concat(u, `;
    overscroll-behavior: contain;
    `).concat([r && "position: relative ".concat(u, ";"), o === "margin" && `
    padding-left: `.concat(g, `px;
    padding-top: `).concat(y, `px;
    padding-right: `).concat(E, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s, "px ").concat(u, `;
    `), o === "padding" && "padding-right: ".concat(s, "px ").concat(u, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(nw, ` {
    right: `).concat(s, "px ").concat(u, `;
  }
  
  .`).concat(iw, ` {
    margin-right: `).concat(s, "px ").concat(u, `;
  }
  
  .`).concat(nw, " .").concat(nw, ` {
    right: 0 `).concat(u, `;
  }
  
  .`).concat(iw, " .").concat(iw, ` {
    margin-right: 0 `).concat(u, `;
  }
  
  body[`).concat(qm, `] {
    `).concat(jK, ": ").concat(s, `px;
  }
`);
}, tO = function () { var t = parseInt(document.body.getAttribute(qm) || "0", 10); return isFinite(t) ? t : 0; }, sY = function () { ne.useEffect(function () { return document.body.setAttribute(qm, (tO() + 1).toString()), function () { var t = tO() - 1; t <= 0 ? document.body.removeAttribute(qm) : document.body.setAttribute(qm, t.toString()); }; }, []); }, oY = function (t) { var r = t.noRelative, o = t.noImportant, u = t.gapMode, g = u === void 0 ? "margin" : u; sY(); var y = ne.useMemo(function () { return rY(g); }, [g]); return ne.createElement(nY, { styles: iY(y, !r, g, o ? "" : "!important") }); }, vC = !1;
if (typeof window < "u")
    try {
        var z1 = Object.defineProperty({}, "passive", { get: function () { return vC = !0, !0; } });
        window.addEventListener("test", z1, z1), window.removeEventListener("test", z1, z1);
    }
    catch {
        vC = !1;
    }
var mm = vC ? { passive: !1 } : !1, aY = function (t) { return t.tagName === "TEXTAREA"; }, SB = function (t, r) { if (!(t instanceof Element))
    return !1; var o = window.getComputedStyle(t); return o[r] !== "hidden" && !(o.overflowY === o.overflowX && !aY(t) && o[r] === "visible"); }, lY = function (t) { return SB(t, "overflowY"); }, cY = function (t) { return SB(t, "overflowX"); }, rO = function (t, r) { var o = r.ownerDocument, u = r; do {
    typeof ShadowRoot < "u" && u instanceof ShadowRoot && (u = u.host);
    var g = EB(t, u);
    if (g) {
        var y = CB(t, u), E = y[1], s = y[2];
        if (E > s)
            return !0;
    }
    u = u.parentNode;
} while (u && u !== o.body); return !1; }, uY = function (t) { var r = t.scrollTop, o = t.scrollHeight, u = t.clientHeight; return [r, o, u]; }, hY = function (t) { var r = t.scrollLeft, o = t.scrollWidth, u = t.clientWidth; return [r, o, u]; }, EB = function (t, r) { return t === "v" ? lY(r) : cY(r); }, CB = function (t, r) { return t === "v" ? uY(r) : hY(r); }, dY = function (t, r) { return t === "h" && r === "rtl" ? -1 : 1; }, fY = function (t, r, o, u, g) { var y = dY(t, window.getComputedStyle(r).direction), E = y * u, s = o.target, k = r.contains(s), L = !1, N = E > 0, V = 0, H = 0; do {
    var ee = CB(t, s), ce = ee[0], J = ee[1], ye = ee[2], ie = J - ye - y * ce;
    (ce || ie) && EB(t, s) && (V += ie, H += ce), s instanceof ShadowRoot ? s = s.host : s = s.parentNode;
} while (!k && s !== document.body || k && (r.contains(s) || r === s)); return (N && (Math.abs(V) < 1 || !g) || !N && (Math.abs(H) < 1 || !g)) && (L = !0), L; }, F1 = function (t) { return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0]; }, nO = function (t) { return [t.deltaX, t.deltaY]; }, iO = function (t) { return t && "current" in t ? t.current : t; }, pY = function (t, r) { return t[0] === r[0] && t[1] === r[1]; }, mY = function (t) {
    return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, gY = 0, gm = [];
function _Y(t) { var r = ne.useRef([]), o = ne.useRef([0, 0]), u = ne.useRef(), g = ne.useState(gY++)[0], y = ne.useState(TB)[0], E = ne.useRef(t); ne.useEffect(function () { E.current = t; }, [t]), ne.useEffect(function () { if (t.inert) {
    document.body.classList.add("block-interactivity-".concat(g));
    var J = NK([t.lockRef.current], (t.shards || []).map(iO), !0).filter(Boolean);
    return J.forEach(function (ye) { return ye.classList.add("allow-interactivity-".concat(g)); }), function () { document.body.classList.remove("block-interactivity-".concat(g)), J.forEach(function (ye) { return ye.classList.remove("allow-interactivity-".concat(g)); }); };
} }, [t.inert, t.lockRef.current, t.shards]); var s = ne.useCallback(function (J, ye) { if ("touches" in J && J.touches.length === 2 || J.type === "wheel" && J.ctrlKey)
    return !E.current.allowPinchZoom; var ie = F1(J), Q = o.current, ue = "deltaX" in J ? J.deltaX : Q[0] - ie[0], be = "deltaY" in J ? J.deltaY : Q[1] - ie[1], Ie, Be = J.target, Ze = Math.abs(ue) > Math.abs(be) ? "h" : "v"; if ("touches" in J && Ze === "h" && Be.type === "range")
    return !1; var ot = rO(Ze, Be); if (!ot)
    return !0; if (ot ? Ie = Ze : (Ie = Ze === "v" ? "h" : "v", ot = rO(Ze, Be)), !ot)
    return !1; if (!u.current && "changedTouches" in J && (ue || be) && (u.current = Ie), !Ie)
    return !0; var At = u.current || Ie; return fY(At, ye, J, At === "h" ? ue : be, !0); }, []), k = ne.useCallback(function (J) { var ye = J; if (!(!gm.length || gm[gm.length - 1] !== y)) {
    var ie = "deltaY" in ye ? nO(ye) : F1(ye), Q = r.current.filter(function (Ie) { return Ie.name === ye.type && (Ie.target === ye.target || ye.target === Ie.shadowParent) && pY(Ie.delta, ie); })[0];
    if (Q && Q.should) {
        ye.cancelable && ye.preventDefault();
        return;
    }
    if (!Q) {
        var ue = (E.current.shards || []).map(iO).filter(Boolean).filter(function (Ie) { return Ie.contains(ye.target); }), be = ue.length > 0 ? s(ye, ue[0]) : !E.current.noIsolation;
        be && ye.cancelable && ye.preventDefault();
    }
} }, []), L = ne.useCallback(function (J, ye, ie, Q) { var ue = { name: J, delta: ye, target: ie, should: Q, shadowParent: yY(ie) }; r.current.push(ue), setTimeout(function () { r.current = r.current.filter(function (be) { return be !== ue; }); }, 1); }, []), N = ne.useCallback(function (J) { o.current = F1(J), u.current = void 0; }, []), V = ne.useCallback(function (J) { L(J.type, nO(J), J.target, s(J, t.lockRef.current)); }, []), H = ne.useCallback(function (J) { L(J.type, F1(J), J.target, s(J, t.lockRef.current)); }, []); ne.useEffect(function () { return gm.push(y), t.setCallbacks({ onScrollCapture: V, onWheelCapture: V, onTouchMoveCapture: H }), document.addEventListener("wheel", k, mm), document.addEventListener("touchmove", k, mm), document.addEventListener("touchstart", N, mm), function () { gm = gm.filter(function (J) { return J !== y; }), document.removeEventListener("wheel", k, mm), document.removeEventListener("touchmove", k, mm), document.removeEventListener("touchstart", N, mm); }; }, []); var ee = t.removeScrollBar, ce = t.inert; return ne.createElement(ne.Fragment, null, ce ? ne.createElement(y, { styles: mY(g) }) : null, ee ? ne.createElement(oY, { gapMode: t.gapMode }) : null); }
function yY(t) { for (var r = null; t !== null;)
    t instanceof ShadowRoot && (r = t.host, t = t.host), t = t.parentNode; return r; }
const vY = WK(bB, _Y);
var aI = ne.forwardRef(function (t, r) { return ne.createElement(jb, nc({}, t, { ref: r, sideCar: vY })); });
aI.classNames = jb.classNames;
var xY = function (t) { if (typeof document > "u")
    return null; var r = Array.isArray(t) ? t[0] : t; return r.ownerDocument.body; }, _m = new WeakMap, N1 = new WeakMap, B1 = {}, UE = 0, AB = function (t) { return t && (t.host || AB(t.parentNode)); }, wY = function (t, r) { return r.map(function (o) { if (t.contains(o))
    return o; var u = AB(o); return u && t.contains(u) ? u : (console.error("aria-hidden", o, "in not contained inside", t, ". Doing nothing"), null); }).filter(function (o) { return !!o; }); }, bY = function (t, r, o, u) { var g = wY(r, Array.isArray(t) ? t : [t]); B1[o] || (B1[o] = new WeakMap); var y = B1[o], E = [], s = new Set, k = new Set(g), L = function (V) { !V || s.has(V) || (s.add(V), L(V.parentNode)); }; g.forEach(L); var N = function (V) { !V || k.has(V) || Array.prototype.forEach.call(V.children, function (H) { if (s.has(H))
    N(H);
else
    try {
        var ee = H.getAttribute(u), ce = ee !== null && ee !== "false", J = (_m.get(H) || 0) + 1, ye = (y.get(H) || 0) + 1;
        _m.set(H, J), y.set(H, ye), E.push(H), J === 1 && ce && N1.set(H, !0), ye === 1 && H.setAttribute(o, "true"), ce || H.setAttribute(u, "true");
    }
    catch (ie) {
        console.error("aria-hidden: cannot operate on ", H, ie);
    } }); }; return N(r), s.clear(), UE++, function () { E.forEach(function (V) { var H = _m.get(V) - 1, ee = y.get(V) - 1; _m.set(V, H), y.set(V, ee), H || (N1.has(V) || V.removeAttribute(u), N1.delete(V)), ee || V.removeAttribute(o); }), UE--, UE || (_m = new WeakMap, _m = new WeakMap, N1 = new WeakMap, B1 = {}); }; }, IB = function (t, r, o) { o === void 0 && (o = "data-aria-hidden"); var u = Array.from(Array.isArray(t) ? t : [t]), g = xY(t); return g ? (u.push.apply(u, Array.from(g.querySelectorAll("[aria-live]"))), bY(u, g, o, "aria-hidden")) : function () { return null; }; }, lI = "Dialog", [PB, wee] = pc(lI), [TY, El] = PB(lI), MB = t => { const { __scopeDialog: r, children: o, open: u, defaultOpen: g, onOpenChange: y, modal: E = !0 } = t, s = ne.useRef(null), k = ne.useRef(null), [L = !1, N] = Cg({ prop: u, defaultProp: g, onChange: y }); return j.jsx(TY, { scope: r, triggerRef: s, contentRef: k, contentId: Sf(), titleId: Sf(), descriptionId: Sf(), open: L, onOpenChange: N, onOpenToggle: ne.useCallback(() => N(V => !V), [N]), modal: E, children: o }); };
MB.displayName = lI;
var RB = "DialogTrigger", SY = ne.forwardRef((t, r) => { const { __scopeDialog: o, ...u } = t, g = El(RB, o), y = is(r, g.triggerRef); return j.jsx(si.button, { type: "button", "aria-haspopup": "dialog", "aria-expanded": g.open, "aria-controls": g.contentId, "data-state": hI(g.open), ...u, ref: y, onClick: qr(t.onClick, g.onOpenToggle) }); });
SY.displayName = RB;
var cI = "DialogPortal", [EY, kB] = PB(cI, { forceMount: void 0 }), DB = t => { const { __scopeDialog: r, forceMount: o, children: u, container: g } = t, y = El(cI, r); return j.jsx(EY, { scope: r, forceMount: o, children: ne.Children.map(u, E => j.jsx(Va, { present: o || y.open, children: j.jsx(_b, { asChild: !0, container: g, children: E }) })) }); };
DB.displayName = cI;
var Kw = "DialogOverlay", LB = ne.forwardRef((t, r) => { const o = kB(Kw, t.__scopeDialog), { forceMount: u = o.forceMount, ...g } = t, y = El(Kw, t.__scopeDialog); return y.modal ? j.jsx(Va, { present: u || y.open, children: j.jsx(AY, { ...g, ref: r }) }) : null; });
LB.displayName = Kw;
var CY = fg("DialogOverlay.RemoveScroll"), AY = ne.forwardRef((t, r) => { const { __scopeDialog: o, ...u } = t, g = El(Kw, o); return j.jsx(aI, { as: CY, allowPinchZoom: !0, shards: [g.contentRef], children: j.jsx(si.div, { "data-state": hI(g.open), ...u, ref: r, style: { pointerEvents: "auto", ...u.style } }) }); }), Nf = "DialogContent", OB = ne.forwardRef((t, r) => { const o = kB(Nf, t.__scopeDialog), { forceMount: u = o.forceMount, ...g } = t, y = El(Nf, t.__scopeDialog); return j.jsx(Va, { present: u || y.open, children: y.modal ? j.jsx(IY, { ...g, ref: r }) : j.jsx(PY, { ...g, ref: r }) }); });
OB.displayName = Nf;
var IY = ne.forwardRef((t, r) => { const o = El(Nf, t.__scopeDialog), u = ne.useRef(null), g = is(r, o.contentRef, u); return ne.useEffect(() => { const y = u.current; if (y)
    return IB(y); }, []), j.jsx(zB, { ...t, ref: g, trapFocus: o.open, disableOutsidePointerEvents: !0, onCloseAutoFocus: qr(t.onCloseAutoFocus, y => { var E; y.preventDefault(), (E = o.triggerRef.current) == null || E.focus(); }), onPointerDownOutside: qr(t.onPointerDownOutside, y => { const E = y.detail.originalEvent, s = E.button === 0 && E.ctrlKey === !0; (E.button === 2 || s) && y.preventDefault(); }), onFocusOutside: qr(t.onFocusOutside, y => y.preventDefault()) }); }), PY = ne.forwardRef((t, r) => { const o = El(Nf, t.__scopeDialog), u = ne.useRef(!1), g = ne.useRef(!1); return j.jsx(zB, { ...t, ref: r, trapFocus: !1, disableOutsidePointerEvents: !1, onCloseAutoFocus: y => { var E, s; (E = t.onCloseAutoFocus) == null || E.call(t, y), y.defaultPrevented || (u.current || (s = o.triggerRef.current) == null || s.focus(), y.preventDefault()), u.current = !1, g.current = !1; }, onInteractOutside: y => { var k, L; (k = t.onInteractOutside) == null || k.call(t, y), y.defaultPrevented || (u.current = !0, y.detail.originalEvent.type === "pointerdown" && (g.current = !0)); const E = y.target; ((L = o.triggerRef.current) == null ? void 0 : L.contains(E)) && y.preventDefault(), y.detail.originalEvent.type === "focusin" && g.current && y.preventDefault(); } }); }), zB = ne.forwardRef((t, r) => { const { __scopeDialog: o, trapFocus: u, onOpenAutoFocus: g, onCloseAutoFocus: y, ...E } = t, s = El(Nf, o), k = ne.useRef(null), L = is(r, k); return vB(), j.jsxs(j.Fragment, { children: [j.jsx(oI, { asChild: !0, loop: !0, trapped: u, onMountAutoFocus: g, onUnmountAutoFocus: y, children: j.jsx(i0, { role: "dialog", id: s.contentId, "aria-describedby": s.descriptionId, "aria-labelledby": s.titleId, "data-state": hI(s.open), ...E, ref: L, onDismiss: () => s.onOpenChange(!1) }) }), j.jsxs(j.Fragment, { children: [j.jsx(MY, { titleId: s.titleId }), j.jsx(kY, { contentRef: k, descriptionId: s.descriptionId })] })] }); }), uI = "DialogTitle", FB = ne.forwardRef((t, r) => { const { __scopeDialog: o, ...u } = t, g = El(uI, o); return j.jsx(si.h2, { id: g.titleId, ...u, ref: r }); });
FB.displayName = uI;
var NB = "DialogDescription", BB = ne.forwardRef((t, r) => { const { __scopeDialog: o, ...u } = t, g = El(NB, o); return j.jsx(si.p, { id: g.descriptionId, ...u, ref: r }); });
BB.displayName = NB;
var jB = "DialogClose", VB = ne.forwardRef((t, r) => { const { __scopeDialog: o, ...u } = t, g = El(jB, o); return j.jsx(si.button, { type: "button", ...u, ref: r, onClick: qr(t.onClick, () => g.onOpenChange(!1)) }); });
VB.displayName = jB;
function hI(t) { return t ? "open" : "closed"; }
var UB = "DialogTitleWarning", [bee, $B] = xG(UB, { contentName: Nf, titleName: uI, docsSlug: "dialog" }), MY = ({ titleId: t }) => {
    const r = $B(UB), o = `\`${r.contentName}\` requires a \`${r.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${r.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${r.docsSlug}`;
    return ne.useEffect(() => { t && (document.getElementById(t) || console.error(o)); }, [o, t]), null;
}, RY = "DialogDescriptionWarning", kY = ({ contentRef: t, descriptionId: r }) => { const u = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${$B(RY).contentName}}.`; return ne.useEffect(() => { var y; const g = (y = t.current) == null ? void 0 : y.getAttribute("aria-describedby"); r && g && (document.getElementById(r) || console.warn(u)); }, [u, t, r]), null; }, DY = MB, LY = DB, GB = LB, qB = OB, HB = FB, WB = BB, OY = VB;
const dI = DY, zY = LY, ZB = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(GB, { ref: o, className: $n("fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", t), ...r }));
ZB.displayName = GB.displayName;
const Vb = ne.forwardRef(({ className: t, children: r, ...o }, u) => j.jsxs(zY, { children: [j.jsx(ZB, {}), j.jsxs(qB, { ref: u, className: $n("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg", t), ...o, children: [r, j.jsxs(OY, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground", children: [j.jsx(kF, { className: "h-4 w-4" }), j.jsx("span", { className: "sr-only", children: "Close" })] })] })] }));
Vb.displayName = qB.displayName;
const fI = ({ className: t, ...r }) => j.jsx("div", { className: $n("flex flex-col space-y-1.5 text-center sm:text-left", t), ...r });
fI.displayName = "DialogHeader";
const pI = ({ className: t, ...r }) => j.jsx("div", { className: $n("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", t), ...r });
pI.displayName = "DialogFooter";
const mI = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(HB, { ref: o, className: $n("text-lg font-semibold leading-none tracking-tight", t), ...r }));
mI.displayName = HB.displayName;
const gI = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(WB, { ref: o, className: $n("text-sm text-muted-foreground", t), ...r }));
gI.displayName = WB.displayName;
const Hs = ne.forwardRef(({ className: t, type: r, ...o }, u) => j.jsx("input", { type: r, className: $n("flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", t), ref: u, ...o }));
Hs.displayName = "Input";
var FY = "Label", XB = ne.forwardRef((t, r) => j.jsx(si.label, { ...t, ref: r, onMouseDown: o => { var g; o.target.closest("button, input, select, textarea") || ((g = t.onMouseDown) == null || g.call(t, o), !o.defaultPrevented && o.detail > 1 && o.preventDefault()); } }));
XB.displayName = FY;
var KB = XB;
const NY = wb("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"), za = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(KB, { ref: o, className: $n(NY(), t), ...r }));
za.displayName = KB.displayName;
const BY = zs.object({ title: zs.string().min(1, "Trip name is required"), startDate: zs.date({ required_error: "Start date is required" }), endDate: zs.date({ required_error: "End date is required" }), city: zs.string().min(1, "Please select a city"), cityLatitude: zs.string().optional(), cityLongitude: zs.string().optional() });
function jY({ isOpen: t, onClose: r, onSuccess: o, userId: u }) { const { toast: g } = fc(), { geocodeLocation: y } = sI(), E = new Date, s = new Date; s.setDate(E.getDate() + 3); const k = { title: "New Trip", startDate: E, endDate: s, city: "", cityLatitude: "", cityLongitude: "" }, { register: L, handleSubmit: N, setValue: V, watch: H, formState: { errors: ee } } = Fb({ resolver: Nb(BY), defaultValues: k }), ce = H("city"); ne.useEffect(() => { if (ce && ce.length > 3) {
    const ie = setTimeout(async () => { try {
        const Q = await y(ce);
        Q && (V("cityLatitude", Q.latitude.toString()), V("cityLongitude", Q.longitude.toString()), g({ title: "City found", description: Q.fullAddress, duration: 2e3 }));
    }
    catch (Q) {
        console.error("Error geocoding city:", Q);
    } }, 800);
    return () => clearTimeout(ie);
} }, [ce, y, V, g]); const J = uo({ mutationFn: async (ie) => { const Q = { title: ie.title, startDate: ie.startDate.toISOString(), endDate: ie.endDate.toISOString(), userId: u, city: ie.city, location: ie.city, collaborators: [] }; return console.log("Creating trip with data:", Q), (await Es("POST", En.TRIPS, Q)).json(); }, onSuccess: ie => { g({ title: "Trip created", description: "Your new trip has been created successfully." }), o(ie.id); }, onError: ie => { g({ title: "Error", description: "Could not create trip. Please try again.", variant: "destructive" }), console.error("Error creating trip:", ie); } }), ye = ie => { J.mutate(ie); }; return j.jsx(dI, { open: t, onOpenChange: r, children: j.jsxs(Vb, { className: "sm:max-w-[425px]", children: [j.jsxs(fI, { children: [j.jsx(mI, { children: "Create New Trip" }), j.jsx(gI, { children: "Enter your trip details to get started with planning." })] }), j.jsxs("form", { onSubmit: N(ye), children: [j.jsxs("div", { className: "grid gap-4 py-4", children: [j.jsxs("div", { className: "grid gap-2", children: [j.jsx(za, { htmlFor: "title", children: "Trip Name" }), j.jsx(Hs, { id: "title", ...L("title"), placeholder: "e.g., Summer Vacation" }), ee.title && j.jsx("p", { className: "text-xs text-[hsl(var(--destructive))]", children: ee.title.message })] }), j.jsxs("div", { className: "grid gap-2", children: [j.jsx(za, { htmlFor: "city", children: "Destination City" }), j.jsx(Hs, { id: "city", ...L("city"), placeholder: "e.g., New York, Paris, Tokyo" }), ee.city && j.jsx("p", { className: "text-xs text-[hsl(var(--destructive))]", children: ee.city.message }), j.jsx("p", { className: "text-xs text-[hsl(var(--muted-foreground))]", children: "Enter your main destination city to center your trip map" })] }), j.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [j.jsxs("div", { className: "grid gap-2", children: [j.jsx(za, { htmlFor: "startDate", children: "Start Date" }), j.jsx(Hs, { id: "startDate", type: "date", ...L("startDate", { valueAsDate: !0 }), defaultValue: Xw(E, "yyyy-MM-dd") }), ee.startDate && j.jsx("p", { className: "text-xs text-[hsl(var(--destructive))]", children: ee.startDate.message })] }), j.jsxs("div", { className: "grid gap-2", children: [j.jsx(za, { htmlFor: "endDate", children: "End Date" }), j.jsx(Hs, { id: "endDate", type: "date", ...L("endDate", { valueAsDate: !0 }), defaultValue: Xw(s, "yyyy-MM-dd") }), ee.endDate && j.jsx("p", { className: "text-xs text-[hsl(var(--destructive))]", children: ee.endDate.message })] })] })] }), j.jsxs(pI, { children: [j.jsx(ci, { type: "button", variant: "outline", onClick: r, disabled: J.isPending, children: "Cancel" }), j.jsx(ci, { type: "submit", disabled: J.isPending, children: J.isPending ? "Creating..." : "Create Trip" })] })] })] }) }); }
const VY = "Left", UY = "Right", $Y = "Up", GY = "Down", Dm = { delta: 10, preventScrollOnSwipe: !1, rotationAngle: 0, trackMouse: !1, trackTouch: !0, swipeDuration: 1 / 0, touchEventOptions: { passive: !0 } }, xC = { first: !0, initial: [0, 0], start: 0, swiping: !1, xy: [0, 0] }, sO = "mousemove", oO = "mouseup", qY = "touchend", HY = "touchmove", WY = "touchstart";
function ZY(t, r, o, u) { return t > r ? o > 0 ? UY : VY : u > 0 ? GY : $Y; }
function aO(t, r) { if (r === 0)
    return t; const o = Math.PI / 180 * r, u = t[0] * Math.cos(o) + t[1] * Math.sin(o), g = t[1] * Math.cos(o) - t[0] * Math.sin(o); return [u, g]; }
function XY(t, r) { const o = N => { const V = "touches" in N; V && N.touches.length > 1 || t((H, ee) => { ee.trackMouse && !V && (document.addEventListener(sO, u), document.addEventListener(oO, E)); const { clientX: ce, clientY: J } = V ? N.touches[0] : N, ye = aO([ce, J], ee.rotationAngle); return ee.onTouchStartOrOnMouseDown && ee.onTouchStartOrOnMouseDown({ event: N }), Object.assign(Object.assign(Object.assign({}, H), xC), { initial: ye.slice(), xy: ye, start: N.timeStamp || 0 }); }); }, u = N => { t((V, H) => { const ee = "touches" in N; if (ee && N.touches.length > 1)
    return V; if (N.timeStamp - V.start > H.swipeDuration)
    return V.swiping ? Object.assign(Object.assign({}, V), { swiping: !1 }) : V; const { clientX: ce, clientY: J } = ee ? N.touches[0] : N, [ye, ie] = aO([ce, J], H.rotationAngle), Q = ye - V.xy[0], ue = ie - V.xy[1], be = Math.abs(Q), Ie = Math.abs(ue), Be = (N.timeStamp || 0) - V.start, Ze = Math.sqrt(be * be + Ie * Ie) / (Be || 1), ot = [Q / (Be || 1), ue / (Be || 1)], At = ZY(be, Ie, Q, ue), kt = typeof H.delta == "number" ? H.delta : H.delta[At.toLowerCase()] || Dm.delta; if (be < kt && Ie < kt && !V.swiping)
    return V; const ct = { absX: be, absY: Ie, deltaX: Q, deltaY: ue, dir: At, event: N, first: V.first, initial: V.initial, velocity: Ze, vxvy: ot }; ct.first && H.onSwipeStart && H.onSwipeStart(ct), H.onSwiping && H.onSwiping(ct); let St = !1; return (H.onSwiping || H.onSwiped || H[`onSwiped${At}`]) && (St = !0), St && H.preventScrollOnSwipe && H.trackTouch && N.cancelable && N.preventDefault(), Object.assign(Object.assign({}, V), { first: !1, eventData: ct, swiping: !0 }); }); }, g = N => { t((V, H) => { let ee; if (V.swiping && V.eventData) {
    if (N.timeStamp - V.start < H.swipeDuration) {
        ee = Object.assign(Object.assign({}, V.eventData), { event: N }), H.onSwiped && H.onSwiped(ee);
        const ce = H[`onSwiped${ee.dir}`];
        ce && ce(ee);
    }
}
else
    H.onTap && H.onTap({ event: N }); return H.onTouchEndOrOnMouseUp && H.onTouchEndOrOnMouseUp({ event: N }), Object.assign(Object.assign(Object.assign({}, V), xC), { eventData: ee }); }); }, y = () => { document.removeEventListener(sO, u), document.removeEventListener(oO, E); }, E = N => { y(), g(N); }, s = (N, V) => { let H = () => { }; if (N && N.addEventListener) {
    const ee = Object.assign(Object.assign({}, Dm.touchEventOptions), V.touchEventOptions), ce = [[WY, o, ee], [HY, u, Object.assign(Object.assign({}, ee), V.preventScrollOnSwipe ? { passive: !1 } : {})], [qY, g, ee]];
    ce.forEach(([J, ye, ie]) => N.addEventListener(J, ye, ie)), H = () => ce.forEach(([J, ye]) => N.removeEventListener(J, ye));
} return H; }, L = { ref: N => { N !== null && t((V, H) => { if (V.el === N)
        return V; const ee = {}; return V.el && V.el !== N && V.cleanUpTouch && (V.cleanUpTouch(), ee.cleanUpTouch = void 0), H.trackTouch && N && (ee.cleanUpTouch = s(N, H)), Object.assign(Object.assign(Object.assign({}, V), { el: N }), ee); }); } }; return r.trackMouse && (L.onMouseDown = o), [L, s]; }
function KY(t, r, o, u) { return !r.trackTouch || !t.el ? (t.cleanUpTouch && t.cleanUpTouch(), Object.assign(Object.assign({}, t), { cleanUpTouch: void 0 })) : t.cleanUpTouch ? r.preventScrollOnSwipe !== o.preventScrollOnSwipe || r.touchEventOptions.passive !== o.touchEventOptions.passive ? (t.cleanUpTouch(), Object.assign(Object.assign({}, t), { cleanUpTouch: u(t.el, r) })) : t : Object.assign(Object.assign({}, t), { cleanUpTouch: u(t.el, r) }); }
function YY(t) { const { trackMouse: r } = t, o = ne.useRef(Object.assign({}, xC)), u = ne.useRef(Object.assign({}, Dm)), g = ne.useRef(Object.assign({}, u.current)); g.current = Object.assign({}, u.current), u.current = Object.assign(Object.assign({}, Dm), t); let y; for (y in Dm)
    u.current[y] === void 0 && (u.current[y] = Dm[y]); const [E, s] = ne.useMemo(() => XY(k => o.current = k(o.current, u.current), { trackMouse: r }), [r]); return o.current = KY(o.current, u.current, g.current, s), E; }
function QY({ trip: t, onNavigate: r, onRename: o }) { const { toast: u } = fc(), g = n0(), [y, E] = ne.useState(!1), [s, k] = ne.useState(!1), [L, N] = ne.useState(!1), V = ne.useRef(null), H = 300, ee = uo({ mutationFn: async () => { if (!(await Es("DELETE", `${En.TRIPS}/${t.id}`)).ok)
        throw new Error("Failed to delete trip"); return !0; }, onSuccess: () => { g.invalidateQueries({ queryKey: [En.TRIPS] }), u({ title: "Trip deleted", description: "Your trip has been deleted successfully." }), E(!1), k(!1); }, onError: ue => { u({ title: "Error", description: "Failed to delete trip. Please try again.", variant: "destructive" }), E(!1), k(!1); } }), ce = YY({ onSwipedLeft: () => { k(!0); }, onSwipedRight: () => { k(!1); }, trackMouse: !0 }), J = () => { s || (V.current = setTimeout(() => { N(!0), o(t); }, H)); }, ye = () => { V.current && (clearTimeout(V.current), V.current = null), !L && !s && r(t.id), L && N(!1); }, ie = () => { V.current && (clearTimeout(V.current), V.current = null); }; ne.useEffect(() => () => { V.current && clearTimeout(V.current); }, []), ne.useEffect(() => { const ue = () => { s && k(!1); }; return document.addEventListener("click", ue), () => { document.removeEventListener("click", ue); }; }, [s]); const Q = ue => { ue.stopPropagation(), window.confirm(`Are you sure you want to delete "${t.title}"?`) && (E(!0), ee.mutate()); }; return j.jsxs("div", { className: "relative overflow-hidden rounded-md", ...ce, children: [j.jsx("div", { className: `absolute inset-y-0 right-0 flex items-center transition-transform duration-200 ease-out ${s ? "transform translate-x-0" : "transform translate-x-full"}`, style: { width: "70px" }, children: j.jsx(ci, { variant: "destructive", size: "icon", className: "h-full w-full rounded-none", onClick: Q, disabled: y, children: y ? j.jsx("div", { className: "h-5 w-5 animate-spin rounded-full border-2 border-white border-t-transparent" }) : j.jsx(_q, { className: "h-5 w-5" }) }) }), j.jsx("div", { className: `transition-transform duration-200 ease-out ${s ? "transform -translate-x-[70px]" : "transform translate-x-0"}`, children: j.jsx(Vh, { className: `cursor-pointer hover:shadow-md transition-shadow ${L ? "bg-[hsl(var(--muted))]" : ""}`, onMouseDown: J, onMouseUp: ye, onMouseMove: ie, onTouchStart: J, onTouchEnd: ye, onTouchMove: ie, children: j.jsx(Uh, { className: "p-4", children: j.jsxs("div", { className: "flex justify-between items-start", children: [j.jsxs("div", { children: [j.jsx("h3", { className: "font-medium text-lg", children: t.title }), j.jsxs("p", { className: "text-sm text-[hsl(var(--muted-foreground))]", children: [Xw(new Date(t.startDate), "MMM d"), " - ", Xw(new Date(t.endDate), "MMM d, yyyy")] })] }), j.jsx("div", { className: "text-[hsl(var(--muted-foreground))] opacity-50", children: j.jsx(gq, { size: 16 }) })] }) }) }) })] }); }
function JY({ isOpen: t, onClose: r, trip: o }) { const { toast: u } = fc(), g = n0(), [y, E] = ne.useState(""), s = ne.useRef(!1); o && t && !s.current && (E(o.title), s.current = !0), !t && s.current && (s.current = !1); const k = uo({ mutationFn: async () => { if (!o)
        throw new Error("No trip to rename"); const N = await Es("PUT", `${En.TRIPS}/${o.id}`, { title: y }); if (!N.ok)
        throw new Error("Failed to rename trip"); return await N.json(); }, onSuccess: () => { g.invalidateQueries({ queryKey: [En.TRIPS] }), u({ title: "Trip renamed", description: "Your trip has been renamed successfully." }), r(); }, onError: N => { u({ title: "Error", description: "Failed to rename trip. Please try again.", variant: "destructive" }); } }), L = N => { N.preventDefault(), y.trim() && k.mutate(); }; return j.jsx(dI, { open: t, onOpenChange: r, children: j.jsxs(Vb, { className: "sm:max-w-[425px]", children: [j.jsxs(fI, { children: [j.jsx(mI, { children: "Rename Trip" }), j.jsx(gI, { children: "Enter a new name for your trip." })] }), j.jsxs("form", { onSubmit: L, children: [j.jsx("div", { className: "grid gap-4 py-4", children: j.jsxs("div", { className: "grid gap-2", children: [j.jsx(za, { htmlFor: "title", children: "Trip Name" }), j.jsx(Hs, { id: "title", value: y, onChange: N => E(N.target.value), autoComplete: "off" })] }) }), j.jsxs(pI, { children: [j.jsx(ci, { type: "button", variant: "outline", onClick: r, disabled: k.isPending, children: "Cancel" }), j.jsx(ci, { type: "submit", disabled: k.isPending || !y.trim(), children: k.isPending ? "Renaming..." : "Rename Trip" })] })] })] }) }); }
const eQ = wb("relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground", { variants: { variant: { default: "bg-background text-foreground", destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive" } }, defaultVariants: { variant: "default" } }), _I = ne.forwardRef(({ className: t, variant: r, ...o }, u) => j.jsx("div", { ref: u, role: "alert", className: $n(eQ({ variant: r }), t), ...o }));
_I.displayName = "Alert";
const tQ = ne.forwardRef(({ className: t, ...r }, o) => j.jsx("h5", { ref: o, className: $n("mb-1 font-medium leading-none tracking-tight", t), ...r }));
tQ.displayName = "AlertTitle";
const yI = ne.forwardRef(({ className: t, ...r }, o) => j.jsx("div", { ref: o, className: $n("text-sm [&_p]:leading-relaxed", t), ...r }));
yI.displayName = "AlertDescription";
const rQ = eI({ email: kh().email({ message: "Please enter a valid email address" }), password: kh().min(6, { message: "Password must be at least 6 characters" }) });
function nQ({ onSuccess: t, onToggleForm: r }) { const { signIn: o } = ZA(), [u, g] = ne.useState(!1), [y, E] = ne.useState(""), s = Fb({ resolver: Nb(rQ), defaultValues: { email: "", password: "" } }), k = async (L) => { try {
    g(!0), E(""), await o(L.email, L.password), t && t();
}
catch (N) {
    E(N.message || "Failed to sign in. Please try again.");
}
finally {
    g(!1);
} }; return j.jsxs(Vh, { className: "w-full max-w-md mx-auto", children: [j.jsxs(XA, { children: [j.jsx(KA, { className: "text-2xl", children: "Sign In" }), j.jsx(YA, { children: "Enter your credentials to access your trips" })] }), j.jsxs("form", { onSubmit: s.handleSubmit(k), children: [j.jsxs(Uh, { className: "space-y-4", children: [y && j.jsxs(_I, { variant: "destructive", children: [j.jsx(RA, { className: "h-4 w-4" }), j.jsx(yI, { children: y })] }), j.jsxs("div", { className: "space-y-2", children: [j.jsx(za, { htmlFor: "email", children: "Email" }), j.jsx(Hs, { id: "email", type: "email", placeholder: "your.email@example.com", ...s.register("email") }), s.formState.errors.email && j.jsx("p", { className: "text-sm text-destructive", children: s.formState.errors.email.message })] }), j.jsxs("div", { className: "space-y-2", children: [j.jsxs("div", { className: "flex items-center justify-between", children: [j.jsx(za, { htmlFor: "password", children: "Password" }), j.jsx("button", { type: "button", className: "text-sm font-medium text-primary hover:underline", onClick: () => { }, children: "Forgot password?" })] }), j.jsx(Hs, { id: "password", type: "password", ...s.register("password") }), s.formState.errors.password && j.jsx("p", { className: "text-sm text-destructive", children: s.formState.errors.password.message })] })] }), j.jsxs(QA, { className: "flex flex-col space-y-4", children: [j.jsx(ci, { type: "submit", className: "w-full", disabled: u, children: u ? "Signing in..." : "Sign In" }), j.jsxs("div", { className: "text-center text-sm", children: [j.jsx("span", { className: "text-muted-foreground", children: "Don't have an account? " }), j.jsx("button", { type: "button", className: "font-medium text-primary hover:underline", onClick: r, children: "Sign Up" })] })] })] })] }); }
const iQ = eI({ email: kh().email({ message: "Please enter a valid email address" }), name: kh().min(2, { message: "Name must be at least 2 characters" }), password: kh().min(6, { message: "Password must be at least 6 characters" }), passwordConfirm: kh().min(6, { message: "Password must be at least 6 characters" }) }).refine(t => t.password === t.passwordConfirm, { message: "Passwords do not match", path: ["passwordConfirm"] });
function sQ({ onSuccess: t, onToggleForm: r }) { const { signUp: o } = ZA(), [u, g] = ne.useState(!1), [y, E] = ne.useState(""), s = Fb({ resolver: Nb(iQ), defaultValues: { email: "", name: "", password: "", passwordConfirm: "" } }), k = async (L) => { try {
    g(!0), E(""), await o(L.email, L.password, { display_name: L.name }), t && t();
}
catch (N) {
    E(N.message || "Failed to sign up. Please try again.");
}
finally {
    g(!1);
} }; return j.jsxs(Vh, { className: "w-full max-w-md mx-auto", children: [j.jsxs(XA, { children: [j.jsx(KA, { className: "text-2xl", children: "Create Account" }), j.jsx(YA, { children: "Sign up to start planning your trips" })] }), j.jsxs("form", { onSubmit: s.handleSubmit(k), children: [j.jsxs(Uh, { className: "space-y-4", children: [y && j.jsxs(_I, { variant: "destructive", children: [j.jsx(RA, { className: "h-4 w-4" }), j.jsx(yI, { children: y })] }), j.jsxs("div", { className: "space-y-2", children: [j.jsx(za, { htmlFor: "email", children: "Email" }), j.jsx(Hs, { id: "email", type: "email", placeholder: "your.email@example.com", ...s.register("email") }), s.formState.errors.email && j.jsx("p", { className: "text-sm text-destructive", children: s.formState.errors.email.message })] }), j.jsxs("div", { className: "space-y-2", children: [j.jsx(za, { htmlFor: "name", children: "Full Name" }), j.jsx(Hs, { id: "name", type: "text", placeholder: "Your Name", ...s.register("name") }), s.formState.errors.name && j.jsx("p", { className: "text-sm text-destructive", children: s.formState.errors.name.message })] }), j.jsxs("div", { className: "space-y-2", children: [j.jsx(za, { htmlFor: "password", children: "Password" }), j.jsx(Hs, { id: "password", type: "password", ...s.register("password") }), s.formState.errors.password && j.jsx("p", { className: "text-sm text-destructive", children: s.formState.errors.password.message })] }), j.jsxs("div", { className: "space-y-2", children: [j.jsx(za, { htmlFor: "passwordConfirm", children: "Confirm Password" }), j.jsx(Hs, { id: "passwordConfirm", type: "password", ...s.register("passwordConfirm") }), s.formState.errors.passwordConfirm && j.jsx("p", { className: "text-sm text-destructive", children: s.formState.errors.passwordConfirm.message })] })] }), j.jsxs(QA, { className: "flex flex-col space-y-4", children: [j.jsx(ci, { type: "submit", className: "w-full", disabled: u, children: u ? "Creating Account..." : "Create Account" }), j.jsxs("div", { className: "text-center text-sm", children: [j.jsx("span", { className: "text-muted-foreground", children: "Already have an account? " }), j.jsx("button", { type: "button", className: "font-medium text-primary hover:underline", onClick: r, children: "Sign In" })] })] })] })] }); }
function oQ({ isOpen: t, onClose: r, defaultView: o = "login", onSuccess: u }) { const [g, y] = ne.useState(o), E = () => { u && u(), r(); }, s = () => { y(g === "login" ? "signup" : "login"); }; return j.jsx(dI, { open: t, onOpenChange: k => { k || r(); }, children: j.jsx(Vb, { className: "sm:max-w-md md:max-w-lg p-0 bg-transparent border-none shadow-none", children: g === "login" ? j.jsx(nQ, { onSuccess: E, onToggleForm: s }) : j.jsx(sQ, { onSuccess: E, onToggleForm: s }) }) }); }
function aQ() { var At; const [, t] = xA(), [r, o] = ne.useState(!1), [u, g] = ne.useState(!1), [y, E] = ne.useState(null), [s, k] = ne.useState(!1), [L, N] = ne.useState("login"), { user: V, signOut: H } = ZA(), ee = n0(), ce = V ? Number(V.id) : 1, { data: J = [], isLoading: ye } = nv({ queryKey: [En.TRIPS, { userId: ce }], queryFn: async () => { const kt = await fetch(`${En.TRIPS}?userId=${ce}`); if (!kt.ok)
        throw new Error("Failed to fetch trips"); return kt.json(); }, enabled: !!ce }), ie = () => { if (!V) {
    N("signup"), k(!0);
    return;
} o(!0); }, Q = kt => { o(!1), t(`/trip/${kt}`); }, ue = kt => { t(`/trip/${kt}`); }, be = kt => { E(kt), g(!0); }, Ie = () => { g(!1), E(null); }, Be = () => { N("login"), k(!0); }, Ze = () => { N("signup"), k(!0); }, ot = async () => { await H(), ee.invalidateQueries({ queryKey: [En.TRIPS] }); }; return j.jsxs("div", { className: "min-h-screen bg-[hsl(var(--background))]", children: [j.jsx(jY, { isOpen: r, onClose: () => o(!1), onSuccess: Q, userId: ce }), j.jsx(oQ, { isOpen: s, onClose: () => k(!1), defaultView: L, onSuccess: () => { k(!1), ee.invalidateQueries({ queryKey: [En.TRIPS] }); } }), j.jsx("header", { className: "bg-white dark:bg-[hsl(var(--card))] shadow-sm", children: j.jsx("div", { className: "container mx-auto px-4 py-4", children: j.jsxs("div", { className: "flex items-center justify-between", children: [j.jsxs("div", { className: "flex items-center", children: [j.jsx("div", { className: "h-10 w-10 bg-[hsl(var(--secondary))] rounded-full flex items-center justify-center", children: j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6 text-[hsl(var(--foreground))]", viewBox: "0 0 20 20", fill: "currentColor", children: j.jsx("path", { fillRule: "evenodd", d: "M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z", clipRule: "evenodd" }) }) }), j.jsxs("div", { className: "ml-3", children: [j.jsx("h1", { className: "text-2xl font-bold", children: "NestMap" }), j.jsx("p", { className: "text-sm text-[hsl(var(--muted-foreground))]", children: "Plan. Pin. Wander." })] })] }), j.jsx("div", { className: "flex items-center space-x-2", children: V ? j.jsxs("div", { className: "flex items-center", children: [j.jsxs("div", { className: "mr-3 text-right hidden sm:block", children: [j.jsx("p", { className: "font-medium", children: ((At = V.user_metadata) == null ? void 0 : At.display_name) || V.email }), j.jsx("p", { className: "text-xs text-[hsl(var(--muted-foreground))]", children: "Signed in" })] }), j.jsx("div", { className: "flex space-x-2", children: j.jsx(ci, { variant: "ghost", size: "icon", className: "rounded-full", onClick: ot, title: "Sign Out", children: j.jsx(pq, { className: "h-5 w-5" }) }) })] }) : j.jsxs("div", { className: "flex items-center space-x-2", children: [j.jsx(ci, { variant: "ghost", onClick: Be, children: "Sign In" }), j.jsx(ci, { variant: "default", onClick: Ze, className: "bg-[hsl(var(--primary))] hover:bg-[hsl(var(--primary))]", children: "Sign Up" })] }) })] }) }) }), j.jsx("main", { className: "container mx-auto px-4 py-8", children: j.jsxs("div", { className: "max-w-3xl mx-auto", children: [j.jsxs("section", { className: "mb-8", children: [j.jsxs("div", { className: "flex justify-between items-center mb-6", children: [j.jsx("h2", { className: "text-xl font-semibold", children: "Welcome to NestMap" }), j.jsx(ci, { onClick: ie, className: "bg-[hsl(var(--primary))] hover:bg-[hsl(var(--primary))]", children: "New Trip" })] }), j.jsx(Vh, { children: j.jsxs(Uh, { className: "pt-6", children: [j.jsx("h3", { className: "text-lg font-medium mb-2", children: "Your Trip Planner" }), j.jsx("p", { className: "text-[hsl(var(--muted-foreground))] mb-4", children: "Create collaborative trip itineraries with time-blocked activities, map visualizations, and AI-powered suggestions." }), j.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [j.jsxs("div", { className: "flex items-start", children: [j.jsx("div", { className: "h-8 w-8 bg-[hsl(var(--primary))] text-white rounded-full flex items-center justify-center mr-3 mt-0.5", children: "1" }), j.jsxs("div", { children: [j.jsx("h4", { className: "font-medium", children: "Plan Your Itinerary" }), j.jsx("p", { className: "text-sm text-[hsl(var(--muted-foreground))]", children: "Create a daily schedule with locations automatically pinned on the map." })] })] }), j.jsxs("div", { className: "flex items-start", children: [j.jsx("div", { className: "h-8 w-8 bg-[hsl(var(--primary))] text-white rounded-full flex items-center justify-center mr-3 mt-0.5", children: "2" }), j.jsxs("div", { children: [j.jsx("h4", { className: "font-medium", children: "See Travel Times" }), j.jsx("p", { className: "text-sm text-[hsl(var(--muted-foreground))]", children: "Automatically calculate distances and travel times between stops." })] })] }), j.jsxs("div", { className: "flex items-start", children: [j.jsx("div", { className: "h-8 w-8 bg-[hsl(var(--primary))] text-white rounded-full flex items-center justify-center mr-3 mt-0.5", children: "3" }), j.jsxs("div", { children: [j.jsx("h4", { className: "font-medium", children: "Get AI Suggestions" }), j.jsx("p", { className: "text-sm text-[hsl(var(--muted-foreground))]", children: "Find nearby restaurants, detect schedule conflicts, and get themed itinerary ideas." })] })] }), j.jsxs("div", { className: "flex items-start", children: [j.jsx("div", { className: "h-8 w-8 bg-[hsl(var(--primary))] text-white rounded-full flex items-center justify-center mr-3 mt-0.5", children: "4" }), j.jsxs("div", { children: [j.jsx("h4", { className: "font-medium", children: "Collaborate" }), j.jsx("p", { className: "text-sm text-[hsl(var(--muted-foreground))]", children: "Share and edit trips with friends and family." })] })] })] })] }) })] }), j.jsxs("section", { children: [j.jsx("h2", { className: "text-xl font-semibold mb-4", children: "Your Trips" }), ye ? j.jsxs("div", { className: "text-center py-8", children: [j.jsx("div", { className: "animate-spin h-8 w-8 border-4 border-[hsl(var(--primary))] border-t-transparent rounded-full mx-auto mb-4" }), j.jsx("p", { children: "Loading your trips..." })] }) : J.length === 0 ? j.jsx(Vh, { children: j.jsxs(Uh, { className: "py-8 text-center", children: [j.jsx("div", { className: "mb-4", children: j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-12 w-12 mx-auto text-[hsl(var(--muted-foreground))]", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" }) }) }), j.jsx("h3", { className: "text-lg font-medium mb-2", children: "No trips yet" }), j.jsx("p", { className: "text-[hsl(var(--muted-foreground))] mb-4", children: "Create your first trip to get started." }), j.jsx(ci, { onClick: ie, children: "Create New Trip" })] }) }) : j.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [J.map(kt => j.jsx(QY, { trip: kt, onNavigate: ue, onRename: be }, kt.id)), j.jsx(JY, { isOpen: u, onClose: Ie, trip: y }), j.jsx(Vh, { className: "border-dashed cursor-pointer hover:bg-[hsl(var(--muted))] transition-colors", onClick: ie, children: j.jsx(Uh, { className: "p-4 flex items-center justify-center h-full", children: j.jsxs("div", { className: "text-center py-4", children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6 mx-auto mb-2 text-[hsl(var(--primary))]", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 4v16m8-8H4" }) }), j.jsx("span", { className: "text-[hsl(var(--primary))]", children: "New Trip" })] }) }) })] })] })] }) })] }); }
var lQ = ne.createContext(void 0);
function vI(t) { const r = ne.useContext(lQ); return t || r || "ltr"; }
var $E = "rovingFocusGroup.onEntryFocus", cQ = { bubbles: !1, cancelable: !0 }, Ub = "RovingFocusGroup", [wC, YB, uQ] = CA(Ub), [hQ, $b] = pc(Ub, [uQ]), [dQ, fQ] = hQ(Ub), QB = ne.forwardRef((t, r) => j.jsx(wC.Provider, { scope: t.__scopeRovingFocusGroup, children: j.jsx(wC.Slot, { scope: t.__scopeRovingFocusGroup, children: j.jsx(pQ, { ...t, ref: r }) }) }));
QB.displayName = Ub;
var pQ = ne.forwardRef((t, r) => { const { __scopeRovingFocusGroup: o, orientation: u, loop: g = !1, dir: y, currentTabStopId: E, defaultCurrentTabStopId: s, onCurrentTabStopIdChange: k, onEntryFocus: L, preventScrollOnEntryFocus: N = !1, ...V } = t, H = ne.useRef(null), ee = is(r, H), ce = vI(y), [J = null, ye] = Cg({ prop: E, defaultProp: s, onChange: k }), [ie, Q] = ne.useState(!1), ue = To(L), be = YB(o), Ie = ne.useRef(!1), [Be, Ze] = ne.useState(0); return ne.useEffect(() => { const ot = H.current; if (ot)
    return ot.addEventListener($E, ue), () => ot.removeEventListener($E, ue); }, [ue]), j.jsx(dQ, { scope: o, orientation: u, dir: ce, loop: g, currentTabStopId: J, onItemFocus: ne.useCallback(ot => ye(ot), [ye]), onItemShiftTab: ne.useCallback(() => Q(!0), []), onFocusableItemAdd: ne.useCallback(() => Ze(ot => ot + 1), []), onFocusableItemRemove: ne.useCallback(() => Ze(ot => ot - 1), []), children: j.jsx(si.div, { tabIndex: ie || Be === 0 ? -1 : 0, "data-orientation": u, ...V, ref: ee, style: { outline: "none", ...t.style }, onMouseDown: qr(t.onMouseDown, () => { Ie.current = !0; }), onFocus: qr(t.onFocus, ot => { const At = !Ie.current; if (ot.target === ot.currentTarget && At && !ie) {
            const kt = new CustomEvent($E, cQ);
            if (ot.currentTarget.dispatchEvent(kt), !kt.defaultPrevented) {
                const ct = be().filter(tr => tr.focusable), St = ct.find(tr => tr.active), Kt = ct.find(tr => tr.id === J), ir = [St, Kt, ...ct].filter(Boolean).map(tr => tr.ref.current);
                tj(ir, N);
            }
        } Ie.current = !1; }), onBlur: qr(t.onBlur, () => Q(!1)) }) }); }), JB = "RovingFocusGroupItem", ej = ne.forwardRef((t, r) => { const { __scopeRovingFocusGroup: o, focusable: u = !0, active: g = !1, tabStopId: y, ...E } = t, s = Sf(), k = y || s, L = fQ(JB, o), N = L.currentTabStopId === k, V = YB(o), { onFocusableItemAdd: H, onFocusableItemRemove: ee } = L; return ne.useEffect(() => { if (u)
    return H(), () => ee(); }, [u, H, ee]), j.jsx(wC.ItemSlot, { scope: o, id: k, focusable: u, active: g, children: j.jsx(si.span, { tabIndex: N ? 0 : -1, "data-orientation": L.orientation, ...E, ref: r, onMouseDown: qr(t.onMouseDown, ce => { u ? L.onItemFocus(k) : ce.preventDefault(); }), onFocus: qr(t.onFocus, () => L.onItemFocus(k)), onKeyDown: qr(t.onKeyDown, ce => { if (ce.key === "Tab" && ce.shiftKey) {
            L.onItemShiftTab();
            return;
        } if (ce.target !== ce.currentTarget)
            return; const J = _Q(ce, L.orientation, L.dir); if (J !== void 0) {
            if (ce.metaKey || ce.ctrlKey || ce.altKey || ce.shiftKey)
                return;
            ce.preventDefault();
            let ie = V().filter(Q => Q.focusable).map(Q => Q.ref.current);
            if (J === "last")
                ie.reverse();
            else if (J === "prev" || J === "next") {
                J === "prev" && ie.reverse();
                const Q = ie.indexOf(ce.currentTarget);
                ie = L.loop ? yQ(ie, Q + 1) : ie.slice(Q + 1);
            }
            setTimeout(() => tj(ie));
        } }) }) }); });
ej.displayName = JB;
var mQ = { ArrowLeft: "prev", ArrowUp: "prev", ArrowRight: "next", ArrowDown: "next", PageUp: "first", Home: "first", PageDown: "last", End: "last" };
function gQ(t, r) { return r !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t; }
function _Q(t, r, o) { const u = gQ(t.key, o); if (!(r === "vertical" && ["ArrowLeft", "ArrowRight"].includes(u)) && !(r === "horizontal" && ["ArrowUp", "ArrowDown"].includes(u)))
    return mQ[u]; }
function tj(t, r = !1) { const o = document.activeElement; for (const u of t)
    if (u === o || (u.focus({ preventScroll: r }), document.activeElement !== o))
        return; }
function yQ(t, r) { return t.map((o, u) => t[(r + u) % t.length]); }
var rj = QB, nj = ej, bC = ["Enter", " "], vQ = ["ArrowDown", "PageUp", "Home"], ij = ["ArrowUp", "PageDown", "End"], xQ = [...vQ, ...ij], wQ = { ltr: [...bC, "ArrowRight"], rtl: [...bC, "ArrowLeft"] }, bQ = { ltr: ["ArrowLeft"], rtl: ["ArrowRight"] }, u0 = "Menu", [qv, TQ, SQ] = CA(u0), [Uf, sj] = pc(u0, [SQ, Eb, $b]), Gb = Eb(), oj = $b(), [EQ, $f] = Uf(u0), [CQ, h0] = Uf(u0), aj = t => { const { __scopeMenu: r, open: o = !1, children: u, dir: g, onOpenChange: y, modal: E = !0 } = t, s = Gb(r), [k, L] = ne.useState(null), N = ne.useRef(!1), V = To(y), H = vI(g); return ne.useEffect(() => { const ee = () => { N.current = !0, document.addEventListener("pointerdown", ce, { capture: !0, once: !0 }), document.addEventListener("pointermove", ce, { capture: !0, once: !0 }); }, ce = () => N.current = !1; return document.addEventListener("keydown", ee, { capture: !0 }), () => { document.removeEventListener("keydown", ee, { capture: !0 }), document.removeEventListener("pointerdown", ce, { capture: !0 }), document.removeEventListener("pointermove", ce, { capture: !0 }); }; }, []), j.jsx(aW, { ...s, children: j.jsx(EQ, { scope: r, open: o, onOpenChange: V, content: k, onContentChange: L, children: j.jsx(CQ, { scope: r, onClose: ne.useCallback(() => V(!1), [V]), isUsingKeyboardRef: N, dir: H, modal: E, children: u }) }) }); };
aj.displayName = u0;
var AQ = "MenuAnchor", xI = ne.forwardRef((t, r) => { const { __scopeMenu: o, ...u } = t, g = Gb(o); return j.jsx(uN, { ...g, ...u, ref: r }); });
xI.displayName = AQ;
var wI = "MenuPortal", [IQ, lj] = Uf(wI, { forceMount: void 0 }), cj = t => { const { __scopeMenu: r, forceMount: o, children: u, container: g } = t, y = $f(wI, r); return j.jsx(IQ, { scope: r, forceMount: o, children: j.jsx(Va, { present: o || y.open, children: j.jsx(_b, { asChild: !0, container: g, children: u }) }) }); };
cj.displayName = wI;
var Na = "MenuContent", [PQ, bI] = Uf(Na), uj = ne.forwardRef((t, r) => { const o = lj(Na, t.__scopeMenu), { forceMount: u = o.forceMount, ...g } = t, y = $f(Na, t.__scopeMenu), E = h0(Na, t.__scopeMenu); return j.jsx(qv.Provider, { scope: t.__scopeMenu, children: j.jsx(Va, { present: u || y.open, children: j.jsx(qv.Slot, { scope: t.__scopeMenu, children: E.modal ? j.jsx(MQ, { ...g, ref: r }) : j.jsx(RQ, { ...g, ref: r }) }) }) }); }), MQ = ne.forwardRef((t, r) => { const o = $f(Na, t.__scopeMenu), u = ne.useRef(null), g = is(r, u); return ne.useEffect(() => { const y = u.current; if (y)
    return IB(y); }, []), j.jsx(TI, { ...t, ref: g, trapFocus: o.open, disableOutsidePointerEvents: o.open, disableOutsideScroll: !0, onFocusOutside: qr(t.onFocusOutside, y => y.preventDefault(), { checkForDefaultPrevented: !1 }), onDismiss: () => o.onOpenChange(!1) }); }), RQ = ne.forwardRef((t, r) => { const o = $f(Na, t.__scopeMenu); return j.jsx(TI, { ...t, ref: r, trapFocus: !1, disableOutsidePointerEvents: !1, disableOutsideScroll: !1, onDismiss: () => o.onOpenChange(!1) }); }), kQ = fg("MenuContent.ScrollLock"), TI = ne.forwardRef((t, r) => { const { __scopeMenu: o, loop: u = !1, trapFocus: g, onOpenAutoFocus: y, onCloseAutoFocus: E, disableOutsidePointerEvents: s, onEntryFocus: k, onEscapeKeyDown: L, onPointerDownOutside: N, onFocusOutside: V, onInteractOutside: H, onDismiss: ee, disableOutsideScroll: ce, ...J } = t, ye = $f(Na, o), ie = h0(Na, o), Q = Gb(o), ue = oj(o), be = TQ(o), [Ie, Be] = ne.useState(null), Ze = ne.useRef(null), ot = is(r, Ze, ye.onContentChange), At = ne.useRef(0), kt = ne.useRef(""), ct = ne.useRef(0), St = ne.useRef(null), Kt = ne.useRef("right"), bt = ne.useRef(0), ir = ce ? aI : ne.Fragment, tr = ce ? { as: kQ, allowPinchZoom: !0 } : void 0, Or = Pt => { var mn, Xs; const Ft = kt.current + Pt, gr = be().filter(ln => !ln.disabled), Jr = document.activeElement, pi = (mn = gr.find(ln => ln.ref.current === Jr)) == null ? void 0 : mn.textValue, Si = gr.map(ln => ln.textValue), an = GQ(Si, Ft, pi), Kr = (Xs = gr.find(ln => ln.textValue === an)) == null ? void 0 : Xs.ref.current; (function ln(Bs) { kt.current = Bs, window.clearTimeout(At.current), Bs !== "" && (At.current = window.setTimeout(() => ln(""), 1e3)); })(Ft), Kr && setTimeout(() => Kr.focus()); }; ne.useEffect(() => () => window.clearTimeout(At.current), []), vB(); const xt = ne.useCallback(Pt => { var gr, Jr; return Kt.current === ((gr = St.current) == null ? void 0 : gr.side) && HQ(Pt, (Jr = St.current) == null ? void 0 : Jr.area); }, []); return j.jsx(PQ, { scope: o, searchRef: kt, onItemEnter: ne.useCallback(Pt => { xt(Pt) && Pt.preventDefault(); }, [xt]), onItemLeave: ne.useCallback(Pt => { var Ft; xt(Pt) || ((Ft = Ze.current) == null || Ft.focus(), Be(null)); }, [xt]), onTriggerLeave: ne.useCallback(Pt => { xt(Pt) && Pt.preventDefault(); }, [xt]), pointerGraceTimerRef: ct, onPointerGraceIntentChange: ne.useCallback(Pt => { St.current = Pt; }, []), children: j.jsx(ir, { ...tr, children: j.jsx(oI, { asChild: !0, trapped: g, onMountAutoFocus: qr(y, Pt => { var Ft; Pt.preventDefault(), (Ft = Ze.current) == null || Ft.focus({ preventScroll: !0 }); }), onUnmountAutoFocus: E, children: j.jsx(i0, { asChild: !0, disableOutsidePointerEvents: s, onEscapeKeyDown: L, onPointerDownOutside: N, onFocusOutside: V, onInteractOutside: H, onDismiss: ee, children: j.jsx(rj, { asChild: !0, ...ue, dir: ie.dir, orientation: "vertical", loop: u, currentTabStopId: Ie, onCurrentTabStopIdChange: Be, onEntryFocus: qr(k, Pt => { ie.isUsingKeyboardRef.current || Pt.preventDefault(); }), preventScrollOnEntryFocus: !0, children: j.jsx(hN, { role: "menu", "aria-orientation": "vertical", "data-state": Cj(ye.open), "data-radix-menu-content": "", dir: ie.dir, ...Q, ...J, ref: ot, style: { outline: "none", ...J.style }, onKeyDown: qr(J.onKeyDown, Pt => { const gr = Pt.target.closest("[data-radix-menu-content]") === Pt.currentTarget, Jr = Pt.ctrlKey || Pt.altKey || Pt.metaKey, pi = Pt.key.length === 1; gr && (Pt.key === "Tab" && Pt.preventDefault(), !Jr && pi && Or(Pt.key)); const Si = Ze.current; if (Pt.target !== Si || !xQ.includes(Pt.key))
                            return; Pt.preventDefault(); const Kr = be().filter(mn => !mn.disabled).map(mn => mn.ref.current); ij.includes(Pt.key) && Kr.reverse(), UQ(Kr); }), onBlur: qr(t.onBlur, Pt => { Pt.currentTarget.contains(Pt.target) || (window.clearTimeout(At.current), kt.current = ""); }), onPointerMove: qr(t.onPointerMove, Hv(Pt => { const Ft = Pt.target, gr = bt.current !== Pt.clientX; if (Pt.currentTarget.contains(Ft) && gr) {
                            const Jr = Pt.clientX > bt.current ? "right" : "left";
                            Kt.current = Jr, bt.current = Pt.clientX;
                        } })) }) }) }) }) }) }); });
uj.displayName = Na;
var DQ = "MenuGroup", SI = ne.forwardRef((t, r) => { const { __scopeMenu: o, ...u } = t; return j.jsx(si.div, { role: "group", ...u, ref: r }); });
SI.displayName = DQ;
var LQ = "MenuLabel", hj = ne.forwardRef((t, r) => { const { __scopeMenu: o, ...u } = t; return j.jsx(si.div, { ...u, ref: r }); });
hj.displayName = LQ;
var Yw = "MenuItem", lO = "menu.itemSelect", qb = ne.forwardRef((t, r) => { const { disabled: o = !1, onSelect: u, ...g } = t, y = ne.useRef(null), E = h0(Yw, t.__scopeMenu), s = bI(Yw, t.__scopeMenu), k = is(r, y), L = ne.useRef(!1), N = () => { const V = y.current; if (!o && V) {
    const H = new CustomEvent(lO, { bubbles: !0, cancelable: !0 });
    V.addEventListener(lO, ee => u == null ? void 0 : u(ee), { once: !0 }), AA(V, H), H.defaultPrevented ? L.current = !1 : E.onClose();
} }; return j.jsx(dj, { ...g, ref: k, disabled: o, onClick: qr(t.onClick, N), onPointerDown: V => { var H; (H = t.onPointerDown) == null || H.call(t, V), L.current = !0; }, onPointerUp: qr(t.onPointerUp, V => { var H; L.current || (H = V.currentTarget) == null || H.click(); }), onKeyDown: qr(t.onKeyDown, V => { const H = s.searchRef.current !== ""; o || H && V.key === " " || bC.includes(V.key) && (V.currentTarget.click(), V.preventDefault()); }) }); });
qb.displayName = Yw;
var dj = ne.forwardRef((t, r) => { const { __scopeMenu: o, disabled: u = !1, textValue: g, ...y } = t, E = bI(Yw, o), s = oj(o), k = ne.useRef(null), L = is(r, k), [N, V] = ne.useState(!1), [H, ee] = ne.useState(""); return ne.useEffect(() => { const ce = k.current; ce && ee((ce.textContent ?? "").trim()); }, [y.children]), j.jsx(qv.ItemSlot, { scope: o, disabled: u, textValue: g ?? H, children: j.jsx(nj, { asChild: !0, ...s, focusable: !u, children: j.jsx(si.div, { role: "menuitem", "data-highlighted": N ? "" : void 0, "aria-disabled": u || void 0, "data-disabled": u ? "" : void 0, ...y, ref: L, onPointerMove: qr(t.onPointerMove, Hv(ce => { u ? E.onItemLeave(ce) : (E.onItemEnter(ce), ce.defaultPrevented || ce.currentTarget.focus({ preventScroll: !0 })); })), onPointerLeave: qr(t.onPointerLeave, Hv(ce => E.onItemLeave(ce))), onFocus: qr(t.onFocus, () => V(!0)), onBlur: qr(t.onBlur, () => V(!1)) }) }) }); }), OQ = "MenuCheckboxItem", fj = ne.forwardRef((t, r) => { const { checked: o = !1, onCheckedChange: u, ...g } = t; return j.jsx(yj, { scope: t.__scopeMenu, checked: o, children: j.jsx(qb, { role: "menuitemcheckbox", "aria-checked": Qw(o) ? "mixed" : o, ...g, ref: r, "data-state": CI(o), onSelect: qr(g.onSelect, () => u == null ? void 0 : u(Qw(o) ? !0 : !o), { checkForDefaultPrevented: !1 }) }) }); });
fj.displayName = OQ;
var pj = "MenuRadioGroup", [zQ, FQ] = Uf(pj, { value: void 0, onValueChange: () => { } }), mj = ne.forwardRef((t, r) => { const { value: o, onValueChange: u, ...g } = t, y = To(u); return j.jsx(zQ, { scope: t.__scopeMenu, value: o, onValueChange: y, children: j.jsx(SI, { ...g, ref: r }) }); });
mj.displayName = pj;
var gj = "MenuRadioItem", _j = ne.forwardRef((t, r) => { const { value: o, ...u } = t, g = FQ(gj, t.__scopeMenu), y = o === g.value; return j.jsx(yj, { scope: t.__scopeMenu, checked: y, children: j.jsx(qb, { role: "menuitemradio", "aria-checked": y, ...u, ref: r, "data-state": CI(y), onSelect: qr(u.onSelect, () => { var E; return (E = g.onValueChange) == null ? void 0 : E.call(g, o); }, { checkForDefaultPrevented: !1 }) }) }); });
_j.displayName = gj;
var EI = "MenuItemIndicator", [yj, NQ] = Uf(EI, { checked: !1 }), vj = ne.forwardRef((t, r) => { const { __scopeMenu: o, forceMount: u, ...g } = t, y = NQ(EI, o); return j.jsx(Va, { present: u || Qw(y.checked) || y.checked === !0, children: j.jsx(si.span, { ...g, ref: r, "data-state": CI(y.checked) }) }); });
vj.displayName = EI;
var BQ = "MenuSeparator", xj = ne.forwardRef((t, r) => { const { __scopeMenu: o, ...u } = t; return j.jsx(si.div, { role: "separator", "aria-orientation": "horizontal", ...u, ref: r }); });
xj.displayName = BQ;
var jQ = "MenuArrow", wj = ne.forwardRef((t, r) => { const { __scopeMenu: o, ...u } = t, g = Gb(o); return j.jsx(dN, { ...g, ...u, ref: r }); });
wj.displayName = jQ;
var VQ = "MenuSub", [Tee, bj] = Uf(VQ), Hy = "MenuSubTrigger", Tj = ne.forwardRef((t, r) => { const o = $f(Hy, t.__scopeMenu), u = h0(Hy, t.__scopeMenu), g = bj(Hy, t.__scopeMenu), y = bI(Hy, t.__scopeMenu), E = ne.useRef(null), { pointerGraceTimerRef: s, onPointerGraceIntentChange: k } = y, L = { __scopeMenu: t.__scopeMenu }, N = ne.useCallback(() => { E.current && window.clearTimeout(E.current), E.current = null; }, []); return ne.useEffect(() => N, [N]), ne.useEffect(() => { const V = s.current; return () => { window.clearTimeout(V), k(null); }; }, [s, k]), j.jsx(xI, { asChild: !0, ...L, children: j.jsx(dj, { id: g.triggerId, "aria-haspopup": "menu", "aria-expanded": o.open, "aria-controls": g.contentId, "data-state": Cj(o.open), ...t, ref: gb(r, g.onTriggerChange), onClick: V => { var H; (H = t.onClick) == null || H.call(t, V), !(t.disabled || V.defaultPrevented) && (V.currentTarget.focus(), o.open || o.onOpenChange(!0)); }, onPointerMove: qr(t.onPointerMove, Hv(V => { y.onItemEnter(V), !V.defaultPrevented && !t.disabled && !o.open && !E.current && (y.onPointerGraceIntentChange(null), E.current = window.setTimeout(() => { o.onOpenChange(!0), N(); }, 100)); })), onPointerLeave: qr(t.onPointerLeave, Hv(V => { var ee, ce; N(); const H = (ee = o.content) == null ? void 0 : ee.getBoundingClientRect(); if (H) {
            const J = (ce = o.content) == null ? void 0 : ce.dataset.side, ye = J === "right", ie = ye ? -5 : 5, Q = H[ye ? "left" : "right"], ue = H[ye ? "right" : "left"];
            y.onPointerGraceIntentChange({ area: [{ x: V.clientX + ie, y: V.clientY }, { x: Q, y: H.top }, { x: ue, y: H.top }, { x: ue, y: H.bottom }, { x: Q, y: H.bottom }], side: J }), window.clearTimeout(s.current), s.current = window.setTimeout(() => y.onPointerGraceIntentChange(null), 300);
        }
        else {
            if (y.onTriggerLeave(V), V.defaultPrevented)
                return;
            y.onPointerGraceIntentChange(null);
        } })), onKeyDown: qr(t.onKeyDown, V => { var ee; const H = y.searchRef.current !== ""; t.disabled || H && V.key === " " || wQ[u.dir].includes(V.key) && (o.onOpenChange(!0), (ee = o.content) == null || ee.focus(), V.preventDefault()); }) }) }); });
Tj.displayName = Hy;
var Sj = "MenuSubContent", Ej = ne.forwardRef((t, r) => { const o = lj(Na, t.__scopeMenu), { forceMount: u = o.forceMount, ...g } = t, y = $f(Na, t.__scopeMenu), E = h0(Na, t.__scopeMenu), s = bj(Sj, t.__scopeMenu), k = ne.useRef(null), L = is(r, k); return j.jsx(qv.Provider, { scope: t.__scopeMenu, children: j.jsx(Va, { present: u || y.open, children: j.jsx(qv.Slot, { scope: t.__scopeMenu, children: j.jsx(TI, { id: s.contentId, "aria-labelledby": s.triggerId, ...g, ref: L, align: "start", side: E.dir === "rtl" ? "left" : "right", disableOutsidePointerEvents: !1, disableOutsideScroll: !1, trapFocus: !1, onOpenAutoFocus: N => { var V; E.isUsingKeyboardRef.current && ((V = k.current) == null || V.focus()), N.preventDefault(); }, onCloseAutoFocus: N => N.preventDefault(), onFocusOutside: qr(t.onFocusOutside, N => { N.target !== s.trigger && y.onOpenChange(!1); }), onEscapeKeyDown: qr(t.onEscapeKeyDown, N => { E.onClose(), N.preventDefault(); }), onKeyDown: qr(t.onKeyDown, N => { var ee; const V = N.currentTarget.contains(N.target), H = bQ[E.dir].includes(N.key); V && H && (y.onOpenChange(!1), (ee = s.trigger) == null || ee.focus(), N.preventDefault()); }) }) }) }) }); });
Ej.displayName = Sj;
function Cj(t) { return t ? "open" : "closed"; }
function Qw(t) { return t === "indeterminate"; }
function CI(t) { return Qw(t) ? "indeterminate" : t ? "checked" : "unchecked"; }
function UQ(t) { const r = document.activeElement; for (const o of t)
    if (o === r || (o.focus(), document.activeElement !== r))
        return; }
function $Q(t, r) { return t.map((o, u) => t[(r + u) % t.length]); }
function GQ(t, r, o) { const g = r.length > 1 && Array.from(r).every(L => L === r[0]) ? r[0] : r, y = o ? t.indexOf(o) : -1; let E = $Q(t, Math.max(y, 0)); g.length === 1 && (E = E.filter(L => L !== o)); const k = E.find(L => L.toLowerCase().startsWith(g.toLowerCase())); return k !== o ? k : void 0; }
function qQ(t, r) { const { x: o, y: u } = t; let g = !1; for (let y = 0, E = r.length - 1; y < r.length; E = y++) {
    const s = r[y].x, k = r[y].y, L = r[E].x, N = r[E].y;
    k > u != N > u && o < (L - s) * (u - k) / (N - k) + s && (g = !g);
} return g; }
function HQ(t, r) { if (!r)
    return !1; const o = { x: t.clientX, y: t.clientY }; return qQ(o, r); }
function Hv(t) { return r => r.pointerType === "mouse" ? t(r) : void 0; }
var WQ = aj, ZQ = xI, XQ = cj, KQ = uj, YQ = SI, QQ = hj, JQ = qb, eJ = fj, tJ = mj, rJ = _j, nJ = vj, iJ = xj, sJ = wj, oJ = Tj, aJ = Ej, AI = "DropdownMenu", [lJ, See] = pc(AI, [sj]), Ao = sj(), [cJ, Aj] = lJ(AI), Ij = t => { const { __scopeDropdownMenu: r, children: o, dir: u, open: g, defaultOpen: y, onOpenChange: E, modal: s = !0 } = t, k = Ao(r), L = ne.useRef(null), [N = !1, V] = Cg({ prop: g, defaultProp: y, onChange: E }); return j.jsx(cJ, { scope: r, triggerId: Sf(), triggerRef: L, contentId: Sf(), open: N, onOpenChange: V, onOpenToggle: ne.useCallback(() => V(H => !H), [V]), modal: s, children: j.jsx(WQ, { ...k, open: N, onOpenChange: V, dir: u, modal: s, children: o }) }); };
Ij.displayName = AI;
var Pj = "DropdownMenuTrigger", Mj = ne.forwardRef((t, r) => { const { __scopeDropdownMenu: o, disabled: u = !1, ...g } = t, y = Aj(Pj, o), E = Ao(o); return j.jsx(ZQ, { asChild: !0, ...E, children: j.jsx(si.button, { type: "button", id: y.triggerId, "aria-haspopup": "menu", "aria-expanded": y.open, "aria-controls": y.open ? y.contentId : void 0, "data-state": y.open ? "open" : "closed", "data-disabled": u ? "" : void 0, disabled: u, ...g, ref: gb(r, y.triggerRef), onPointerDown: qr(t.onPointerDown, s => { !u && s.button === 0 && s.ctrlKey === !1 && (y.onOpenToggle(), y.open || s.preventDefault()); }), onKeyDown: qr(t.onKeyDown, s => { u || (["Enter", " "].includes(s.key) && y.onOpenToggle(), s.key === "ArrowDown" && y.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(s.key) && s.preventDefault()); }) }) }); });
Mj.displayName = Pj;
var uJ = "DropdownMenuPortal", Rj = t => { const { __scopeDropdownMenu: r, ...o } = t, u = Ao(r); return j.jsx(XQ, { ...u, ...o }); };
Rj.displayName = uJ;
var kj = "DropdownMenuContent", Dj = ne.forwardRef((t, r) => { const { __scopeDropdownMenu: o, ...u } = t, g = Aj(kj, o), y = Ao(o), E = ne.useRef(!1); return j.jsx(KQ, { id: g.contentId, "aria-labelledby": g.triggerId, ...y, ...u, ref: r, onCloseAutoFocus: qr(t.onCloseAutoFocus, s => { var k; E.current || (k = g.triggerRef.current) == null || k.focus(), E.current = !1, s.preventDefault(); }), onInteractOutside: qr(t.onInteractOutside, s => { const k = s.detail.originalEvent, L = k.button === 0 && k.ctrlKey === !0, N = k.button === 2 || L; (!g.modal || N) && (E.current = !0); }), style: { ...t.style, "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)", "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)", "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)", "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)" } }); });
Dj.displayName = kj;
var hJ = "DropdownMenuGroup", dJ = ne.forwardRef((t, r) => { const { __scopeDropdownMenu: o, ...u } = t, g = Ao(o); return j.jsx(YQ, { ...g, ...u, ref: r }); });
dJ.displayName = hJ;
var fJ = "DropdownMenuLabel", Lj = ne.forwardRef((t, r) => { const { __scopeDropdownMenu: o, ...u } = t, g = Ao(o); return j.jsx(QQ, { ...g, ...u, ref: r }); });
Lj.displayName = fJ;
var pJ = "DropdownMenuItem", Oj = ne.forwardRef((t, r) => { const { __scopeDropdownMenu: o, ...u } = t, g = Ao(o); return j.jsx(JQ, { ...g, ...u, ref: r }); });
Oj.displayName = pJ;
var mJ = "DropdownMenuCheckboxItem", zj = ne.forwardRef((t, r) => { const { __scopeDropdownMenu: o, ...u } = t, g = Ao(o); return j.jsx(eJ, { ...g, ...u, ref: r }); });
zj.displayName = mJ;
var gJ = "DropdownMenuRadioGroup", _J = ne.forwardRef((t, r) => { const { __scopeDropdownMenu: o, ...u } = t, g = Ao(o); return j.jsx(tJ, { ...g, ...u, ref: r }); });
_J.displayName = gJ;
var yJ = "DropdownMenuRadioItem", Fj = ne.forwardRef((t, r) => { const { __scopeDropdownMenu: o, ...u } = t, g = Ao(o); return j.jsx(rJ, { ...g, ...u, ref: r }); });
Fj.displayName = yJ;
var vJ = "DropdownMenuItemIndicator", Nj = ne.forwardRef((t, r) => { const { __scopeDropdownMenu: o, ...u } = t, g = Ao(o); return j.jsx(nJ, { ...g, ...u, ref: r }); });
Nj.displayName = vJ;
var xJ = "DropdownMenuSeparator", Bj = ne.forwardRef((t, r) => { const { __scopeDropdownMenu: o, ...u } = t, g = Ao(o); return j.jsx(iJ, { ...g, ...u, ref: r }); });
Bj.displayName = xJ;
var wJ = "DropdownMenuArrow", bJ = ne.forwardRef((t, r) => { const { __scopeDropdownMenu: o, ...u } = t, g = Ao(o); return j.jsx(sJ, { ...g, ...u, ref: r }); });
bJ.displayName = wJ;
var TJ = "DropdownMenuSubTrigger", jj = ne.forwardRef((t, r) => { const { __scopeDropdownMenu: o, ...u } = t, g = Ao(o); return j.jsx(oJ, { ...g, ...u, ref: r }); });
jj.displayName = TJ;
var SJ = "DropdownMenuSubContent", Vj = ne.forwardRef((t, r) => { const { __scopeDropdownMenu: o, ...u } = t, g = Ao(o); return j.jsx(aJ, { ...g, ...u, ref: r, style: { ...t.style, "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)", "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)", "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)", "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)" } }); });
Vj.displayName = SJ;
var EJ = Ij, CJ = Mj, AJ = Rj, Uj = Dj, $j = Lj, Gj = Oj, qj = zj, Hj = Fj, Wj = Nj, Zj = Bj, Xj = jj, Kj = Vj;
const IJ = EJ, PJ = CJ, MJ = ne.forwardRef(({ className: t, inset: r, children: o, ...u }, g) => j.jsxs(Xj, { ref: g, className: $n("flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", r && "pl-8", t), ...u, children: [o, j.jsx(dq, { className: "ml-auto" })] }));
MJ.displayName = Xj.displayName;
const RJ = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(Kj, { ref: o, className: $n("z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]", t), ...r }));
RJ.displayName = Kj.displayName;
const Yj = ne.forwardRef(({ className: t, sideOffset: r = 4, ...o }, u) => j.jsx(AJ, { children: j.jsx(Uj, { ref: u, sideOffset: r, className: $n("z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]", t), ...o }) }));
Yj.displayName = Uj.displayName;
const Wy = ne.forwardRef(({ className: t, inset: r, ...o }, u) => j.jsx(Gj, { ref: u, className: $n("relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", r && "pl-8", t), ...o }));
Wy.displayName = Gj.displayName;
const kJ = ne.forwardRef(({ className: t, children: r, checked: o, ...u }, g) => j.jsxs(qj, { ref: g, className: $n("relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", t), checked: o, ...u, children: [j.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: j.jsx(Wj, { children: j.jsx(RF, { className: "h-4 w-4" }) }) }), r] }));
kJ.displayName = qj.displayName;
const DJ = ne.forwardRef(({ className: t, children: r, ...o }, u) => j.jsxs(Hj, { ref: u, className: $n("relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50", t), ...o, children: [j.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: j.jsx(Wj, { children: j.jsx(fq, { className: "h-2 w-2 fill-current" }) }) }), r] }));
DJ.displayName = Hj.displayName;
const LJ = ne.forwardRef(({ className: t, inset: r, ...o }, u) => j.jsx($j, { ref: u, className: $n("px-2 py-1.5 text-sm font-semibold", r && "pl-8", t), ...o }));
LJ.displayName = $j.displayName;
const Qj = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(Zj, { ref: o, className: $n("-mx-1 my-1 h-px bg-muted", t), ...r }));
Qj.displayName = Zj.displayName;
function OJ({ trip: t, onOpenShare: r }) { const [, o] = xA(); return j.jsx("header", { className: "bg-white dark:bg-[hsl(var(--card))] shadow-sm z-10", children: j.jsxs("div", { className: "container mx-auto px-4 py-3 flex justify-between items-center", children: [j.jsxs("div", { className: "flex items-center space-x-2", children: [j.jsxs("div", { className: "flex items-center cursor-pointer", onClick: () => o("/"), children: [j.jsx("div", { className: "h-8 w-8 bg-[hsl(var(--secondary))] rounded-full flex items-center justify-center", children: j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5 text-[hsl(var(--foreground))]", viewBox: "0 0 20 20", fill: "currentColor", children: j.jsx("path", { fillRule: "evenodd", d: "M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z", clipRule: "evenodd" }) }) }), j.jsx("h1", { className: "ml-2 text-xl font-semibold", children: "NestMap" })] }), j.jsx("span", { className: "hidden md:block text-sm text-[hsl(var(--muted-foreground))]", children: "Plan. Pin. Wander." })] }), j.jsxs("div", { className: "flex items-center space-x-2", children: [j.jsx(ci, { id: "toggleSidebar", variant: "ghost", size: "icon", className: "md:hidden text-[hsl(var(--primary))]", "aria-label": "Toggle Sidebar", children: j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 6h16M4 12h16M4 18h16" }) }) }), t && j.jsxs(j.Fragment, { children: [j.jsxs(ci, { variant: "ghost", className: "hidden md:flex items-center text-[hsl(var(--primary))] hover:text-[hsl(var(--primary))]", onClick: r, children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5 mr-1", viewBox: "0 0 20 20", fill: "currentColor", children: j.jsx("path", { d: "M8 9a3 3 0 100-6 3 3 0 000 6zM8 11a6 6 0 016 6H2a6 6 0 016-6z" }) }), j.jsx("span", { children: "Share" })] }), j.jsxs(IJ, { children: [j.jsx(PJ, { asChild: !0, children: j.jsx(ci, { variant: "ghost", size: "icon", "aria-label": "Trip Options", children: j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z" }) }) }) }), j.jsxs(Yj, { align: "end", children: [j.jsxs(Wy, { children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4 mr-2", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" }) }), j.jsx("span", { children: "Rename Trip" })] }), j.jsxs(Wy, { children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4 mr-2", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" }) }), j.jsx("span", { children: "Duplicate Trip" })] }), j.jsxs(Wy, { children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4 mr-2", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" }) }), j.jsx("span", { children: "Export as PDF" })] }), j.jsx(Qj, {}), j.jsxs(Wy, { className: "text-[hsl(var(--destructive))]", children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4 mr-2", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" }) }), j.jsx("span", { children: "Delete Trip" })] })] })] })] })] })] }) }); }
function GE({ children: t, trip: r, onOpenShare: o }) { return j.jsxs("div", { className: "flex flex-col h-screen", children: [j.jsx(OJ, { trip: r, onOpenShare: o }), j.jsx("main", { className: "flex-1 flex flex-col md:flex-row overflow-hidden main-content", children: j.jsx("div", { className: "flex flex-col md:flex-row w-full", children: t }) })] }); }
var II = "Tabs", [zJ, Eee] = pc(II, [$b]), Jj = $b(), [FJ, PI] = zJ(II), e4 = ne.forwardRef((t, r) => { const { __scopeTabs: o, value: u, onValueChange: g, defaultValue: y, orientation: E = "horizontal", dir: s, activationMode: k = "automatic", ...L } = t, N = vI(s), [V, H] = Cg({ prop: u, onChange: g, defaultProp: y }); return j.jsx(FJ, { scope: o, baseId: Sf(), value: V, onValueChange: H, orientation: E, dir: N, activationMode: k, children: j.jsx(si.div, { dir: N, "data-orientation": E, ...L, ref: r }) }); });
e4.displayName = II;
var t4 = "TabsList", r4 = ne.forwardRef((t, r) => { const { __scopeTabs: o, loop: u = !0, ...g } = t, y = PI(t4, o), E = Jj(o); return j.jsx(rj, { asChild: !0, ...E, orientation: y.orientation, dir: y.dir, loop: u, children: j.jsx(si.div, { role: "tablist", "aria-orientation": y.orientation, ...g, ref: r }) }); });
r4.displayName = t4;
var n4 = "TabsTrigger", i4 = ne.forwardRef((t, r) => { const { __scopeTabs: o, value: u, disabled: g = !1, ...y } = t, E = PI(n4, o), s = Jj(o), k = a4(E.baseId, u), L = l4(E.baseId, u), N = u === E.value; return j.jsx(nj, { asChild: !0, ...s, focusable: !g, active: N, children: j.jsx(si.button, { type: "button", role: "tab", "aria-selected": N, "aria-controls": L, "data-state": N ? "active" : "inactive", "data-disabled": g ? "" : void 0, disabled: g, id: k, ...y, ref: r, onMouseDown: qr(t.onMouseDown, V => { !g && V.button === 0 && V.ctrlKey === !1 ? E.onValueChange(u) : V.preventDefault(); }), onKeyDown: qr(t.onKeyDown, V => { [" ", "Enter"].includes(V.key) && E.onValueChange(u); }), onFocus: qr(t.onFocus, () => { const V = E.activationMode !== "manual"; !N && !g && V && E.onValueChange(u); }) }) }); });
i4.displayName = n4;
var s4 = "TabsContent", o4 = ne.forwardRef((t, r) => { const { __scopeTabs: o, value: u, forceMount: g, children: y, ...E } = t, s = PI(s4, o), k = a4(s.baseId, u), L = l4(s.baseId, u), N = u === s.value, V = ne.useRef(N); return ne.useEffect(() => { const H = requestAnimationFrame(() => V.current = !1); return () => cancelAnimationFrame(H); }, []), j.jsx(Va, { present: g || N, children: ({ present: H }) => j.jsx(si.div, { "data-state": N ? "active" : "inactive", "data-orientation": s.orientation, role: "tabpanel", "aria-labelledby": k, hidden: !H, id: L, tabIndex: 0, ...E, ref: r, style: { ...t.style, animationDuration: V.current ? "0s" : void 0 }, children: H && y }) }); });
o4.displayName = s4;
function a4(t, r) { return `${t}-trigger-${r}`; }
function l4(t, r) { return `${t}-content-${r}`; }
var NJ = e4, c4 = r4, u4 = i4, h4 = o4;
const BJ = NJ, d4 = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(c4, { ref: o, className: $n("inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground", t), ...r }));
d4.displayName = c4.displayName;
const sw = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(u4, { ref: o, className: $n("inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm", t), ...r }));
sw.displayName = u4.displayName;
const ow = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(h4, { ref: o, className: $n("mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", t), ...r }));
ow.displayName = h4.displayName;
function jJ(t) { const r = ne.useRef({ value: t, previous: t }); return ne.useMemo(() => (r.current.value !== t && (r.current.previous = r.current.value, r.current.value = t), r.current.previous), [t]); }
var MI = "Checkbox", [VJ, Cee] = pc(MI), [UJ, $J] = VJ(MI), f4 = ne.forwardRef((t, r) => { const { __scopeCheckbox: o, name: u, checked: g, defaultChecked: y, required: E, disabled: s, value: k = "on", onCheckedChange: L, form: N, ...V } = t, [H, ee] = ne.useState(null), ce = is(r, be => ee(be)), J = ne.useRef(!1), ye = H ? N || !!H.closest("form") : !0, [ie = !1, Q] = Cg({ prop: g, defaultProp: y, onChange: L }), ue = ne.useRef(ie); return ne.useEffect(() => { const be = H == null ? void 0 : H.form; if (be) {
    const Ie = () => Q(ue.current);
    return be.addEventListener("reset", Ie), () => be.removeEventListener("reset", Ie);
} }, [H, Q]), j.jsxs(UJ, { scope: o, state: ie, disabled: s, children: [j.jsx(si.button, { type: "button", role: "checkbox", "aria-checked": $h(ie) ? "mixed" : ie, "aria-required": E, "data-state": g4(ie), "data-disabled": s ? "" : void 0, disabled: s, value: k, ...V, ref: ce, onKeyDown: qr(t.onKeyDown, be => { be.key === "Enter" && be.preventDefault(); }), onClick: qr(t.onClick, be => { Q(Ie => $h(Ie) ? !0 : !Ie), ye && (J.current = be.isPropagationStopped(), J.current || be.stopPropagation()); }) }), ye && j.jsx(GJ, { control: H, bubbles: !J.current, name: u, value: k, checked: ie, required: E, disabled: s, form: N, style: { transform: "translateX(-100%)" }, defaultChecked: $h(y) ? !1 : y })] }); });
f4.displayName = MI;
var p4 = "CheckboxIndicator", m4 = ne.forwardRef((t, r) => { const { __scopeCheckbox: o, forceMount: u, ...g } = t, y = $J(p4, o); return j.jsx(Va, { present: u || $h(y.state) || y.state === !0, children: j.jsx(si.span, { "data-state": g4(y.state), "data-disabled": y.disabled ? "" : void 0, ...g, ref: r, style: { pointerEvents: "none", ...t.style } }) }); });
m4.displayName = p4;
var GJ = t => { const { control: r, checked: o, bubbles: u = !0, defaultChecked: g, ...y } = t, E = ne.useRef(null), s = jJ(o), k = eN(r); ne.useEffect(() => { const N = E.current, V = window.HTMLInputElement.prototype, ee = Object.getOwnPropertyDescriptor(V, "checked").set; if (s !== o && ee) {
    const ce = new Event("click", { bubbles: u });
    N.indeterminate = $h(o), ee.call(N, $h(o) ? !1 : o), N.dispatchEvent(ce);
} }, [s, o, u]); const L = ne.useRef($h(o) ? !1 : o); return j.jsx("input", { type: "checkbox", "aria-hidden": !0, defaultChecked: g ?? L.current, ...y, tabIndex: -1, ref: E, style: { ...t.style, ...k, position: "absolute", pointerEvents: "none", opacity: 0, margin: 0 } }); };
function $h(t) { return t === "indeterminate"; }
function g4(t) { return $h(t) ? "indeterminate" : t ? "checked" : "unchecked"; }
var _4 = f4, qJ = m4;
const y4 = ne.forwardRef(({ className: t, ...r }, o) => j.jsx(_4, { ref: o, className: $n("peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground", t), ...r, children: j.jsx(qJ, { className: $n("flex items-center justify-center text-current"), children: j.jsx(RF, { className: "h-4 w-4" }) }) }));
y4.displayName = _4.displayName;
function HJ({ tag: t, className: r = "" }) { const o = t.toLowerCase(); let u = Object.values(HN).find(g => g.id === o); return u || (u = { id: o, label: t, color: "bg-[hsl(var(--primary))]", icon: "" }), j.jsx("span", { className: `${u.color} text-white rounded-md text-xs px-2 py-0.5 inline-block ${r}`, children: u.label.toUpperCase() }); }
function WJ({ activity: t, onClick: r, onDelete: o, onToggleComplete: u }) {
    const { toast: g } = fc(), y = uo({ mutationFn: async () => Es("DELETE", `${En.ACTIVITIES}/${t.id}`), onSuccess: () => { ac.invalidateQueries({ queryKey: [En.TRIPS, t.tripId, "activities"] }), g({ title: "Activity Deleted", description: "The activity has been removed from your itinerary." }), o && o(); }, onError: N => { console.error("Error deleting activity:", N), g({ title: "Error", description: "Could not delete the activity. Please try again.", variant: "destructive" }); } }), E = uo({ mutationFn: async (N) => Es("PUT", `${En.ACTIVITIES}/${t.id}/toggle-complete`, { completed: N }), onSuccess: (N, V) => { ac.invalidateQueries({ queryKey: [En.TRIPS, t.tripId, "activities"] }), g({ title: V ? "Activity Completed" : "Activity Marked Incomplete", description: V ? "The activity has been marked as completed and will be hidden from the map." : "The activity has been marked as incomplete and will appear on the map." }), u && u(t.id, V); }, onError: N => { console.error("Error updating activity completion status:", N), g({ title: "Error", description: "Could not update the activity status. Please try again.", variant: "destructive" }); } }), s = N => { if (!N)
        return "--:--"; const [V, H] = N.split(":"), ee = parseInt(V), ce = ee >= 12 ? "PM" : "AM"; return `${ee % 12 || 12}:${H} ${ce}`; }, k = N => { N.stopPropagation(), E.mutate(!t.completed); }, L = N => { N.stopPropagation(), g({ title: "Delete Activity?", description: "Are you sure you want to delete this activity?", action: j.jsxs("div", { className: "flex gap-2", children: [j.jsx("button", { onClick: () => y.mutate(), className: "bg-[hsl(var(--destructive))] text-white px-3 py-1 rounded text-xs", children: "Delete" }), j.jsx("button", { className: "bg-[hsl(var(--secondary))] text-[hsl(var(--secondary-foreground))] px-3 py-1 rounded text-xs", children: "Cancel" })] }) }); };
    return j.jsxs("div", { className: "pl-8 relative timeline-item group", children: [j.jsx("div", { className: "flex items-center absolute left-0 timeline-point", children: j.jsx("div", { className: "h-6 w-6 bg-[hsl(var(--primary))] text-white rounded-full flex items-center justify-center text-xs font-medium", children: j.jsx("div", { className: "h-2 w-2 bg-white rounded-full" }) }) }), j.jsxs("div", { className: `
          bg-white dark:bg-[hsl(var(--card))] border rounded-lg shadow-sm hover:shadow cursor-pointer
          ${t.conflict ? "border-[hsl(var(--destructive))]" : ""}
          ${t.completed ? "opacity-60" : ""}
          relative overflow-hidden
        `, children: [j.jsx("div", { className: "bg-[hsl(var(--primary))] text-white p-2 text-center font-medium", children: s(t.time) }), j.jsxs("div", { className: "p-3 pt-6 relative", children: [j.jsx("div", { className: "absolute right-2 top-2 z-10 w-5 h-5 flex items-center justify-center bg-[hsl(var(--primary))] hover:bg-[hsl(var(--primary))/90] text-white rounded-full cursor-pointer", onClick: k, title: t.completed ? "Mark as incomplete" : "Mark as completed", children: t.completed ? j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-3 w-3", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M5 13l4 4L19 7" }) }) : j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-3 w-3", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 6v6m0 0v6m0-6h6m-6 0H6" }) }) }), j.jsx("div", { className: "absolute top-2 left-2 opacity-0 group-hover:opacity-100 transition-opacity", children: j.jsx("div", { className: "bg-[hsl(var(--destructive))] text-white p-1 rounded-full hover:bg-[hsl(var(--destructive))/90] cursor-pointer", onClick: L, children: j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" }) }) }) }), j.jsxs("div", { onClick: () => r(t), children: [j.jsxs("div", { className: "flex justify-between items-start", children: [j.jsx("h3", { className: "font-medium", children: t.title }), t.tag && j.jsx(HJ, { tag: t.tag })] }), t.notes && j.jsx("div", { className: "text-sm mt-2", children: t.notes }), t.travelTimeFromPrevious && j.jsxs("div", { className: "flex items-center text-xs text-[hsl(var(--muted-foreground))] mt-2", children: [String(t.travelMode).toLowerCase() === "walking" && j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-3 w-3 mr-1", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: j.jsx("path", { d: "M13 5c3 0 5 2 5 5 0 3-2 5-5 5M7 8l2 2M7 12l5 5M19 19l-5-5" }) }), String(t.travelMode).toLowerCase() === "driving" && j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-3 w-3 mr-1", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: j.jsx("path", { d: "M7 17h10M5 11h14m-7-5h-2l-2 5H5l-2 3v2h18v-2l-2-3h-3l-2-5h-2zm2 8a1 1 0 11-2 0 1 1 0 012 0zm6 0a1 1 0 11-2 0 1 1 0 012 0z" }) }), String(t.travelMode).toLowerCase() === "transit" && j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-3 w-3 mr-1", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: j.jsx("path", { d: "M15 5h-6a2 2 0 00-2 2v9a2 2 0 002 2h6a2 2 0 002-2V7a2 2 0 00-2-2zm1 11h-8m8-5H8m4-5v10" }) }), (!t.travelMode || String(t.travelMode).toLowerCase() === "null") && j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-3 w-3 mr-1", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" }) }), t.travelTimeFromPrevious, " from previous stop"] }), t.conflict && j.jsxs("div", { className: "flex items-center text-xs text-[hsl(var(--destructive))] mt-2", children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-3 w-3 mr-1", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" }) }), "Possible scheduling conflict"] })] })] })] })] });
}
const v4 = ne.forwardRef(({ className: t, ...r }, o) => j.jsx("textarea", { className: $n("flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", t), ref: o, ...r }));
v4.displayName = "Textarea";
function x4(t) { const { data: r, isLoading: o, error: u } = nv({ queryKey: [En.TRIPS, t], queryFn: async () => { if (!t)
        return null; const ee = await fetch(`${En.TRIPS}/${t}`); if (!ee.ok)
        throw new Error("Failed to fetch trip"); return ee.json(); }, enabled: !!t }), { data: g = [], isLoading: y, error: E } = nv({ queryKey: [En.TRIPS, t, "todos"], queryFn: async () => { if (!t)
        return []; const ee = await fetch(`${En.TRIPS}/${t}/todos`); if (!ee.ok)
        throw new Error("Failed to fetch todos"); return ee.json(); }, enabled: !!t }), { data: s = [], isLoading: k, error: L } = nv({ queryKey: [En.TRIPS, t, "notes"], queryFn: async () => { if (!t)
        return []; const ee = await fetch(`${En.TRIPS}/${t}/notes`); if (!ee.ok)
        throw new Error("Failed to fetch notes"); return ee.json(); }, enabled: !!t }), N = s.length > 0 ? s[0].content : ""; return { trip: r, todos: g, notes: N, isLoading: o || y || k, error: u || E || L, updateTrip: async (ee) => { if (!t)
        return null; try {
        return await (await Es("PUT", `${En.TRIPS}/${t}`, ee)).json();
    }
    catch (ce) {
        throw console.error("Error updating trip:", ce), ce;
    } }, deleteTrip: async () => { if (!t)
        return !1; try {
        return await Es("DELETE", `${En.TRIPS}/${t}`, void 0), !0;
    }
    catch (ee) {
        throw console.error("Error deleting trip:", ee), ee;
    } } }; }
function ZJ(t, r) { const [o, u] = ne.useState(t); return ne.useEffect(() => { const g = setTimeout(() => { u(t); }, r); return () => { clearTimeout(g); }; }, [t, r]), o; }
const XJ = zs.object({ title: zs.string().min(1, "Title is required"), date: zs.date(), time: zs.string().min(1, "Time is required"), locationName: zs.string().min(1, "Location is required"), notes: zs.string().optional(), tag: zs.string().optional(), latitude: zs.string().optional(), longitude: zs.string().optional(), assignedTo: zs.string().optional(), travelMode: zs.string().default("walking") });
function KJ({ tripId: t, date: r, activity: o, onClose: u, onSave: g }) { const { toast: y } = fc(); sI(); const { trip: E } = x4(t), [s, k] = ne.useState(""), L = ZJ(s, 1e3); ne.useRef(!1); const [N, V] = ne.useState([]), [H, ee] = ne.useState((o == null ? void 0 : o.tag) === null || o == null ? void 0 : o.tag), ce = ct => ct.toISOString().split("T")[0], J = ["walking", "driving", "transit"], ye = o != null && o.travelMode && J.includes(o.travelMode) ? o.travelMode : "walking", ie = { title: (o == null ? void 0 : o.title) || "", date: r, time: (o == null ? void 0 : o.time) || "12:00", locationName: (o == null ? void 0 : o.locationName) || "", notes: (o == null ? void 0 : o.notes) || "", tag: (o == null ? void 0 : o.tag) || void 0, latitude: (o == null ? void 0 : o.latitude) || void 0, longitude: (o == null ? void 0 : o.longitude) || void 0, assignedTo: (o == null ? void 0 : o.assignedTo) || void 0, travelMode: ye }, { register: Q, handleSubmit: ue, setValue: be, watch: Ie, formState: { errors: Be } } = Fb({ resolver: Nb(XJ), defaultValues: ie }); ne.useEffect(() => { L && L.length >= 3 && (console.log("Auto-searching for completed term:", L), be("locationName", L)); }, [L, be]); const Ze = uo({ mutationFn: async (ct) => { const St = (o == null ? void 0 : o.order) || 0; return (await Es("POST", En.ACTIVITIES, { ...ct, tripId: t, order: St, travelMode: ct.travelMode || "walking" })).json(); }, onSuccess: () => { ac.invalidateQueries({ queryKey: [En.TRIPS, t, "activities"] }), y({ title: "Activity created", description: "Your activity has been added to the trip." }), g(), u(); }, onError: ct => { console.error("Error creating activity:", ct), y({ title: "Error", description: "Could not create activity. Please try again.", variant: "destructive" }); } }), ot = uo({ mutationFn: async (ct) => { if (!o)
        return null; const St = { title: ct.title, date: ct.date, time: ct.time, locationName: ct.locationName, latitude: ct.latitude, longitude: ct.longitude, notes: ct.notes, tag: ct.tag, assignedTo: ct.assignedTo, tripId: t, order: o.order, travelMode: String(ct.travelMode || "walking") }; console.log("Updating activity with explicit data:", St); const bt = await (await Es("PUT", `${En.ACTIVITIES}/${o.id}`, St)).json(); return console.log("Server response after update:", bt), bt; }, onSuccess: () => { ac.invalidateQueries({ queryKey: [En.TRIPS, t, "activities"] }), y({ title: "Activity updated", description: "Your activity has been updated." }), g(), u(); }, onError: ct => { console.error("Error updating activity:", ct), y({ title: "Error", description: "Could not update activity. Please try again.", variant: "destructive" }); } }), At = ct => { o ? ot.mutate(ct) : Ze.mutate(ct); }, kt = ct => { ee(ct), be("tag", ct); }; return j.jsx("div", { className: "fixed inset-0 z-[9999] flex items-start justify-center bg-black/50 pt-4 md:pt-16 md:items-center", children: j.jsx("div", { className: "bg-background rounded-lg w-full max-w-md max-h-[96vh] overflow-y-auto", children: j.jsxs("div", { className: "p-6", children: [j.jsxs("div", { className: "flex justify-between items-center mb-4", children: [j.jsx("h2", { className: "text-xl font-semibold", children: o ? "Edit Activity" : "Add Activity" }), j.jsx(ci, { variant: "ghost", size: "icon", onClick: u, children: "" })] }), j.jsxs("form", { onSubmit: ue(At), children: [j.jsxs("div", { className: "space-y-4", children: [j.jsxs("div", { className: "mb-4", children: [j.jsx("label", { className: "block text-sm font-medium text-[hsl(var(--foreground))] mb-1", children: "Title" }), j.jsx(Hs, { ...Q("title"), placeholder: "Activity title", className: Be.title ? "border-[hsl(var(--destructive))]" : "" }), Be.title && j.jsx("p", { className: "mt-1 text-xs text-[hsl(var(--destructive))]", children: Be.title.message })] }), j.jsxs("div", { className: "grid grid-cols-2 gap-4 mb-4", children: [j.jsxs("div", { children: [j.jsx("label", { className: "block text-sm font-medium text-[hsl(var(--foreground))] mb-1", children: "Date" }), j.jsx(Hs, { type: "date", defaultValue: ce(r), ...Q("date", { valueAsDate: !0 }), className: Be.date ? "border-[hsl(var(--destructive))]" : "" }), Be.date && j.jsx("p", { className: "mt-1 text-xs text-[hsl(var(--destructive))]", children: Be.date.message })] }), j.jsxs("div", { children: [j.jsx("label", { className: "block text-sm font-medium text-[hsl(var(--foreground))] mb-1", children: "Time" }), j.jsx(Hs, { type: "time", ...Q("time"), className: Be.time ? "border-[hsl(var(--destructive))]" : "" }), Be.time && j.jsx("p", { className: "mt-1 text-xs text-[hsl(var(--destructive))]", children: Be.time.message })] })] }), j.jsxs("div", { className: "mb-4", children: [j.jsx("label", { className: "block text-sm font-medium text-[hsl(var(--foreground))] mb-1", children: "Location" }), j.jsxs("div", { className: "flex w-full space-x-2", children: [j.jsx(Hs, { ...Q("locationName", { required: !0 }), placeholder: "Search for a place (e.g., 'Leo House')", className: Be.locationName ? "border-[hsl(var(--destructive))]" : "", onChange: ct => k(ct.target.value) }), j.jsxs(ci, { type: "button", variant: "outline", className: "whitespace-nowrap px-3", onClick: async () => { const ct = s || Ie("locationName"); if (ct) {
                                                        console.log("Executing search for:", ct);
                                                        try {
                                                            V([]), console.log("Trip details for location search:", E);
                                                            let St = "New York City";
                                                            E != null && E.city && E.city !== "" ? (St = E.city, console.log("Using trip city for search:", St)) : E != null && E.location && E.location !== "" ? (St = E.location, console.log("Using trip location for search:", St)) : console.log("No city found in trip, using default:", St);
                                                            const Kt = await fetch("/api/ai/find-location", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ searchQuery: ct, cityContext: St }) });
                                                            if (!Kt.ok)
                                                                throw new Error("Error searching for location");
                                                            const bt = await Kt.json();
                                                            if (console.log("OpenAI location result:", bt), ct.toLowerCase().includes("leo house")) {
                                                                V([{ name: "Leo House", address: "332 W 23rd St", city: "New York City", region: "NY", country: "USA", description: "Catholic guesthouse located in Chelsea, Manhattan", latitude: "40.7453", longitude: "-73.9977" }]);
                                                                return;
                                                            }
                                                            if (bt.locations && Array.isArray(bt.locations)) {
                                                                const ir = "pk.eyJ1IjoicmV0bW91c2VyIiwiYSI6ImNtOXJtOHZ0MjA0dTgycG9ocDA3dXNpMGIifQ.WHYwcRzR3g8djNiBsVw1vg", Or = (await Promise.all(bt.locations.map(async (xt) => { try {
                                                                    const Pt = (xt.address || xt.name) + ", " + (xt.city || "New York City") + ", " + (xt.region || "NY"), Ft = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(Pt)}.json?access_token=${ir}&limit=1`);
                                                                    if (Ft.ok) {
                                                                        const gr = await Ft.json();
                                                                        if (console.log("Mapbox result:", gr), gr.features && gr.features.length > 0) {
                                                                            const Jr = gr.features[0];
                                                                            return { ...xt, latitude: Jr.center[1].toString(), longitude: Jr.center[0].toString() };
                                                                        }
                                                                    }
                                                                    return xt;
                                                                }
                                                                catch (Pt) {
                                                                    return console.error("Error geocoding location:", Pt), xt;
                                                                } }))).filter(xt => xt.latitude && xt.longitude);
                                                                Or.length > 0 ? (V(Or), y({ title: "Search results", description: `Found ${Or.length} matching locations` })) : (V([{ name: ct, address: "", city: St, description: "Approximate location", latitude: "40.7580", longitude: "-73.9855" }]), y({ title: "Location added", description: "Using approximate coordinates" }));
                                                                return;
                                                            }
                                                            console.log("Using default location with fallback coordinates"), V([{ name: bt.name || ct, address: bt.address || "", city: bt.city || St, region: bt.region, country: bt.country, description: bt.description || "Location details not available", latitude: "40.7580", longitude: "-73.9855" }]), y({ title: "Location added", description: bt.name || ct });
                                                        }
                                                        catch (St) {
                                                            console.error("Error in location search:", St), ct.toLowerCase().includes("empire") ? (be("locationName", "Empire State Building", { shouldValidate: !0 }), be("latitude", "40.7484"), be("longitude", "-73.9857"), y({ title: "Location found", description: "Empire State Building, New York" })) : ct.toLowerCase().includes("central park") ? (be("locationName", "Central Park", { shouldValidate: !0 }), be("latitude", "40.7812"), be("longitude", "-73.9665"), y({ title: "Location found", description: "Central Park, New York" })) : ct.toLowerCase().includes("statue") || ct.toLowerCase().includes("liberty") ? (be("locationName", "Statue of Liberty", { shouldValidate: !0 }), be("latitude", "40.6892"), be("longitude", "-74.0445"), y({ title: "Location found", description: "Statue of Liberty, New York" })) : (be("locationName", ct, { shouldValidate: !0 }), be("latitude", "40.7580"), be("longitude", "-73.9855"), y({ title: "Using default location", description: "Added with default New York coordinates" }));
                                                        }
                                                    } }, children: [j.jsx(mq, { className: "w-4 h-4 mr-1" }), "Search"] })] }), Be.locationName && j.jsx("p", { className: "mt-1 text-xs text-[hsl(var(--destructive))]", children: Be.locationName.message }), N.length > 0 && j.jsxs("div", { className: "mt-2 bg-muted rounded-md max-h-[250px] overflow-y-auto", children: [j.jsx("h4", { className: "px-3 pt-2 text-sm font-medium", children: "Select a location:" }), j.jsx("div", { className: "p-2 space-y-1", children: N.map((ct, St) => j.jsxs("div", { className: "p-2 rounded-md text-sm cursor-pointer hover:bg-accent", onClick: () => { be("locationName", ct.name, { shouldValidate: !0 }), be("latitude", ct.latitude || ""), be("longitude", ct.longitude || ""), V([]), y({ title: "Location selected", description: ct.name }); }, children: [j.jsx("div", { className: "font-medium", children: ct.name }), j.jsxs("div", { className: "text-xs opacity-80", children: [ct.address ? `${ct.address}, ` : "", ct.city, ct.region ? `, ${ct.region}` : "", ct.country ? `, ${ct.country}` : ""] }), ct.description && j.jsx("div", { className: "text-xs opacity-70 mt-1 italic", children: ct.description })] }, St)) })] })] }), j.jsxs("div", { className: "mb-4", children: [j.jsx("input", { type: "hidden", ...Q("latitude") }), j.jsx("input", { type: "hidden", ...Q("longitude") }), j.jsx("label", { className: "block text-sm font-medium text-[hsl(var(--foreground))] mb-1", children: "Notes" }), j.jsx(v4, { ...Q("notes"), placeholder: "Add any details or special instructions", className: "min-h-[100px]" })] }), j.jsxs("div", { className: "mb-4", children: [j.jsx("label", { className: "block text-sm font-medium text-[hsl(var(--foreground))] mb-1", children: "Type" }), j.jsx("div", { className: "flex flex-wrap gap-2", children: Object.values(HN).map(ct => j.jsxs(ci, { type: "button", variant: H === ct.id ? "default" : "outline", className: "px-3 py-1 h-8", onClick: () => kt(ct.id), children: [ct.icon && j.jsx("span", { className: "mr-1", children: ct.icon }), ct.label] }, ct.id)) }), j.jsx("input", { type: "hidden", ...Q("tag"), value: H })] }), j.jsxs("div", { className: "mb-4", children: [j.jsx("label", { className: "block text-sm font-medium text-[hsl(var(--foreground))] mb-1", children: "Travel Mode (to this location)" }), j.jsxs("div", { className: "flex flex-wrap gap-2", children: [j.jsxs(ci, { type: "button", variant: Ie("travelMode") === "walking" ? "default" : "outline", className: "px-3 py-1 h-8", onClick: () => be("travelMode", "walking"), children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4 mr-1", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: j.jsx("path", { d: "M13 5c3 0 5 2 5 5 0 3-2 5-5 5M7 8l2 2M7 12l5 5M19 19l-5-5" }) }), "Walking"] }), j.jsxs(ci, { type: "button", variant: Ie("travelMode") === "driving" ? "default" : "outline", className: "px-3 py-1 h-8", onClick: () => be("travelMode", "driving"), children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4 mr-1", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: j.jsx("path", { d: "M7 17h10M5 11h14m-7-5h-2l-2 5H5l-2 3v2h18v-2l-2-3h-3l-2-5h-2zm2 8a1 1 0 11-2 0 1 1 0 012 0zm6 0a1 1 0 11-2 0 1 1 0 012 0z" }) }), "Driving"] }), j.jsxs(ci, { type: "button", variant: Ie("travelMode") === "transit" ? "default" : "outline", className: "px-3 py-1 h-8", onClick: () => be("travelMode", "transit"), children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4 mr-1", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", children: j.jsx("path", { d: "M15 5h-6a2 2 0 00-2 2v9a2 2 0 002 2h6a2 2 0 002-2V7a2 2 0 00-2-2zm1 11h-8m8-5H8m4-5v10" }) }), "Public Transit"] })] })] })] }), j.jsxs("div", { className: "flex justify-end gap-2 mt-6", children: [j.jsx(ci, { type: "button", variant: "outline", onClick: u, children: "Cancel" }), j.jsx(ci, { type: "submit", disabled: Ze.isPending || ot.isPending, children: o ? ot.isPending ? "Updating..." : "Update" : Ze.isPending ? "Adding..." : "Add Activity" })] })] })] }) }) }); }
function YJ({ activities: t, date: r, tripId: o, onActivityUpdated: u }) { const [g, y] = ne.useState(!1), [E, s] = ne.useState(null), k = () => { s(null), y(!0); }, L = ce => { s(ce), y(!0); }, N = () => { y(!1), s(null); }, V = () => { y(!1), u(); }, H = (ce, J) => { console.log(`Toggling activity ${ce} completion to ${J}`), u(); }, ee = [...t].sort((ce, J) => ce.time.localeCompare(J.time)); return j.jsxs("div", { className: "space-y-6 relative timeline-container", children: [ee.length === 0 ? j.jsxs("div", { className: "py-6 text-center", children: [j.jsx("p", { className: "text-[hsl(var(--muted-foreground))] mb-4", children: "No activities planned for this day." }), j.jsx(ci, { onClick: k, className: "bg-[hsl(var(--primary))] hover:bg-[hsl(var(--primary))]", children: "Add Your First Activity" })] }) : ee.map(ce => j.jsx(WJ, { activity: ce, onClick: L, onToggleComplete: H }, ce.id)), j.jsxs(ci, { className: `w-full ${ee.length === 0 ? "text-base py-5 mt-4" : "text-sm"} bg-[hsl(var(--primary))] hover:bg-[hsl(var(--primary))]/90`, onClick: k, children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5 mr-2", viewBox: "0 0 20 20", fill: "currentColor", children: j.jsx("path", { fillRule: "evenodd", d: "M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z", clipRule: "evenodd" }) }), "Add Activity"] }), g && j.jsx(KJ, { tripId: o, date: r, activity: E, onClose: N, onSave: V })] }); }
function QJ({ isOpen: t, onClose: r, trip: o, activities: u, currentDate: g }) {
    const { toast: y } = fc(), [E, s] = ne.useState(""), [k, L] = ne.useState([]), N = u.filter(Q => new Date(Q.date).toDateString() === g.toDateString()), V = uo({ mutationFn: async () => (await Es("POST", En.AI.SUMMARIZE_DAY, { activities: N })).json(), onSuccess: Q => { Q.summary && L(ue => [...ue, { role: "assistant", content: Q.summary }]); }, onError: Q => { y({ title: "Error", description: "Could not generate summary. Please try again.", variant: "destructive" }), console.error("Error summarizing day:", Q); } }), H = uo({ mutationFn: async () => { const Q = N.length > 0 ? N[0].locationName : o.title; return (await Es("POST", En.AI.SUGGEST_FOOD, { location: Q, foodType: "food and coffee" })).json(); }, onSuccess: Q => {
            if (Q.suggestions && Q.suggestions.length > 0) {
                const ue = `
          Here are some food and coffee suggestions:
          ${Q.suggestions.map(be => `
             ${be.name} - ${be.type}
            ${be.description}
            ${be.priceRange} | ${be.distance}
          `).join(`
`)}
        `;
                L(be => [...be, { role: "assistant", content: ue.trim() }]);
            }
            else
                L(ue => [...ue, { role: "assistant", content: "I couldn't find any food suggestions for this location." }]);
        }, onError: Q => { y({ title: "Error", description: "Could not generate food suggestions. Please try again.", variant: "destructive" }), console.error("Error suggesting food:", Q); } }), ee = uo({ mutationFn: async () => (await Es("POST", En.AI.DETECT_CONFLICTS, { activities: N })).json(), onSuccess: Q => {
            if (Q.conflicts && Q.conflicts.length > 0) {
                const ue = `
          I've detected the following potential issues with your schedule:
          ${Q.conflicts.map(be => `
             ${be.description} (${be.severity} severity)
          `).join(`
`)}
        `;
                L(be => [...be, { role: "assistant", content: ue.trim() }]);
            }
            else
                L(ue => [...ue, { role: "assistant", content: "I didn't find any scheduling conflicts in your itinerary for this day." }]);
        }, onError: Q => { y({ title: "Error", description: "Could not detect conflicts. Please try again.", variant: "destructive" }), console.error("Error detecting conflicts:", Q); } }), ce = uo({ mutationFn: async () => (await Es("POST", En.AI.THEMED_ITINERARY, { location: o.title, theme: "local experience", duration: "half-day" })).json(), onSuccess: Q => {
            if (Q.themedItinerary) {
                const ue = Q.themedItinerary, be = `
          ${ue.title}
          
          ${ue.description}
          
          Suggested activities:
          ${ue.activities.map(Ie => `
             ${Ie.time} - ${Ie.title} (${Ie.location})
            ${Ie.description}
          `).join(`
`)}
        `;
                L(Ie => [...Ie, { role: "assistant", content: be.trim() }]);
            }
            else
                L(ue => [...ue, { role: "assistant", content: "I couldn't generate activity suggestions at this time." }]);
        }, onError: Q => { y({ title: "Error", description: "Could not suggest activities. Please try again.", variant: "destructive" }), console.error("Error suggesting activities:", Q); } }), J = uo({ mutationFn: async (Q) => { const ue = { trip: o, currentDate: g, activities: N }; return (await Es("POST", En.AI.ASSISTANT, { question: Q, tripContext: ue })).json(); }, onSuccess: (Q, ue) => {
            Q.activities && Array.isArray(Q.activities) && Q.activities.length > 0 ? (console.log("Received parsed itinerary with activities:", Q.activities), L(be => [...be, { role: "user", content: ue }, { role: "assistant", content: Q.answer + `

I'm now processing these activities to add them to your trip. Please wait...` }]), setTimeout(() => { Q.activities && Array.isArray(Q.activities) && ye(Q.activities); }, 500)) : L(be => [...be, { role: "user", content: ue }, { role: "assistant", content: Q.answer || "I couldn't answer that question." }]), s("");
        }, onError: Q => { y({ title: "Error", description: "Could not process your question. Please try again.", variant: "destructive" }), console.error("Error asking question:", Q); } });
    uo({ mutationFn: async (Q) => { const ue = { title: Q.title, date: Q.date || g.toISOString().split("T")[0], time: Q.time || "12:00", locationName: Q.locationName, notes: Q.notes || "", tag: Q.tag || "Event", tripId: o.id, latitude: Q.latitude, longitude: Q.longitude }; return (await Es("POST", En.ACTIVITIES, ue)).json(); }, onSuccess: Q => { console.log("Activity created:", Q); }, onError: Q => { console.error("Error creating activity:", Q), y({ title: "Error", description: "Could not create activity from itinerary.", variant: "destructive" }); } });
    const ye = async (Q) => {
        let ue = 0;
        const be = [];
        L(Ie => [...Ie, { role: "assistant", content: `Found ${Q.length} activities in your itinerary. Creating them one by one...` }]), y({ title: "Processing Itinerary", description: `Creating ${Q.length} activities from your schedule...` });
        for (let Ie = 0; Ie < Q.length; Ie++) {
            const Be = Q[Ie];
            if (Ie > 0 && Ie % 5 === 0) {
                const Ze = Math.min(100, Math.round(Ie / Q.length * 100));
                L(ot => [...ot, { role: "assistant", content: `Progress: ${Ze}% complete (${Ie} of ${Q.length} activities)` }]);
            }
            try {
                (!Be.date || Be.date === "") && (Be.date = new Date(o.startDate).toISOString().split("T")[0]), (!Be.time || Be.time === "") && (Be.time = "10:00"), (!Be.tag || Be.tag === "") && (Be.title.toLowerCase().includes("breakfast") || Be.title.toLowerCase().includes("lunch") || Be.title.toLowerCase().includes("dinner") || Be.title.toLowerCase().includes("restaurant") || Be.title.toLowerCase().includes("caf") || Be.title.toLowerCase().includes("cafe") ? Be.tag = "Food" : Be.title.toLowerCase().includes("museum") || Be.title.toLowerCase().includes("gallery") || Be.title.toLowerCase().includes("theater") || Be.title.toLowerCase().includes("theatre") || Be.title.toLowerCase().includes("park") ? Be.tag = "Culture" : Be.title.toLowerCase().includes("shopping") || Be.title.toLowerCase().includes("store") || Be.title.toLowerCase().includes("mall") || Be.title.toLowerCase().includes("market") ? Be.tag = "Shop" : Be.title.toLowerCase().includes("leave") || Be.title.toLowerCase().includes("arrive") || Be.title.toLowerCase().includes("drive") || Be.title.toLowerCase().includes("metro") || Be.title.toLowerCase().includes("subway") ? Be.tag = "Transport" : Be.tag = "Event");
                const Ze = { tripId: o.id, title: Be.title, date: Be.date, time: Be.time, locationName: Be.locationName || "Unknown location", latitude: Be.latitude || null, longitude: Be.longitude || null, notes: Be.notes || "", tag: Be.tag || "Event", order: Ie, assignedTo: "" };
                console.log(`Adding activity ${Ie + 1}/${Q.length}:`, Ze);
                const ot = await fetch("/api/activities", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(Ze) });
                if (ot.ok)
                    ue++, console.log(`Successfully added activity ${Ie + 1}: ${Be.title}`);
                else {
                    const At = await ot.json();
                    console.error(`Error creating activity ${Ie + 1}:`, At), be.push(Be.title || "Unnamed activity");
                }
            }
            catch (Ze) {
                console.error(`Error processing activity ${Ie + 1}:`, Ze), be.push(Be.title || "Unnamed activity");
            }
            await new Promise(Ze => setTimeout(Ze, 200));
        }
        ac.invalidateQueries({ queryKey: [En.TRIPS, o.id, "activities"] }), ue > 0 ? (y({ title: "Itinerary Imported", description: `Successfully added ${ue} activities to your trip.${be.length > 0 ? " Some activities could not be added." : ""}` }), L(Ie => [...Ie, { role: "assistant", content: ` Import complete! I've added ${ue} activities to your trip from the itinerary.${be.length > 0 ? `

 I had trouble with ${be.length} activities: ${be.join(", ")}. Please check those manually.` : `

All activities have been added and should now appear in your schedule with the correct times and locations.`}` }])) : be.length > 0 && (y({ title: "Import Failed", description: "Could not add any activities from the itinerary.", variant: "destructive" }), L(Ie => [...Ie, { role: "assistant", content: " I wasn't able to add any activities from your itinerary. There may be an issue with the format or connection. Please try again or add activities manually." }]));
    }, ie = Q => { Q.preventDefault(), E.trim() && J.mutate(E); };
    return t ? j.jsx("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50", children: j.jsxs("div", { className: "bg-white dark:bg-[hsl(var(--card))] rounded-lg shadow-xl max-w-lg w-full max-h-[90vh] overflow-y-auto", children: [j.jsxs("div", { className: "p-4 border-b dark:border-[hsl(var(--border))] flex justify-between items-center", children: [j.jsxs("div", { className: "flex items-center", children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6 text-[hsl(var(--primary))] mr-2", viewBox: "0 0 20 20", fill: "currentColor", children: j.jsx("path", { fillRule: "evenodd", d: "M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z", clipRule: "evenodd" }) }), j.jsx("h3", { className: "text-lg font-semibold", children: "NestMap Assistant" })] }), j.jsx("button", { className: "text-[hsl(var(--muted-foreground))] hover:text-[hsl(var(--foreground))]", onClick: r, children: j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) })] }), j.jsxs("div", { className: "p-4", children: [j.jsxs("div", { className: "mb-4", children: [j.jsx("h4", { className: "font-medium mb-2", children: "How can I help with your trip?" }), j.jsxs("div", { className: "grid grid-cols-2 gap-3", children: [j.jsxs("button", { className: "p-3 border rounded-lg bg-blue-50 border-blue-200 text-left col-span-2", onClick: () => {
                                                L(Q => [...Q, { role: "assistant", content: "To import your itinerary, paste your full schedule below and I'll create activities with all the correct locations and times. I can handle many formats including day-by-day schedules, time ranges, and bulleted lists." }]), s(`I'd like to import my itinerary:

`), setTimeout(() => { const Q = document.querySelector("textarea[name=\"question\"]"); Q && Q.focus(); }, 100);
                                            }, children: [j.jsx("span", { className: "block font-medium text-blue-700", children: "Import Itinerary" }), j.jsx("span", { className: "text-sm text-blue-600", children: "Paste your schedule to add all activities to your trip" })] }), j.jsxs("button", { className: "p-3 border rounded-lg hover:bg-blue-50 hover:border-blue-200 text-left", onClick: () => V.mutate(), disabled: V.isPending, children: [j.jsx("span", { className: "block font-medium", children: "Summarize day" }), j.jsx("span", { className: "text-sm text-[hsl(var(--muted-foreground))]", children: "Get a brief overview" })] }), j.jsxs("button", { className: "p-3 border rounded-lg hover:bg-blue-50 hover:border-blue-200 text-left", onClick: () => H.mutate(), disabled: H.isPending, children: [j.jsx("span", { className: "block font-medium", children: "Food nearby" }), j.jsx("span", { className: "text-sm text-[hsl(var(--muted-foreground))]", children: "Find places to eat" })] }), j.jsxs("button", { className: "p-3 border rounded-lg hover:bg-blue-50 hover:border-blue-200 text-left", onClick: () => ee.mutate(), disabled: ee.isPending, children: [j.jsx("span", { className: "block font-medium", children: "Find time conflicts" }), j.jsx("span", { className: "text-sm text-[hsl(var(--muted-foreground))]", children: "Check schedule issues" })] }), j.jsxs("button", { className: "p-3 border rounded-lg hover:bg-blue-50 hover:border-blue-200 text-left", onClick: () => ce.mutate(), disabled: ce.isPending, children: [j.jsx("span", { className: "block font-medium", children: "Suggest activities" }), j.jsx("span", { className: "text-sm text-[hsl(var(--muted-foreground))]", children: "Based on interests" })] })] })] }), (k.length > 0 || V.isPending || H.isPending || ee.isPending || ce.isPending || J.isPending) && j.jsxs("div", { className: "border-t pt-4 mt-4 max-h-[300px] overflow-y-auto", children: [k.map((Q, ue) => j.jsxs("div", { className: "flex items-start mb-4", children: [j.jsx("div", { className: `
                    ${Q.role === "assistant" ? "bg-[hsl(var(--primary))]" : "bg-[hsl(var(--muted))]"} 
                    rounded-full h-8 w-8 flex items-center justify-center 
                    ${Q.role === "assistant" ? "text-white" : "text-[hsl(var(--foreground))]"} 
                    shrink-0 mr-3
                  `, children: Q.role === "assistant" ? j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", viewBox: "0 0 20 20", fill: "currentColor", children: j.jsx("path", { fillRule: "evenodd", d: "M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z", clipRule: "evenodd" }) }) : j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", viewBox: "0 0 20 20", fill: "currentColor", children: j.jsx("path", { fillRule: "evenodd", d: "M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z", clipRule: "evenodd" }) }) }), j.jsx("div", { className: `
                    ${Q.role === "assistant" ? "bg-blue-50 dark:bg-blue-900/20" : "bg-[hsl(var(--muted))]"} 
                    p-3 rounded-lg ${Q.role === "assistant" ? "rounded-tl-none" : "rounded-tr-none"} flex-1
                  `, children: j.jsx("p", { className: "text-sm whitespace-pre-line", children: Q.content }) })] }, ue)), (V.isPending || H.isPending || ee.isPending || ce.isPending || J.isPending) && j.jsxs("div", { className: "flex items-start mb-4", children: [j.jsx("div", { className: "bg-[hsl(var(--primary))] rounded-full h-8 w-8 flex items-center justify-center text-white shrink-0 mr-3", children: j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", viewBox: "0 0 20 20", fill: "currentColor", children: j.jsx("path", { fillRule: "evenodd", d: "M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z", clipRule: "evenodd" }) }) }), j.jsx("div", { className: "bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg rounded-tl-none flex-1", children: j.jsxs("div", { className: "flex items-center space-x-2", children: [j.jsx("div", { className: "h-2 w-2 bg-[hsl(var(--primary))] rounded-full animate-bounce" }), j.jsx("div", { className: "h-2 w-2 bg-[hsl(var(--primary))] rounded-full animate-bounce", style: { animationDelay: "0.2s" } }), j.jsx("div", { className: "h-2 w-2 bg-[hsl(var(--primary))] rounded-full animate-bounce", style: { animationDelay: "0.4s" } }), j.jsx("span", { className: "text-sm text-[hsl(var(--muted-foreground))]", children: "Thinking..." })] }) })] })] }), j.jsx("form", { onSubmit: ie, className: "mt-4", children: j.jsxs("div", { className: "flex items-center border rounded-lg overflow-hidden dark:border-[hsl(var(--border))]", children: [j.jsx(Hs, { type: "text", className: "flex-1 px-4 py-2 border-0 focus:outline-none", placeholder: "Ask anything about your trip...", value: E, onChange: Q => s(Q.target.value), disabled: J.isPending }), j.jsx(ci, { type: "submit", variant: "ghost", className: "p-2 text-[hsl(var(--primary))]", disabled: !E.trim() || J.isPending, children: j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", viewBox: "0 0 20 20", fill: "currentColor", children: j.jsx("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 0l-3 3a1 1 0 001.414 1.414L9 9.414V13a1 1 0 102 0V9.414l1.293 1.293a1 1 0 001.414-1.414z", clipRule: "evenodd" }) }) })] }) })] })] }) }) : null;
}
function cO({ trip: t, activities: r, todos: o, notes: u, activeDay: g, onChangeDayClick: y, onActivitiesUpdated: E }) { var be; const { toast: s } = fc(), [k, L] = ne.useState(!1), [N, V] = ne.useState(""), [H, ee] = ne.useState(""), ce = uo({ mutationFn: async (Ie) => (await Es("PUT", `${En.TODOS}/${Ie.id}`, { ...Ie, completed: !Ie.completed })).json(), onSuccess: () => { ac.invalidateQueries({ queryKey: [En.TRIPS, t.id, "todos"] }); } }), J = uo({ mutationFn: async () => (await Es("POST", En.TODOS, { tripId: t.id, task: N, completed: !1 })).json(), onSuccess: () => { ac.invalidateQueries({ queryKey: [En.TRIPS, t.id, "todos"] }), V(""), s({ title: "Todo added", description: "Your todo has been added to the list." }); } }), ye = uo({ mutationFn: async () => !u && H ? (await Es("POST", En.NOTES, { tripId: t.id, content: H })).json() : (await Es("PUT", `${En.NOTES}/1`, { tripId: t.id, content: H })).json(), onSuccess: () => { ac.invalidateQueries({ queryKey: [En.TRIPS, t.id, "notes"] }), s({ title: "Notes updated", description: "Your notes have been saved." }); } }), ie = Ie => { Ie.preventDefault(), N.trim() && J.mutate(); }, Q = Ie => { Ie.preventDefault(), H.trim() !== u && ye.mutate(); }, ue = r.filter(Ie => new Date(Ie.date).toDateString() === g.toDateString()); return j.jsxs(j.Fragment, { children: [j.jsxs("aside", { id: "sidebar", className: "w-full h-full bg-white dark:bg-[hsl(var(--card))] border-r dark:border-[hsl(var(--border))] overflow-y-auto p-4", children: [j.jsxs("div", { className: "mb-6", children: [j.jsx("h2", { className: "text-2xl font-semibold", children: t.title }), j.jsx("p", { className: "text-[hsl(var(--muted-foreground))]", children: HZ(new Date(t.startDate), new Date(t.endDate)) })] }), j.jsxs(BJ, { defaultValue: "itinerary", children: [j.jsxs(d4, { className: "grid grid-cols-3 mb-4", children: [j.jsx(sw, { value: "itinerary", children: "Itinerary" }), j.jsx(sw, { value: "todo", children: "To-Do" }), j.jsx(sw, { value: "notes", children: "Notes" })] }), j.jsxs(ow, { value: "itinerary", className: "space-y-4", children: [j.jsx("div", { className: "mb-4", children: j.jsx("div", { className: "grid grid-cols-2 gap-2", children: (be = t.days) == null ? void 0 : be.map((Ie, Be) => j.jsxs("button", { className: `px-3 py-2 ${Ie.toDateString() === g.toDateString() ? "bg-[hsl(var(--primary))] text-white" : "bg-[hsl(var(--muted))] hover:bg-[hsl(var(--muted))]"} rounded-md text-sm md:text-base`, onClick: () => y(Ie), children: ["Day ", Be + 1, " - ", WZ(Ie)] }, Ie.toISOString())) }) }), j.jsxs("div", { className: "space-y-2 mb-4", children: [j.jsxs("button", { className: "w-full py-3 px-4 bg-[hsl(var(--primary))] text-white rounded-md flex items-center justify-center", onClick: () => { const Ie = document.querySelector(".timeline-container"); if (Ie) {
                                                const Be = Ie.querySelector("button");
                                                Be && Be.click();
                                            } }, children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5 mr-2", viewBox: "0 0 20 20", fill: "currentColor", children: j.jsx("path", { fillRule: "evenodd", d: "M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z", clipRule: "evenodd" }) }), "Add Activity"] }), j.jsxs("button", { className: "w-full py-3 px-4 bg-blue-50 dark:bg-blue-900/20 text-[hsl(var(--primary))] rounded-md border border-blue-100 dark:border-blue-900/40 flex items-center justify-center", onClick: () => L(!0), children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5 mr-2", viewBox: "0 0 20 20", fill: "currentColor", children: j.jsx("path", { fillRule: "evenodd", d: "M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z", clipRule: "evenodd" }) }), "AI Assistant"] })] }), j.jsx(YJ, { activities: ue, date: g, tripId: t.id, onActivityUpdated: E })] }), j.jsx(ow, { value: "todo", children: j.jsxs("div", { className: "space-y-4", children: [j.jsxs("form", { onSubmit: ie, className: "flex space-x-2", children: [j.jsx("input", { type: "text", placeholder: "Add a new task...", className: "flex-1 px-3 py-2 border dark:border-[hsl(var(--border))] rounded-md focus:outline-none focus:ring-2 focus:ring-[hsl(var(--ring))]", value: N, onChange: Ie => V(Ie.target.value) }), j.jsx(ci, { type: "submit", disabled: !N.trim() || J.isPending, children: "Add" })] }), j.jsx("div", { className: "space-y-2", children: o.length === 0 ? j.jsx("p", { className: "text-center py-4 text-[hsl(var(--muted-foreground))]", children: "No tasks yet. Add one above!" }) : o.map(Ie => j.jsxs("div", { className: "flex items-center space-x-2 p-2 hover:bg-[hsl(var(--muted))] rounded-md", children: [j.jsx(y4, { id: `todo-${Ie.id}`, checked: Ie.completed, onCheckedChange: () => ce.mutate(Ie) }), j.jsx("label", { htmlFor: `todo-${Ie.id}`, className: `flex-1 cursor-pointer ${Ie.completed ? "line-through text-[hsl(var(--muted-foreground))]" : ""}`, children: Ie.task })] }, Ie.id)) })] }) }), j.jsx(ow, { value: "notes", children: j.jsxs("form", { onSubmit: Q, children: [j.jsx("textarea", { className: "w-full h-64 p-3 border dark:border-[hsl(var(--border))] rounded-md focus:outline-none focus:ring-2 focus:ring-[hsl(var(--ring))]", placeholder: "Add notes for your trip...", value: H || u, onChange: Ie => ee(Ie.target.value) }), j.jsx("div", { className: "mt-2 flex justify-end", children: j.jsx(ci, { type: "submit", disabled: ye.isPending || H.trim() === u, children: "Save Notes" }) })] }) })] })] }), j.jsx(QJ, { isOpen: k, onClose: () => L(!1), trip: t, activities: r, currentDate: g })] }); }
function uO({ markers: t = [], routes: r = [], center: o = CL.center, zoom: u = CL.zoom, onMarkerClick: g }) { var J; const y = ne.useRef(null), { initializeMap: E, addMarkers: s, addRoutes: k, flyToLocation: L } = sI(), [N, V] = ne.useState(!1); ne.useEffect(() => { y.current && !N && E(y.current, o, u).then(() => { V(!0); }); }, [y, o, u, E, N]), ne.useEffect(() => { N && t.length > 0 && s(t, g); }, [N, t, s, g]), ne.useEffect(() => { N && r.length > 0 && k(r); }, [N, r, k]); const H = () => { N && L(o, u + 1); }, ee = () => { N && L(o, u - 1); }, ce = () => { N && navigator.geolocation && navigator.geolocation.getCurrentPosition(ye => { const { longitude: ie, latitude: Q } = ye.coords; L([ie, Q], 14); }); }; return j.jsx("section", { className: "relative w-full h-full overflow-hidden map-container", style: { height: "100%", position: "relative" }, children: j.jsxs("div", { className: "w-full h-full bg-[hsl(var(--muted))]", style: { height: "100%", position: "relative" }, children: [j.jsx("div", { className: "absolute inset-0", ref: y, id: "map", style: { height: "100%", position: "absolute", top: 0, left: 0, right: 0, bottom: 0 } }), j.jsxs("div", { className: "absolute top-4 right-4 flex flex-col space-y-2", children: [j.jsx(ci, { variant: "secondary", size: "icon", className: "bg-white hover:bg-white dark:bg-[hsl(var(--card))] dark:hover:bg-[hsl(var(--card))] shadow-md rounded-full", onClick: H, children: j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", viewBox: "0 0 20 20", fill: "currentColor", children: j.jsx("path", { fillRule: "evenodd", d: "M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z", clipRule: "evenodd" }) }) }), j.jsx(ci, { variant: "secondary", size: "icon", className: "bg-white hover:bg-white dark:bg-[hsl(var(--card))] dark:hover:bg-[hsl(var(--card))] shadow-md rounded-full", onClick: ee, children: j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", viewBox: "0 0 20 20", fill: "currentColor", children: j.jsx("path", { fillRule: "evenodd", d: "M5 10a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1z", clipRule: "evenodd" }) }) }), j.jsx(ci, { variant: "secondary", size: "icon", className: "bg-white hover:bg-white dark:bg-[hsl(var(--card))] dark:hover:bg-[hsl(var(--card))] shadow-md rounded-full", onClick: ce, children: j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", viewBox: "0 0 20 20", fill: "currentColor", children: j.jsx("path", { fillRule: "evenodd", d: "M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z", clipRule: "evenodd" }) }) })] }), t.length > 0 && j.jsx("div", { className: "absolute bottom-4 left-4 right-4 bg-white dark:bg-[hsl(var(--card))] bg-opacity-90 dark:bg-opacity-90 p-3 rounded-lg shadow-lg", children: j.jsxs("div", { className: "flex items-center justify-between", children: [j.jsxs("div", { children: [j.jsx("h3", { className: "font-medium", children: "Route Overview" }), j.jsxs("p", { className: "text-sm text-[hsl(var(--muted-foreground))]", children: [t.length, " stops", r.length > 0 && ((J = r[0]) == null ? void 0 : J.distance) && `  ${(r[0].distance / 1609.34).toFixed(1)} miles total`] })] }), j.jsx(ci, { variant: "ghost", size: "icon", className: "text-[hsl(var(--primary))]", children: j.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: [j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" }), j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z" })] }) })] }) }), j.jsx("div", { className: "absolute bottom-20 right-4 md:hidden", children: j.jsx(ci, { className: "bg-[hsl(var(--primary))] text-white p-4 rounded-full shadow-lg", size: "icon", children: j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 4v16m8-8H4" }) }) }) })] }) }); }
function JJ(t) { const { data: r = [], isLoading: o, error: u, refetch: g } = nv({ queryKey: [En.TRIPS, t, "activities"], queryFn: async () => { if (!t)
        return []; const N = await fetch(`${En.TRIPS}/${t}/activities`); if (!N.ok)
        throw new Error("Failed to fetch activities"); const V = await N.json(); return y(V); }, enabled: !!t }), y = N => { if (!N || N.length === 0)
    return []; const V = [...N].sort((ce, J) => { const ye = new Date(ce.date), ie = new Date(J.date); return ye.getTime() !== ie.getTime() ? ye.getTime() - ie.getTime() : ce.time.localeCompare(J.time); }), H = {}; V.forEach(ce => { const J = new Date(ce.date).toDateString(); H[J] || (H[J] = []), H[J].push(ce); }); const ee = []; return Object.values(H).forEach(ce => { ce.forEach((J, ye) => { if (ye === 0) {
    ee.push(J);
    return;
} const ie = ce[ye - 1]; if (ie.latitude && ie.longitude && J.latitude && J.longitude) {
    const Q = E(parseFloat(ie.latitude), parseFloat(ie.longitude), parseFloat(J.latitude), parseFloat(J.longitude));
    let ue = 4.8, be = "walking";
    const Ie = typeof J.travelMode == "string" ? J.travelMode.toLowerCase() : "walking", Be = Q > 50, Ze = Q > 10 && Q <= 50;
    Ie === "driving" ? (Be ? ue = 105 : Ze ? ue = 70 : ue = 30, be = "driving") : Ie === "transit" ? (Be ? ue = 90 : Ze ? ue = 50 : ue = 20, be = "transit") : Be ? (ue = 90, be = "walking (estimated)") : Ze ? (ue = 50, be = "walking (estimated)") : (ue = 4.8, be = "walking");
    const ot = Math.round(Q / ue * 60);
    let At = "";
    if (ot >= 60) {
        const St = Math.floor(ot / 60), Kt = ot % 60;
        Kt > 0 ? At = `${St} hr ${Kt} min ${be}` : At = `${St} hr ${be}`;
    }
    else
        At = `${ot} min ${be}`;
    let kt = 30;
    Ie === "driving" ? kt = Be ? 480 : 60 : Ie === "transit" && (kt = Be ? 360 : 45);
    const ct = ot > kt;
    ee.push({ ...J, travelTimeFromPrevious: At, travelDistanceFromPrevious: `${Q.toFixed(1)} km`, conflict: ct });
}
else
    ee.push(J); }); }), ee; }, E = (N, V, H, ee) => { const J = s(H - N), ye = s(ee - V), ie = Math.sin(J / 2) * Math.sin(J / 2) + Math.cos(s(N)) * Math.cos(s(H)) * Math.sin(ye / 2) * Math.sin(ye / 2); return 6371 * (2 * Math.atan2(Math.sqrt(ie), Math.sqrt(1 - ie))); }, s = N => N * (Math.PI / 180); return { activities: r, isLoading: o, error: u, refetchActivities: () => g(), invalidateActivities: () => ac.invalidateQueries({ queryKey: [En.TRIPS, t, "activities"] }) }; }
function eee() { const [, t] = D8("/trip/:id"), r = t ? parseInt(t.id) : 0, { toast: o } = fc(), { trip: u, todos: g, notes: y, isLoading: E, error: s } = x4(r), { activities: k, isLoading: L, error: N, refetchActivities: V } = JJ(r), [H, ee] = ne.useState(null), [ce, J] = ne.useState("itinerary"); ne.useEffect(() => { if (u && u.startDate && !H) {
    ee(new Date(u.startDate));
    const Ze = ZZ(new Date(u.startDate), new Date(u.endDate));
    u.days = Ze;
    try {
        localStorage.setItem(`trip_${r}`, JSON.stringify({ city: u.city || "New York City", latitude: u.latitude, longitude: u.longitude }));
    }
    catch (ot) {
        console.error("Error saving trip geocoding context:", ot);
    }
} }, [u, H, r]), ne.useEffect(() => { s && o({ title: "Error", description: "Failed to load trip details. Please try again.", variant: "destructive" }), N && o({ title: "Error", description: "Failed to load activities. Please try again.", variant: "destructive" }); }, [s, N, o]); const Q = [...k.filter(Ze => H ? new Date(Ze.date).toDateString() === H.toDateString() : !1)].sort((Ze, ot) => Ze.time.localeCompare(ot.time)).filter(Ze => Ze.latitude && Ze.longitude && !Ze.completed).map((Ze, ot) => ({ id: Ze.id, latitude: parseFloat(Ze.latitude || "0"), longitude: parseFloat(Ze.longitude || "0"), label: String.fromCharCode(65 + ot), activity: Ze })), ue = Q.length > 1 ? [{ id: "main-route", coordinates: Q.map(Ze => [Ze.longitude, Ze.latitude]), duration: 0, distance: 0 }] : [], be = Q.length > 0 ? [Q.reduce((Ze, ot) => Ze + ot.longitude, 0) / Q.length, Q.reduce((Ze, ot) => Ze + ot.latitude, 0) / Q.length] : void 0, Ie = Ze => { Ze.activity && console.log("Clicked activity:", Ze.activity); }, Be = () => { o({ title: "Share", description: "Sharing functionality would open here." }); }; return E || L || !H ? j.jsx(GE, { children: j.jsx("div", { className: "flex-1 flex items-center justify-center", children: j.jsxs("div", { className: "text-center", children: [j.jsx("div", { className: "animate-spin h-8 w-8 border-4 border-[hsl(var(--primary))] border-t-transparent rounded-full mx-auto mb-4" }), j.jsx("p", { children: "Loading trip planner..." })] }) }) }) : !u || s || N ? j.jsx(GE, { children: j.jsx("div", { className: "flex-1 flex items-center justify-center", children: j.jsxs("div", { className: "text-center max-w-md mx-auto p-4", children: [j.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-12 w-12 mx-auto text-[hsl(var(--destructive))]", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: j.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" }) }), j.jsx("h2", { className: "text-xl font-bold mt-4", children: "Could not load trip" }), j.jsx("p", { className: "mt-2 text-[hsl(var(--muted-foreground))]", children: "There was an error loading the trip details. Please try again or return to the home page." })] }) }) }) : j.jsxs(GE, { trip: u, onOpenShare: Be, children: [j.jsxs("div", { className: "md:hidden flex border rounded-md overflow-hidden shadow-sm m-2", children: [j.jsx("button", { onClick: () => J("itinerary"), className: `flex-1 py-3 px-4 font-medium ${ce === "itinerary" ? "bg-[hsl(var(--primary))] text-white" : "bg-white dark:bg-[hsl(var(--card))]"}`, children: "Itinerary" }), j.jsx("button", { onClick: () => J("map"), className: `flex-1 py-3 px-4 font-medium ${ce === "map" ? "bg-[hsl(var(--primary))] text-white" : "bg-white dark:bg-[hsl(var(--card))]"}`, children: "Map" })] }), j.jsxs("div", { className: "hidden md:grid md:grid-cols-2 h-[calc(100vh-110px)]", children: [j.jsx("div", { className: "h-full overflow-y-auto", children: j.jsx(cO, { trip: u, activities: k, todos: g, notes: y, activeDay: H, onChangeDayClick: ee, onActivitiesUpdated: V }) }), j.jsx("div", { className: "h-full", children: j.jsx(uO, { markers: Q, routes: ue, center: be, zoom: 13, onMarkerClick: Ie }) })] }), j.jsx("div", { className: "md:hidden", children: ce === "itinerary" && j.jsx("div", { className: "h-[calc(100vh-120px)] overflow-y-auto", children: j.jsx(cO, { trip: u, activities: k, todos: g, notes: y, activeDay: H, onChangeDayClick: ee, onActivitiesUpdated: V }) }) }), ce === "map" && j.jsx("div", { className: "md:hidden fixed inset-0 top-[108px] z-10", style: { height: "calc(100vh - 108px)" }, children: j.jsx(uO, { markers: Q, routes: ue, center: be, zoom: 13, onMarkerClick: Ie }) })] }); }
function tee() { return j.jsx("div", { className: "min-h-screen w-full flex items-center justify-center bg-gray-50", children: j.jsx(Vh, { className: "w-full max-w-md mx-4", children: j.jsxs(Uh, { className: "pt-6", children: [j.jsxs("div", { className: "flex mb-4 gap-2", children: [j.jsx(RA, { className: "h-8 w-8 text-red-500" }), j.jsx("h1", { className: "text-2xl font-bold text-gray-900", children: "404 Page Not Found" })] }), j.jsx("p", { className: "mt-4 text-sm text-gray-600", children: "Did you forget to add the page to the router?" })] }) }) }); }
function ree() { return j.jsxs(z8, { children: [j.jsx(yE, { path: "/", component: aQ }), j.jsx(yE, { path: "/trip/:id", component: eee }), j.jsx(yE, { component: tee })] }); }
function nee() { return j.jsx(rG, { client: ac, children: j.jsx(GZ, { children: j.jsxs(EW, { children: [j.jsx(Jq, {}), j.jsx(ree, {})] }) }) }); }
const w4 = document.getElementById("root");
if (!w4)
    throw new Error("Root element not found in the document!");
L3(w4).render(j.jsx(nee, {}));
export { TC as g };
